/**
 * Do not use this interface. Instead, write:
 * const { addDebuggerToGlobal } = ChromeUtils.importESModule(
 * "resource://gre/modules/jsdebugger.sys.mjs"
 * );
 * addDebuggerToGlobal(global);
 */
declare interface IJSDebuggerType extends nsISupportsType {
    /**
     * Define the global Debugger constructor on a given global.
     */
    addClass(global: jsval): void;
}

/**
 * Do not confuse with nsIDOMRTCPeerConnection. This interface is purely for
 * communication between the PeerConnection JS DOM binding and the C++
 * implementation in SIPCC.
 *
 * See media/webrtc/signaling/include/PeerConnectionImpl.h
 */
declare interface IPeerConnectionObserverType extends nsISupportsType {
}

/**
 *
 */
declare interface IPeerConnectionType extends nsISupportsType {
}

/**
 *
 */
declare interface IUrlClassifierUITelemetryType extends nsISupportsType {
}

/**
 *
 */
declare interface nsIScriptableOKType extends nsISupportsType {
    /**
     *
     */
    method1(): void;
}

/**
 *
 */
declare interface nsIScriptableWithNotXPCOMType extends nsISupportsType {
    /**
     *
     */
    method2(): void;
}

/**
 *
 */
declare interface nsISessionStoreFunctionsType extends nsISupportsType {
    /**
     *
     */
    UpdateSessionStore(aBrowser: Element, aBrowsingContext: BrowsingContext, aPermanentKey: jsval, aEpoch: uint32_t, aCollectSHistory: boolean, aData: jsval): void;
    /**
     *
     */
    UpdateSessionStoreForStorage(aBrowser: Element, aBrowsingContext: BrowsingContext, aPermanentKey: jsval, aEpoch: uint32_t, aData: jsval): void;
}

/**
 *
 */
declare interface amIAddonManagerStartupType extends nsISupportsType {
    /**
     * Reads and parses startup data from the addonState.json.lz4 file, checks
     * for modifications, and returns the result.
     *
     * Returns null for an empty or nonexistent state file, but throws for an
     * invalid one.
     */
    readStartupData(): jsval;
    /**
     * Registers a set of dynamic chrome registry entries, and returns an object
     * with a `destruct()` method which must be called in order to unregister
     * the entries.
     *
     * @param manifestURI The base manifest URI for the entries. URL values are
     * resolved relative to this URI.
     * @param entries An array of arrays, each containing a registry entry as it
     * would appar in a chrome.manifest file. Only the following entry
     * types are currently accepted:
     *
     * - "locale" A locale package entry. Must be a 4-element array.
     * - "override" A URL override entry. Must be a 3-element array.
     */
    registerChrome(manifestURI: nsIURIType, entries: jsval): nsIJSRAIIHelper;
    /**
     *
     */
    encodeBlob(value: jsval): jsval;
    /**
     *
     */
    decodeBlob(value: jsval): jsval;
    /**
     * Initializes the URL Preloader.
     *
     * NOT FOR USE OUTSIDE OF UNIT TESTS.
     */
    initializeURLPreloader(): void;
}

/**
 * amIWebInstallPrompt is used, if available, by the default implementation of
 * amIWebInstallInfo to display a confirmation UI to the user before running
 * installs.
 */
declare interface amIWebInstallPromptType extends nsISupportsType {
    /**
     * Get a confirmation that the user wants to start the installs.
     *
     * @param  aBrowser
     * The browser that triggered the installs
     * @param  aUri
     * The URI of the site that triggered the installs
     * @param  aInstalls
     * The AddonInstalls that were requested
     */
    confirm(aBrowser: Element, aUri: nsIURIType, aInstalls: invalid): void;
}

/**
 *
 */
declare interface extIWebNavigationType extends nsISupportsType {
    /**
     *
     */
    onDocumentChange(bc: BrowsingContext, transitionData: jsval, location: nsIURIType): void;
    /**
     *
     */
    onHistoryChange(bc: BrowsingContext, transitionData: jsval, location: nsIURIType, isHistoryStateUpdated: bool, isReferenceFragmentUpdated: bool): void;
    /**
     *
     */
    onStateChange(bc: BrowsingContext, requestURI: nsIURIType, status: nsresult, stateFlags: unsigned_long): void;
    /**
     *
     */
    onCreatedNavigationTarget(bc: BrowsingContext, sourceBC: BrowsingContext, url: ACString): void;
    /**
     *
     */
    onDOMContentLoaded(bc: BrowsingContext, documentURI: nsIURIType): void;
}

/**
 * imgICache interface
 *
 * @author Stuart Parmenter <pavlov@netscape.com>
 * @version 0.1
 * @see imagelib2
 */
declare interface imgICacheType extends nsISupportsType {
    /**
     * Evict images from the cache.
     *
     * @param chrome If TRUE,  evict only chrome images.
     * If FALSE, evict everything except chrome images.
     */
    clearCache(chrome: boolean): void;
    /**
     * Evict images from the cache with the same origin and the same
     * originAttributes of the passed principal, across all processes. May only be
     * called from the parent process.
     *
     * @param aPrincipal The principal to clear cache entries for. The principals
     * origin attributes are used to determine whether the private or normal
     * browsing cache is cleared.
     * @throws NS_ERROR_NOT_AVAILABLE if not called in the parent process.
     */
    removeEntriesFromPrincipalInAllProcesses(aPrincipal: nsIPrincipalType): void;
    /**
     * Evict images from the non-chrome cache which match the the given base
     * domain. Matching cache entries will be cleared across all origin attributes
     * and all processes.
     *
     * @param aBaseDomain base domain to delete cache entries for.
     * @throws NS_ERROR_NOT_AVAILABLE if not called in the parent process.
     */
    removeEntriesFromBaseDomainInAllProcesses(aBaseDomain: ACString): void;
    /**
     * Find Properties
     * Used to get properties such as 'type' and 'content-disposition'
     * 'type' is a nsISupportsCString containing the images' mime type such as
     * 'image/png'
     * 'content-disposition' will be a nsISupportsCString containing the header
     * If you call this before any data has been loaded from a URI, it will
     * succeed, but come back empty.
     *
     * Hopefully this will be removed with bug 805119
     *
     * @param uri The URI to look up.
     * @param doc Optional pointer to the document that the cache entry belongs to.
     * @returns NULL if the URL was not found in the cache
     */
    findEntryProperties(uri: nsIURIType, doc: Document): nsIProperties;
    /**
     * Make this cache instance respect private browsing notifications. This
     * entails clearing the chrome and content caches whenever the
     * last-pb-context-exited notification is observed.
     */
    respectPrivacyNotifications(): void;
}

/**
 * imgIContainer is the interface that represents an image. It allows
 * access to frames as Thebes surfaces. It also allows drawing of images
 * onto Thebes contexts.
 *
 * Internally, imgIContainer also manages animation of images.
 */
declare interface imgIContainerType extends nsISupportsType {
    /**
     * The width of the container rectangle.  In the case of any error,
     * zero is returned, and an exception will be thrown.
     */
    readonly width: int32_t;
    /**
     * The height of the container rectangle.  In the case of any error,
     * zero is returned, and an exception will be thrown.
     */
    readonly height: int32_t;
    /**
     * The intrinsic size of this image in appunits. If the image has no intrinsic
     * size in a dimension, -1 will be returned for that dimension. In the case of
     * any error, an exception will be thrown.
     */
    readonly intrinsicSize: nsSize;
    /**
     * The (dimensionless) intrinsic ratio of this image. In the case of any
     * error, Nothing() will be returned.
     */
    readonly intrinsicRatio: MaybeAspectRatio;
    /**
     * The x coordinate of the image's hotspot, or 0 if there is no hotspot.
     */
    readonly hotspotX: int32_t;
    /**
     * The y coordinate of the image's hotspot, or 0 if there is no hotspot.
     */
    readonly hotspotY: int32_t;
    /**
     * Given a size at which this image will be displayed, and the drawing
     * parameters affecting how it will be drawn, returns the image size which
     * should be used to draw to produce the highest quality result. This is the
     * appropriate size, for example, to use as an input to the pixel snapping
     * algorithm.
     *
     * For best results the size returned by this method should not be cached. It
     * can change over time due to changes in the internal state of the image.
     *
     * @param aDest The size of the destination rect into which this image will be
     * drawn, in device pixels.
     * @param aWhichFrame Frame specifier of the FRAME_* variety.
     * @param aSamplingFilter The filter to be used if we're scaling the image.
     * @param aFlags Flags of the FLAG_* variety
     */
    optimalImageSizeForDest(aDest: gfxSize, aWhichFrame: uint32_t, aSamplingFilter: SamplingFilter, aFlags: uint32_t): nsIntSizeByVal;
    /**
     * The type of this image (one of the TYPE_* values above).
     */
    readonly type: unsigned_short;
    /**
     * Whether this image is animated. You can only be guaranteed that querying
     * this will not throw if STATUS_DECODE_COMPLETE is set on the imgIRequest.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if the animated state cannot be determined.
     */
    readonly animated: boolean;
    /**
     * Provider ID for image providers created by this image.
     */
    readonly providerId: unsigned_long;
    /**
     * Increments the lock count on the image. An image will not be discarded
     * as long as the lock count is nonzero. Note that it is still possible for
     * the image to be undecoded if decode-on-draw is enabled and the image
     * was never drawn.
     *
     * Upon instantiation images have a lock count of zero.
     */
    lockImage(): void;
    /**
     * Decreases the lock count on the image. If the lock count drops to zero,
     * the image is allowed to discard its frame data to save memory.
     *
     * Upon instantiation images have a lock count of zero. It is an error to
     * call this method without first having made a matching lockImage() call.
     * In other words, the lock count is not allowed to be negative.
     */
    unlockImage(): void;
    /**
     * If this image is unlocked, discard its decoded data.  If the image is
     * locked or has already been discarded, do nothing.
     */
    requestDiscard(): void;
    /**
     * Indicates that this imgIContainer has been triggered to update
     * its internal animation state. Likely this should only be called
     * from within nsImageFrame or objects of similar type.
     */
    requestRefresh(aTime: TimeStamp): void;
    /**
     *
     */
    animationMode: unsigned_short;
    /**
     * Methods to control animation
     */
    resetAnimation(): void;
    /**
     * Returns an index for the requested animation frame (either FRAME_FIRST or
     * FRAME_CURRENT).
     *
     * The units of the index aren't specified, and may vary between different
     * types of images. What you can rely on is that on all occasions when
     * getFrameIndex(FRAME_CURRENT) returns a certain value,
     * draw(..FRAME_CURRENT..) will draw the same frame. The same holds for
     * FRAME_FIRST as well.
     *
     * @param aWhichFrame Frame specifier of the FRAME_* variety.
     */
    getFrameIndex(aWhichFrame: uint32_t): float;
    /**
     * Returns the inherent orientation of the image, as described in the image's
     * metadata (e.g. EXIF).
     */
    getOrientation(): Orientation;
    /**
     * Returns the intrinsic resolution of the image, or 1.0 if the image doesn't
     * declare any.
     */
    getResolution(): ImageResolution;
    /**
     * Returns the delay, in ms, between the first and second frame. If this
     * returns 0, there is no delay between first and second frame (i.e., this
     * image could render differently whenever it draws).
     *
     * If this image is not animated, or not known to be animated (see attribute
     * animated), returns -1.
     */
    getFirstFrameDelay(): int32_t;
    /**
     * If this is an animated image that hasn't started animating already, this
     * sets the animation's start time to the indicated time.
     *
     * This has no effect if the image isn't animated or it has started animating
     * already; it also has no effect if the image format doesn't care about
     * animation start time.
     *
     * In all cases, animation does not actually begin until startAnimation(),
     * resetAnimation(), or requestRefresh() is called for the first time.
     */
    setAnimationStartTime(aTime: TimeStamp): void;
    /**
     * Given an invalidation rect in the coordinate system used by the decoder,
     * returns an invalidation rect in image space.
     *
     * This is the identity transformation in most cases, but the result can
     * differ if the image is wrapped by an ImageWrapper that changes its size
     * or orientation.
     */
    getImageSpaceInvalidationRect(aRect: nsIntRectType): nsIntRectByVal;
    /**
     * Removes any ImageWrappers and returns the unwrapped base image.
     */
    unwrap(): TempRefImgIContainer;
    /**
     * Called when media feature values that apply to all documents (such as
     * those based on system metrics) have changed.  If this image is a type
     * that can respond to media queries (i.e., an SVG image), this function
     * is overridden to handle restyling and invalidating the image.
     */
    mediaFeatureValuesChangedAllDocuments(aChange: MediaFeatureChange): void;
    /**
     *
     */
    getNativeSizesLength(): size_t;
}

/**
 * This interface is used in debug builds (and only there) in
 * order to let automatic tests running JavaScript access
 * internal state of imgContainers. This lets us test
 * things like animation.
 */
declare interface imgIContainerDebugType extends nsISupportsType {
    /**
     * The # of frames this imgContainer has been notified about.
     * That is equal to the # of times the animation timer has
     * fired, and is usually equal to the # of frames actually
     * drawn (but actual drawing might be disabled).
     */
    readonly framesNotified: uint32_t;
}

/**
 * imgIEncoder interface
 */
declare interface imgIEncoderType extends nsIAsyncInputStreamType {
    /**
     * data - list of bytes in the format specified by inputFormat
     * width  - width in pixels
     * height - height in pixels
     * stride - number of bytes per row in the image
     * Normally (width*3) or (width*4), depending on your input format,
     * but some data uses padding at the end of each row, which would
     * be extra.
     * inputFormat - one of INPUT_FORMAT_* specifying the format of data
     * outputOptions - semicolon-delimited list of name=value pairs that can
     * give options to the output encoder. Options are encoder-
     * specific. Just give empty string for default behavior.
     */
    initFromData(data: uint8_t[], length: unsigned_long, width: uint32_t, height: uint32_t, stride: uint32_t, inputFormat: uint32_t, outputOptions: AString): void;
    /**
     * For encoding images which may contain multiple frames, the 1-shot
     * initFromData() interface is too simplistic. The alternative is to
     * use startImageEncode(), call addImageFrame() one or more times, and
     * then finish initialization with endImageEncode().
     *
     * The arguments are basically the same as in initFromData().
     */
    startImageEncode(width: uint32_t, height: uint32_t, inputFormat: uint32_t, outputOptions: AString): void;
    /**
     *
     */
    addImageFrame(data: uint8_t[], length: unsigned_long, width: uint32_t, height: uint32_t, stride: uint32_t, frameFormat: uint32_t, frameOptions: AString): void;
    /**
     *
     */
    endImageEncode(): void;
}

/**
 * imgILoader interface
 *
 * @author Stuart Parmenter <pavlov@netscape.com>
 * @version 0.3
 * @see imagelib2
 */
declare interface imgILoaderType extends nsISupportsType {
    /**
     * Start the load and decode of an image.
     * @param aURI the URI to load
     * @param aInitialDocumentURI the URI that 'initiated' the load -- used for
     * 3rd party cookie blocking
     * @param aReferrerInfo the referrer info to compute sending referrer.
     * @param aLoadingPrincipal the principal of the loading document
     * @param aLoadGroup Loadgroup to put the image load into
     * @param aObserver the observer (may be null)
     * @param aLoadingDocument loading document
     * @param aLoadFlags Load flags for the request
     * @param aCacheKey cache key to use for a load if the original
     * image came from a request that had post data
     * @param aContentPolicyType [optional] the nsContentPolicyType to
     * use for this load. Defaults to
     * nsIContentPolicy::TYPE_IMAGE
     * ImageLib does NOT keep a strong ref to the observer; this prevents
     * reference cycles.  This means that callers of loadImage should
     * make sure to Cancel() the resulting request before the observer
     * goes away.
     */
    loadImageXPCOM(aURI: nsIURIType, aInitialDocumentURL: nsIURIType, aReferrerInfo: nsIReferrerInfoType, aLoadingPrincipal: nsIPrincipalType, aLoadGroup: nsILoadGroupType, aObserver: imgINotificationObserver, aLoadingDocument: Document, aLoadFlags: nsLoadFlags, cacheKey: nsISupportsType, aContentPolicyType: nsContentPolicyType): imgIRequest;
    /**
     * Start the load and decode of an image.
     * @param aChannel the channel to load the image from.  This must
     * already be opened before this method is called, and there
     * must have been no OnDataAvailable calls for it yet.
     * @param aObserver the observer (may be null)
     * @param aLoadingDocument loading document
     * @param aListener [out]
     * A listener that you must send the channel's notifications and data
     * to.  Can be null, in which case imagelib has found a cached image
     * and is not interested in the data. @aChannel will be canceled for
     * you in this case.
     *
     * ImageLib does NOT keep a strong ref to the observer; this prevents
     * reference cycles.  This means that callers of loadImageWithChannel should
     * make sure to Cancel() the resulting request before the observer goes away.
     */
    loadImageWithChannelXPCOM(aChannel: nsIChannelType, aObserver: imgINotificationObserver, aLoadingDocument: Document, aListener: nsIStreamListenerType): imgIRequest;
}

/**
 *
 */
declare interface imgINotificationObserverType extends nsISupportsType {
}

/**
 * imgIRequest interface
 *
 * @author Stuart Parmenter <stuart@mozilla.com>
 * @version 0.1
 * @see imagelib2
 */
declare interface imgIRequestType extends nsIRequestType {
    /**
     * the image container...
     * @return the image object associated with the request.
     * @attention NEED DOCS
     */
    readonly image: imgIContainer;
    /**
     * Provider ID for image providers created by this image.
     */
    readonly providerId: unsigned_long;
    /**
     * The principal for the document that loaded this image. Used when trying to
     * validate a CORS image load.
     */
    readonly triggeringPrincipal: nsIPrincipal;
    /**
     * Status flags of the STATUS_* variety.
     */
    readonly imageStatus: unsigned_long;
    /**
     * Actual error code that generated a STATUS_ERROR imageStatus
     * (see xpcom/base/ErrorList.h)
     */
    readonly imageErrorCode: nsresult;
    /**
     * The URI the image load was started with.  Note that this might not be the
     * actual URI for the image (e.g. if HTTP redirects happened during the
     * load).
     */
    readonly URI: nsIURI;
    /**
     * The URI of the resource we ended up loading after all redirects, etc.
     */
    readonly finalURI: nsIURI;
    /**
     *
     */
    readonly notificationObserver: imgINotificationObserver;
    /**
     *
     */
    readonly mimeType: string;
    /**
     * The filename that should be used when saving the image. This is determined
     * from the Content-Disposition, if present, or the uri of the image. This
     * filename should be validated using nsIMIMEService::GetValidFilenameForSaving
     * before creating the file.
     */
    readonly fileName: ACString;
    /**
     * Clone this request; the returned request will have aObserver as the
     * observer.  aObserver will be notified synchronously (before the clone()
     * call returns) with all the notifications that have already been dispatched
     * for this image load.
     */
    clone(aObserver: imgINotificationObserver): imgIRequest;
    /**
     * The principal gotten from the channel the image was loaded from.
     */
    readonly imagePrincipal: nsIPrincipal;
    /**
     * true if the loading of the image required cross-origin redirects.
     */
    readonly hadCrossOriginRedirects: bool;
    /**
     * Whether the request is multipart (ie, multipart/x-mixed-replace)
     */
    readonly multipart: bool;
    /**
     * The CORS mode that this image was loaded with (a mozilla::CORSMode).
     */
    readonly CORSMode: long;
    /**
     * The referrer that this image was loaded with.
     */
    readonly referrerInfo: nsIReferrerInfo;
    /**
     * Cancels this request as in nsIRequest::Cancel(); further, also nulls out
     * decoderObserver so it gets no further notifications from us.
     *
     * NOTE: You should not use this in any new code; instead, use cancel(). Note
     * that cancel() is asynchronous, which means that some time after you call
     * it, the listener/observer will get an OnStopRequest(). This means that, if
     * you're the observer, you can't call cancel() from your destructor.
     */
    cancelAndForgetObserver(aStatus: nsresult): void;
    /**
     * Requests a synchronous decode for the image.
     *
     * imgIContainer has a startDecoding() method, but callers may want to request
     * a decode before the container has necessarily been instantiated. Calling
     * startDecoding() on the imgIRequest simply forwards along the request if the
     * container already exists, or calls it once the container becomes available
     * if it does not yet exist.
     */
    startDecoding(aFlags: uint32_t): void;
    /**
     * Locks an image. If the image does not exist yet, locks it once it becomes
     * available. The lock persists for the lifetime of the imgIRequest (until
     * unlockImage is called) even if the underlying image changes.
     *
     * If you don't call unlockImage() by the time this imgIRequest goes away, it
     * will be called for you automatically.
     *
     * @see imgIContainer::lockImage for documentation of the underlying call.
     */
    lockImage(): void;
    /**
     * Unlocks an image.
     *
     * @see imgIContainer::unlockImage for documentation of the underlying call.
     */
    unlockImage(): void;
    /**
     * If this image is unlocked, discard the image's decoded data.  If the image
     * is locked or is already discarded, do nothing.
     */
    requestDiscard(): void;
    /**
     * If this request is for an animated image, the method creates a new
     * request which contains the current frame of the image.
     * Otherwise returns the same request.
     */
    getStaticRequest(): imgIRequest;
    /**
     * Requests that the image animate (if it has an animation).
     *
     * @see Image::IncrementAnimationConsumers for documentation of the
     * underlying call.
     */
    incrementAnimationConsumers(): void;
    /**
     * Tell the image it can forget about a request that the image animate.
     *
     * @see Image::DecrementAnimationConsumers for documentation of the
     * underlying call.
     */
    decrementAnimationConsumers(): void;
    /**
     *
     */
    boostPriority(aCategory: uint32_t): void;
}

/**
 *
 */
declare interface imgIScriptedNotificationObserverType extends nsISupportsType {
    /**
     *
     */
    sizeAvailable(aRequest: imgIRequest): void;
    /**
     *
     */
    frameUpdate(aRequest: imgIRequest): void;
    /**
     *
     */
    frameComplete(aRequest: imgIRequest): void;
    /**
     *
     */
    loadComplete(aRequest: imgIRequest): void;
    /**
     *
     */
    decodeComplete(aRequest: imgIRequest): void;
    /**
     *
     */
    discard(aRequest: imgIRequest): void;
    /**
     *
     */
    isAnimated(aRequest: imgIRequest): void;
    /**
     *
     */
    hasTransparency(aRequest: imgIRequest): void;
}

/**
 *
 */
declare interface imgIToolsType extends nsISupportsType {
    /**
     * decodeImageFromBuffer
     * Caller provides an buffer, a buffer size and a mimetype. We read from
     * the stream and decompress it (according to the specified mime type) and
     * return the resulting imgIContainer.
     *
     * @param aBuffer
     * Data in memory.
     * @param aSize
     * Buffer size.
     * @param aMimeType
     * Type of image in the stream.
     */
    decodeImageFromBuffer(aBuffer: string, aSize: unsigned_long, aMimeType: ACString): imgIContainer;
    /**
     * decodeImageFromArrayBuffer
     * Caller provides an ArrayBuffer and a mimetype. We read from
     * the stream and decompress it (according to the specified mime type) and
     * return the resulting imgIContainer.
     *
     * @param aArrayBuffer
     * An ArrayBuffer.
     * @param aMimeType
     * Type of image in the stream.
     */
    decodeImageFromArrayBuffer(aArrayBuffer: jsval, aMimeType: ACString): imgIContainer;
    /**
     * decodeImageFromChannelAsync
     * See decodeImage. The main difference between this method and decodeImage
     * is that here the operation is done async on a thread from the decode
     * pool. When the operation is completed, the callback is executed with the
     * result.
     *
     * @param aURI
     * The original URI of the image
     * @param aChannel
     * Channel to the image to be decoded.
     * @param aCallback
     * The callback is executed when the imgContainer is fully created.
     * @param aObserver
     * Optional observer for the decoded image, the caller should make
     * sure the observer is kept alive as long as necessary, as ImageLib
     * does not keep a strong reference to the observer.
     */
    decodeImageFromChannelAsync(aURI: nsIURIType, aChannel: nsIChannelType, aCallback: imgIContainerCallback, aObserver: imgINotificationObserver): void;
    /**
     * decodeImageAsync
     * See decodeImage. The main difference between this method and decodeImage
     * is that here the operation is done async on a thread from the decode
     * pool. When the operation is completed, the callback is executed with the
     * result.
     *
     * @param aStream
     * An input stream for an encoded image file.
     * @param aMimeType
     * Type of image in the stream.
     * @param aCallback
     * The callback is executed when the imgContainer is fully created.
     * @param aEventTarget
     * This eventTarget is used to execute aCallback
     */
    decodeImageAsync(aStream: nsIInputStreamType, aMimeType: ACString, aCallback: imgIContainerCallback, aEventTarget: nsIEventTargetType): void;
    /**
     * encodeImage
     * Caller provides an image container, and the mime type it should be
     * encoded to. We return an input stream for the encoded image data.
     *
     * @param aContainer
     * An image container.
     * @param aMimeType
     * Type of encoded image desired (eg "image/png").
     * @param outputOptions
     * Encoder-specific output options.
     */
    encodeImage(aContainer: imgIContainer, aMimeType: ACString, outputOptions: AString): nsIInputStream;
    /**
     * encodeScaledImage
     * Caller provides an image container, and the mime type it should be
     * encoded to. We return an input stream for the encoded image data.
     * The encoded image is scaled to the specified dimensions.
     *
     * @param aContainer
     * An image container.
     * @param aMimeType
     * Type of encoded image desired (eg "image/png").
     * @param aWidth, aHeight
     * The size (in pixels) desired for the resulting image. Specify 0 to
     * use the given image's width or height. Values must be >= 0.
     * @param outputOptions
     * Encoder-specific output options.
     */
    encodeScaledImage(aContainer: imgIContainer, aMimeType: ACString, aWidth: long, aHeight: long, outputOptions: AString): nsIInputStream;
    /**
     * getImgLoaderForDocument
     * Retrieve an image loader that reflects the privacy status of the given
     * document.
     *
     * @param doc
     * A document. Must not be null.
     */
    getImgLoaderForDocument(doc: Document): imgILoader;
    /**
     * getImgLoaderForDocument
     * Retrieve an image cache that reflects the privacy status of the given
     * document.
     *
     * @param doc
     * A document. Null is allowed, but must _only_ be passed
     * when there is no way to obtain a relevant document for
     * the current context in which a cache is desired.
     */
    getImgCacheForDocument(doc: Document): imgICache;
    /**
     * encodeCroppedImage
     * Caller provides an image container, and the mime type it should be
     * encoded to. We return an input stream for the encoded image data.
     * The encoded image is cropped to the specified dimensions.
     *
     * The given offset and size must not exceed the image bounds.
     *
     * @param aContainer
     * An image container.
     * @param aMimeType
     * Type of encoded image desired (eg "image/png").
     * @param aOffsetX, aOffsetY
     * The crop offset (in pixels). Values must be >= 0.
     * @param aWidth, aHeight
     * The size (in pixels) desired for the resulting image. Specify 0 to
     * use the given image's width or height. Values must be >= 0.
     * @param outputOptions
     * Encoder-specific output options.
     */
    encodeCroppedImage(aContainer: imgIContainer, aMimeType: ACString, aOffsetX: long, aOffsetY: long, aWidth: long, aHeight: long, outputOptions: AString): nsIInputStream;
    /**
     * Create a wrapper around a scripted notification observer (ordinarily
     * imgINotificationObserver cannot be implemented from scripts).
     *
     * @param aObserver The scripted observer to wrap
     */
    createScriptedObserver(aObserver: imgIScriptedNotificationObserver): imgINotificationObserver;
}

/**
 * This is a companion interface for nsIAsyncInputStream::asyncWait.
 */
declare interface imgIContainerCallbackType extends nsISupportsType {
    /**
     * If the operation fails, aStatus will contain the error value
     */
    onImageReady(aImage: imgIContainer, aStatus: nsresult): void;
}

/**
 *
 */
declare interface inIDeepTreeWalkerType extends nsISupportsType {
    /**
     *
     */
    showAnonymousContent: boolean;
    /**
     *
     */
    showSubDocuments: boolean;
    /**
     *
     */
    showDocumentsAsNodes: boolean;
    /**
     *
     */
    init(aRoot: Node): void;
    /**
     *
     */
    readonly root: Node;
    /**
     *
     */
    currentNode: Node;
    /**
     *
     */
    parentNode(): Node;
    /**
     *
     */
    firstChild(): Node;
    /**
     *
     */
    lastChild(): Node;
    /**
     *
     */
    previousSibling(): Node;
    /**
     *
     */
    nextSibling(): Node;
    /**
     *
     */
    previousNode(): Node;
    /**
     *
     */
    nextNode(): Node;
}

/**
 *
 */
declare interface mozIAppServicesLoggerType extends nsISupportsType {
    /**
     *
     */
    register(target: AString, logger: mozIServicesLogSink): void;
}

/**
 *
 */
declare interface mozIVisitInfoType extends nsISupportsType {
    /**
     * The machine-local (internal) id of the visit.
     */
    readonly visitId: long_long;
    /**
     * The time the visit occurred.
     */
    readonly visitDate: PRTime;
    /**
     * The transition type used to get to this visit.  One of the TRANSITION_TYPE
     * constants on nsINavHistory.
     *
     * @see nsINavHistory.idl
     */
    readonly transitionType: unsigned_long;
    /**
     * The referring URI of this visit.  This may be null.
     */
    readonly referrerURI: nsIURI;
}

/**
 *
 */
declare interface mozIPlaceInfoType extends nsISupportsType {
    /**
     * The machine-local (internal) id of the place.
     */
    readonly placeId: long_long;
    /**
     * The globally unique id of the place.
     */
    readonly guid: ACString;
    /**
     * The URI of the place.
     */
    readonly uri: nsIURI;
    /**
     * The title associated with the place.
     */
    readonly title: AString;
    /**
     * The frecency of the place.
     */
    readonly frecency: long_long;
    /**
     * An array of mozIVisitInfo objects for the place.
     */
    readonly visits: jsval;
}

/**
 * Shared Callback interface for mozIAsyncHistory methods. The semantics
 * for each method are detailed in mozIAsyncHistory.
 */
declare interface mozIVisitInfoCallbackType extends nsISupportsType {
    /**
     * Called when the given place could not be processed.
     *
     * @param aResultCode
     * nsresult indicating the failure reason.
     * @param aPlaceInfo
     * The information that was given to the caller for the place.
     */
    handleError(aResultCode: nsresult, aPlaceInfo: mozIPlaceInfo): void;
    /**
     * Called for each place processed successfully.
     *
     * @param aPlaceInfo
     * The current info stored for the place.
     */
    handleResult(aPlaceInfo: mozIPlaceInfo): void;
    /**
     * Called when all records were processed.
     * @param aUpdatedItems
     * How many items were successfully updated.
     */
    handleCompletion(aUpdatedItems: unsigned_long): void;
    /**
     * These two attributes govern whether we attempt to call
     * handleResult and handleError, respectively, if/once
     * results/errors occur.
     */
    readonly ignoreResults: bool;
    /**
     *
     */
    readonly ignoreErrors: bool;
}

/**
 *
 */
declare interface mozIVisitedStatusCallbackType extends nsISupportsType {
    /**
     * Notifies whether a certain URI has been visited.
     *
     * @param aURI
     * URI being notified about.
     * @param aVisitedStatus
     * The visited status of aURI.
     */
    isVisited(aURI: nsIURIType, aVisitedStatus: boolean): void;
}

/**
 * This interface contains APIs for cpp consumers.
 * Javascript consumers should look at History.jsm instead,
 * that is exposed through PlacesUtils.history.
 *
 * If you're evaluating adding a new history API, it should
 * usually go to History.jsm, unless it needs to do long and
 * expensive work in a batch, then it could be worth doing
 * that in History.cpp.
 */
declare interface mozIAsyncHistoryType extends nsISupportsType {
    /**
     * Adds a set of visits for one or more mozIPlaceInfo objects, and updates
     * each mozIPlaceInfo's title or guid.
     *
     * aCallback.handleResult is called for each visit added.
     *
     * @param aPlaceInfo
     * The mozIPlaceInfo object[s] containing the information to store or
     * update.  This can be a single object, or an array of objects.
     * @param [optional] aCallback
     * A mozIVisitInfoCallback object which consists of callbacks to be
     * notified for successful and/or failed changes.
     *
     * @throws NS_ERROR_INVALID_ARG
     * - Passing in NULL for aPlaceInfo.
     * - Not providing at least one valid guid, or uri for all
     * mozIPlaceInfo object[s].
     * - Not providing an array or nothing for the visits property of
     * mozIPlaceInfo.
     * - Not providing a visitDate and transitionType for each
     * mozIVisitInfo.
     * - Providing an invalid transitionType for a mozIVisitInfo.
     */
    updatePlaces(aPlaceInfo: jsval, aCallback: mozIVisitInfoCallback): void;
    /**
     * Checks if a given URI has been visited.
     *
     * @param aURI
     * The URI to check for.
     * @param aCallback
     * A mozIVisitStatusCallback object which receives the visited status.
     */
    isURIVisited(aURI: nsIURIType, aCallback: mozIVisitedStatusCallback): void;
    /**
     * Helper to clear any internal state caches, like the recent URIs list.
     * This may be useful in testing code.
     */
    clearCache(): void;
}

/**
 *
 */
declare interface mozIBridgedSyncEngineCallbackType extends nsISupportsType {
    /**
     *
     */
    handleSuccess(result: nsIVariantType): void;
    /**
     *
     */
    handleError(code: nsresult, message: AUTF8String): void;
}

/**
 *
 */
declare interface mozIBridgedSyncEngineApplyCallbackType extends nsISupportsType {
    /**
     *
     */
    handleSuccess(outgoingEnvelopesAsJSON: invalid): void;
    /**
     *
     */
    handleError(code: nsresult, message: AUTF8String): void;
}

/**
 *
 */
declare interface mozIBridgedSyncEngineType extends nsISupportsType {
    /**
     *
     */
    readonly storageVersion: long;
    /**
     *
     */
    readonly allowSkippedRecord: boolean;
    /**
     *
     */
    logger: mozIServicesLogSink;
    /**
     *
     */
    getLastSync(callback: mozIBridgedSyncEngineCallback): void;
    /**
     *
     */
    setLastSync(lastSyncMillis: long_long, callback: mozIBridgedSyncEngineCallback): void;
    /**
     *
     */
    getSyncId(callback: mozIBridgedSyncEngineCallback): void;
    /**
     *
     */
    resetSyncId(callback: mozIBridgedSyncEngineCallback): void;
    /**
     *
     */
    ensureCurrentSyncId(newSyncId: AUTF8String, callback: mozIBridgedSyncEngineCallback): void;
    /**
     *
     */
    syncStarted(callback: mozIBridgedSyncEngineCallback): void;
    /**
     *
     */
    storeIncoming(incomingEnvelopesAsJSON: invalid, callback: mozIBridgedSyncEngineCallback): void;
    /**
     *
     */
    apply(callback: mozIBridgedSyncEngineApplyCallback): void;
    /**
     *
     */
    setUploaded(newTimestampMillis: long_long, uploadedIds: invalid, callback: mozIBridgedSyncEngineCallback): void;
    /**
     *
     */
    syncFinished(callback: mozIBridgedSyncEngineCallback): void;
    /**
     *
     */
    reset(callback: mozIBridgedSyncEngineCallback): void;
    /**
     *
     */
    wipe(callback: mozIBridgedSyncEngineCallback): void;
}

/**
 * Placeholder interfaces to allow passing inner/outer windows through XPIDL.
 */
declare interface mozIDOMWindowType extends nsISupportsType {
}

/**
 *
 */
declare interface mozIDOMWindowProxyType extends nsISupportsType {
}

/**
 *
 */
declare interface mozIDownloadPlatformType extends nsISupportsType {
    /**
     * Perform platform specific operations when a download is done.
     *
     * Windows:
     * Add the download to the recent documents list
     * Set the file to be indexed for searching
     * Mac:
     * Bounce the downloads dock icon
     * GTK:
     * Add the download to the recent documents list
     * Save the source uri in the downloaded file's metadata
     * Android:
     * Scan media
     *
     * @param aSource
     * Source URI of the download
     * @param aReferrer
     * Referrer URI of the download
     * @param aTarget
     * Downloaded file
     * @param aContentType
     * The source's content type
     * @param aIsPrivate
     * True for private downloads
     * @return Promise that resolves once operations have completed.
     */
    downloadDone(aSource: nsIURIType, aReferrer: nsIURIType, aTarget: nsIFileType, aContentType: ACString, aIsPrivate: boolean): Promise;
    /**
     * Proxy for IInternetSecurityManager::MapUrlToZone().
     *
     * Windows only.
     *
     * @param aURL
     * URI of the download
     * @return Security Zone corresponding to aURL.
     */
    mapUrlToZone(aURL: AString): unsigned_long;
}

/**
 *
 */
declare interface mozIExtensionServiceWorkerInfoType extends nsISupportsType {
    /**
     *
     */
    readonly principal: nsIPrincipal;
    /**
     *
     */
    readonly scriptURL: AString;
    /**
     *
     */
    readonly clientInfoId: AString;
    /**
     *
     */
    readonly descriptorId: unsigned_long_long;
}

/**
 *
 */
declare interface mozIExtensionListenerCallOptionsType extends nsISupportsType {
    /**
     *
     */
    readonly apiObjectType: mozIExtensionListenerCallOptions_APIObjectType;
    /**
     *
     */
    readonly apiObjectDescriptor: jsval;
    /**
     *
     */
    readonly apiObjectPrepended: bool;
    /**
     *
     */
    callbackType: mozIExtensionListenerCallOptions_CallbackType;
}

/**
 *
 */
declare interface mozIExtensionEventListenerType extends nsISupportsType {
    /**
     *
     */
    callListener(args: invalid, listenerCallOptions: mozIExtensionListenerCallOptions): Promise;
}

/**
 *
 */
declare interface mozIExtensionAPIRequestType extends nsISupportsType {
    /**
     *
     */
    toString(): AUTF8String;
    /**
     *
     */
    readonly requestType: AUTF8String;
    /**
     *
     */
    readonly apiNamespace: AUTF8String;
    /**
     *
     */
    readonly apiName: AUTF8String;
    /**
     *
     */
    readonly apiObjectType: AUTF8String;
    /**
     *
     */
    readonly apiObjectId: AUTF8String;
    /**
     *
     */
    readonly args: jsval;
    /**
     *
     */
    normalizedArgs: jsval;
    /**
     *
     */
    readonly callerSavedFrame: jsval;
    /**
     *
     */
    readonly serviceWorkerInfo: mozIExtensionServiceWorkerInfo;
    /**
     *
     */
    readonly eventListener: mozIExtensionEventListener;
}

/**
 *
 */
declare interface mozIExtensionAPIRequestResultType extends nsISupportsType {
    /**
     *
     */
    readonly type: mozIExtensionAPIRequestResult_ResultType;
    /**
     *
     */
    readonly value: jsval;
}

/**
 *
 */
declare interface mozIExtensionAPIRequestHandlerType extends nsISupportsType {
    /**
     * Handle an API request originated from the WebExtensions webidl API
     * bindings.
     *
     * @param extension An instance of the WebExtensionPolicy webidl interface.
     * @param apiRequest An instance of the mozIExtensionAPIRequest xpcom interface.
     *
     * @return mozIExtensionAPIRequestResult
     * JS value returned by the API request handler, may contain a value
     * (the result of the API call or a WebIDL dictionary that is used to
     * initialize WebIDL-based API object, e.g. ExtensionPort) or
     * an Error to be throw on the thread that originated the request.
     */
    handleAPIRequest(extension: nsISupportsType, apiRequest: mozIExtensionAPIRequest, apiRequestResult: mozIExtensionAPIRequestResult): void;
    /**
     * A method called when an extension background service worker is initialized and
     * ready to execute its main script.
     *
     * @param extension An instance of the WebExtensionPolicy webidl interface.
     * @param serviceWorkerInfo
     */
    initExtensionWorker(extension: nsISupportsType, serviceWorkerInfo: mozIExtensionServiceWorkerInfo): void;
    /**
     * A method called when an extension background service worker has loaded its
     * main script.
     *
     * @param extension An instance of the WebExtensionPolicy webidl interface.
     * @param serviceWorkerDescriptorId
     */
    onExtensionWorkerLoaded(extension: nsISupportsType, serviceWorkerDescriptorId: unsigned_long_long): void;
    /**
     * A method called when an extension background service worker is destroyed.
     *
     * @param extension An instance of the WebExtensionPolicy webidl interface.
     * @param serviceWorkerDescriptorId
     */
    onExtensionWorkerDestroyed(extension: nsISupportsType, serviceWorkerDescriptorId: unsigned_long_long): void;
}

/**
 *
 */
declare interface mozIExtensionProcessScriptType extends nsISupportsType {
    /**
     *
     */
    preloadContentScript(contentScript: nsISupportsType): void;
    /**
     *
     */
    loadContentScript(contentScript: WebExtensionContentScript, window: mozIDOMWindow): Promise;
    /**
     *
     */
    initExtensionDocument(extension: nsISupportsType, doc: Document, privileged: bool): void;
}

/**
 *
 */
declare interface mozIExtensionStorageAreaType extends nsISupportsType {
    /**
     *
     */
    set(extensionId: AUTF8String, json: AUTF8String, callback: mozIExtensionStorageCallback): void;
    /**
     *
     */
    get(extensionId: AUTF8String, key: AUTF8String, callback: mozIExtensionStorageCallback): void;
    /**
     *
     */
    remove(extensionId: AUTF8String, key: AUTF8String, callback: mozIExtensionStorageCallback): void;
    /**
     *
     */
    clear(extensionId: AUTF8String, callback: mozIExtensionStorageCallback): void;
    /**
     *
     */
    getBytesInUse(extensionId: AUTF8String, keys: AUTF8String, callback: mozIExtensionStorageCallback): void;
    /**
     *
     */
    takeMigrationInfo(callback: mozIExtensionStorageCallback): void;
}

/**
 *
 */
declare interface mozIConfigurableExtensionStorageAreaType extends nsISupportsType {
    /**
     *
     */
    configure(databaseFile: nsIFileType, kintoFile: nsIFileType): void;
    /**
     *
     */
    teardown(callback: mozIExtensionStorageCallback): void;
}

/**
 *
 */
declare interface mozISyncedExtensionStorageAreaType extends nsISupportsType {
    /**
     *
     */
    fetchPendingSyncChanges(callback: mozIExtensionStorageCallback): void;
}

/**
 *
 */
declare interface mozIExtensionStorageListenerType extends nsISupportsType {
    /**
     *
     */
    onChanged(extensionId: AUTF8String, json: AUTF8String): void;
}

/**
 *
 */
declare interface mozIExtensionStorageCallbackType extends nsISupportsType {
    /**
     *
     */
    handleSuccess(result: nsIVariantType): void;
    /**
     *
     */
    handleError(code: nsresult, message: AUTF8String): void;
}

/**
 *
 */
declare interface mozIGeckoMediaPluginChromeServiceType extends nsISupportsType {
    /**
     * Add a directory to scan for gecko media plugins.
     * @note Main-thread API.
     */
    addPluginDirectory(directory: AString): void;
    /**
     * Remove a directory for gecko media plugins.
     * @note Main-thread API.
     */
    removePluginDirectory(directory: AString): void;
    /**
     * Remove a directory for gecko media plugins and delete it from disk.
     * If |defer| is true, wait until the plugin is unused before removing.
     * @note Main-thread API.
     */
    removeAndDeletePluginDirectory(directory: AString, defer: bool): void;
    /**
     * Clears storage data associated with the site and the originAttributes
     * pattern in JSON format.
     */
    forgetThisSite(site: AString, aPattern: AString): void;
    /**
     * Clears storage data associated with the base domain
     * This means cleaning any storage that is associated
     * either by origin or top level origin with the base domain
     */
    forgetThisBaseDomain(baseDomain: AString): void;
    /**
     * Returns true if the given node id is allowed to store things
     * persistently on disk. Private Browsing and local content are not
     * allowed to store persistent data.
     */
    isPersistentStorageAllowed(nodeId: ACString): bool;
    /**
     * Returns the directory to use as the base for storing data about GMPs.
     */
    getStorageDir(): nsIFile;
}

/**
 *
 */
declare interface mozIGeckoMediaPluginServiceType extends nsISupportsType {
    /**
     * The GMP thread. Callable from any thread.
     */
    readonly thread: nsIThread;
    /**
     * Run through windows registered registered for pluginId, sending
     * 'PluginCrashed' chrome-only event
     */
    RunPluginCrashCallbacks(pluginId: unsigned_long, pluginName: ACString): void;
}

/**
 *
 */
declare interface mozIInterruptibleType extends nsISupportsType {
    /**
     *
     */
    interrupt(): void;
}

/**
 * Interface for synchronous script loads from local file: or jar: sources.
 * For asynchronous script loads, ChromeUtils.compileScript() should be used
 * instead.
 */
declare interface mozIJSSubScriptLoaderType extends nsISupportsType {
    /**
     * This method should only be called from JS!
     * In JS, the signature looks like:
     * rv loadSubScript (url [, obj] [, charset]);
     * @param url the url of the UTF-8-encoded sub-script, it MUST be either a
     * file:, resource:, blob:, or chrome: url, and MUST be local.
     * @param obj an optional object to evaluate the script onto, it
     * defaults to the global object of the caller.
     * @retval rv the value returned by the sub-script
     */
    loadSubScript(url: AString, obj: jsval): jsval;
    /**
     * This method should only be called from JS!
     * In JS, the signature looks like:
     * rv = loadSubScript (url, optionsObject)
     * @param url the url of the UTF-8-encoded sub-script, which MUST be either
     * a file:, resource:, blob:, or chrome: url, and MUST be local.
     * @param optionsObject an object with parameters. Valid parameters are:
     * - target:  an object to evaluate onto (default: global object of the caller)
     * - ignoreCache: if set to true, will bypass the cache for reading the file.
     * - async: if set to true, the script will be loaded
     * asynchronously, and a Promise is returned which
     * resolves to its result when execution is complete.
     * - wantReturnValue: If true, the script will return
     * the value of the last statement that it evaluated.
     * This option disables most optimizations in the
     * top-level scope, and should be avoided if at all
     * possible. Defaults to false.
     * @retval rv the value returned by the sub-script
     */
    loadSubScriptWithOptions(url: AString, options: jsval): jsval;
}

/**
 *
 */
declare interface mozILocaleServiceType extends nsISupportsType {
    /**
     * Default locale of the browser. The locale we are guaranteed to have
     * resources for that should be used as a last resort fallack in cases
     * where requested locales do not match available locales.
     */
    readonly defaultLocale: ACString;
    /**
     * Last fallback is the final fallback locale we're going to attempt if all
     * else fails in any language negotiation or locale resource retrieval situations.
     *
     * At the moment it returns `en-US`.
     */
    readonly lastFallbackLocale: ACString;
    /**
     * Returns the best locale that the application should be localized to.
     *
     * The result is a valid locale ID and it should be
     * used for all APIs that do not handle language negotiation.
     *
     * When retrieving the locales for language negotiation and matching
     * to language resources, use the language tag form.
     * When retrieving the locales for Intl API or ICU locale settings,
     * use the BCP47 form.
     *
     * Where possible, appLocales* should be preferred over this API and
     * all callsites should handle some form of "best effort" language
     * negotiation to respect user preferences in case the use case does
     * not have data for the first locale in the list.
     *
     * Example: "zh-Hans-HK"
     */
    readonly appLocaleAsLangTag: ACString;
    /**
     *
     */
    readonly appLocaleAsBCP47: ACString;
    /**
     * Returns the top-requested locale from the user, or an empty string if none is set.
     */
    readonly requestedLocale: ACString;
    /**
     * Returns whether the current app locale is RTL.
     */
    readonly isAppLocaleRTL: boolean;
}

/**
 * This is a set of APIs that are of general usefulness for user interface
 * internationalization.
 *
 * They're all in various stages of the standardization process through
 * ECMA402, so they are exposed to privileged content only but are written
 * in the way to allow for easy migration to standard Intl object once
 * the appropriate stage of the ECMA402 is achieved.
 *
 * The exact structure of the code is a little bit complex because of that:
 *
 * 1) The core is in SpiderMonkey together with other Intl APIs
 *
 * This allows us to write the code once, stick to the spec language
 * of the proposal, reuse our ICU bindings in Spidermonkey and use
 * the code to inform us on refining the spec proposal for the given API itself.
 *
 * 2) The MozIntlHelper API exposes the SpiderMonkey APIs
 *
 * This helper API allows attaching the new APIs on any regular object.
 *
 * 3) The MozIntl API provides the access to those APIs
 *
 * This API exposes the actual functionality and wraps around the MozIntlHelper
 * lazily retrieving and setting the accessors.
 * On top of that, the API also binds additional functionality like using
 * current application locale by default, and fetching OS regional preferences
 * for date time format.
 */
declare interface mozIMozIntlType extends nsISupportsType {
    /**
     *
     */
    getCalendarInfo(locales: jsval): jsval;
    /**
     * Helper for IntlUtils.webidl, will be removed once Intl.DisplayNames
     * supports date-time types in non-privileged code.
     */
    getDisplayNamesDeprecated(locales: jsval, options: jsval): jsval;
    /**
     * Returns a list of locale codes for a given type.
     * At the moment only type="region" is supported.
     *
     * Example:
     * let codes = getAvailableLocaleDisplayNames("region");
     * codes === ["ar", "ae", "af", ...]
     */
    getAvailableLocaleDisplayNames(type: jsval): jsval;
    /**
     * Returns a list of language names formatted for display.
     *
     * Example:
     * let langs = getLanguageDisplayNames(["pl"], ["fr", "de", "en"]);
     * langs === ["Francuski", "Niemiecki", "Angielski"]
     */
    getLanguageDisplayNames(locales: jsval, langCodes: jsval): jsval;
    /**
     * Returns a list of region names formatted for display.
     *
     * Example:
     * let regs = getRegionDisplayNames(["pl"], ["US", "CA", "MX"]);
     * regs === ["Stany Zjednoczone", "Kanada", "Meksyk"]
     */
    getRegionDisplayNames(locales: jsval, regionCodes: jsval): jsval;
    /**
     * Returns a list of locale names formatted for display.
     *
     * Example:
     * let locs = getLocaleDisplayNames(["pl"], ["sr-RU", "es-MX", "fr-CA"]);
     * locs === ["Serbski (Rosja)", "Hiszpaski (Meksyk)", "Francuski (Kanada)"]
     */
    getLocaleDisplayNames(locales: jsval, localeCodes: jsval, options: jsval): jsval;
    /**
     * Returns the assumed script directionality for known Firefox locales. This is
     * somewhat crude, but should work until Bug 1750781 lands.
     *
     * TODO (Bug 1750781) - Callers should use Intl.LocaleInfo once it is standardized (see
     * Bug 1693576), rather than maintaining a hardcoded list of RTL locales.
     */
    getScriptDirection(locale: jsval): jsval;
    /**
     *
     */
    readonly Collator: jsval;
    /**
     *
     */
    readonly DateTimeFormat: jsval;
    /**
     *
     */
    readonly DisplayNames: jsval;
    /**
     *
     */
    readonly ListFormat: jsval;
    /**
     *
     */
    readonly Locale: jsval;
    /**
     *
     */
    readonly NumberFormat: jsval;
    /**
     *
     */
    readonly PluralRules: jsval;
    /**
     *
     */
    readonly RelativeTimeFormat: jsval;
}

/**
 * This is an internal helper for mozIMozIntl API. There should be virtually
 * no reason for you to call this API except from mozIMozIntl implementation.
 *
 * This API helps accessing the SpiderMonkey Intl APIs, but it is mozIMozIntl
 * that exposes the thin wrapper around them that binds the functionality
 * to Gecko.
 */
declare interface mozIMozIntlHelperType extends nsISupportsType {
    /**
     *
     */
    addGetCalendarInfo(intlObject: jsval): void;
    /**
     * Adds a MozDateTimeFormat contructor to the given object.
     *
     * The difference between regular Intl.DateTimeFormat and the method created here
     * is that we support two more options:
     *
     * timeStyle: full | long | medium | short
     * dateStyle: full | long | medium | short
     *
     * which allow user to create normalized date/time style formats.
     * Additionally, when those options are used instead of the regular atomic
     * options (hour, minute, month, etc.) this code will look into host
     * Operating System regional preferences and adjust for that.
     *
     * That means that if user will manually select time format (hour12/24) or
     * adjust how the date should be displayed, MozDateTimeFormat will use that.
     *
     * This API should be used everywhere in the UI instead of regular Intl  API.
     */
    addDateTimeFormatConstructor(intlObject: jsval): void;
    /**
     * Adds a MozDisplayNames contructor to the given object.
     *
     * The difference between regular Intl.DisplayNames and the method created here
     * is that we additionally support the following values for the "type" option:
     *
     * weekday
     * month
     * quarter
     * dayPeriod
     *
     * And we additionally support "abbreviated" for the "style" option.
     *
     * MozDisplayNames.prototype.of accepts the following inputs for these options:
     *
     * weekday: an integer in the range 1 = Monday to 7 = Sunday.
     * month: an integer in the range 1 = January to 13 = Undecimber.
     * quarter: an integer in the range 1 to 4.
     * dayPeriod: a string from the set {"am", "pm"}.
     */
    addDisplayNamesConstructor(intlObject: jsval): void;
}

/**
 *
 */
declare interface mozIOSPreferencesType extends nsISupportsType {
    /**
     * Returns the best locale that the host environment is localized to.
     *
     * The result is a valid locale ID and it should be
     * used for all APIs that do not handle language negotiation.
     *
     * In any scenario involving language negotiation, systemLocales should
     * be preferred over the single value.
     *
     * Example: "zh-Hans-HK"
     */
    readonly systemLocale: ACString;
    /**
     * Returns the best possible date/time pattern for the host environment
     * taking into account date/time regional settings user defined in the OS
     * preferences.
     *
     * Notice, that depending on the OS it may take into account those settings
     * for all locales, or only if the locale matches the OS locale.
     *
     * It takes two integer arguments that must be valid `dateTimeFormatStyle*`
     * values (see constants defined above), and a string representing a
     * BCP47 locale.
     *
     * It returns a string with a LDML date/time pattern.
     *
     * If no pattern can be retrieved from the host environment, it will
     * lookup the best available pattern from ICU.
     *
     * Notice, this is a pretty unique method in this API in that it does
     * more than look up into host environment.
     * The reason for that is that constructing the right date/time pattern
     * requires a lot of OS-specific logic and it ends up being easier to just
     * handle all scenarios, including with cases where we fail to retrieve
     * anything from the OS, here.
     */
    getDateTimePattern(timeFormatStyle: long, dateFormatStyle: long, locale: ACString): AUTF8String;
}

/**
 * This interface represents a Personal Dictionary.
 */
declare interface mozIPersonalDictionaryType extends nsISupportsType {
    /**
     * Load the dictionary
     */
    load(): void;
    /**
     * Save the dictionary
     */
    save(): void;
    /**
     * Get the (lexicographically sorted) list of words
     */
    readonly wordList: nsIStringEnumerator;
    /**
     * Check a unicode string
     */
    check(word: AString): boolean;
    /**
     * Add a word to the personal dictionary
     */
    addWord(word: AString): void;
    /**
     * Remove a word from the personal dictionary
     */
    removeWord(word: AString): void;
    /**
     * Add a word to the ignore all list
     */
    ignoreWord(word: AString): void;
    /**
     * Clear the ignore list
     */
    endSession(): void;
}

/**
 * This interface provides some constants used by the Places AutoComplete
 * search provider as well as methods to track opened pages for AutoComplete
 * purposes.
 */
declare interface mozIPlacesAutoCompleteType extends nsISupportsType {
}

/**
 *
 */
declare interface mozIPlacesPendingOperationType extends nsISupportsType {
    /**
     * Cancels a pending operation, if possible.  This will only fail if you try
     * to cancel more than once.
     */
    cancel(): void;
}

/**
 * A simple interface to get the underlying stream from an
 * RemoteLazyInputStream.
 */
declare interface mozIRemoteLazyInputStreamType extends nsISupportsType {
    /**
     * If this RemoteLazyInputStream is actively backed by an actor, get the
     * underlying actor's ID. Will throw if the underlying actor is no longer
     * available.
     */
    readonly internalStreamID: nsIDRef;
}

/**
 *
 */
declare interface mozISandboxReportType extends nsISupportsType {
    /**
     *
     */
    readonly msecAgo: uint64_t;
    /**
     *
     */
    readonly pid: int32_t;
    /**
     *
     */
    readonly tid: int32_t;
    /**
     *
     */
    readonly procType: ACString;
    /**
     *
     */
    readonly syscall: uint32_t;
    /**
     *
     */
    readonly numArgs: uint32_t;
    /**
     *
     */
    getArg(aIndex: uint32_t): ACString;
}

/**
 *
 */
declare interface mozISandboxReportArrayType extends nsISupportsType {
    /**
     *
     */
    readonly begin: uint64_t;
    /**
     *
     */
    readonly end: uint64_t;
    /**
     *
     */
    getElement(aIndex: uint64_t): mozISandboxReport;
}

/**
 *
 */
declare interface mozISandboxReporterType extends nsISupportsType {
    /**
     *
     */
    snapshot(): mozISandboxReportArray;
}

/**
 * Used to expose information about the configuration of the sanbox.
 */
declare interface mozISandboxSettingsType extends nsISupportsType {
    /**
     *
     */
    readonly effectiveContentSandboxLevel: long;
    /**
     * The possible values for this are defined in the ContentWin32kLockdownState
     * enum in security/sandbox/common/SandboxSettings.h
     */
    readonly contentWin32kLockdownState: long;
    /**
     *
     */
    readonly contentWin32kLockdownStateString: AString;
}

/**
 *
 */
declare interface mozISandboxTestType extends nsISupportsType {
    /**
     *
     */
    startTests(aProcessesList: invalid): void;
    /**
     *
     */
    finishTests(): void;
}

/**
 *
 */
declare interface mozIServicesLogSinkType extends nsISupportsType {
    /**
     *
     */
    maxLevel: short;
    /**
     *
     */
    error(message: AString): void;
    /**
     *
     */
    warn(message: AString): void;
    /**
     *
     */
    debug(message: AString): void;
    /**
     *
     */
    trace(message: AString): void;
    /**
     *
     */
    info(message: AString): void;
}

/**
 * This interface represents a SpellChecker.
 */
declare interface mozISpellCheckingEngineType extends nsISupportsType {
    /**
     * the personal dictionary
     */
    personalDictionary: mozIPersonalDictionary;
    /**
     * check a word
     */
    check(word: AString): boolean;
    /**
     * Load dictionaries from the specified dir
     */
    loadDictionariesFromDir(dir: nsIFileType): void;
    /**
     * Add dictionaries from a directory to the spell checker
     */
    addDirectory(dir: nsIFileType): void;
    /**
     * Remove dictionaries from a directory from the spell checker
     */
    removeDirectory(dir: nsIFileType): void;
    /**
     * Add a dictionary with the given language code and source URI. The URI
     * must point to an affix file, with the ".aff" extension. The word list
     * file must be in the same directory, with the same base name, and the
     * ".dic" extension.
     */
    addDictionary(lang: AString, file: nsIURIType): void;
    /**
     * Remove a dictionary with the given language code and path. If the path does
     * not match that of the current entry with the given language code, it is not
     * removed.
     *
     * @returns True if the dictionary was found and removed.
     */
    removeDictionary(lang: AString, file: nsIURIType): bool;
}

/**
 * mozIStorageAsyncConnection represents an asynchronous database
 * connection attached to a specific file or to an in-memory data
 * storage.  It is the primary interface for interacting with a
 * database from the main thread, including creating prepared
 * statements, executing SQL, and examining database errors.
 */
declare interface mozIStorageAsyncConnectionType extends nsISupportsType {
    /**
     * The default behavior for all transactions run on this connection. Defaults
     * to `TRANSACTION_DEFERRED`, and can be overridden for individual
     * transactions.
     */
    defaultTransactionType: int32_t;
    /**
     * The maximum number of bound parameters for statements executed on this
     * connection. If your statement has more params than this limit, you'll
     * need to chunk them into multiple statements. See `PlacesUtils.chunkArray`
     * and its callers in Places for examples of how to do this, or read on for
     * an overview.
     *
     * Keep in mind that the variable limit is for the _total_ number of
     * parameters, including ones bound by name (using the `:VVV`, `@VVV`, or
     * `?VVV` syntax) and index (`?` and `?NNN`).
     *
     * This means, when chunking:
     *
     * - If you're binding 1 param per 1 value per chunk (for example, if you
     * have a list of GUIDs and a clause like `WHERE guid IN (?, ?, ?, ...)`,
     * your chunk length is just `variableLimit`.
     * - If you're binding 1 param per 1 value per chunk, but using that
     * param in multiple positions in the query (for example, `WHERE url_hash
     * IN (hash(?1), hash(?2), ...) AND url IN (?1, ?2, ...)`), you can use the
     * `?NNN` syntax with a chunk length of `variableLimit`.
     * - If you're binding N params per 1 value per chunk (for example, if you
     * have a list of items with GUIDs and parent GUIDs, and you want to bind
     * both), your chunk length is `variableLimit / N`, since you're binding
     * two params for each element.
     * - If you're binding K params per L values per chunk, plus M fixed ones
     * (for example, `WHERE parentGuid = :parentGuid AND guid IN (?, ?, ...)`),
     * your chunk length is `variableLimit - M`, to ensure there's space for the
     * fixed variables.
     *
     * If you bind more params than this limit, `create{Async}Statement` will
     * fail with a "too many SQL variables" error.
     */
    readonly variableLimit: int32_t;
    /**
     * Returns true if a transaction is active on this connection.
     *
     * Note that this is true if a transaction is active on the connection,
     * regardless of how it was opened. There are several ways to open one:
     *
     * 1. Explicitly calling `beginTransaction` on a `mozIStorageConnection`.
     * 2. Calling `executeSimpleSQL("BEGIN")` or
     * `createStatement("BEGIN").execute()` on a `mozIStorageConnection`.
     * 3. Executing an async statement, like
     * `createAsyncStatement("BEGIN").executeAsync(...)`. This is what
     * `Sqlite.sys.mjs` does under the hood.
     *
     * Because of this, it's important *not* to use this attribute to decide
     * whether to *commit* the active transaction, because the caller that opened
     * it may not expect that. This is why both `mozStorageTransaction` and
     * `Sqlite.sys.mjs` use an internal variable (`mHasTransaction` for the former;
     * `_hasInProgressTransaction` for the latter) to check if their transaction
     * is already in progress, instead of just checking this attribute before
     * committing. Otherwise, mozStorage might accidentally commit (or roll back!)
     * a transaction started by `Sqlite.sys.mjs`, and vice versa.
     */
    readonly transactionInProgress: boolean;
    /**
     * Close this database connection, allowing all pending statements
     * to complete first.
     *
     * @param aCallback [optional]
     * A callback that will be notified when the close is completed,
     * with the following arguments:
     * - status: the status of the call
     * - value: |null|
     *
     * @throws NS_ERROR_NOT_SAME_THREAD
     * If called on a thread other than the one that opened it.  The
     * callback will not be dispatched.
     * @throws NS_ERROR_NOT_INITIALIZED
     * If called on a connection that has already been closed or was
     * never properly opened.  The callback will still be dispatched
     * to the main thread despite the returned error.
     * @note If this call should fail, the callback won't be invoked.
     */
    asyncClose(aCallback: mozIStorageCompletionCallback): void;
    /**
     * Clone a database and make the clone read only if needed.
     * SQL Functions and attached on-disk databases are applied to the new clone.
     *
     * @param aReadOnly
     * If true, the returned database should be put into read-only mode.
     *
     * @param aCallback
     * A callback that will be notified when the operation is complete,
     * with the following arguments:
     * - status: the status of the operation
     * - value: in case of success, an intance of
     * mozIStorageAsyncConnection cloned from this one.
     *
     * @throws NS_ERROR_NOT_SAME_THREAD
     * If is called on a thread other than the one that opened it.
     * @throws NS_ERROR_UNEXPECTED
     * If this connection is a memory database.
     *
     * @note If your connection is already read-only, you will get a read-only
     * clone.
     * @note The resulting connection will implement `mozIStorageConnection`, but
     * all synchronous methods will throw if called from the main thread.
     * @note Due to a bug in SQLite, if you use the shared cache
     * (see mozIStorageService), you end up with the same privileges as the
     * first connection opened regardless of what is specified in aReadOnly.
     * @note The following pragmas are copied over to a read-only clone:
     * - cache_size
     * - temp_store
     * The following pragmas are copied over to a writeable clone:
     * - cache_size
     * - temp_store
     * - foreign_keys
     * - journal_size_limit
     * - synchronous
     * - wal_autocheckpoint
     * All SQL functions are copied over to read-only and writeable clones.
     * Additionally, all temporary tables, triggers, and views, as well as
     * any indexes on temporary tables, are copied over to writeable clones.
     * For temporary tables, only the schemas are copied, not their
     * contents.
     */
    asyncClone(aReadOnly: boolean, aCallback: mozIStorageCompletionCallback): void;
    /**
     * The current database nsIFile.  Null if the database
     * connection refers to an in-memory database.
     */
    readonly databaseFile: nsIFile;
    /**
     * Causes any pending database operation to abort and return at the first
     * opportunity.
     * @note this cannot be used on mozIStorageConnection unless the connection is
     * explicitly marked as `interruptible`. For more details, please
     * refer to CONNECTION_INTERRUPTIBLE in mozIStorageService.
     * @note operations that are nearly complete may still be able to complete.
     * @throws if used on an unsupported connection type, or a closed connection.
     */
    interrupt(): void;
    /**
     * Vacuum the main database plus all the attached one.
     * If the database is in auto_vacuum = INCREMENTAL mode, this executes an
     * incremental_vacuum, otherwise it will always execute a full vacuum.
     *
     * While it's possible to invoke this method directly, it's suggested, when
     * possible, to use the VacuumManager instead.
     * That means registering your component for the "vacuum-participant" XPCOM
     * category, and implement the mozIStorageVacuumParticipant interface.
     *
     * @param [aCallback] Completion callback invoked once the operation is
     * complete.
     * @param [aUseIncremental] When set to true, this will try to convert the
     * main schema to auto_vacuum = INCREMENTAL mode, if it's not set yet.
     * When set to false, it will try to set auto_vacuum = NONE.
     * Note a full vacuum will be executed if the auto_vacuum mode must be
     * changed, otherwise an incremental vacuum will happen if the database
     * is already in INCREMENTAL mode.
     * @param [aSetPageSize] This can be used to change the database page_size, a
     * full vacuum will be executed to persist the change. If the page
     * size is already correct, or you pass 0, this will be a no-op.
     * @throws If it's not possible to start the async vacuum operation, note in
     * this case the callback won't be invoked.
     * @note Vacuum will fail inside a transaction, or if there is an ongoing
     * read statement.
     */
    asyncVacuum(aCallback: mozIStorageCompletionCallback?, aUseIncremental: boolean?, aSetPageSize: long?): void;
    /**
     * Create an asynchronous statement for the given SQL. An
     * asynchronous statement can only be used to dispatch asynchronous
     * requests to the asynchronous execution thread and cannot be used
     * to take any synchronous actions on the database.
     *
     * The expression may use ? to indicate sequential numbered arguments,
     * ?1, ?2 etc. to indicate specific numbered arguments or :name and
     * $var to indicate named arguments.
     *
     * @param aSQLStatement
     * The SQL statement to execute.
     * @return a new mozIStorageAsyncStatement
     * @note The statement is created lazily on first execution.
     */
    createAsyncStatement(aSQLStatement: AUTF8String): mozIStorageAsyncStatement;
    /**
     * Execute an array of statements created with this connection using
     * any currently bound parameters. When the array contains multiple
     * statements, the execution is wrapped in a single
     * transaction. These statements can be reused immediately, and
     * reset does not need to be called.
     *
     * @param aStatements
     * The array of statements to execute asynchronously, in the order they
     * are given in the array.
     * @param aCallback [optional]
     * The callback object that will be notified of progress, errors, and
     * completion.
     * @return an object that can be used to cancel the statements execution.
     *
     * @note If you have any custom defined functions, they must be
     * re-entrant since they can be called on multiple threads.
     */
    executeAsync(aStatements: invalid, aCallback: mozIStorageStatementCallback): mozIStoragePendingStatement;
    /**
     * Execute asynchronously an SQL expression, expecting no arguments.
     *
     * @param aSQLStatement
     * The SQL statement to execute
     * @param aCallback [optional]
     * The callback object that will be notified of progress, errors, and
     * completion.
     * @return an object that can be used to cancel the statement execution.
     */
    executeSimpleSQLAsync(aSQLStatement: AUTF8String, aCallback: mozIStorageStatementCallback): mozIStoragePendingStatement;
    /**
     * Create a new SQL function.  If you use your connection on multiple threads,
     * your function needs to be threadsafe, or it should only be called on one
     * thread.
     *
     * @param aFunctionName
     * The name of function to create, as seen in SQL.
     * @param aNumArguments
     * The number of arguments the function takes. Pass -1 for
     * variable-argument functions.
     * @param aFunction
     * The instance of mozIStorageFunction, which implements the function
     * in question.
     */
    createFunction(aFunctionName: AUTF8String, aNumArguments: long, aFunction: mozIStorageFunction): void;
    /**
     * Delete custom SQL function.
     *
     * @param aFunctionName
     * The name of function to remove.
     */
    removeFunction(aFunctionName: AUTF8String): void;
    /**
     * Sets a progress handler. Only one handler can be registered at a time.
     * If you need more than one, you need to chain them yourself.  This progress
     * handler should be threadsafe if you use this connection object on more than
     * one thread.
     *
     * @param aGranularity
     * The number of SQL virtual machine steps between progress handler
     * callbacks.
     * @param aHandler
     * The instance of mozIStorageProgressHandler.
     * @return previous registered handler.
     */
    setProgressHandler(aGranularity: int32_t, aHandler: mozIStorageProgressHandler): mozIStorageProgressHandler;
    /**
     * Remove a progress handler.
     *
     * @return previous registered handler.
     */
    removeProgressHandler(): mozIStorageProgressHandler;
}

/**
 * An asynchronous SQL statement.  This differs from mozIStorageStatement by
 * only being usable for asynchronous execution.  (mozIStorageStatement can
 * be used for both synchronous and asynchronous purposes.)  This specialization
 * for asynchronous operation allows us to avoid needing to acquire
 * synchronization primitives also used by the asynchronous execution thread.
 * In contrast, mozIStorageStatement may need to acquire the primitives and
 * consequently can cause the main thread to lock for extended intervals while
 * the asynchronous thread performs some long-running operation.
 */
declare interface mozIStorageAsyncStatementType extends mozIStorageBaseStatementType {
}

/**
 * The base interface for both pure asynchronous storage statements
 * (mozIStorageAsyncStatement) and 'classic' storage statements
 * (mozIStorageStatement) that can be used for both synchronous and asynchronous
 * purposes.
 */
declare interface mozIStorageBaseStatementType extends mozIStorageBindingParamsType {
    /**
     * Finalizes a statement so you can successfully close a database connection.
     * Once a statement has been finalized it can no longer be used for any
     * purpose.
     *
     * Statements are implicitly finalized when their reference counts hits zero.
     * If you are a native (C++) caller this is accomplished by setting all of
     * your nsCOMPtr instances to be NULL.  If you are operating from JavaScript
     * code then you cannot rely on this behavior because of the involvement of
     * garbage collection.
     *
     * When finalizing an asynchronous statement you do not need to worry about
     * whether the statement has actually been executed by the asynchronous
     * thread; you just need to call finalize after your last call to executeAsync
     * involving the statement.  However, you do need to use asyncClose instead of
     * close on the connection if any statements have been used asynchronously.
     */
    finalize(): void;
    /**
     * Binds the array of parameters to the statement.  When executeAsync is
     * called, all the parameters in aParameters are bound and then executed.
     *
     * @param aParameters
     * The array of parameters to bind to the statement upon execution.
     *
     * @note This is only works on statements being used asynchronously.
     */
    bindParameters(aParameters: mozIStorageBindingParamsArray): void;
    /**
     * Creates a new mozIStorageBindingParamsArray that can be used to bind
     * multiple sets of data to a statement with bindParameters.
     *
     * @return a mozIStorageBindingParamsArray that multiple sets of parameters
     * can be bound to.
     *
     * @note This is only useful for statements being used asynchronously.
     */
    newBindingParamsArray(): mozIStorageBindingParamsArray;
    /**
     * Execute a query asynchronously using any currently bound parameters.  This
     * statement can be reused immediately, and reset does not need to be called.
     *
     * @note If you have any custom defined functions, they must be re-entrant
     * since they can be called on multiple threads.
     *
     * @param aCallback [optional]
     * The callback object that will be notified of progress, errors, and
     * completion.
     * @return an object that can be used to cancel the statements execution.
     */
    executeAsync(aCallback: mozIStorageStatementCallback): mozIStoragePendingStatement;
    /**
     * Find out whether the statement is usable (has not been finalized).
     */
    readonly state: long;
    /**
     * Escape a string for SQL LIKE search.
     *
     * @note Consumers will have to use same escape char when doing statements
     * such as:   ...LIKE '?1' ESCAPE '/'...
     *
     * @param aValue
     * The string to escape for SQL LIKE.
     * @param aEscapeChar
     * The escape character.
     * @return an AString of an escaped version of aValue
     * (%, _ and the escape char are escaped with the escape char)
     * For example, we will convert "foo/bar_baz%20cheese"
     * into "foo//bar/_baz/%20cheese" (if the escape char is '/').
     */
    escapeStringForLIKE(aValue: AString, aEscapeChar: wchar): AString;
    /**
     * The same as above, but for UTF8 strings.
     */
    escapeUTF8StringForLIKE(aValue: AUTF8String, aEscapeChar: char): AUTF8String;
}

/**
 *
 */
declare interface mozIStorageBindingParamsType extends nsISupportsType {
    /**
     * Binds aValue to the parameter with the name aName.
     *
     * @param aName
     * The name of the parameter to bind aValue to.
     * @param aValue
     * The value to bind.
     */
    bindByName(aName: AUTF8String, aValue: nsIVariantType): void;
    /**
     *
     */
    bindBlobByName(aName: AUTF8String, aValue: invalid): void;
    /**
     *
     */
    bindStringAsBlobByName(aName: AUTF8String, aValue: AString): void;
    /**
     *
     */
    bindUTF8StringAsBlobByName(aName: AUTF8String, aValue: AUTF8String): void;
    /**
     * Binds aValue to the parameter with the index aIndex.
     *
     * @param aIndex
     * The zero-based index of the parameter to bind aValue to.
     * @param aValue
     * The value to bind.
     */
    bindByIndex(aIndex: unsigned_long, aValue: nsIVariantType): void;
    /**
     *
     */
    bindBlobByIndex(aIndex: unsigned_long, aValue: invalid): void;
    /**
     *
     */
    bindStringAsBlobByIndex(aIndex: unsigned_long, aValue: AString): void;
    /**
     *
     */
    bindUTF8StringAsBlobByIndex(aIndex: unsigned_long, aValue: AUTF8String): void;
}

/**
 *
 */
declare interface mozIStorageBindingParamsArrayType extends nsISupportsType {
    /**
     * Creates a new mozIStorageBindingParams object that can be added to this
     * array.
     *
     * @return a mozIStorageBindingParams object that can be used to specify
     * parameters that need to be bound.
     */
    newBindingParams(): mozIStorageBindingParams;
    /**
     * Adds the parameters to the end of this array.
     *
     * @param aParameters
     * The parameters to add to this array.
     */
    addParams(aParameters: mozIStorageBindingParams): void;
    /**
     * The number of mozIStorageBindingParams this object contains.
     */
    readonly length: unsigned_long;
}

/**
 *
 */
declare interface mozIStorageCompletionCallbackType extends nsISupportsType {
    /**
     * Indicates that the event this callback was passed in for has completed.
     *
     * @param status
     * The status of the call. Generally NS_OK if the operation
     * completed successfully.
     * @param value
     * If the operation produces a result, the result. Otherwise,
     * |null|.
     *
     * @see The calling method for expected values.
     */
    complete(status: nsresult, value: nsISupportsType): void;
}

/**
 * mozIStorageConnection represents a database connection attached to
 * a specific file or to the in-memory data storage.  It is the
 * primary interface for interacting with a database, including
 * creating prepared statements, executing SQL, and examining database
 * errors.
 *
 * @note From the main thread, you should rather use mozIStorageAsyncConnection.
 *
 * @threadsafe
 */
declare interface mozIStorageConnectionType extends mozIStorageAsyncConnectionType {
    /**
     * Closes a database connection.  Callers must finalize all statements created
     * for this connection prior to calling this method.  It is illegal to use
     * call this method if any asynchronous statements have been executed on this
     * connection.
     *
     * @throws NS_ERROR_UNEXPECTED
     * If any statement has been executed asynchronously on this object.
     * @throws NS_ERROR_UNEXPECTED
     * If is called on a thread other than the one that opened it.
     */
    close(): void;
    /**
     * Clones a database connection and makes the clone read only if needed.
     * SQL Functions and attached on-disk databases are applied to the new clone.
     *
     * @param aReadOnly
     * If true, the returned database should be put into read-only mode.
     * Defaults to false.
     * @return the cloned database connection.
     *
     * @throws NS_ERROR_UNEXPECTED
     * If this connection is a memory database.
     * @note If your connection is already read-only, you will get a read-only
     * clone.
     * @note Due to a bug in SQLite, if you use the shared cache (openDatabase),
     * you end up with the same privileges as the first connection opened
     * regardless of what is specified in aReadOnly.
     * @note The following pragmas are copied over to a read-only clone:
     * - cache_size
     * - temp_store
     * The following pragmas are copied over to a writeable clone:
     * - cache_size
     * - temp_store
     * - foreign_keys
     * - journal_size_limit
     * - synchronous
     * - wal_autocheckpoint
     * All SQL functions are copied over to read-only and writeable clones.
     * Additionally, all temporary tables, triggers, and views, as well as
     * any indexes on temporary tables, are copied over to writeable clones.
     * For temporary tables, only the schemas are copied, not their
     * contents.
     */
    clone(aReadOnly: boolean): mozIStorageConnection;
    /**
     * The default size for SQLite database pages used by mozStorage for new
     * databases.
     */
    readonly defaultPageSize: long;
    /**
     * Indicates if the connection is open and ready to use.  This will be false
     * if the connection failed to open, or it has been closed.
     */
    readonly connectionReady: boolean;
    /**
     * lastInsertRowID returns the row ID from the last INSERT
     * operation.
     */
    readonly lastInsertRowID: long_long;
    /**
     * affectedRows returns the number of database rows that were changed or
     * inserted or deleted by last operation.
     */
    readonly affectedRows: long;
    /**
     * The last error SQLite error code.
     */
    readonly lastError: long;
    /**
     * The last SQLite error as a string (in english, straight from the
     * sqlite library).
     */
    readonly lastErrorString: AUTF8String;
    /**
     * The schema version of the database.  This should not be used until the
     * database is ready.  The schema will be reported as zero if it is not set.
     */
    schemaVersion: long;
    /**
     * Create a mozIStorageStatement for the given SQL expression.  The
     * expression may use ? to indicate sequential numbered arguments,
     * ?1, ?2 etc. to indicate specific numbered arguments or :name and
     * $var to indicate named arguments.
     *
     * @param aSQLStatement
     * The SQL statement to execute.
     * @return a new mozIStorageStatement
     */
    createStatement(aSQLStatement: AUTF8String): mozIStorageStatement;
    /**
     * Execute a SQL expression, expecting no arguments.
     *
     * @param aSQLStatement  The SQL statement to execute
     */
    executeSimpleSQL(aSQLStatement: AUTF8String): void;
    /**
     * Check if the given table exists.
     *
     * @param aTableName
     * The table to check
     * @return TRUE if table exists, FALSE otherwise.
     */
    tableExists(aTableName: AUTF8String): boolean;
    /**
     * Check if the given index exists.
     *
     * @param aIndexName   The index to check
     * @return TRUE if the index exists, FALSE otherwise.
     */
    indexExists(aIndexName: AUTF8String): boolean;
    /**
     * Begin a new transaction. If a transaction is active, throws an error.
     */
    beginTransaction(): void;
    /**
     * Commits the current transaction.  If no transaction is active,
     * @throws NS_ERROR_UNEXPECTED.
     * @throws NS_ERROR_NOT_INITIALIZED.
     */
    commitTransaction(): void;
    /**
     * Rolls back the current transaction.  If no transaction is active,
     * @throws NS_ERROR_UNEXPECTED.
     * @throws NS_ERROR_NOT_INITIALIZED.
     */
    rollbackTransaction(): void;
    /**
     * Create the table with the given name and schema.
     *
     * If the table already exists, NS_ERROR_FAILURE is thrown.
     * (XXX at some point in the future it will check if the schema is
     * the same as what is specified, but that doesn't happen currently.)
     *
     * @param aTableName
     * The table name to be created, consisting of [A-Za-z0-9_], and
     * beginning with a letter.
     * @param aTableSchema
     * The schema of the table; what would normally go between the parens
     * in a CREATE TABLE statement: e.g., "foo  INTEGER, bar STRING".
     *
     * @throws NS_ERROR_FAILURE
     * If the table already exists or could not be created for any other
     * reason.
     */
    createTable(aTableName: string, aTableSchema: string): void;
    /**
     * Controls SQLITE_FCNTL_CHUNK_SIZE setting in sqlite. This helps avoid fragmentation
     * by growing/shrinking the database file in SQLITE_FCNTL_CHUNK_SIZE increments. To
     * conserve memory on systems short on storage space, this function will have no effect
     * on mobile devices or if less than 500MiB of space is left available.
     *
     * @param aIncrement
     * The database file will grow in multiples of chunkSize.
     * @param aDatabaseName
     * Sqlite database name. "" means pass NULL for zDbName to sqlite3_file_control.
     * See http://sqlite.org/c3ref/file_control.html for more details.
     * @throws NS_ERROR_FILE_TOO_BIG
     * If the system is short on storage space.
     */
    setGrowthIncrement(aIncrement: int32_t, aDatabaseName: AUTF8String): void;
    /**
     * The mutex used for protection of operations (BEGIN/COMMIT/ROLLBACK) in
     * mozStorageTransaction. The lock must be held in a way that spans whole
     * operation, not just when accessing the nesting level.
     */
    readonly sharedDBMutex: SQLiteMutex;
    /**
     * Helper methods for managing the transaction nesting level. The methods
     * must be called with a proof of lock. Currently only used by
     * mozStorageTransaction.
     */
    getTransactionNestingLevel(aProofOfLock: SQLiteMutexAutoLock): unsigned_long;
    /**
     *
     */
    increaseTransactionNestingLevel(aProofOfLock: SQLiteMutexAutoLock): unsigned_long;
    /**
     *
     */
    decreaseTransactionNestingLevel(aProofOfLock: SQLiteMutexAutoLock): unsigned_long;
}

/**
 *
 */
declare interface mozIStorageErrorType extends nsISupportsType {
    /**
     * Indicates what type of error occurred.
     */
    readonly result: long;
    /**
     * An error string the gives more details, if available.
     */
    readonly message: AUTF8String;
}

/**
 * mozIStorageFunction is to be implemented by storage consumers that
 * wish to receive callbacks during the request execution.
 *
 * SQL can apply functions to values from tables. Examples of
 * such functions are MIN(a1,a2) or SQRT(num). Many functions are
 * implemented in SQL engine.
 *
 * This interface allows consumers to implement their own,
 * problem-specific functions.
 * These functions can be called from triggers, too.
 */
declare interface mozIStorageFunctionType extends nsISupportsType {
    /**
     * onFunctionCall is called when execution of a custom
     * function should occur.
     *
     * @param aNumArguments         The number of arguments
     * @param aFunctionArguments    The arguments passed in to the function
     *
     * @returns any value as Variant type.
     */
    onFunctionCall(aFunctionArguments: mozIStorageValueArray): nsIVariant;
}

/**
 *
 */
declare interface mozIStoragePendingStatementType extends nsISupportsType {
    /**
     * Cancels a pending statement, if possible.  This will only fail if you try
     * cancel more than once.
     *
     * @note For read statements (such as SELECT), you will no longer receive any
     * notifications about results once cancel is called.
     */
    cancel(): void;
}

/**
 * mozIProgressHandler is to be implemented by storage consumers that
 * wish to receive callbacks during the request execution.
 */
declare interface mozIStorageProgressHandlerType extends nsISupportsType {
    /**
     * onProgress is invoked periodically during long running calls.
     *
     * @param aConnection    connection, for which progress handler is
     * invoked.
     *
     * @return true to abort request, false to continue work.
     */
    onProgress(aConnection: mozIStorageConnection): boolean;
}

/**
 *
 */
declare interface mozIStorageResultSetType extends nsISupportsType {
    /**
     * Obtains the next row from the result set from the statement that was
     * executed.
     *
     * @returns the next row from the result set.  This will be null when there
     * are no more results.
     */
    getNextRow(): mozIStorageRow;
}

/**
 *
 */
declare interface mozIStorageRowType extends mozIStorageValueArrayType {
    /**
     * Obtains the result of a given column specified by aIndex.
     *
     * @param aIndex
     * Zero-based index of the result to get from the tuple.
     * @returns the result of the specified column.
     */
    getResultByIndex(aIndex: unsigned_long): nsIVariant;
    /**
     * Obtains the result of a given column specified by aName.
     *
     * @param aName
     * Name of the result to get from the tuple.
     * @returns the result of the specified column.
     * @note The name of a result column is the value of the "AS" clause for that
     * column.  If there is no AS clause then the name of the column is
     * unspecified and may change from one release to the next.
     */
    getResultByName(aName: AUTF8String): nsIVariant;
}

/**
 * The mozIStorageService interface is intended to be implemented by
 * a service that can create storage connections (mozIStorageConnection)
 * to either a well-known profile database or to a specific database file.
 *
 * This is the only way to open a database connection.
 *
 * @note The first reference to mozIStorageService must be made on the main
 * thread.
 */
declare interface mozIStorageServiceType extends nsISupportsType {
    /**
     * Open an asynchronous connection to a database.
     *
     * This method MUST be called from the main thread. The connection object
     * returned by this function is not threadsafe. You MUST use it only from
     * the main thread.
     *
     * If you have more than one connection to a file, you MUST use the EXACT
     * SAME NAME for the file each time, including case. The sqlite code uses
     * a simple string compare to see if there is already a connection. Opening
     * a connection to "Foo.sqlite" and "foo.sqlite" will CORRUPT YOUR DATABASE.
     *
     * @param aDatabaseStore Either a nsIFile representing the file that contains
     * the database or a special string to open a special database. The special
     * string may be:
     * - "memory" to open an in-memory database.
     *
     * @param [optional] aOpenFlags
     * A set of flags to open the database with optional features.
     * Currently supports OPEN_SHARED, OPEN_READONLY and
     * OPEN_IGNORE_LOCKING_MODE flags.
     * For full details, please refer to the documentation of the flags.
     *
     * @param [optional] aConnectionFlags
     * A set of flags to enable optional features for the returned
     * asynchronous connection object.
     * Currently supports CONNECTION_INTERRUPTIBLE flag.
     * For full details, please refer to the documentation of the flag.
     *
     * @param aCallback A callback that will receive the result of the operation.
     * In case of error, it may receive as status:
     * - NS_ERROR_OUT_OF_MEMORY if allocating a new storage object fails.
     * - NS_ERROR_FILE_CORRUPTED if the database file is corrupted.
     * In case of success, it receives as argument the new database
     * connection, as an instance of |mozIStorageAsyncConnection|.
     *
     * @throws NS_ERROR_INVALID_ARG if |aDatabaseStore| is neither a file nor
     * one of the special strings understood by this method, or if one of
     * the options passed through |aOptions| does not have
     * the right type.
     * @throws NS_ERROR_NOT_SAME_THREAD if called from a thread other than the
     * main thread.
     */
    openAsyncDatabase(aDatabaseStore: nsIVariantType, aOpenFlags: unsigned_long, aConnectionFlags: unsigned_long, aCallback: mozIStorageCompletionCallback): void;
    /**
     * Get a connection to a named special database storage.
     *
     * @param aStorageKey a string key identifying the type of storage
     * requested.  Valid values include: "memory".
     *
     * @param aName an optional string identifying the name of the database.
     * If omitted, a filename of ":memory:" will be used which results in a
     * private in-memory database specific to this connection, making it
     * impossible to clone the in-memory database. If you want to be able to
     * clone the connection (or otherwise connect to the in-memory database from
     * a connection), then you must pick a name that's sufficiently unique within
     * the process to not collide with other mozStorage users.
     *
     * @param [optional] aConnectionFlags
     * A set of flags to enable optional features for the returned
     * synchronous connection object.
     * Currently supports CONNECTION_INTERRUPTIBLE flag.
     * For full details, please refer to the documentation of the flag.
     *
     * @see openDatabase for restrictions on how database connections may be
     * used. For the profile database, you should only access it from the main
     * thread since other callers may also have connections.
     *
     * @returns a new mozIStorageConnection for the requested
     * storage database.
     *
     * @throws NS_ERROR_INVALID_ARG if aStorageKey is invalid.
     */
    openSpecialDatabase(aStorageKey: ACString, aName: ACString, aConnectionFlags: unsigned_long): mozIStorageConnection;
    /**
     * Open a connection to the specified file.
     *
     * Consumers should check mozIStorageConnection::connectionReady to ensure
     * that they can use the database.  If this value is false, it is strongly
     * recommended that the database be backed up with
     * mozIStorageConnection::backupDB so user data is not lost.
     *
     * ==========
     * DANGER
     * ==========
     *
     * If you have more than one connection to a file, you MUST use the EXACT
     * SAME NAME for the file each time, including case. The sqlite code uses
     * a simple string compare to see if there is already a connection. Opening
     * a connection to "Foo.sqlite" and "foo.sqlite" will CORRUPT YOUR DATABASE.
     *
     * The connection object returned by this function is not threadsafe. You
     * must use it only from the thread you created it from.
     *
     * @param aDatabaseFile
     * A nsIFile that represents the database that is to be opened.
     * @param [optional] aConnectionFlags
     * A set of flags to enable optional features for the returned
     * synchronous connection object.
     * Currently supports CONNECTION_INTERRUPTIBLE flag.
     * For full details, please refer to the documentation of the flag.
     *
     * @returns a mozIStorageConnection for the requested database file.
     *
     * @throws NS_ERROR_OUT_OF_MEMORY
     * If allocating a new storage object fails.
     * @throws NS_ERROR_FILE_CORRUPTED
     * If the database file is corrupted.
     */
    openDatabase(aDatabaseFile: nsIFileType, aConnectionFlags: unsigned_long): mozIStorageConnection;
    /**
     * Open a connection to the specified file that doesn't share a sqlite cache.
     *
     * Without a shared-cache, each connection uses its own pages cache, which
     * may be memory inefficient with a large number of connections, in such a
     * case so you should use openDatabase instead.  On the other side, if cache
     * contention may be an issue, for instance when concurrency is important to
     * ensure responsiveness, using unshared connections may be a
     * performance win.
     *
     * ==========
     * DANGER
     * ==========
     *
     * If you have more than one connection to a file, you MUST use the EXACT
     * SAME NAME for the file each time, including case. The sqlite code uses
     * a simple string compare to see if there is already a connection. Opening
     * a connection to "Foo.sqlite" and "foo.sqlite" will CORRUPT YOUR DATABASE.
     *
     * The connection object returned by this function is not threadsafe. You
     * must use it only from the thread you created it from.
     *
     * @param aDatabaseFile
     * A nsIFile that represents the database that is to be opened.
     * @param [optional] aConnectionFlags
     * A set of flags to enable optional features for the returned
     * synchronous connection object.
     * Currently supports CONNECTION_INTERRUPTIBLE flag.
     * For full details, please refer to the documentation of the flag.
     *
     * @returns a mozIStorageConnection for the requested database file.
     *
     * @throws NS_ERROR_OUT_OF_MEMORY
     * If allocating a new storage object fails.
     * @throws NS_ERROR_FILE_CORRUPTED
     * If the database file is corrupted.
     */
    openUnsharedDatabase(aDatabaseFile: nsIFileType, aConnectionFlags: unsigned_long): mozIStorageConnection;
    /**
     * See openDatabase(). Exactly the same only initialized with a file URL.
     * Custom parameters can be passed to SQLite and VFS implementations through
     * the query part of the URL.
     *
     * @param aURL
     * A nsIFileURL that represents the database that is to be opened.
     * @param [optional] aTelemetryFilename
     * The name to use for the database in telemetry. Only needed if the
     * actual filename can contain sensitive information.
     * @param [optional] aConnectionFlags
     * A set of flags to enable optional features for the returned
     * synchronous connection object.
     * Currently supports CONNECTION_INTERRUPTIBLE flag.
     * For full details, please refer to the documentation of the flag.
     */
    openDatabaseWithFileURL(aFileURL: nsIFileURLType, aTelemetryFilename: ACString, aConnectionFlags: unsigned_long): mozIStorageConnection;
    /**
     * Utilities
     *
     * Copies the specified database file to the specified parent directory with
     * the specified file name.  If the parent directory is not specified, it
     * places the backup in the same directory as the current file.  This
     * function ensures that the file being created is unique.
     *
     * @param aDBFile
     * The database file that will be backed up.
     * @param aBackupFileName
     * The name of the new backup file to create.
     * @param [optional] aBackupParentDirectory
     * The directory you'd like the backup file to be placed.
     * @return The nsIFile representing the backup file.
     */
    backupDatabaseFile(aDBFile: nsIFileType, aBackupFileName: AString, aBackupParentDirectory: nsIFileType): nsIFile;
}

/**
 * A SQL statement that can be used for both synchronous and asynchronous
 * purposes.
 */
declare interface mozIStorageStatementType extends mozIStorageBaseStatementType {
    /**
     * Create a clone of this statement, by initializing a new statement
     * with the same connection and same SQL statement as this one.  It
     * does not preserve statement state; that is, if a statement is
     * being executed when it is cloned, the new statement will not be
     * executing.
     */
    clone(): mozIStorageStatement;
    /**
     * Number of parameters
     */
    readonly parameterCount: unsigned_long;
    /**
     * Name of nth parameter, if given
     */
    getParameterName(aParamIndex: unsigned_long): AUTF8String;
    /**
     * Returns the index of the named parameter.
     *
     * @param aName
     * The name of the parameter you want the index for.  This does not
     * include the leading ':'.
     * @return the index of the named parameter.
     */
    getParameterIndex(aName: AUTF8String): unsigned_long;
    /**
     * Number of columns returned
     */
    readonly columnCount: unsigned_long;
    /**
     * Name of nth column
     */
    getColumnName(aColumnIndex: unsigned_long): AUTF8String;
    /**
     * Obtains the index of the column with the specified name.
     *
     * @param aName
     * The name of the column.
     * @return The index of the column with the specified name.
     */
    getColumnIndex(aName: AUTF8String): unsigned_long;
    /**
     * Reset parameters/statement execution
     */
    reset(): void;
    /**
     * Execute the query, ignoring any results.  This is accomplished by
     * calling executeStep() once, and then calling reset().
     *
     * Error and last insert info, etc. are available from
     * the mozStorageConnection.
     */
    execute(): void;
    /**
     * Execute a query, using any currently-bound parameters.  Reset
     * must be called on the statement after the last call of
     * executeStep.
     *
     * @return a boolean indicating whether there are more rows or not;
     * row data may be accessed using mozIStorageValueArray methods on
     * the statement.
     */
    executeStep(): boolean;
    /**
     * The number of entries in the array (each corresponding to a column in the
     * database row)
     */
    readonly numEntries: unsigned_long;
    /**
     * Indicate the data type of the current result row for the the given column.
     * SQLite will perform type conversion if you ask for a value as a different
     * type than it is stored as.
     *
     * @param aIndex
     * 0-based column index.
     * @return The type of the value at the given column index; one of
     * VALUE_TYPE_NULL, VALUE_TYPE_INTEGER, VALUE_TYPE_FLOAT,
     * VALUE_TYPE_TEXT, VALUE_TYPE_BLOB.
     */
    getTypeOfIndex(aIndex: unsigned_long): long;
    /**
     * Retrieve the contents of a column from the current result row as a
     * variant.
     *
     * @param aIndex
     * 0-based colummn index.
     * @return A variant with the type of the column value.
     */
    getVariant(aIndex: unsigned_long): nsIVariant;
    /**
     * Retrieve the contents of a column from the current result row as an
     * integer.
     *
     * @param aIndex
     * 0-based colummn index.
     * @return Column value interpreted as an integer per type conversion rules.
     * @{
     */
    getInt32(aIndex: unsigned_long): long;
    /**
     *
     */
    getInt64(aIndex: unsigned_long): long_long;
    /**
     * @}
     *
     * Retrieve the contents of a column from the current result row as a
     * floating point double.
     *
     * @param aIndex
     * 0-based colummn index.
     * @return Column value interpreted as a double per type conversion rules.
     */
    getDouble(aIndex: unsigned_long): double;
    /**
     * Retrieve the contents of a column from the current result row as a
     * string.
     *
     * @param aIndex
     * 0-based colummn index.
     * @return The value for the result column interpreted as a string.  If the
     * stored value was NULL, you will get an empty string with IsVoid set
     * to distinguish it from an explicitly set empty string.
     * @{
     */
    getUTF8String(aIndex: unsigned_long): AUTF8String;
    /**
     *
     */
    getString(aIndex: unsigned_long): AString;
    /**
     * @}
     *
     * Retrieve the contents of a column from the current result row as a
     * blob.
     *
     * @param aIndex
     * 0-based colummn index.
     * @param[out] aDataSize
     * The number of bytes in the blob.
     * @param[out] aData
     * The contents of the BLOB.  This will be NULL if aDataSize == 0.
     */
    getBlob(aIndex: unsigned_long, aDataSize: unsigned_long, aData: octet[]): void;
    /**
     * Retrieve the contents of a Blob column from the current result row as a
     * string.
     *
     * @param aIndex
     * 0-based colummn index.
     * @return The value for the result Blob column interpreted as a String.
     * No encoding conversion is performed.
     */
    getBlobAsString(aIndex: unsigned_long): AString;
    /**
     * Retrieve the contents of a Blob column from the current result row as a
     * UTF8 string.
     *
     * @param aIndex
     * 0-based colummn index.
     * @return The value for the result Blob column interpreted as a UTF8 String.
     * No encoding conversion is performed.
     */
    getBlobAsUTF8String(aIndex: unsigned_long): AUTF8String;
    /**
     * Check whether the given column in the current result row is NULL.
     *
     * @param aIndex
     * 0-based colummn index.
     * @return true if the value for the result column is null.
     */
    getIsNull(aIndex: unsigned_long): boolean;
}

/**
 *
 */
declare interface mozIStorageStatementCallbackType extends nsISupportsType {
    /**
     * Called when some result is obtained from the database.  This function can
     * be called more than once with a different storageIResultSet each time for
     * any given asynchronous statement.
     *
     * @param aResultSet
     * The result set containing the data from the database.
     */
    handleResult(aResultSet: mozIStorageResultSet): void;
    /**
     * Called when some error occurs while executing the statement.  This function
     * may be called more than once with a different storageIError each time for
     * any given asynchronous statement.
     *
     * @param aError
     * An object containing information about the error.
     */
    handleError(aError: mozIStorageError): void;
    /**
     *
     */
    handleCompletion(aReason: unsigned_short): void;
}

/**
 * This interface contains the information that the Storage service needs to
 * vacuum a database.  This interface is created as a service through the
 * category manager with the category "vacuum-participant".
 * Please see https://developer.mozilla.org/en/mozIStorageVacuumParticipant for
 * more information.
 */
declare interface mozIStorageVacuumParticipantType extends nsISupportsType {
    /**
     * The expected page size in bytes for the database.  The vacuum manager will
     * try to correct the page size by executing a full vacuum.
     *
     * @note If the database is using the WAL journal mode, the page size won't
     * be changed to the requested value.  See bug 634374.
     * @note Valid page size values are powers of 2 between 512 and 65536.
     * The suggested value is mozIStorageConnection::defaultPageSize.
     */
    readonly expectedDatabasePageSize: long;
    /**
     * Whether the main schema should be using auto_vacuum = INCREMENTAL.
     * This will cause auto_vacuum to change to INCREMENTAL if it's not set yet.
     * It is not possible to change mode of any attached databases through this,
     * to do that you must open a separate connection and use asyncVacuum() on it.
     */
    readonly useIncrementalVacuum: boolean;
    /**
     * Connection to the database file to be vacuumed.
     */
    readonly databaseConnection: mozIStorageAsyncConnection;
    /**
     * Notifies when a vacuum operation begins.  Listeners should avoid using the
     * database till onEndVacuum is received.
     *
     * @return true to proceed with the vacuum, false if the participant wants to
     * opt-out for now, it will be retried later.  Useful when participant
     * is running some other heavy operation that can't be interrupted.
     *
     * @note When a vacuum operation starts or ends it will also dispatch global
     * "vacuum-begin" and "vacuum-end" notifications through the observer
     * service with the data argument being the database filename.
     */
    onBeginVacuum(): boolean;
    /**
     * Notifies when a vacuum operation ends.
     *
     * @param aSucceeded
     * reports if the vacuum succeeded or failed.
     */
    onEndVacuum(aSucceeded: boolean): void;
}

/**
 * mozIStorageValueArray wraps an array of SQL values, such as a single database
 * row.
 */
declare interface mozIStorageValueArrayType extends nsISupportsType {
    /**
     * numEntries
     *
     * number of entries in the array (each corresponding to a column
     * in the database row)
     */
    readonly numEntries: unsigned_long;
    /**
     * Returns the type of the value at the given column index;
     * one of VALUE_TYPE_NULL, VALUE_TYPE_INTEGER, VALUE_TYPE_FLOAT,
     * VALUE_TYPE_TEXT, VALUE_TYPE_BLOB.
     */
    getTypeOfIndex(aIndex: unsigned_long): long;
    /**
     * Obtain a value for the given entry (column) index.
     * Due to SQLite's type conversion rules, any of these are valid
     * for any column regardless of the column's data type.  However,
     * if the specific type matters, getTypeOfIndex should be used
     * first to identify the column type, and then the appropriate
     * get method should be called.
     *
     * If you ask for a string value for a NULL column, you will get an empty
     * string with IsVoid set to distinguish it from an explicitly set empty
     * string.
     */
    getInt32(aIndex: unsigned_long): long;
    /**
     *
     */
    getInt64(aIndex: unsigned_long): long_long;
    /**
     *
     */
    getDouble(aIndex: unsigned_long): double;
    /**
     *
     */
    getUTF8String(aIndex: unsigned_long): AUTF8String;
    /**
     *
     */
    getString(aIndex: unsigned_long): AString;
    /**
     *
     */
    getBlob(aIndex: unsigned_long, aDataSize: unsigned_long, aData: octet[]): void;
    /**
     *
     */
    getBlobAsString(aIndex: unsigned_long): AString;
    /**
     *
     */
    getBlobAsUTF8String(aIndex: unsigned_long): AUTF8String;
    /**
     *
     */
    getIsNull(aIndex: unsigned_long): boolean;
}

/**
 *
 */
declare interface mozISyncedBookmarksMirrorProgressListenerType extends nsISupportsType {
    /**
     *
     */
    onFetchLocalTree(took: long_long, itemCount: long_long, deletedCount: long_long, problems: nsIPropertyBagType): void;
    /**
     *
     */
    onFetchRemoteTree(took: long_long, itemCount: long_long, deletedCount: long_long, problems: nsIPropertyBagType): void;
    /**
     *
     */
    onMerge(took: long_long, counts: nsIPropertyBagType): void;
    /**
     *
     */
    onApply(took: long_long): void;
}

/**
 *
 */
declare interface mozISyncedBookmarksMirrorCallbackType extends nsISupportsType {
    /**
     *
     */
    handleSuccess(result: bool): void;
    /**
     *
     */
    handleError(code: nsresult, message: AString): void;
}

/**
 *
 */
declare interface mozISyncedBookmarksMirrorLoggerType extends nsISupportsType {
    /**
     *
     */
    maxLevel: short;
    /**
     *
     */
    error(message: AString): void;
    /**
     *
     */
    warn(message: AString): void;
    /**
     *
     */
    debug(message: AString): void;
    /**
     *
     */
    trace(message: AString): void;
}

/**
 *
 */
declare interface mozISyncedBookmarksMergerType extends nsISupportsType {
    /**
     *
     */
    db: mozIStorageConnection;
    /**
     *
     */
    logger: mozIServicesLogSink;
    /**
     *
     */
    merge(localTimeSeconds: long_long, remoteTimeSeconds: long_long, callback: mozISyncedBookmarksMirrorCallback): mozIPlacesPendingOperation;
    /**
     *
     */
    reset(): void;
}

/**
 *
 */
declare interface mozITXTToHTMLConvType extends nsIStreamConverterType {
    /**
     * @param text: plain text to scan. May be a line, paragraph (recommended)
     * or just a substring.
     *
     * Must be non-escaped, pure unicode.
     *
     * **Note:** ScanTXT(a, o) + ScanTXT(b, o) may be !=
     * Scan(a + b, o)
     * @param whattodo: Bitfield describing the modes of operation
     * @result      "<", ">" and "&" are escaped and HTML tags are inserted where
     * appropriate.
     */
    scanTXT(text: AString, whattodo: unsigned_long): AString;
    /**
     * Adds additional formatting to user edited text, that the user was too lazy
     * or "unknowledged" (DELETEME: is that a word?) to make.
     *
     *
     * **Note:** Don't use kGlyphSubstitution with this function. This option
     * generates tags, that are unuseable for UAs other than Mozilla. This would
     * be a data loss bug.
     *
     * @param text: HTML source to scan. May be a line, paragraph (recommended)
     * or just a substring.
     *
     * Must be correct HTML. "<", ">" and "&" must be escaped,
     * other chars must be pure unicode.
     *
     * **Note:** ScanTXT(a, o) + ScanTXT(b, o) may be !=
     * Scan(a + b, o)
     * @param whattodo: Bitfield describing the modes of operation
     * @result      Additional HTML tags are inserted where appropriate.
     */
    scanHTML(text: AString, whattodo: unsigned_long): AString;
    /**
     * @param line: line in original msg, possibly starting starting with
     * txt quote tags like ">"
     * @param logLineStart: pos in line, where the real content (logical line)
     * begins, i.e. pos after all txt quote tags.
     * E.g. position of "t" in "> > text".
     * Initial value must be 0, unless line is not real line.
     * @return      Cite Level, i.e. number of txt quote tags found, i.e. number of
     * nested quotes.
     */
    citeLevelTXT(line: wstring, logLineStart: unsigned_long): unsigned_long;
    /**
     * @param a wide string to scan for the presence of a URL.
     * @param aLength --> the length of the buffer to be scanned
     * @param aPos --> the position in the buffer to start scanning for a url
     *
     * aStartPos --> index into the start of a url (-1 if no url found)
     * aEndPos --> index of the last character in the url (-1 if no url found)
     */
    findURLInPlaintext(text: wstring, aLength: long, aPos: long, aStartPos: long, aEndPos: long): void;
}

/**
 * An interface to allow testing of binding interactions with JS-implemented
 * XPCOM components.  The actual implementation is TestInterfaceJS, just like
 * for TestInteraceJS.webidl.
 */
declare interface mozITestInterfaceJSType extends nsISupportsType {
    /**
     *
     */
    testThrowNsresult(): void;
    /**
     *
     */
    testThrowNsresultFromNative(): void;
}

/**
 * Utility functions for determining whether a given URI, channel, or window
 * hierarchy is third party with respect to a known URI.
 */
declare interface mozIThirdPartyUtilType extends nsISupportsType {
    /**
     * isThirdPartyURI
     *
     * Determine whether two URIs are third party with respect to each other.
     * This is determined by computing the base domain for both URIs. If they can
     * be determined, and the base domains match, the request is defined as first
     * party. If it cannot be determined because one or both URIs do not have a
     * base domain (for instance, in the case of IP addresses, host aliases such
     * as 'localhost', or a file:// URI), an exact string comparison on host is
     * performed.
     *
     * For example, the URI "http://mail.google.com/" is not third party with
     * respect to "http://images.google.com/", but "http://mail.yahoo.com/" and
     * "http://192.168.1.1/" are.
     *
     * @return true if aFirstURI is third party with respect to aSecondURI.
     *
     * @throws if either URI is null, has a malformed host, or has an empty host
     * and is not a file:// URI.
     */
    isThirdPartyURI(aFirstURI: nsIURIType, aSecondURI: nsIURIType): boolean;
    /**
     * isThirdPartyWindow
     *
     * Determine whether the given window hierarchy is third party. This is done
     * as follows:
     *
     * 1) Obtain the URI of the principal associated with 'aWindow'. Call this the
     * 'bottom URI'.
     * 2) If 'aURI' is provided, determine if it is third party with respect to
     * the bottom URI. If so, return.
     * 3) Find the same-type parent window, if there is one, and its URI.
     * Determine whether it is third party with respect to the bottom URI. If
     * so, return.
     *
     * Therefore, each level in the window hierarchy is tested. (This means that
     * nested iframes with different base domains, even though the bottommost and
     * topmost URIs might be equal, will be considered third party.)
     *
     * @param aWindow
     * The bottommost window in the hierarchy.
     * @param aURI
     * A URI to test against. If null, the URI of the principal
     * associated with 'aWindow' will be used.
     *
     * For example, if 'aURI' is "http://mail.google.com/", 'aWindow' has a URI
     * of "http://google.com/", and its parent is the topmost content window with
     * a URI of "http://mozilla.com", the result will be true.
     *
     * @return true if 'aURI' is third party with respect to any of the URIs
     * associated with aWindow and its same-type parents.
     *
     * @throws if aWindow is null; the same-type parent of any window in the
     * hierarchy cannot be determined; or the URI associated with any
     * window in the hierarchy is null, has a malformed host, or has an
     * empty host and is not a file:// URI.
     *
     * @see isThirdPartyURI
     */
    isThirdPartyWindow(aWindow: mozIDOMWindowProxy, aURI: nsIURIType): boolean;
    /**
     * isThirdPartyChannel
     *
     * Determine whether the given channel and its content window hierarchy is
     * third party. This is done as follows:
     *
     * 1) If 'aChannel' is an nsIHttpChannel and has the
     * 'forceAllowThirdPartyCookie' property set, then:
     * a) If 'aURI' is null, return false.
     * b) Otherwise, find the URI of the channel, determine whether it is
     * foreign with respect to 'aURI', and return.
     * 2) Find the URI of the channel and determine whether it is third party with
     * respect to the URI of the channel. If so, return.
     * 3) Obtain the bottommost nsIDOMWindow, and its same-type parent if it
     * exists, from the channel's notification callbacks. Then:
     * a) If the parent is the same as the bottommost window, and the channel
     * has the LOAD_DOCUMENT_URI flag set, return false. This represents the
     * case where a toplevel load is occurring and the window's URI has not
     * yet been updated. (We have already checked that 'aURI' is not foreign
     * with respect to the channel URI.)
     * b) Otherwise, return the result of isThirdPartyWindow with arguments
     * of the channel's bottommost window and the channel URI, respectively.
     *
     * Therefore, both the channel's URI and each level in the window hierarchy
     * associated with the channel is tested.
     *
     * @param aChannel
     * The channel associated with the load.
     * @param aURI
     * A URI to test against. If null, the URI of the channel will be used.
     *
     * For example, if 'aURI' is "http://mail.google.com/", 'aChannel' has a URI
     * of "http://google.com/", and its parent is the topmost content window with
     * a URI of "http://mozilla.com", the result will be true.
     *
     * @return true if aURI is third party with respect to the channel URI or any
     * of the URIs associated with the same-type window hierarchy of the
     * channel.
     *
     * @throws if 'aChannel' is null; the channel has no notification callbacks or
     * an associated window; or isThirdPartyWindow throws.
     *
     * @see isThirdPartyWindow
     */
    isThirdPartyChannel(aChannel: nsIChannelType, aURI: nsIURIType): boolean;
    /**
     * getBaseDomain
     *
     * Get the base domain for aHostURI; e.g. for "www.bbc.co.uk", this would be
     * "bbc.co.uk". Only properly-formed URI's are tolerated, though a trailing
     * dot may be present. If aHostURI is an IP address, an alias such as
     * 'localhost', an eTLD such as 'co.uk', or the empty string, aBaseDomain will
     * be the exact host. The result of this function should only be used in exact
     * string comparisons, since substring comparisons will not be valid for the
     * special cases elided above.
     *
     * @param aHostURI
     * The URI to analyze.
     *
     * @return the base domain.
     */
    getBaseDomain(aHostURI: nsIURIType): AUTF8String;
    /**
     * NOTE: Long term, this method won't be needed once bug 922464 is fixed which
     * will make it possible to parse all URI's off the main thread.
     *
     * getBaseDomainFromSchemeHost
     *
     * Get the base domain for aScheme and aHost. Otherwise identical to
     * getBaseDomain().
     *
     * @param aScheme
     * The scheme to analyze.
     *
     * @param aAsciiHost
     * The host to analyze.
     *
     * @return the base domain.
     */
    getBaseDomainFromSchemeHost(aScheme: AUTF8String, aAsciiHost: AUTF8String): AUTF8String;
    /**
     * getURIFromWindow
     *
     * Returns the URI associated with the script object principal for the
     * window.
     */
    getURIFromWindow(aWindow: mozIDOMWindowProxy): nsIURI;
    /**
     * getPrincipalFromWindow
     *
     * Returns the script object principal for the window.
     */
    getPrincipalFromWindow(aWindow: mozIDOMWindowProxy): nsIPrincipal;
}

/**
 *
 */
declare interface nsIASN1TreeType extends nsITreeViewType {
    /**
     *
     */
    loadASN1Structure(asn1Object: nsIASN1ObjectType): void;
    /**
     *
     */
    getDisplayData(index: unsigned_long): AString;
}

/**
 *
 */
declare interface nsIAboutModuleType extends nsISupportsType {
    /**
     * Constructs a new channel for the about protocol module.
     *
     * @param aURI the uri of the new channel
     * @param aLoadInfo the loadinfo of the new channel
     */
    newChannel(aURI: nsIURIType, aLoadInfo: nsILoadInfoType): nsIChannel;
    /**
     * A method to get the flags that apply to a given about: URI.  The URI
     * passed in is guaranteed to be one of the URIs that this module
     * registered to deal with.
     */
    getURIFlags(aURI: nsIURIType): unsigned_long;
    /**
     * A method to get the chrome URI that corresponds to a given about URI.
     */
    getChromeURI(aURI: nsIURIType): nsIURI;
}

/**
 *
 */
declare interface nsIAboutNewTabServiceType extends nsISupportsType {
    /**
     * Returns the default URL (local or activity stream depending on pref)
     */
    readonly defaultURL: ACString;
    /**
     * In the "privileged about content process", if about:home is being
     * retrieved, the AboutRedirector will call this function to get the
     * nsIChannel for the document. This gives the nsIAboutNewTabService
     * the opportunity to provide a cached document for about:home. If
     * no cache exists, the nsIChannel will be for the normal dynamically
     * generated about:home document.
     */
    aboutHomeChannel(aURI: nsIURIType, aLoadInfo: nsILoadInfoType): nsIChannel;
    /**
     * Returns the about:welcome URL.
     */
    readonly welcomeURL: ACString;
}

/**
 *
 */
declare interface nsIInstalledApplicationType extends nsISupportsType {
    /**
     *
     */
    readonly name: AString;
    /**
     *
     */
    readonly publisher: AString;
}

/**
 *
 */
declare interface nsIAboutThirdPartyType extends nsISupportsType {
    /**
     * Returns a bitwise combination of the ModuleType_* flags
     * for the given leaf name of a module.
     */
    lookupModuleType(aLeafName: AString): unsigned_long;
    /**
     * Returns an object representing an application which includes
     * the given path of a module in its installation.
     */
    lookupApplication(aModulePath: AString): nsIInstalledApplication;
    /**
     * Returns true if DynamicBlocklist is available.
     */
    readonly isDynamicBlocklistAvailable: bool;
    /**
     * Returns true if DynamicBlocklist is available but disabled.
     */
    readonly isDynamicBlocklistDisabled: bool;
    /**
     * Add or remove an entry from the dynamic blocklist and save
     * the resulting file.
     */
    updateBlocklist(aLeafName: AString, aNewBlockStatus: boolean): Promise;
    /**
     * Posts a background task to collect system information and resolves
     * the returned promise when the task is finished.
     */
    collectSystemInfo(): Promise;
    /**
     * Open an OpenFile dialog with given parameters and immediately close it.
     * This method should only be used for testing.
     */
    openAndCloseFileDialogForTesting(aModuleName: AString, aInitialDir: AString, aFilter: AString): void;
}

/**
 * This interface allows the security manager to query custom per-addon security
 * policy.
 */
declare interface nsIAddonPolicyServiceType extends nsISupportsType {
    /**
     * Returns the default content security policy which applies to extension
     * documents which do not specify any custom policies.
     */
    readonly defaultCSP: AString;
    /**
     * Same as above, but used for extensions using manifest v3.
     */
    readonly defaultCSPV3: AString;
    /**
     * Returns the base content security policy which applies to all extension resources.
     */
    getBaseCSP(aAddonId: AString): AString;
    /**
     * Returns the content security policy which applies to documents belonging
     * to the extension with the given ID. This may be either a custom policy,
     * if one was supplied, or the default policy if one was not.
     */
    getExtensionPageCSP(aAddonId: AString): AString;
    /**
     * Returns the generated background page as a data-URI, if any. If the addon
     * does not have an auto-generated background page, an empty string is
     * returned.
     */
    getGeneratedBackgroundPageUrl(aAddonId: ACString): ACString;
    /**
     * Returns true if the addon was granted the |aPerm| API permission.
     */
    addonHasPermission(aAddonId: AString, aPerm: AString): boolean;
    /**
     * Returns true if unprivileged code associated with the given addon may load
     * data from |aURI|.  If |aExplicit| is true, the <all_urls> permission and
     * permissive host globs are ignored when checking for a match.
     */
    addonMayLoadURI(aAddonId: AString, aURI: nsIURIType, aExplicit: boolean): boolean;
    /**
     * Returns the name of the WebExtension with the given ID, or the ID string
     * if no matching add-on can be found.
     */
    getExtensionName(aAddonId: AString): AString;
    /**
     * Returns true if a given extension:// URI is web-accessible and loadable by the source.
     * This should be called if the protocol flags for the extension URI has URI_WEB_ACCESSIBLE.
     */
    sourceMayLoadExtensionURI(aSourceURI: nsIURIType, aExtensionURI: nsIURIType): boolean;
    /**
     * Maps an extension URI to the ID of the addon it belongs to.
     */
    extensionURIToAddonId(aURI: nsIURIType): AString;
}

/**
 * This interface exposes functionality related to add-on content policy
 * enforcement.
 */
declare interface nsIAddonContentPolicyType extends nsISupportsType {
    /**
     * Checks a custom content security policy string, to ensure that it meets
     * minimum security requirements. Returns null for valid policies, or a
     * string describing the error for invalid policies.
     */
    validateAddonCSP(aPolicyString: AString, aPermittedPolicy: unsigned_long): AString;
}

/**
 *
 */
declare interface nsIAlertNotificationImageListenerType extends nsISupportsType {
    /**
     * Called when the image finishes loading.
     *
     * @param aUserData An opaque parameter passed to |loadImage|.
     * @param aRequest  The image request.
     */
    onImageReady(aUserData: nsISupportsType, aRequest: imgIRequest): void;
    /**
     * Called if the alert doesn't have an image, or if the image request times
     * out or fails.
     *
     * @param aUserData An opaque parameter passed to |loadImage|.
     */
    onImageMissing(aUserData: nsISupportsType): void;
}

/**
 *
 */
declare interface nsIAlertActionType extends nsISupportsType {
    /**
     * Returns a string identifying a user action to be displayed on the alert.
     *
     * This string is an opaque identifier that identifies an action in potential
     * callbacks; it is not displayed to the user.
     */
    readonly action: AString;
    /**
     * Returns a string containing action text to be shown to the user.
     */
    readonly title: AString;
    /**
     * Returns a string containing the URL of an icon to display with the action.
     */
    readonly iconURL: AString;
    /**
     * On Windows, chrome-privileged notifications -- i.e., those with a
     * non-actionable principal -- can have actions that are activated by Windows
     * and not processed by Firefox.  When `windowsSystemActivationType` is true,
     * we request Windows to process `action`.  At the time of writing, Windows
     * recognizes the following actions:
     *
     * - `action="dismiss"` dismisses the alert entirely.
     * - `action="snooze"` snoozes the alert, generally making it disappear before
     * reappearing a Windows-determined amount of time later.
     *
     * On non-Windows, this field is ignored.
     */
    readonly windowsSystemActivationType: boolean;
    /**
     * On Windows, chrome-privileged notifications -- i.e., those with a
     * non-actionable principal -- can have action-specific `opaqueRelaunchData`.
     * This data will be provided to the application at relaunch and can trigger
     * specific actions.
     *
     * On non-Windows, this field is ignored.
     */
    readonly opaqueRelaunchData: AString;
}

/**
 *
 */
declare interface nsIAlertNotificationType extends nsISupportsType {
    /**
     * Initializes an alert notification.
     */
    init(aName: AString, aImageURL: AString, aTitle: AString, aText: AString, aTextClickable: boolean, aCookie: AString, aDir: AString, aLang: AString, aData: AString, aPrincipal: nsIPrincipalType, aInPrivateBrowsing: boolean, aRequireInteraction: boolean, aSilent: boolean, aVibrate: invalid): void;
    /**
     * The name of the notification. On Windows and Android, the name is hashed
     * and used as a notification ID. Notifications will replace previous
     * notifications with the same name.
     */
    readonly name: AString;
    /**
     * A URL identifying the image to put in the alert. The OS X backend limits
     * the amount of time it will wait for the image to load to six seconds. After
     * that time, the alert will show without an image.
     */
    readonly imageURL: AString;
    /**
     * The title for the alert.
     */
    readonly title: AString;
    /**
     * The contents of the alert.
     */
    readonly text: AString;
    /**
     * Controls the click behavior. If true, the alert listener will be notified
     * when the user clicks on the alert.
     */
    readonly textClickable: boolean;
    /**
     * An opaque cookie that will be passed to the alert listener for each
     * callback.
     */
    readonly cookie: AString;
    /**
     * Bidi override for the title and contents. Valid values are "auto", "ltr",
     * or "rtl". Ignored if the backend doesn't support localization.
     */
    readonly dir: AString;
    /**
     * Language of the title and text. Ignored if the backend doesn't support
     * localization.
     */
    readonly lang: AString;
    /**
     * A Base64-encoded structured clone buffer containing data associated with
     * this alert. Only used for web notifications. Chrome callers should use a
     * cookie instead.
     */
    readonly data: AString;
    /**
     * The principal of the page that created the alert. Used for IPC security
     * checks, and to determine whether the alert is actionable.
     */
    readonly principal: nsIPrincipal;
    /**
     * The URI of the page that created the alert. |null| if the alert is not
     * actionable.
     */
    readonly URI: nsIURI;
    /**
     * Controls the image loading behavior. If true, the image request will be
     * loaded anonymously (without cookies or authorization tokens).
     */
    readonly inPrivateBrowsing: boolean;
    /**
     * Indicates that the notification should remain readily available until
     * the user activates or dismisses the notification.
     */
    readonly requireInteraction: boolean;
    /**
     * When set, indicates that no sounds or vibrations should be made.
     */
    readonly silent: boolean;
    /**
     * Indicates whether this alert should show the source string and action
     * buttons. False for system alerts (which can omit the principal), or
     * expanded, system, and null principals.
     */
    readonly actionable: boolean;
    /**
     * The host and port of the originating page, or an empty string if the alert
     * is not actionable.
     */
    readonly source: AString;
    /**
     * On Windows, chrome-privileged notifications -- i.e., those with a
     * non-actionable principal -- can have `opaqueRelaunchData`.  This data will
     * be provided to the application at relaunch and can trigger specific
     * actions.
     *
     * On non-Windows, this field is ignored.
     */
    opaqueRelaunchData: AString;
    /**
     * Loads the image associated with this alert.
     *
     * @param aTimeout  The number of milliseconds to wait before cancelling the
     * image request. If zero, there is no timeout.
     * @param aListener An |nsIAlertNotificationImageListener| implementation,
     * notified when the image loads. The listener is kept alive
     * until the request completes.
     * @param aUserData An opaque parameter passed to the listener's methods.
     * Not used by the libnotify backend, but the OS X backend
     * passes the pending notification.
     */
    loadImage(aTimeout: unsigned_long, aListener: nsIAlertNotificationImageListenerType, aUserData: nsISupportsType): nsICancelable;
}

/**
 *
 */
declare interface nsIAlertsServiceType extends nsISupportsType {
    /**
     *
     */
    showPersistentNotification(aPersistentData: AString, aAlert: nsIAlertNotificationType, aAlertListener: nsIObserverType): void;
    /**
     *
     */
    showAlert(aAlert: nsIAlertNotificationType, aAlertListener: nsIObserverType): void;
    /**
     * Initializes and shows an |nsIAlertNotification| with the given parameters.
     *
     * @param aAlertListener Used for callbacks. May be null if the caller
     * doesn't care about callbacks.
     * @see nsIAlertNotification for descriptions of all other parameters.
     * @throws NS_ERROR_NOT_AVAILABLE If the notification cannot be displayed.
     *
     * The following arguments will be passed to the alertListener's observe()
     * method:
     * subject - null
     * topic   - "alertfinished" when the alert goes away
     * "alertdisablecallback" when alerts should be disabled for the principal
     * "alertsettingscallback" when alert settings should be opened
     * "alertclickcallback" when the text is clicked
     * "alertshow" when the alert is shown
     * data    - the value of the cookie parameter passed to showAlertNotification.
     *
     * @note Depending on current circumstances (if the user's in a fullscreen
     * application, for instance), the alert might not be displayed at all.
     * In that case, if an alert listener is passed in it will receive the
     * "alertfinished" notification immediately.
     */
    showAlertNotification(aImageURL: AString, aTitle: AString, aText: AString, aTextClickable: boolean, aCookie: AString, aAlertListener: nsIObserverType, aName: AString, aDir: AString, aLang: AString, aData: AString, aPrincipal: nsIPrincipalType, aInPrivateBrowsing: boolean, aRequireInteraction: boolean): void;
    /**
     * Close alerts created by the service.
     *
     * @param aName          The name of the notification to close. If no name
     * is provided then only a notification created with
     * no name (if any) will be closed.
     * @param aContextClosed The notification was implicitly closed, e.g. by tab
     * or window closure. This is necessary to track as some
     * platforms intentionally leave the notification visible
     * unless explicitly closed, e.g. by notification.close().
     */
    closeAlert(aName: AString, aContextClosed: boolean): void;
}

/**
 *
 */
declare interface nsIAlertsDoNotDisturbType extends nsISupportsType {
    /**
     * Toggles a manual Do Not Disturb mode for the service to reduce the amount
     * of disruption that alerts cause the user.
     * This may mean only displaying them in a notification tray/center or not
     * displaying them at all. If a system backend already supports a similar
     * feature controlled by the user, enabling this may not have any impact on
     * code to show an alert. e.g. on OS X, the system will take care not
     * disrupting a user if we simply create a notification like usual.
     */
    manualDoNotDisturb: bool;
    /**
     * Toggles a mode for the service to suppress all notifications from
     * being dispatched when sharing the screen via the getMediaDisplay
     * API.
     */
    suppressForScreenSharing: bool;
}

/**
 *
 */
declare interface nsIAlertsIconDataType extends nsISupportsType {
    /**
     * Shows an alert with an icon. Web notifications use the favicon of the
     * page that created the alert. If the favicon is not in the Places database,
     * |aIconSize| will be zero.
     */
    showAlertWithIconData(aAlert: nsIAlertNotificationType, aAlertListener: nsIObserverType, aIconSize: uint32_t, aIconData: uint8_t[]): void;
}

/**
 *
 */
declare interface nsIAlertsIconURIType extends nsISupportsType {
    /**
     * Shows an alert with an icon URI. Web notifications use |moz-anno:|
     * URIs to reference favicons from Places. If the page doesn't have a
     * favicon, |aIconURI| will be |null|.
     */
    showAlertWithIconURI(aAlert: nsIAlertNotificationType, aAlertListener: nsIObserverType, aIconURI: nsIURIType): void;
}

/**
 *
 */
declare interface nsIAndroidEventCallbackType extends nsISupportsType {
    /**
     *
     */
    onSuccess(data: jsval): void;
    /**
     *
     */
    onError(data: jsval): void;
}

/**
 *
 */
declare interface nsIAndroidEventFinalizerType extends nsISupportsType {
    /**
     *
     */
    onFinalize(): void;
}

/**
 *
 */
declare interface nsIAndroidEventListenerType extends nsISupportsType {
    /**
     *
     */
    onEvent(event: AString, data: jsval, callback: nsIAndroidEventCallbackType): void;
}

/**
 *
 */
declare interface nsIAndroidEventDispatcherType extends nsISupportsType {
    /**
     *
     */
    dispatch(event: jsval, data: jsval, callback: nsIAndroidEventCallbackType, finalizer: nsIAndroidEventFinalizerType): void;
    /**
     *
     */
    registerListener(listener: nsIAndroidEventListenerType, events: jsval): void;
    /**
     *
     */
    unregisterListener(listener: nsIAndroidEventListenerType, events: jsval): void;
}

/**
 *
 */
declare interface nsIAndroidViewType extends nsIAndroidEventDispatcherType {
    /**
     *
     */
    readonly initData: jsval;
}

/**
 *
 */
declare interface nsIAndroidBridgeType extends nsIAndroidEventDispatcherType {
    /**
     *
     */
    getDispatcherByName(name: string): nsIAndroidEventDispatcher;
}

/**
 * Interface for the native event system layer.  This interface is designed
 * to be used on the main application thread only.
 */
declare interface nsIAppShellType extends nsISupportsType {
    /**
     * Enter an event loop.  Don't leave until exit() is called.
     */
    run(): void;
    /**
     * Exit the handle event loop
     */
    exit(): void;
    /**
     * Ask the native event queue notification mechanism to favor Gecko tasks
     * (instead of native tasks) for a short while. (Content processes always
     * favor Gecko tasks.)
     */
    geckoTaskBurst(): void;
    /**
     * Suspends the use of additional platform-specific methods (besides the
     * nsIAppShell->run() event loop) to run Gecko events on the main
     * application thread.  Under some circumstances these "additional methods"
     * can cause Gecko event handlers to be re-entered, sometimes leading to
     * hangs and crashes.  Calls to suspendNative() and resumeNative() may be
     * nested.  On some platforms (those that don't use any "additional
     * methods") this will be a no-op.  Does not (in itself) stop Gecko events
     * from being processed on the main application thread.  But if the
     * nsIAppShell->run() event loop is blocked when this call is made, Gecko
     * events will stop being processed until resumeNative() is called (even
     * if a plugin or library is temporarily processing events on a nested
     * event loop).
     */
    suspendNative(): void;
    /**
     * Resumes the use of additional platform-specific methods to run Gecko
     * events on the main application thread.  Calls to suspendNative() and
     * resumeNative() may be nested.  On some platforms this will be a no-op.
     */
    resumeNative(): void;
    /**
     * The current event loop nesting level.
     */
    readonly eventloopNestingLevel: unsigned_long;
}

/**
 *
 */
declare interface nsIAppShellServiceType extends nsISupportsType {
    /**
     *
     */
    createTopLevelWindow(aParent: nsIAppWindowType, aUrl: nsIURIType, aChromeMask: uint32_t, aInitialWidth: long, aInitialHeight: long): nsIAppWindow;
    /**
     * This is the constructor for creating an invisible DocShell.
     * It is used to simulate DOM windows without an actual physical
     * representation.
     * @param aIsChrome Set true if you want to use it for chrome content.
     * @param aChromeMask Used to specify chrome flags that should be set on the
     * window. See nsIWebBrowserChrome for flag definitions.
     */
    createWindowlessBrowser(aIsChrome: bool, aChromeMask: uint32_t): nsIWindowlessBrowser;
    /**
     *
     */
    destroyHiddenWindow(): void;
    /**
     * Return the (singleton) application hidden window, automatically created
     * and maintained by this AppShellService.
     * @param aResult the hidden window.  Do not unhide hidden window.
     * Do not taunt hidden window.
     */
    readonly hiddenWindow: nsIAppWindow;
    /**
     * Return the (singleton) application hidden window, automatically created
     * and maintained by this AppShellService.
     * @param aResult the hidden window.  Do not unhide hidden window.
     * Do not taunt hidden window.
     */
    readonly hiddenDOMWindow: mozIDOMWindowProxy;
    /**
     * Return true if the application hidden window was provided by the
     * application. If it wasn't, the default hidden window was used. This will
     * usually be false on all non-mac platforms.
     */
    readonly applicationProvidedHiddenWindow: boolean;
    /**
     * Add a window to the application's registry of windows.  These windows
     * are generally shown in the Windows taskbar, and the application
     * knows it can't quit until it's out of registered windows.
     * @param aWindow the window to register
     * @note When this method is successful, it fires the global notification
     * "xul-window-registered"
     */
    registerTopLevelWindow(aWindow: nsIAppWindowType): void;
    /**
     * Remove a window from the application's window registry. Note that
     * this method won't automatically attempt to quit the app when
     * the last window is unregistered. For that, see Quit().
     * @param aWindow you see the pattern
     */
    unregisterTopLevelWindow(aWindow: nsIAppWindowType): void;
    /**
     * Whether the hidden window has been lazily created.
     */
    readonly hasHiddenWindow: boolean;
    /**
     * Start/stop tracking lags in the event loop.
     * If the event loop gets unresponsive, a "event-loop-lag" notification
     * is sent. Note that calling `startEventLoopLagTracking` when tracking
     * is already enabled has no effect.
     * @return true if tracking succeeded.
     */
    startEventLoopLagTracking(): bool;
    /**
     *
     */
    stopEventLoopLagTracking(): void;
}

/**
 *
 */
declare interface nsIAppStartupType extends nsISupportsType {
    /**
     * Create the hidden window.
     */
    createHiddenWindow(): void;
    /**
     * Destroys the hidden window. This will have no effect if the hidden window
     * has not yet been created.
     */
    destroyHiddenWindow(): void;
    /**
     * Runs an application event loop: normally the main event pump which
     * defines the lifetime of the application. If there are no windows open
     * and no outstanding calls to enterLastWindowClosingSurvivalArea this
     * method will exit immediately.
     *
     * @returnCode NS_SUCCESS_RESTART_APP
     * This return code indicates that the application should be
     * restarted because quit was called with the eRestart flag.
     */
    run(): void;
    /**
     * There are situations where all application windows will be
     * closed but we don't want to take this as a signal to quit the
     * app. Bracket the code where the last window could close with
     * these.
     */
    enterLastWindowClosingSurvivalArea(): void;
    /**
     *
     */
    exitLastWindowClosingSurvivalArea(): void;
    /**
     * Startup Crash Detection
     *
     * Keeps track of application startup begining and success using flags to
     * determine whether the application is crashing on startup.
     * When the number of crashes crosses the acceptable threshold, safe mode
     * or other repair procedures are performed.
     * Whether automatic safe mode is necessary at this time.  This gets set
     * in trackStartupCrashBegin.
     *
     * @see trackStartupCrashBegin
     */
    readonly automaticSafeModeNecessary: boolean;
    /**
     * Restart the application in safe mode
     * @param aQuitMode
     * This parameter modifies how the app is shutdown.
     * @see nsIAppStartup::quit
     */
    restartInSafeMode(aQuitMode: uint32_t): void;
    /**
     * Run a new instance of this app with a specified profile
     * @param aProfile
     * The profile we want to use.
     * @see nsIAppStartup::quit
     */
    createInstanceWithProfile(aProfile: nsIToolkitProfileType): void;
    /**
     * If the last startup crashed then increment a counter.
     * Set a flag so on next startup we can detect whether TrackStartupCrashEnd
     * was called (and therefore the application crashed).
     * @return whether safe mode is necessary
     */
    trackStartupCrashBegin(): bool;
    /**
     * We have succesfully started without crashing. Clear flags that were
     * tracking past crashes.
     */
    trackStartupCrashEnd(): void;
    /**
     * Exit the event loop, and shut down the app.
     *
     * @param aMode
     * This parameter modifies how the app is shutdown, and it is
     * constructed from the constants defined above.
     * @param aExitCode
     * The exit code to return from the process. The precise code
     * returned by the process may vary depending on the platform. Only
     * values 0-255 should generally be used. If not specified an exit
     * code of 0 will be used.
     *
     * @return false if the shutdown was cancelled due to the presence
     * of a hidden window or if the user disallowed a window
     * to be closed.
     */
    quit(aMode: uint32_t, aExitCode: int32_t): bool;
    /**
     * Wrapper for shutdown notifications that informs the terminator before
     * we notify other observers. Calls MaybeFastShutdown.
     * This function is supposed to be used only from some (xpcshell) tests
     * explicitely dealing with shutdown.
     *
     * @param aPhase
     * The shutdown phase we want to advance to. Please note, that
     * we cannot go back to earlier phases or abort shutdown once
     * it started.
     */
    advanceShutdownPhase(aPhase: nsIAppStartup_IDLShutdownPhaseType): void;
    /**
     * Check if we entered or passed a specific shutdown phase.
     *
     * @param aPhase
     * The shutdown phase we want to check.
     *
     * @return true if we are in or beyond the given phase.
     */
    isInOrBeyondShutdownPhase(aPhase: nsIAppStartup_IDLShutdownPhaseType): bool;
    /**
     * True if the application is in the process of shutting down.
     * This is functionally equivalent to the C++ call
     * AppShutdown::IsInOrBeyond(ShutdownPhase::AppShutdownConfirmed);
     * (which is the preferred way of checking for shutdown in C++).
     */
    readonly shuttingDown: boolean;
    /**
     * True if the application is in the process of starting up.
     *
     * Startup is complete once all observers of final-ui-startup have returned.
     */
    readonly startingUp: boolean;
    /**
     * True if the application is being restarted
     */
    readonly restarting: boolean;
    /**
     * True if this is the startup following restart, i.e. if the application
     * was restarted using quit(eRestart*).
     */
    readonly wasRestarted: boolean;
    /**
     * True if this is the startup following a silent restart, i.e. if the
     * application was restarted using quit(eSilently*), or if the application
     * was started with the "silentmode" command line flag.
     */
    readonly wasSilentlyStarted: boolean;
    /**
     * The number of seconds since the OS was last rebooted
     */
    readonly secondsSinceLastOSRestart: int64_t;
    /**
     * Whether or not we showed the startup skeleton UI.
     */
    readonly showedPreXULSkeletonUI: bool;
    /**
     * Returns an object with main, process, firstPaint, sessionRestored properties.
     * Properties may not be available depending on platform or application
     */
    getStartupInfo(): jsval;
    /**
     * True if startup was interrupted by an interactive prompt.
     */
    interrupted: boolean;
}

/**
 *
 */
declare interface nsIAppWindowType extends nsISupportsType {
    /**
     * The docshell owning the XUL for this window.
     */
    readonly docShell: nsIDocShell;
    /**
     * Indicates if this window is instrinsically sized.
     */
    intrinsicallySized: boolean;
    /**
     * The primary content shell.
     *
     * Note that this is a docshell tree item and therefore can not be assured of
     * what object it is. It could be an editor, a docshell, or a browser object.
     * Or down the road any other object that supports being a DocShellTreeItem
     * Query accordingly to determine the capabilities.
     */
    readonly primaryContentShell: nsIDocShellTreeItem;
    /**
     * In multiprocess case we may not have primaryContentShell but
     * primaryRemoteTab.
     */
    readonly primaryRemoteTab: nsIRemoteTab;
    /**
     * Helper for getting the BrowsingContext from either `primaryContentShell` or
     * `primaryRemoteTab` depending on which is available.
     */
    readonly primaryContentBrowsingContext: BrowsingContext;
    /**
     *
     */
    remoteTabAdded(aTab: nsIRemoteTabType, aPrimary: boolean): void;
    /**
     *
     */
    remoteTabRemoved(aTab: nsIRemoteTabType): void;
    /**
     * Tell this window that it has picked up a child XUL window
     * @param aChild the child window being added
     */
    addChildWindow(aChild: nsIAppWindowType): void;
    /**
     * Returns the difference between the inner window size (client size) and the
     * outer window size, in CSS pixels.
     */
    readonly outerToInnerHeightDifferenceInCSSPixels: unsigned_long;
    /**
     *
     */
    readonly outerToInnerWidthDifferenceInCSSPixels: unsigned_long;
    /**
     * Tell this window that it has lost a child XUL window
     * @param aChild the child window being removed
     */
    removeChildWindow(aChild: nsIAppWindowType): void;
    /**
     * Move the window to a centered position.
     * @param aRelative If not null, the window relative to which the window is
     * moved. See aScreen parameter for details.
     * @param aScreen   PR_TRUE to center the window relative to the screen
     * containing aRelative if aRelative is not null. If
     * aRelative is null then relative to the screen of the
     * opener window if it was initialized by passing it to
     * nsWebShellWindow::Initialize. Failing that relative to
     * the main screen.
     * PR_FALSE to center it relative to aRelative itself.
     * @param aAlert    PR_TRUE to move the window to an alert position,
     * generally centered horizontally and 1/3 down from the top.
     */
    center(aRelative: nsIAppWindowType, aScreen: boolean, aAlert: boolean): void;
    /**
     * Shows the window as a modal window. That is, ensures that it is visible
     * and runs a local event loop, exiting only once the window has been closed.
     */
    showModal(): void;
    /**
     * Locks the aspect ratio for a window.
     * @param aShouldLock boolean
     */
    lockAspectRatio(aShouldLock: bool): void;
    /**
     *
     */
    zLevel: unsigned_long;
    /**
     *
     */
    chromeFlags: uint32_t;
    /**
     * Begin assuming |chromeFlags| don't change hereafter, and assert
     * if they do change.  The state change is one-way and idempotent.
     */
    assumeChromeFlagsAreFrozen(): void;
    /**
     * Create a new window.
     * @param aChromeFlags see nsIWebBrowserChrome
     * @param aOpenWindowInfo information about the request for a content window
     * to be opened. Will be null for non-content loads.
     * @return the newly minted window
     */
    createNewWindow(aChromeFlags: int32_t, aOpenWindowInfo: nsIOpenWindowInfoType): nsIAppWindow;
    /**
     *
     */
    XULBrowserWindow: nsIXULBrowserWindow;
    /**
     * If the window was opened as a content window, this will return the initial
     * nsIOpenWindowInfo to use.
     */
    readonly initialOpenWindowInfo: nsIOpenWindowInfo;
    /**
     * Request fast snapshot at RenderCompositor of WebRender.
     * Since readback of Windows DirectComposition is very slow.
     */
    needFastSnaphot(): void;
}

/**
 *
 */
declare interface nsIApplicationChooserFinishedCallbackType extends nsISupportsType {
    /**
     *
     */
    done(handlerApp: nsIHandlerAppType): void;
}

/**
 *
 */
declare interface nsIApplicationChooserType extends nsISupportsType {
    /**
     * Initialize the application chooser picker widget.  The application chooser
     * is not valid until this method is called.
     *
     * @param      parent   nsIDOMWindow parent.  This dialog will be dependent
     * on this parent. parent must be non-null.
     * @param      title    The title for the file widget
     */
    init(parent: mozIDOMWindowProxy, title: ACString): void;
    /**
     * Open application chooser dialog.
     *
     * @param    contentType   content type of file to open
     * @param    applicationChooserFinishedCallback  callback fuction to run when dialog is closed
     */
    open(contentType: ACString, applicationChooserFinishedCallback: nsIApplicationChooserFinishedCallbackType): void;
}

/**
 * A service for asynchronously querying an application reputation service
 * based on metadata of the downloaded file.
 */
declare interface nsIApplicationReputationServiceType extends nsISupportsType {
    /**
     * Start querying the application reputation service.
     *
     * @param aQuery
     * The nsIApplicationReputationQuery containing metadata of the
     * downloaded file.
     *
     * @param aCallback
     * The callback for receiving the results of the query.
     *
     * @remarks aCallback may not be null.  onComplete is guaranteed to be called
     * on aCallback. This function may not be called more than once with
     * the same query object. If any of the attributes of aQuery have
     * not been set or have been set with empty data (with the exception
     * of sourceURI), then a valid request can still be constructed and
     * will solicit a valid response, but won't produce any useful
     * information.
     */
    queryReputation(aQuery: nsIApplicationReputationQueryType, aCallback: nsIApplicationReputationCallbackType): void;
    /**
     * Check if a file with this name should be treated as a binary executable,
     * and is therefore subject to application reputation checks.
     * Will return true if the filename's extension is either:
     * - in kBinaryFileExtensions in ApplicationReputation.cpp
     * - in sExecutableExts in nsLocalFileCommon.h *and* not in
     * kNonBinaryExecutables in ApplicationReputation.cpp
     *
     * @param aFilename
     * The filename to check.
     */
    isBinary(aFilename: AUTF8String): bool;
    /**
     * Check if a file with this name should be treated as an executable,
     * and should not be opened without caution.
     * Will return true if the filename's extension is in sExecutableExts
     * in nsLocalFileCommon.h.
     *
     * @param aFilename
     * The filename to check.
     */
    isExecutable(aFilename: AUTF8String): bool;
}

/**
 * A single-use, write-once interface for recording the metadata of the
 * downloaded file. nsIApplicationReputationService.Start() may only be called
 * once with a single query.
 */
declare interface nsIApplicationReputationQueryType extends nsISupportsType {
    /**
     * The nsIURI from which the file was downloaded. This may not be null.
     */
    readonly sourceURI: nsIURI;
    /**
     * The reference, if any.
     */
    readonly referrerInfo: nsIReferrerInfo;
    /**
     * The target filename for the downloaded file, as inferred from the source
     * URI or provided by the Content-Disposition attachment file name. If this
     * is not set by the caller, it will be passed as an empty string but the
     * query won't produce any useful information.
     */
    readonly suggestedFileName: AUTF8String;
    /**
     * The size of the downloaded file in bytes.
     */
    readonly fileSize: unsigned_long;
    /**
     * The SHA256 hash of the downloaded file in raw bytes. If this is not set by
     * the caller, it will be passed as an empty string but the query won't
     * produce any useful information.
     */
    readonly sha256Hash: ACString;
    /**
     * The nsIArray of nsIPrincipal of redirects that lead to this download. The
     * most recent redirect is the last element.
     */
    readonly redirects: nsIArray;
}

/**
 *
 */
declare interface nsIApplicationReputationCallbackType extends nsISupportsType {
    /**
     * Callback for the result of the application reputation query.
     * @param aStatus
     * NS_OK if and only if the query succeeded. If it did, then
     * shouldBlock is meaningful (otherwise it defaults to false). This
     * may be NS_ERROR_FAILURE if the response cannot be parsed, or
     * NS_ERROR_NOT_AVAILABLE if the service has been disabled or is not
     * reachable.
     * @param aShouldBlock
     * Whether or not the download should be blocked.
     * @param aVerdict
     * Indicates the result of the lookup that determines whether the
     * download should be blocked, according to the "VERDICT_" constants.
     * This may be set to a value different than "VERDICT_SAFE" even if
     * aShouldBlock is false, so you should always check aShouldBlock.
     */
    onComplete(aShouldBlock: bool, aStatus: nsresult, aVerdict: unsigned_long): void;
}

/**
 * nsIArray
 *
 * An indexed collection of elements. Provides basic functionality for
 * retrieving elements at a specific position, searching for
 * elements. Indexes are zero-based, such that the last element in the
 * array is stored at the index length-1.
 *
 * For an array which can be modified, see nsIMutableArray below.
 *
 * Neither interface makes any attempt to protect the individual
 * elements from modification. The convention is that the elements of
 * the array should not be modified. Documentation within a specific
 * interface should describe variations from this convention.
 *
 * It is also convention that if an interface provides access to an
 * nsIArray, that the array should not be QueryInterfaced to an
 * nsIMutableArray for modification. If the interface in question had
 * intended the array to be modified, it would have returned an
 * nsIMutableArray!
 *
 * null is a valid entry in the array, and as such any nsISupports
 * parameters may be null, except where noted.
 */
declare interface nsIArrayType extends nsISupportsType {
    /**
     * length
     *
     * number of elements in the array.
     */
    readonly length: unsigned_long;
    /**
     * queryElementAt()
     *
     * Retrieve a specific element of the array, and QueryInterface it
     * to the specified interface. null is a valid result for
     * this method, but exceptions are thrown in other circumstances
     *
     * @param index position of element
     * @param uuid the IID of the requested interface
     * @param result the object, QI'd to the requested interface
     *
     * @throws NS_ERROR_NO_INTERFACE when an entry exists at the
     * specified index, but the requested interface is not
     * available.
     * @throws NS_ERROR_ILLEGAL_VALUE when index > length-1
     */
    queryElementAt(index: unsigned_long, uuid: nsIIDRefType, result: nsQIResult): void;
    /**
     * indexOf()
     *
     * Get the position of a specific element. Note that since null is
     * a valid input, exceptions are used to indicate that an element
     * is not found.
     *
     * @param startIndex The initial element to search in the array
     * To start at the beginning, use 0 as the
     * startIndex
     * @param element    The element you are looking for
     * @returns a number >= startIndex which is the position of the
     * element in the array.
     * @throws NS_ERROR_FAILURE if the element was not in the array.
     */
    indexOf(startIndex: unsigned_long, element: nsISupportsType): unsigned_long;
    /**
     * enumerate the array
     *
     * @returns a new enumerator positioned at the start of the array
     * @throws NS_ERROR_FAILURE if the array is empty (to make it easy
     * to detect errors), or NS_ERROR_OUT_OF_MEMORY if out of memory.
     */
    enumerate(aElemIID: nsIIDRefType): nsISimpleEnumerator;
}

/**
 * nsIArrayBufferInputStream
 *
 * Provides scriptable methods for initializing a nsIInputStream
 * implementation with an ArrayBuffer.
 */
declare interface nsIArrayBufferInputStreamType extends nsIInputStreamType {
    /**
     * SetData - assign an ArrayBuffer to the input stream.
     *
     * @param buffer    - stream data
     * @param byteOffset - stream data offset
     * @param byteLen - stream data length
     */
    setData(buffer: jsval, byteOffset: uint64_t, byteLen: uint64_t): void;
}

/**
 * Helper interface for allowing scripts to treat nsIArray instances as if
 * they were nsISupportsArray instances while iterating.
 *
 * nsISupportsArray is convenient to iterate over in JavaScript:
 *
 * for (let i = 0; i < array.Count(); ++i) {
 * let elem = array.GetElementAt(i);
 * ...
 * }
 *
 * but doing the same with nsIArray is somewhat less convenient, since
 * queryElementAt is not nearly so nice to use from JavaScript.  So we provide
 * this extension interface so interfaces that currently return
 * nsISupportsArray can start returning nsIArrayExtensions and all JavaScript
 * should Just Work. Eventually we'll roll this interface into nsIArray
 * itself, possibly getting rid of the Count() method, as it duplicates
 * nsIArray functionality.
 */
declare interface nsIArrayExtensionsType extends nsIArrayType {
    /**
     * Count()
     *
     * Retrieves the length of the array. This is an alias for the
     * |nsIArray.length| attribute.
     */
    Count(): uint32_t;
    /**
     * GetElementAt()
     *
     * Retrieve a specific element of the array. null is a valid result for
     * this method.
     *
     * Note: If the index is out of bounds null will be returned.
     * This differs from the behavior of nsIArray.queryElementAt() which
     * will throw if an invalid index is specified.
     *
     * @param index position of element
     */
    GetElementAt(index: uint32_t): nsISupports;
}

/**
 * If an input stream is non-blocking, it may return NS_BASE_STREAM_WOULD_BLOCK
 * when read.  The caller must then wait for the stream to have some data to
 * read.  If the stream implements nsIAsyncInputStream, then the caller can use
 * this interface to request an asynchronous notification when the stream
 * becomes readable or closed (via the AsyncWait method).
 *
 * While this interface is almost exclusively used with non-blocking streams, it
 * is not necessary that nsIInputStream::isNonBlocking return true.  Nor is it
 * necessary that a non-blocking nsIInputStream implementation also implement
 * nsIAsyncInputStream.
 */
declare interface nsIAsyncInputStreamType extends nsIInputStreamType {
    /**
     * This method closes the stream and sets its internal status.  If the
     * stream is already closed, then this method is ignored.  Once the stream
     * is closed, the stream's status cannot be changed.  Any successful status
     * code passed to this method is treated as NS_BASE_STREAM_CLOSED, which
     * has an effect equivalent to nsIInputStream::close.
     *
     * NOTE: this method exists in part to support pipes, which have both an
     * input end and an output end.  If the input end of a pipe is closed, then
     * writes to the output end of the pipe will fail.  The error code returned
     * when an attempt is made to write to a "broken" pipe corresponds to the
     * status code passed in when the input end of the pipe was closed, which
     * greatly simplifies working with pipes in some cases.
     *
     * @param aStatus
     * The error that will be reported if this stream is accessed after
     * it has been closed.
     */
    closeWithStatus(aStatus: nsresult): void;
    /**
     * Asynchronously wait for the stream to be readable or closed.  The
     * notification is one-shot, meaning that each asyncWait call will result
     * in exactly one notification callback.  After the OnInputStreamReady event
     * is dispatched, the stream releases its reference to the
     * nsIInputStreamCallback object.  It is safe to call asyncWait again from the
     * notification handler.
     *
     * This method may be called at any time (even if read has not been called).
     * In other words, this method may be called when the stream already has
     * data to read.  It may also be called when the stream is closed and will NOT
     * result in an error return, e.g., NS_BASE_STREAM_CLOSED.  If the stream is
     * already readable or closed when AsyncWait is called, then the
     * OnInputStreamReady event will be dispatched immediately.  Otherwise, the
     * event will be dispatched when the stream becomes readable or closed.
     *
     * @param aCallback
     * This object is notified when the stream becomes ready.  This
     * parameter may be null to clear an existing callback.
     * @param aFlags
     * This parameter specifies optional flags passed in to configure
     * the behavior of this method.  Pass zero to specify no flags.
     * @param aRequestedCount
     * Wait until at least this many bytes can be read.  This is only
     * a suggestion to the underlying stream; it may be ignored.  The
     * caller may pass zero to indicate no preference.
     * @param aEventTarget
     * Specify NULL to receive notification on ANY thread (possibly even
     * recursively on the calling thread -- i.e., synchronously), or
     * specify that the notification be delivered to a specific event
     * target.
     */
    asyncWait(aCallback: nsIInputStreamCallbackType, aFlags: unsigned_long, aRequestedCount: unsigned_long, aEventTarget: nsIEventTargetType): void;
}

/**
 * This is a companion interface for nsIAsyncInputStream::asyncWait.
 */
declare interface nsIInputStreamCallbackType extends nsISupportsType {
    /**
     * Called to indicate that the stream is either readable or closed.
     *
     * @param aStream
     * The stream whose asyncWait method was called.
     */
    onInputStreamReady(aStream: nsIAsyncInputStreamType): void;
}

/**
 * If an output stream is non-blocking, it may return NS_BASE_STREAM_WOULD_BLOCK
 * when written to.  The caller must then wait for the stream to become
 * writable.  If the stream implements nsIAsyncOutputStream, then the caller can
 * use this interface to request an asynchronous notification when the stream
 * becomes writable or closed (via the AsyncWait method).
 *
 * While this interface is almost exclusively used with non-blocking streams, it
 * is not necessary that nsIOutputStream::isNonBlocking return true.  Nor is it
 * necessary that a non-blocking nsIOutputStream implementation also implement
 * nsIAsyncOutputStream.
 */
declare interface nsIAsyncOutputStreamType extends nsIOutputStreamType {
    /**
     * This method closes the stream and sets its internal status.  If the
     * stream is already closed, then this method is ignored.  Once the stream
     * is closed, the stream's status cannot be changed.  Any successful status
     * code passed to this method is treated as NS_BASE_STREAM_CLOSED, which
     * is equivalent to nsIInputStream::close.
     *
     * NOTE: this method exists in part to support pipes, which have both an
     * input end and an output end.  If the output end of a pipe is closed, then
     * reads from the input end of the pipe will fail.  The error code returned
     * when an attempt is made to read from a "closed" pipe corresponds to the
     * status code passed in when the output end of the pipe is closed, which
     * greatly simplifies working with pipes in some cases.
     *
     * @param aStatus
     * The error that will be reported if this stream is accessed after
     * it has been closed.
     */
    closeWithStatus(reason: nsresult): void;
    /**
     * Asynchronously wait for the stream to be writable or closed.  The
     * notification is one-shot, meaning that each asyncWait call will result
     * in exactly one notification callback.  After the OnOutputStreamReady event
     * is dispatched, the stream releases its reference to the
     * nsIOutputStreamCallback object.  It is safe to call asyncWait again from the
     * notification handler.
     *
     * This method may be called at any time (even if write has not been called).
     * In other words, this method may be called when the stream already has
     * room for more data.  It may also be called when the stream is closed.  If
     * the stream is already writable or closed when AsyncWait is called, then the
     * OnOutputStreamReady event will be dispatched immediately.  Otherwise, the
     * event will be dispatched when the stream becomes writable or closed.
     *
     * @param aCallback
     * This object is notified when the stream becomes ready.  This
     * parameter may be null to clear an existing callback.
     * @param aFlags
     * This parameter specifies optional flags passed in to configure
     * the behavior of this method.  Pass zero to specify no flags.
     * @param aRequestedCount
     * Wait until at least this many bytes can be written.  This is only
     * a suggestion to the underlying stream; it may be ignored.  The
     * caller may pass zero to indicate no preference.
     * @param aEventTarget
     * Specify NULL to receive notification on ANY thread (possibly even
     * recursively on the calling thread -- i.e., synchronously), or
     * specify that the notification be delivered to a specific event
     * target.
     */
    asyncWait(aCallback: nsIOutputStreamCallbackType, aFlags: unsigned_long, aRequestedCount: unsigned_long, aEventTarget: nsIEventTargetType): void;
}

/**
 * This is a companion interface for nsIAsyncOutputStream::asyncWait.
 */
declare interface nsIOutputStreamCallbackType extends nsISupportsType {
    /**
     * Called to indicate that the stream is either writable or closed.
     *
     * @param aStream
     * The stream whose asyncWait method was called.
     */
    onOutputStreamReady(aStream: nsIAsyncOutputStreamType): void;
}

/**
 * A blocker installed by a client to be informed during some stage of
 * shutdown and block shutdown asynchronously until some condition is
 * complete.
 *
 * If you wish to use AsyncShutdown, you will need to implement this
 * interface (and only this interface).
 */
declare interface nsIAsyncShutdownBlockerType extends nsISupportsType {
    /**
     * The *unique* name of the blocker.
     *
     * By convention, it should respect the following format:
     * "MyModuleName: Doing something while it's time"
     * e.g.
     * "OS.File: Flushing before profile-before-change"
     *
     * This attribute is uploaded as part of crash reports.
     */
    readonly name: AString;
    /**
     * Inform the blocker that the stage of shutdown has started.
     * Shutdown will NOT proceed until `aBarrierClient.removeBlocker(this)`
     * has been called.
     */
    blockShutdown(aBarrierClient: nsIAsyncShutdownClientType): void;
    /**
     * The current state of the blocker.
     *
     * In case of crash, this is converted to JSON and attached to
     * the crash report.
     *
     * This field may be used to provide JSON-style data structures.
     * For this purpose, use
     * - nsIPropertyBag to represent objects;
     * - nsIVariant to represent field values (which may hold nsIPropertyBag
     * themselves).
     */
    readonly state: nsIPropertyBag;
}

/**
 * A client for a nsIAsyncShutdownBarrier.
 */
declare interface nsIAsyncShutdownClientType extends nsISupportsType {
    /**
     * The name of the barrier.
     */
    readonly name: AString;
    /**
     * Whether the client is still open for new blockers.
     * When this is true it is too late to add new blockers and addBlocker will
     * throw an exception.
     */
    readonly isClosed: boolean;
    /**
     * Add a blocker.
     *
     * After a `blocker` has been added with `addBlocker`, if it is not
     * removed with `removeBlocker`, this will, by design, eventually
     * CAUSE A CRASH.
     *
     * Calling `addBlocker` once nsIAsyncShutdownBarrier::wait() has been
     * called on the owning barrier returns an error.
     *
     * @param aBlocker The blocker to add. Once
     * nsIAsyncShutdownBarrier::wait() has been called, it will not
     * call its `aOnReady` callback until all blockers have been
     * removed, each  by a call to `removeBlocker`.
     * @param aFileName The filename of the callsite, as given by `__FILE__`.
     * @param aLineNumber The linenumber of the callsite, as given by `__LINE__`.
     * @param aStack Information on the stack that lead to this call. Generally
     * empty when called from C++.
     * @throws If it's too late to add a blocker.
     * @see isClosed.
     */
    addBlocker(aBlocker: nsIAsyncShutdownBlockerType, aFileName: AString, aLineNumber: long, aStack: AString): void;
    /**
     * Remove a blocker.
     *
     * @param aBlocker A blocker previously added to this client through
     * `addBlocker`. Noop if the blocker has never been added or has been
     * removed already.
     */
    removeBlocker(aBlocker: nsIAsyncShutdownBlockerType): void;
    /**
     * The JS implementation of the client.
     *
     * It is strongly recommended that JS clients of this API use
     * `jsclient` instead of the `nsIAsyncShutdownClient`. See
     * AsyncShutdown.sys.mjs for more information on the JS version of
     * this API.
     */
    readonly jsclient: jsval;
}

/**
 * Callback invoked once all blockers of a barrier have been removed.
 */
declare interface nsIAsyncShutdownCompletionCallbackType extends nsISupportsType {
    /**
     * The operation has been completed.
     */
    done(): void;
}

/**
 * A stage of shutdown that supports blocker registration.
 */
declare interface nsIAsyncShutdownBarrierType extends nsISupportsType {
    /**
     * The blocker registration capability.  Most services may wish to
     * publish this capability to let services that depend on it register
     * blockers.
     */
    readonly client: nsIAsyncShutdownClient;
    /**
     * The state of all the blockers of the barrier.
     *
     * See the documentation of `nsIAsyncShutdownBlocker` for the
     * format.
     */
    readonly state: nsIPropertyBag;
    /**
     * Wait for all blockers to complete.
     *
     * Method `aOnReady` will be called once all blockers have finished.
     * The callback always receives NS_OK.
     */
    wait(aOnReady: nsIAsyncShutdownCompletionCallbackType): void;
}

/**
 * A service that allows registering shutdown-time dependencies.
 */
declare interface nsIAsyncShutdownServiceType extends nsISupportsType {
    /**
     * Create a new barrier.
     *
     * By convention, the name should respect the following format:
     * "MyModuleName: Doing something while it's time"
     * e.g.
     * "OS.File: Waiting for clients to flush before shutting down"
     *
     * This attribute is uploaded as part of crash reports.
     */
    makeBarrier(aName: AString): nsIAsyncShutdownBarrier;
    /**
     * Barrier for notification profile-before-change.
     */
    readonly profileBeforeChange: nsIAsyncShutdownClient;
    /**
     * Barrier for notification profile-change-teardown.
     */
    readonly profileChangeTeardown: nsIAsyncShutdownClient;
    /**
     * Barrier for notification quit-application-granted.
     */
    readonly quitApplicationGranted: nsIAsyncShutdownClient;
    /**
     * Barrier for notification profile-before-change-telemetry.
     */
    readonly sendTelemetry: nsIAsyncShutdownClient;
    /**
     * Barrier for notification web-workers-shutdown.
     */
    readonly webWorkersShutdown: nsIAsyncShutdownClient;
    /**
     * Barrier for notification xpcom-will-shutdown.
     */
    readonly xpcomWillShutdown: nsIAsyncShutdownClient;
}

/**
 *
 */
declare interface nsIAsyncStreamCopierType extends nsIRequestType {
    /**
     * Initialize the stream copier.
     *
     * @param aSource
     * contains the data to be copied.
     * @param aSink
     * specifies the destination for the data.
     * @param aTarget
     * specifies the thread on which the copy will occur.  a null value
     * is permitted and will cause the copy to occur on an unspecified
     * background thread.
     * @param aSourceBuffered
     * true if aSource implements ReadSegments.
     * @param aSinkBuffered
     * true if aSink implements WriteSegments.
     * @param aChunkSize
     * specifies how many bytes to read/write at a time.  this controls
     * the granularity of the copying.  it should match the segment size
     * of the "buffered" streams involved.
     * @param aCloseSource
     * true if aSource should be closed after copying.
     * @param aCloseSink
     * true if aSink should be closed after copying.
     *
     * NOTE: at least one of the streams must be buffered. If you do not know
     * whether your streams are buffered, you should use nsIAsyncStreamCopier2
     * instead.
     */
    init(aSource: nsIInputStreamType, aSink: nsIOutputStreamType, aTarget: nsIEventTargetType, aSourceBuffered: boolean, aSinkBuffered: boolean, aChunkSize: unsigned_long, aCloseSource: boolean, aCloseSink: boolean): void;
    /**
     * asyncCopy triggers the start of the copy.  The observer will be notified
     * when the copy completes.
     *
     * @param aObserver
     * receives notifications.
     * @param aObserverContext
     * passed to observer methods.
     */
    asyncCopy(aObserver: nsIRequestObserverType, aObserverContext: nsISupportsType): void;
}

/**
 *
 */
declare interface nsIAsyncStreamCopier2Type extends nsIRequestType {
    /**
     * Initialize the stream copier.
     *
     * If neither the source nor the sink are buffered, buffering will
     * be automatically added to the sink.
     *
     *
     * @param aSource
     * contains the data to be copied.
     * @param aSink
     * specifies the destination for the data.
     * @param aTarget
     * specifies the thread on which the copy will occur.  a null value
     * is permitted and will cause the copy to occur on an unspecified
     * background thread.
     * @param aChunkSize
     * specifies how many bytes to read/write at a time.  this controls
     * the granularity of the copying.  it should match the segment size
     * of the "buffered" streams involved.
     * @param aCloseSource
     * true if aSource should be closed after copying (this is generally
     * the desired behavior).
     * @param aCloseSink
     * true if aSink should be closed after copying (this is generally
     * the desired behavior).
     */
    init(aSource: nsIInputStreamType, aSink: nsIOutputStreamType, aTarget: nsIEventTargetType, aChunkSize: unsigned_long, aCloseSource: boolean, aCloseSink: boolean): void;
    /**
     * asyncCopy triggers the start of the copy.  The observer will be notified
     * when the copy completes.
     *
     * @param aObserver
     * receives notifications.
     * @param aObserverContext
     * passed to observer methods.
     */
    asyncCopy(aObserver: nsIRequestObserverType, aObserverContext: nsISupportsType): void;
}

/**
 *
 */
declare interface nsIAsyncVerifyRedirectCallbackType extends nsISupportsType {
    /**
     * Complement to nsIChannelEventSink asynchronous callback. The result of
     * the redirect decision is passed through this callback.
     *
     * @param result
     * Result of the redirect veto decision. If FAILED the redirect has been
     * vetoed. If SUCCEEDED the redirect has been allowed by all consumers.
     */
    onRedirectVerifyCallback(result: nsresult): void;
}

/**
 *
 */
declare interface nsISuspendedTypesType extends nsISupportsType {
}

/**
 *
 */
declare interface nsIAudioChannelAgentCallbackType extends nsISupportsType {
    /**
     * Notified when the window volume/mute is changed
     */
    windowVolumeChanged(aVolume: float, aMuted: bool): void;
    /**
     * Notified when the window needs to be suspended or resumed.
     */
    windowSuspendChanged(aSuspend: uint32_t): void;
    /**
     * Notified when the capture state is changed.
     */
    windowAudioCaptureChanged(aCapture: bool): void;
}

/**
 * This interface provides an agent for gecko components to participate
 * in the audio channel service. Gecko components are responsible for
 * 1. Notifying the agent when they start/stop using this channel.
 * 2. Notifying the agent when they are audible.
 *
 * The agent will invoke a callback to notify Gecko components of
 * 1. Changes to the playable status of this channel.
 */
declare interface nsIAudioChannelAgentType extends nsISupportsType {
    /**
     * Initialize the agent with a channel type.
     * Note: This function should only be called once.
     *
     * @param window
     * The window
     * @param callback
     * 1. Once the playable status changes, agent uses this callback function
     * to notify Gecko component.
     * 2. The callback is allowed to be null. Ex: telephony doesn't need to
     * listen change of the playable status.
     * 3. The AudioChannelAgent keeps a strong reference to the callback
     * object.
     */
    init(window: mozIDOMWindow, callback: nsIAudioChannelAgentCallbackType): void;
    /**
     * This method is just like init(), except the audio channel agent keeps a
     * weak reference to the callback object.
     *
     * In order for this to work, |callback| must implement
     * nsISupportsWeakReference.
     */
    initWithWeakCallback(window: mozIDOMWindow, callback: nsIAudioChannelAgentCallbackType): void;
    /**
     * Notify the agent that we want to start playing.
     * Note: Gecko component SHOULD call this function first then start to
     * play audio stream only when return value is true.
     */
    notifyStartedPlaying(audible: uint8_t): void;
    /**
     * Notify the agent we no longer want to play.
     *
     * Note : even if notifyStartedPlaying() returned false, the agent would
     * still be registered with the audio channel service and receive callbacks
     * for status changes. So notifyStoppedPlaying must still eventually be
     * called to unregister the agent with the channel service.
     */
    notifyStoppedPlaying(): void;
    /**
     * Notify agent that we already start producing audible data.
     *
     * Note : sometime audio might become silent during playing, this method is used to
     * notify the actually audible state to other services which want to know
     * about that, ex. tab sound indicator.
     */
    notifyStartedAudible(audible: uint8_t, reason: uint32_t): void;
}

/**
 *
 */
declare interface nsIAudioDeviceInfoType extends nsISupportsType {
    /**
     *
     */
    readonly name: AString;
    /**
     *
     */
    readonly groupId: AString;
    /**
     *
     */
    readonly vendor: AString;
    /**
     *
     */
    readonly type: unsigned_short;
    /**
     *
     */
    readonly state: unsigned_short;
    /**
     *
     */
    readonly preferred: unsigned_short;
    /**
     *
     */
    readonly supportedFormat: unsigned_short;
    /**
     *
     */
    readonly defaultFormat: unsigned_short;
    /**
     *
     */
    readonly maxChannels: unsigned_long;
    /**
     *
     */
    readonly defaultRate: unsigned_long;
    /**
     *
     */
    readonly maxRate: unsigned_long;
    /**
     *
     */
    readonly minRate: unsigned_long;
    /**
     *
     */
    readonly maxLatency: unsigned_long;
    /**
     *
     */
    readonly minLatency: unsigned_long;
}

/**
 * A object that hold authentication information. The caller of
 * nsIAuthPrompt2::promptUsernameAndPassword or
 * nsIAuthPrompt2::promptPasswordAsync provides an object implementing this
 * interface; the prompt implementation can then read the values here to prefill
 * the dialog. After the user entered the authentication information, it should
 * set the attributes of this object to indicate to the caller what was entered
 * by the user.
 */
declare interface nsIAuthInformationType extends nsISupportsType {
    /**
     * @}
     * Flags describing this dialog. A bitwise OR of the flag values
     * above.
     *
     * It is possible that neither #AUTH_HOST nor #AUTH_PROXY are set.
     *
     * Auth prompts should ignore flags they don't understand; especially, they
     * should not throw an exception because of an unsupported flag.
     */
    readonly flags: unsigned_long;
    /**
     * The server-supplied realm of the authentication as defined in RFC 2617.
     * Can be the empty string if the protocol does not support realms.
     * Otherwise, this is a human-readable string like "Secret files".
     */
    readonly realm: AString;
    /**
     * The authentication scheme used for this request, if applicable. If the
     * protocol for this authentication does not support schemes, this will be
     * the empty string. Otherwise, this will be a string such as "basic" or
     * "digest". This string will always be in lowercase.
     */
    readonly authenticationScheme: AUTF8String;
    /**
     * The initial value should be used to prefill the dialog or be shown
     * in some other way to the user.
     * On return, this parameter should contain the username entered by
     * the user.
     * This field can only be changed if the #ONLY_PASSWORD flag is not set.
     */
    username: AString;
    /**
     * The initial value should be used to prefill the dialog or be shown
     * in some other way to the user.
     * The password should not be shown in clear.
     * On return, this parameter should contain the password entered by
     * the user.
     */
    password: AString;
    /**
     * The initial value should be used to prefill the dialog or be shown
     * in some other way to the user.
     * On return, this parameter should contain the domain entered by
     * the user.
     * This attribute is only used if flags include #NEED_DOMAIN.
     */
    domain: AString;
}

/**
 *
 */
declare interface nsIAuthModuleType extends nsISupportsType {
    /**
     * Other flags may be defined in the future
     *
     * Called to initialize an auth module.  The other methods cannot be called
     * unless this method succeeds.
     *
     * @param aServiceName
     * the service name, which may be null if not applicable (e.g., for
     * NTLM, this parameter should be null).
     * @param aServiceFlags
     * a bitwise-or of the REQ_ flags defined above (pass REQ_DEFAULT
     * for default behavior).
     * @param aDomain
     * the authentication domain, which may be null if not applicable.
     * @param aUsername
     * the user's login name
     * @param aPassword
     * the user's password
     */
    init(aServiceName: ACString, aServiceFlags: unsigned_long, aDomain: AString, aUsername: AString, aPassword: AString): void;
    /**
     * Called to get the next token in a sequence of authentication steps.
     *
     * @param aInToken
     * A buffer containing the input token (e.g., a challenge from a
     * server).  This may be null.
     * @param aInTokenLength
     * The length of the input token.
     * @param aOutToken
     * If getNextToken succeeds, then aOutToken will point to a buffer
     * to be sent in response to the server challenge.  The length of
     * this buffer is given by aOutTokenLength.  The buffer at aOutToken
     * must be recycled with a call to free.
     * @param aOutTokenLength
     * If getNextToken succeeds, then aOutTokenLength contains the
     * length of the buffer (number of bytes) pointed to by aOutToken.
     */
    getNextToken(aInToken: voidPtr, aInTokenLength: unsigned_long, aOutToken: voidPtr, aOutTokenLength: unsigned_long): void;
    /**
     * Once a security context has been established through calls to GetNextToken()
     * it may be used to protect data exchanged between client and server. Calls
     * to Wrap() are used to protect items of data to be sent to the server.
     *
     * @param aInToken
     * A buffer containing the data to be sent to the server
     * @param aInTokenLength
     * The length of the input token
     * @param confidential
     * If set to true, Wrap() will encrypt the data, otherwise data will
     * just be integrity protected (checksummed)
     * @param aOutToken
     * A buffer containing the resulting data to be sent to the server
     * @param aOutTokenLength
     * The length of the output token buffer
     *
     * Wrap() may return NS_ERROR_NOT_IMPLEMENTED, if the underlying authentication
     * mechanism does not support security layers.
     */
    wrap(aInToken: voidPtr, aInTokenLength: unsigned_long, confidential: boolean, aOutToken: voidPtr, aOutTokenLength: unsigned_long): void;
    /**
     * Unwrap() is used to unpack, decrypt, and verify the checksums on data
     * returned by a server when security layers are in use.
     *
     * @param aInToken
     * A buffer containing the data received from the server
     * @param aInTokenLength
     * The length of the input token
     * @param aOutToken
     * A buffer containing the plaintext data from the server
     * @param aOutTokenLength
     * The length of the output token buffer
     *
     * Unwrap() may return NS_ERROR_NOT_IMPLEMENTED, if the underlying
     * authentication mechanism does not support security layers.
     */
    unwrap(aInToken: voidPtr, aInTokenLength: unsigned_long, aOutToken: voidPtr, aOutTokenLength: unsigned_long): void;
}

/**
 *
 */
declare interface nsIAuthPromptType extends nsISupportsType {
    /**
     * Puts up a text input dialog with OK and Cancel buttons.
     * Note: prompt uses separate args for the "in" and "out" values of the
     * input field, whereas the other functions use a single inout arg.
     * @param  dialogText    The title for the dialog.
     * @param  text          The text to display in the dialog.
     * @param  passwordRealm The "realm" the password belongs to: e.g.
     * ldap://localhost/dc=test
     * @param  savePassword  One of the SAVE_PASSWORD_* options above.
     * @param  defaultText   The default text to display in the text input box.
     * @param  result        The value entered by the user if OK was
     * selected.
     * @return true for OK, false for Cancel
     */
    prompt(dialogTitle: wstring, text: wstring, passwordRealm: wstring, savePassword: uint32_t, defaultText: wstring, result: wstring): boolean;
    /**
     * Puts up a username/password dialog with OK and Cancel buttons.
     * @param  dialogText    The title for the dialog.
     * @param  text          The text to display in the dialog.
     * @param  passwordRealm The "realm" the password belongs to: e.g.
     * ldap://localhost/dc=test
     * @param  savePassword  One of the SAVE_PASSWORD_* options above.
     * @param  user          The username entered in the dialog.
     * @param  pwd           The password entered by the user if OK was
     * selected.
     * @return true for OK, false for Cancel
     */
    promptUsernameAndPassword(dialogTitle: wstring, text: wstring, passwordRealm: wstring, savePassword: uint32_t, user: wstring, pwd: wstring): boolean;
    /**
     * Puts up an async username/password dialog with OK and Cancel buttons.
     * @param  dialogText    The title for the dialog.
     * @param  text          The text to display in the dialog.
     * @param  passwordRealm The "realm" the password belongs to: e.g.
     * ldap://localhost/dc=test
     * @param  savePassword  One of the SAVE_PASSWORD_* options above.
     * @param  user          The username entered in the dialog.
     * @param  pwd           The password entered by the user if OK was
     * selected.
     * @return promise resolving to true for OK, false for Cancel
     */
    asyncPromptUsernameAndPassword(dialogTitle: wstring, text: wstring, passwordRealm: wstring, savePassword: uint32_t, user: wstring, pwd: wstring): Promise;
    /**
     * Puts up a password dialog with OK and Cancel buttons.
     * @param  dialogText    The title for the dialog.
     * @param  text          The text to display in the dialog.
     * @param  passwordRealm The "realm" the password belongs to: e.g.
     * ldap://localhost/dc=test. If a username is
     * specified (http://user@site.com) it will be used
     * when matching existing logins or saving new ones.
     * If no username is specified, only password-only
     * logins will be matched or saved.
     * Note: if a username is specified, the username
     * should be escaped.
     * @param  savePassword  One of the SAVE_PASSWORD_* options above.
     * @param  pwd           The password entered by the user if OK was
     * selected.
     * @return true for OK, false for Cancel
     */
    promptPassword(dialogTitle: wstring, text: wstring, passwordRealm: wstring, savePassword: uint32_t, pwd: wstring): boolean;
    /**
     * Puts up an async password dialog with OK and Cancel buttons.
     * @param  dialogText    The title for the dialog.
     * @param  text          The text to display in the dialog.
     * @param  passwordRealm The "realm" the password belongs to: e.g.
     * ldap://localhost/dc=test. If a username is
     * specified (http://user@site.com) it will be used
     * when matching existing logins or saving new ones.
     * If no username is specified, only password-only
     * logins will be matched or saved.
     * Note: if a username is specified, the username
     * should be escaped.
     * @param  savePassword  One of the SAVE_PASSWORD_* options above.
     * @param  pwd           The password entered by the user if OK was
     * selected.
     * @return promise resolving to true for OK, false for Cancel
     */
    asyncPromptPassword(dialogTitle: wstring, text: wstring, passwordRealm: wstring, savePassword: uint32_t, pwd: wstring): Promise;
}

/**
 * An interface allowing to prompt for a username and password. This interface
 * is usually acquired using getInterface on notification callbacks or similar.
 * It can be used to prompt users for authentication information, either
 * synchronously or asynchronously.
 */
declare interface nsIAuthPrompt2Type extends nsISupportsType {
    /**
     * @}
     *
     * Requests a username and a password. Implementations will commonly show a
     * dialog with a username and password field, depending on flags also a
     * domain field.
     *
     * @param aChannel
     * The channel that requires authentication.
     * @param level
     * One of the level constants from above. See there for descriptions
     * of the levels.
     * @param authInfo
     * Authentication information object. The implementation should fill in
     * this object with the information entered by the user before
     * returning.
     *
     * @retval true
     * Authentication can proceed using the values in the authInfo
     * object.
     * @retval false
     * Authentication should be cancelled, usually because the user did
     * not provide username/password.
     *
     * @note   Exceptions thrown from this function will be treated like a
     * return value of false.
     * @deprecated use asyncPromptAuth
     */
    promptAuth(aChannel: nsIChannelType, level: uint32_t, authInfo: nsIAuthInformationType): boolean;
    /**
     * Asynchronously prompt the user for a username and password.
     * This has largely the same semantics as promptUsernameAndPassword(),
     * but must return immediately after calling and return the entered
     * data in a callback.
     *
     * If the user closes the dialog using a cancel button or similar,
     * the callback's nsIAuthPromptCallback::onAuthCancelled method must be
     * called.
     * Calling nsICancelable::cancel on the returned object SHOULD close the
     * dialog and MUST call nsIAuthPromptCallback::onAuthCancelled on the provided
     * callback.
     *
     * This implementation may:
     *
     * 1) Coalesce identical prompts.  This means prompts that are guaranteed to
     * want the same auth information from the user.  A single prompt will be
     * shown; then the callbacks for all the coalesced prompts will be notified
     * with the resulting auth information.
     * 2) Serialize prompts that are all in the same "context" (this might mean
     * application-wide, for a given window, or something else depending on
     * the user interface) so that the user is not deluged with prompts.
     *
     * @throw
     * This method may throw any exception when the prompt fails to queue e.g
     * because of out-of-memory error. It must not throw when the prompt
     * could already be potentially shown to the user. In that case information
     * about the failure has to come through the callback. This way we
     * prevent multiple dialogs shown to the user because consumer may fall
     * back to synchronous prompt on synchronous failure of this method.
     */
    asyncPromptAuth(aChannel: nsIChannelType, aCallback: nsIAuthPromptCallbackType, aContext: nsISupportsType, level: uint32_t, authInfo: nsIAuthInformationType): nsICancelable;
}

/**
 * An interface for wrapping nsIAuthPrompt interfaces to make
 * them usable via an nsIAuthPrompt2 interface.
 */
declare interface nsIAuthPromptAdapterFactoryType extends nsISupportsType {
    /**
     * Wrap an object implementing nsIAuthPrompt so that it's usable via
     * nsIAuthPrompt2.
     */
    createAdapter(aPrompt: nsIAuthPromptType): nsIAuthPrompt2;
}

/**
 * Interface for callback methods for the asynchronous nsIAuthPrompt2 method.
 * Callers MUST call exactly one method if nsIAuthPrompt2::promptPasswordAsync
 * returns successfully. They MUST NOT call any method on this interface before
 * promptPasswordAsync returns.
 */
declare interface nsIAuthPromptCallbackType extends nsISupportsType {
    /**
     * Authentication information is available.
     *
     * @param aContext
     * The context as passed to promptPasswordAsync
     * @param aAuthInfo
     * Authentication information. Must be the same object that was passed
     * to promptPasswordAsync.
     *
     * @note  Any exceptions thrown from this method should be ignored.
     */
    onAuthAvailable(aContext: nsISupportsType, aAuthInfo: nsIAuthInformationType): void;
    /**
     * Notification that the prompt was cancelled.
     *
     * @param aContext
     * The context that was passed to promptPasswordAsync.
     * @param userCancel
     * If false, this prompt was cancelled by calling the
     * the cancel method on the nsICancelable; otherwise,
     * it was cancelled by the user.
     */
    onAuthCancelled(aContext: nsISupportsType, userCancel: boolean): void;
}

/**
 *
 */
declare interface nsIAuthPromptProviderType extends nsISupportsType {
    /**
     * Request a prompt interface for the given prompt reason;
     * @throws NS_ERROR_NOT_AVAILABLE if no prompt is allowed or
     * available for the given reason.
     *
     * @param aPromptReason   The reason for the auth prompt;
     * one of #PROMPT_NORMAL or #PROMPT_PROXY
     * @param iid             The desired interface, e.g.
     * NS_GET_IID(nsIAuthPrompt2).
     * @returns an nsIAuthPrompt2 interface, or throws NS_ERROR_NOT_AVAILABLE
     */
    getAuthPrompt(aPromptReason: uint32_t, iid: nsIIDRefType, result: nsQIResult): void;
}

/**
 *
 */
declare interface nsIAutoCompleteControllerType extends nsISupportsType {
    /**
     * The input widget that is currently being controlled.
     */
    input: nsIAutoCompleteInput;
    /**
     * State which indicates the status of possible ongoing searches
     */
    readonly searchStatus: unsigned_short;
    /**
     * The number of matches
     */
    readonly matchCount: unsigned_long;
    /**
     * Start a search on a string, assuming the input property is already set.
     */
    startSearch(searchString: AString): void;
    /**
     * Stop all asynchronous searches
     */
    stopSearch(): void;
    /**
     * Notify the controller that the user has changed text in the textbox.
     * This includes all means of changing the text value, including typing a
     * character, backspacing, deleting, pasting, committing composition or
     * canceling composition.
     *
     * NOTE: handleText() must be called after composition actually ends, even if
     * the composition is canceled and the textbox value isn't changed.
     * Then, implementation of handleText() can access the editor when
     * it's not in composing mode. DOM compositionend event is not good
     * timing for calling handleText(). DOM input event immediately after
     * DOM compositionend event is the best timing to call this.
     *
     * @return whether this handler started a new search.
     */
    handleText(): boolean;
    /**
     * Notify the controller that the user wishes to enter the current text. If
     * aIsPopupSelection is true, then a selection was made from the popup, so
     * fill this value into the input field before continuing. If false, just
     * use the current value of the input field.
     *
     * @param aIsPopupSelection
     * Pass true if the selection was made from the popup.
     * @param aEvent
     * The event that triggered the enter, like a key event if the user
     * pressed the Return key or a click event if the user clicked a popup
     * item.
     * @return Whether the controller wishes to prevent event propagation and
     * default event.
     */
    handleEnter(aIsPopupSelection: boolean, aEvent: Event): boolean;
    /**
     * Notify the controller that the user wishes to revert autocomplete
     *
     * @return Whether the controller wishes to prevent event propagation and
     * default event.
     */
    handleEscape(): boolean;
    /**
     * Notify the controller that the user wishes to start composition
     *
     * NOTE: nsIAutoCompleteController implementation expects that this is called
     * by DOM compositionstart handler.
     */
    handleStartComposition(): void;
    /**
     * Notify the controller that the user wishes to end composition
     *
     * NOTE: nsIAutoCompleteController implementation expects that this is called
     * by DOM compositionend handler.
     */
    handleEndComposition(): void;
    /**
     * Handle tab. Just closes up.
     */
    handleTab(): void;
    /**
     * Notify the controller of the following key navigation events:
     * up, down, left, right, page up, page down
     *
     * @return Whether the controller wishes to prevent event propagation and
     * default event
     */
    handleKeyNavigation(key: unsigned_long): boolean;
    /**
     * Notify the controller that the user chose to delete the current
     * auto-complete result.
     *
     * @return Whether the controller removed a result item.
     */
    handleDelete(): boolean;
    /**
     * Get the value of the result at a given index in the last completed search
     */
    getValueAt(index: long): AString;
    /**
     * Get the label of the result at a given index in the last completed search
     */
    getLabelAt(index: long): AString;
    /**
     * Get the comment of the result at a given index in the last completed search
     */
    getCommentAt(index: long): AString;
    /**
     * Get the style hint for the result at a given index in the last completed search
     */
    getStyleAt(index: long): AString;
    /**
     * Get the url of the image of the result at a given index in the last completed search
     */
    getImageAt(index: long): AString;
    /**
     * For the last completed search, get the final value that should be completed
     * when the user confirms the match at the given index
     */
    getFinalCompleteValueAt(index: long): AString;
    /**
     * Get / set the current search string.  Note, setting will not start searching
     */
    searchString: AString;
    /**
     * Set the index of the result item that should be initially selected.
     * This should be used when a search wants to pre-select an element before
     * the user starts using results.
     *
     * @note Setting this is not the same as just setting selectedIndex in
     * nsIAutocompletePopup, since this will take care of updating any internal
     * tracking variables of features like completeSelectedIndex.
     */
    setInitiallySelectedIndex(index: long): void;
    /**
     * Reset controller internal caches for cases where the input doesn't change
     * but its context resets, thus it is about to start a completely new search
     * session.
     */
    resetInternalState(): void;
}

/**
 *
 */
declare interface nsIAutoCompleteInputType extends nsISupportsType {
    /**
     * The result view that will be used to display results
     */
    readonly popupElement: Element;
    /**
     *
     */
    readonly popup: nsIAutoCompletePopup;
    /**
     * The controller.
     */
    readonly controller: nsIAutoCompleteController;
    /**
     * Indicates if the popup is currently open
     */
    popupOpen: boolean;
    /**
     * Option to disable autocomplete functionality
     */
    disableAutoComplete: boolean;
    /**
     * If a search result has its defaultIndex set, this will optionally
     * try to complete the text in the textbox to the entire text of the
     * result at the default index as the user types
     */
    completeDefaultIndex: boolean;
    /**
     * complete text in the textbox as the user selects from the dropdown
     * options if set to true
     */
    completeSelectedIndex: boolean;
    /**
     * Option for completing to the default result whenever the user hits
     * enter or the textbox loses focus
     */
    forceComplete: boolean;
    /**
     * Option to open the popup only after a certain number of results are available
     */
    minResultsForPopup: unsigned_long;
    /**
     * The maximum number of rows to show in the autocomplete popup.
     */
    maxRows: unsigned_long;
    /**
     * Number of milliseconds after a keystroke before a search begins
     */
    timeout: unsigned_long;
    /**
     * An extra parameter to configure searches with.
     */
    searchParam: AString;
    /**
     * The number of autocomplete session to search
     */
    readonly searchCount: unsigned_long;
    /**
     * Get the name of one of the autocomplete search session objects
     */
    getSearchAt(index: unsigned_long): ACString;
    /**
     * The value of text in the autocomplete textbox.
     */
    textValue: AString;
    /**
     * Report the starting index of the cursor in the textbox
     */
    readonly selectionStart: long;
    /**
     * Report the ending index of the cursor in the textbox
     */
    readonly selectionEnd: long;
    /**
     * Select a range of text in the autocomplete textbox
     */
    selectTextRange(startIndex: long, endIndex: long): void;
    /**
     * Notification that the search has started
     */
    onSearchBegin(): void;
    /**
     * Notification that the search concluded successfully
     */
    onSearchComplete(): void;
    /**
     * Notification that the user selected and entered a result item
     *
     * @param aEvent
     * The event that triggered the enter.
     * @param itemWasSelected
     * A boolean value that indicates whether
     * an item was selected from the autocomplete popup.
     * @return True if the user wishes to prevent the enter
     */
    onTextEntered(aEvent: Event, itemWasSelected: boolean): boolean;
    /**
     * Notification that the user cancelled the autocomplete session
     *
     * @return True if the user wishes to prevent the revert
     */
    onTextReverted(): boolean;
    /**
     * This popup should consume or dispatch the rollup event.
     * TRUE: should consume; FALSE: should dispatch.
     */
    readonly consumeRollupEvent: boolean;
    /**
     * Indicates whether this input is in a "private browsing" context.
     * nsIAutoCompleteSearches for these inputs should not persist any data to disk
     * (such as a history database).
     */
    readonly inPrivateContext: boolean;
    /**
     * Don't rollup the popup when the caret is moved.
     */
    readonly noRollupOnCaretMove: boolean;
    /**
     * Don't rollup the popup when the search string becomes "".
     */
    readonly noRollupOnEmptySearch: boolean;
    /**
     * The userContextId of the current browser.
     */
    readonly userContextId: unsigned_long;
    /**
     * Since search content is updated, we shouldn't use previous search result.
     */
    readonly invalidatePreviousResult: boolean;
}

/**
 *
 */
declare interface nsIAutoCompletePopupType extends nsISupportsType {
    /**
     * The input object that the popup is currently bound to
     */
    readonly input: nsIAutoCompleteInput;
    /**
     * An alternative value to be used when text is entered, rather than the
     * value of the selected item
     */
    readonly overrideValue: AString;
    /**
     * The index of the result item that is currently selected
     */
    selectedIndex: long;
    /**
     * Indicates if the popup is currently open
     */
    readonly popupOpen: boolean;
    /**
     * Bind the popup to an input object and display it with the given coordinates
     *
     * @param input - The input object that the popup will be bound to
     * @param element - The element that the popup will be aligned with
     */
    openAutocompletePopup(input: nsIAutoCompleteInputType, element: Element): void;
    /**
     * Close the popup and detach from the bound input
     */
    closePopup(): void;
    /**
     * Instruct the result view to repaint itself to reflect the most current
     * underlying data
     *
     * @param reason - The reason the popup needs to be invalidated, one of the
     * INVALIDATE_REASON consts.
     */
    invalidate(reason: unsigned_short): void;
    /**
     * Change the selection relative to the current selection and make sure
     * the newly selected row is visible
     *
     * @param reverse - Select a row above the current selection
     * @param page - Select a row that is a full visible page from the current selection
     * @return The currently selected result item index
     */
    selectBy(reverse: boolean, page: boolean): void;
}

/**
 *
 */
declare interface nsIAutoCompleteResultType extends nsISupportsType {
    /**
     * indicates success
     * with matches
     * and that the search
     * is still ongoing
     * The original search string
     */
    readonly searchString: AString;
    /**
     * The result of the search
     */
    readonly searchResult: unsigned_short;
    /**
     * Index of the default item that should be entered if none is selected
     */
    readonly defaultIndex: long;
    /**
     * A string describing the cause of a search failure
     */
    readonly errorDescription: AString;
    /**
     * The number of matches
     */
    readonly matchCount: unsigned_long;
    /**
     * Get the value of the result at the given index
     */
    getValueAt(index: long): AString;
    /**
     * This returns the string that is displayed in the dropdown
     */
    getLabelAt(index: long): AString;
    /**
     * Get the comment of the result at the given index
     */
    getCommentAt(index: long): AString;
    /**
     * Get the style hint for the result at the given index
     */
    getStyleAt(index: long): AString;
    /**
     * Get the image of the result at the given index
     */
    getImageAt(index: long): AString;
    /**
     * Get the final value that should be completed when the user confirms
     * the match at the given index.
     */
    getFinalCompleteValueAt(index: long): AString;
    /**
     * True if the value at the given index is removable.
     */
    isRemovableAt(rowIndex: long): bool;
    /**
     * Remove the value at the given index from the autocomplete results.
     */
    removeValueAt(rowIndex: long): void;
}

/**
 *
 */
declare interface nsIAutoCompleteSearchType extends nsISupportsType {
    /**
     * Search for a given string and notify a listener (either synchronously
     * or asynchronously) of the result
     *
     * @param searchString - The string to search for
     * @param searchParam - An extra parameter
     * @param previousResult - A previous result to use for faster searching
     * @param listener - A listener to notify when the search is complete
     */
    startSearch(searchString: AString, searchParam: AString, previousResult: nsIAutoCompleteResultType, listener: nsIAutoCompleteObserverType): void;
    /**
     * Stop all searches that are in progress
     */
    stopSearch(): void;
}

/**
 *
 */
declare interface nsIAutoCompleteObserverType extends nsISupportsType {
    /**
     * Called when a search is complete and the results are ready
     *
     * @param search - The search object that processed this search
     * @param result - The search result object
     */
    onSearchResult(search: nsIAutoCompleteSearchType, result: nsIAutoCompleteResultType): void;
}

/**
 *
 */
declare interface nsIAutoCompleteSearchDescriptorType extends nsISupportsType {
    /**
     * Identifies the search behavior.
     * Should be one of the SEARCH_TYPE_* constants above.
     * Defaults to SEARCH_TYPE_DELAYED.
     */
    readonly searchType: unsigned_short;
    /**
     * Whether a new search should be triggered when the user deletes the
     * autofilled part.
     */
    readonly clearingAutoFillSearchesAgain: boolean;
}

/**
 * This class implements nsIAutoCompleteResult and provides simple methods
 * for setting the value and result items. It can be used whenever some basic
 * auto complete results are needed that can be pre-generated and filled into
 * an array.
 */
declare interface nsIAutoCompleteSimpleResultType extends nsIAutoCompleteResultType {
    /**
     * A writer for the readonly attribute 'searchString' which should contain
     * the string that the user typed.
     */
    setSearchString(aSearchString: AString): void;
    /**
     * A writer for the readonly attribute 'errorDescription'.
     */
    setErrorDescription(aErrorDescription: AString): void;
    /**
     * A writer for the readonly attribute 'defaultIndex' which should contain
     * the index of the list that will be selected by default (normally 0).
     */
    setDefaultIndex(aDefaultIndex: long): void;
    /**
     * A writer for the readonly attribute 'searchResult' which should contain
     * one of the constants nsIAutoCompleteResult.RESULT_* indicating the success
     * of the search.
     */
    setSearchResult(aSearchResult: unsigned_short): void;
    /**
     * Inserts a match consisting of the given value, comment, image, style and
     * the value to use for defaultIndex completion at a given position.
     * @param aIndex
     * The index to insert at
     * @param aValue
     * The value to autocomplete to
     * @param aComment
     * Comment shown in the autocomplete widget to describe this match
     * @param aImage
     * Image shown in the autocomplete widget for this match.
     * @param aStyle
     * Describes how to style the match in the autocomplete widget
     * @param aFinalCompleteValue
     * Value used when the user confirms selecting this match. If not
     * provided, aValue will be used.
     */
    insertMatchAt(aIndex: long, aValue: AString, aComment: AString, aImage: AString, aStyle: AString, aFinalCompleteValue: AString, aLabel: AString): void;
    /**
     * Appends a match consisting of the given value, comment, image, style and
     * the value to use for defaultIndex completion.
     * @param aValue
     * The value to autocomplete to
     * @param aComment
     * Comment shown in the autocomplete widget to describe this match
     * @param aImage
     * Image shown in the autocomplete widget for this match.
     * @param aStyle
     * Describes how to style the match in the autocomplete widget
     * @param aFinalCompleteValue
     * Value used when the user confirms selecting this match. If not
     * provided, aValue will be used.
     */
    appendMatch(aValue: AString, aComment: AString, aImage: AString, aStyle: AString, aFinalCompleteValue: AString, aLabel: AString): void;
    /**
     * Removes an existing match.
     * @note this is different from removeValueAt, since it's not a consequence of
     * a user action, and as such it won't notify onValueRemoved.
     */
    removeMatchAt(aIndex: long): void;
    /**
     * Gets the listener for changes in the result.
     */
    getListener(): nsIAutoCompleteSimpleResultListener;
    /**
     * Sets a listener for changes in the result.
     */
    setListener(aListener: nsIAutoCompleteSimpleResultListenerType): void;
}

/**
 *
 */
declare interface nsIAutoCompleteSimpleResultListenerType extends nsISupportsType {
    /**
     * Dispatched after a value is removed from the result.
     * @param aResult
     * The result from which aValue has been removed.
     * @param aValue
     * The removed value.
     */
    onValueRemoved(aResult: nsIAutoCompleteSimpleResultType, aValue: AString): void;
}

/**
 * Simple interface that allows the results of the next search to be overridden.
 */
declare interface nsIAutoCompleteSimpleSearchType extends nsIAutoCompleteSearchType {
    /**
     * Sets the result that should be used next time `startSearch` is called.
     */
    overrideNextResult(values: nsIAutoCompleteResultType): void;
}

/**
 *
 */
declare interface nsIAutoplayType extends nsISupportsType {
}

/**
 * nsITabUnloader: interface to represent TabUnloader
 *
 * nsIAvailableMemoryWatcherBase: interface to watch the system's memory
 * status and invoke a registered TabUnloader when it detected a low-memory
 * and high-memory situation.  The logic to detect such a memory situation
 * is defined per platform.
 */
declare interface nsITabUnloaderType extends nsISupportsType {
    /**
     * Unload the least-recently-used tab.
     * JS implementation of this interface TabUnloader.unloadTabAsync takes
     * one parameter that defines a threshold to exclude fresh tabs from the
     * unloading candidate tabs.  Currently the memory watcher is the only one
     * caller of this interface and it always expects the default threshold,
     * so this interface takes no parameter.
     */
    unloadTabAsync(): void;
}

/**
 *
 */
declare interface nsIAvailableMemoryWatcherBaseType extends nsISupportsType {
    /**
     *
     */
    registerTabUnloader(aTabUnloader: nsITabUnloaderType): void;
    /**
     *
     */
    onUnloadAttemptCompleted(aResult: nsresult): void;
}

/**
 * This interface lets you evict a document from the back/forward cache.
 */
declare interface nsIBFCacheEntryType extends nsISupportsType {
    /**
     *
     */
    RemoveFromBFCacheSync(): void;
    /**
     *
     */
    RemoveFromBFCacheAsync(): void;
}

/**
 * Registrar for pairing HttpChannelParent and HttpBackgroundChannelParent via
 * channel Id. HttpChannelParent::OnBackgroundParentReady and
 * HttpBackgroundChannelParent::LinkToChannel will be invoked to notify the
 * existence of associated channel object.
 */
declare interface nsIBackgroundChannelRegistrarType extends nsISupportsType {
}

/**
 * Allows saving data to a file, while handling all the input/output on a
 * background thread, including the initial file name assignment and any
 * subsequent renaming of the target file.
 *
 * This interface is designed for file downloads.  Generally, they start in the
 * temporary directory, while the user is selecting the final name.  Then, they
 * are moved to the chosen target directory with a ".part" extension appended to
 * the file name.  Finally, they are renamed when the download is completed.
 *
 * Components implementing both nsIBackgroundFileSaver and nsIStreamListener
 * allow data to be fed using an implementation of OnDataAvailable that never
 * blocks the calling thread.  They suspend the request that drives the stream
 * listener in case too much data is being fed, and resume it when the data has
 * been written.  Calling OnStopRequest does not necessarily close the target
 * file, and the Finish method must be called to complete the operation.
 *
 * Components implementing both nsIBackgroundFileSaver and nsIAsyncOutputStream
 * allow data to be fed directly to the non-blocking output stream, that however
 * may return NS_BASE_STREAM_WOULD_BLOCK in case too much data is being fed.
 * Closing the output stream does not necessarily close the target file, and the
 * Finish method must be called to complete the operation.
 *
 * @remarks Implementations may require the consumer to always call Finish.  If
 * the object reference is released without calling Finish, a memory
 * leak may occur, and the target file might be kept locked. All
 * public methods of the interface may only be called from the main
 * thread.
 */
declare interface nsIBackgroundFileSaverType extends nsISupportsType {
    /**
     * This observer receives notifications when the target file name changes and
     * when the operation completes, successfully or not.
     *
     * @remarks A strong reference to the observer is held.  Notification events
     * are dispatched to the thread that created the object that
     * implements nsIBackgroundFileSaver.
     */
    observer: nsIBackgroundFileSaverObserver;
    /**
     * The SHA-256 hash, in raw bytes, associated with the data that was saved.
     *
     * In case the enableAppend method has been called, the hash computation
     * includes the contents of the existing file, if any.
     *
     * @throws NS_ERROR_NOT_AVAILABLE
     * In case the enableSha256 method has not been called, or before the
     * onSaveComplete method has been called to notify success.
     */
    readonly sha256Hash: ACString;
    /**
     * Instructs the component to compute the signatureInfo of the target file,
     * and make it available in the signatureInfo property.
     *
     * @remarks This must be set on the main thread before the first call to
     * setTarget.
     */
    enableSignatureInfo(): void;
    /**
     * Instructs the component to compute the SHA-256 hash of the target file, and
     * make it available in the sha256Hash property.
     *
     * @remarks This must be set on the main thread before the first call to
     * setTarget.
     */
    enableSha256(): void;
    /**
     * Instructs the component to append data to the initial target file, that
     * will be specified by the first call to the setTarget method, instead of
     * overwriting the file.
     *
     * If the initial target file does not exist, this method has no effect.
     *
     * @remarks This must be set on the main thread before the first call to
     * setTarget.
     */
    enableAppend(): void;
    /**
     * Sets the name of the output file to be written.  The target can be changed
     * after data has already been fed, in which case the existing file will be
     * moved to the new destination.
     *
     * In case the specified file already exists, and this method is called for
     * the first time, the file may be either overwritten or appended to, based on
     * whether the enableAppend method was called.  Subsequent calls always
     * overwrite the specified target file with the previously saved data.
     *
     * No file will be written until this function is called at least once.  It's
     * recommended not to feed any data until the output file is set.
     *
     * If an input/output error occurs with the specified file, the save operation
     * fails.  Failure is notified asynchronously through the observer.
     *
     * @param aTarget
     * New output file to be written.
     * @param aKeepPartial
     * Indicates whether aFile should be kept as partially completed,
     * rather than deleted, if the operation fails or is canceled.  This is
     * generally set for downloads that use temporary ".part" files.
     */
    setTarget(aTarget: nsIFileType, aKeepPartial: bool): void;
    /**
     * Terminates access to the output file, then notifies the observer with the
     * specified status code.  A failure code will force the operation to be
     * canceled, in which case the output file will be deleted if requested.
     *
     * This forces the involved streams to be closed, thus no more data should be
     * fed to the component after this method has been called.
     *
     * This is the last method that should be called on this object, and the
     * target file name cannot be changed anymore after this method has been
     * called.  Conversely, before calling this method, the file can still be
     * renamed even if all the data has been fed.
     *
     * @param aStatus
     * Result code that determines whether the operation should succeed or
     * be canceled, and is notified to the observer.  If the operation
     * fails meanwhile for other reasons, or the observer has been already
     * notified of completion, this status code is ignored.
     */
    finish(aStatus: nsresult): void;
}

/**
 *
 */
declare interface nsIBackgroundFileSaverObserverType extends nsISupportsType {
    /**
     * Called when the name of the output file has been determined.  This function
     * may be called more than once if the target file is renamed while saving.
     *
     * @param aSaver
     * Reference to the object that raised the notification.
     * @param aTarget
     * Name of the file that is being written.
     */
    onTargetChange(aSaver: nsIBackgroundFileSaverType, aTarget: nsIFileType): void;
    /**
     * Called when the operation completed, and the target file has been closed.
     * If the operation succeeded, the target file is ready to be used, otherwise
     * it might have been already deleted.
     *
     * @param aSaver
     * Reference to the object that raised the notification.
     * @param aStatus
     * Result code that determines whether the operation succeeded or
     * failed, as well as the failure reason.
     */
    onSaveComplete(aSaver: nsIBackgroundFileSaverType, aStatus: nsresult): void;
}

/**
 * Determine if this instance is running background task mode and
 * what, if any, task is active.
 */
declare interface nsIBackgroundTasksType extends nsISupportsType {
    /**
     * True if and only if this invocation is running in background task mode.
     */
    readonly isBackgroundTaskMode: boolean;
    /**
     * A non-empty task name if this invocation is running in background
     * task mode, or `null` if this invocation is not running in
     * background task mode.
     */
    backgroundTaskName(): AString;
    /**
     * Should only be used for testing.
     * Set the background task name.
     */
    overrideBackgroundTaskNameForTesting(taskName: AString): void;
}

/**
 * Import and run named backgroundtask implementations.
 */
declare interface nsIBackgroundTasksManagerType extends nsICommandLineHandlerType {
    /**
     * Run the named background task.
     *
     * @param aTaskName the name of the task to be run.
     * @param aCommandLine the command line of this invocation.
     *
     * This returns a promise which resolves to an integer exit code, 0 when the
     * task succeeded, >0 otherwise.  The task manager will quit after this
     * promise resolves.
     */
    runBackgroundTaskNamed(aTaskName: AString, aCommandLine: nsICommandLineType): void;
}

/**
 *
 */
declare interface nsIBackgroundTasksRunnerType extends nsISupportsType {
    /**
     * Runs a background process in an independent detached process. Any process
     * opened by this function can outlive the main process.
     *
     * This function is thread-safe.
     *
     * XXX: The use of base::LaunchApp can make a zombie process on Unix.
     * See bug 1802559.
     *
     * @param aTaskName The name of the background task.
     * (BackgroundTask_{name}.sys.mjs)
     * @param aArgs The arguments that will be passed to the task process. Any
     * needed escape will happen automatically.
     */
    runInDetachedProcess(aTaskName: ACString, aCommandLine: invalid): void;
    /**
     * Runs removeDirectory background task.
     * `toolkit.background_tasks.remove_directory.testing.sleep_ms` can be set to
     * make it wait for the given milliseconds for testing purpose.
     *
     * See BackgroundTask_removeDirectory.sys.mjs for details about the arguments.
     */
    removeDirectoryInDetachedProcess(aParentDirPath: ACString, aChildDirName: ACString, aSecondsToWait: ACString, aOtherFoldersSuffix: ACString, aMetricsId: ACString): void;
}

/**
 * The nsIBaseWindow describes a generic window and basic operations that
 * can be performed on it.  This is not to be a complete windowing interface
 * but rather a common set that nearly all windowed objects support.
 */
declare interface nsIBaseWindowType extends nsISupportsType {
    /**
     * Tell the window that it should destroy itself.  This call should not be
     * necessary as it will happen implictly when final release occurs on the
     * object.  If for some reaons you want the window destroyed prior to release
     * due to cycle or ordering issues, then this call provides that ability.
     *
     * @return  NS_OK - Everything destroyed properly.
     * NS_ERROR_UNEXPECTED - This call was unexpected at this time.
     * Perhaps create() has not been called yet.
     */
    destroy(): void;
    /**
     * Sets the current x and y coordinates of the control.  This is relative to
     * the parent window.
     */
    setPosition(x: long, y: long): void;
    /**
     * Ditto, with arguments in global desktop pixels rather than (potentially
     * ambiguous) device pixels
     */
    setPositionDesktopPix(x: long, y: long): void;
    /**
     * Gets the current x and y coordinates of the control.  This is relative to the
     * parent window.
     */
    getPosition(x: long, y: long): void;
    /**
     * Sets the width and height of the control.
     */
    setSize(cx: long, cy: long, fRepaint: boolean): void;
    /**
     * Gets the width and height of the control.
     */
    getSize(cx: long, cy: long): void;
    /**
     * Convenience function combining the SetPosition and SetSize into one call.
     * Also is more efficient than calling both.
     */
    setPositionAndSize(x: long, y: long, cx: long, cy: long, flags: unsigned_long): void;
    /**
     * Convenience function combining the GetPosition and GetSize into one call.
     * Also is more efficient than calling both.
     */
    getPositionAndSize(x: long, y: long, cx: long, cy: long): void;
    /**
     * Allows to request the change of individual dimensions without specifying
     * the other components.
     *
     * @param aRequest - The requested change. A request to change only the width
     * may look like:
     * {DimensionKind::Outer, Nothing(), Nothing(), Some(20), Nothing()}
     *
     * Note: Inner position is not supported.
     *
     * @see DimensionRequest
     */
    setDimensions(aRequest: DimensionRequest): void;
    /**
     * Gets the dimensions of the window. The caller may pass nullptr for any
     * value it is uninterested in receiving.
     *
     * @param aDimensionKind  Specifies whether the dimensions are in reference
     * to the inner or outer dimensions.
     * @param aX              Left hand corner of the outer area; or nullptr.
     * @param aY              Top corner of the outer area; or nullptr.
     * @param aCX             Width of the inner or outer area; or nullptr.
     * @param aCY             Height of the inner or outer area; or nullptr.
     *
     * Note: Inner position is not supported.
     *
     * @see DimensionRequest
     */
    getDimensions(aDimensionKind: DimensionKind, aX: long, aY: long, aCX: long, aCY: long): void;
    /**
     * Tell the window to repaint itself
     * @param aForce - if true, repaint immediately
     * if false, the window may defer repainting as it sees fit.
     */
    repaint(force: boolean): void;
    /**
     * This is the parenting widget for the control.  This may be null if the
     * native window was handed in for the parent during initialization.
     * If this  is returned, it should refer to the same object as
     * parentNativeWindow.
     *
     * Setting this after Create() has been called may not be supported by some
     * implementations.
     *
     * On controls that don't support widgets, setting this will return a
     * NS_ERROR_NOT_IMPLEMENTED error.
     */
    parentWidget: nsIWidget;
    /**
     * This is the native window parent of the control.
     *
     * Setting this after Create() has been called may not be supported by some
     * implementations.
     *
     * On controls that don't support setting nativeWindow parents, setting this
     * will return a NS_ERROR_NOT_IMPLEMENTED error.
     */
    parentNativeWindow: nativeWindow;
    /**
     * This is the handle (HWND, GdkWindow*, ...) to the native window of the
     * control, exposed as an AString.
     *
     * @return AString in hex format with "0x" prepended, or empty string if
     * mainWidget undefined
     *
     * @throws NS_ERROR_NOT_IMPLEMENTED for non-XULWindows
     */
    readonly nativeHandle: AString;
    /**
     * Attribute controls the visibility of the object behind this interface.
     * Setting this attribute to false will hide the control.  Setting it to
     * true will show it.
     */
    visibility: boolean;
    /**
     * a disabled window should accept no user interaction; it's a dead window,
     * like the parent of a modal window.
     */
    enabled: boolean;
    /**
     * Allows you to find out what the widget is of a given object.  Depending
     * on the object, this may return the parent widget in which this object
     * lives if it has not had to create its own widget.
     */
    readonly mainWidget: nsIWidget;
    /**
     * The number of device pixels per CSS pixel used by this window's widget at the
     * default full zoom level.
     * This is the value returned by GetDefaultScale() of the underlying widget.
     * Note that this may change if the window is moved between screens with
     * differing resolutions.
     * NOTE: This is mostly an implementation detail of
     * UnscaledDevicePixelsPerCSSPixel, which is what you probably want to use.
     */
    readonly widgetCSSToDeviceScale: double;
    /**
     * The number of device pixels per display pixel on this window's current
     * screen. (The meaning of "display pixel" varies across OS environments;
     * it is the pixel units used by the desktop environment to manage screen
     * real estate and window positioning, which may correspond to (per-screen)
     * device pixels, or may be a virtual coordinate space that covers a multi-
     * monitor, mixed-dpi desktop space.)
     * This is the value returned by GetDesktopToDeviceScale() of the underlying
     * widget.
     * Note that this may change if the window is moved between screens with
     * differing resolutions.
     */
    readonly devicePixelsPerDesktopPixel: double;
    /**
     * Title of the window.
     */
    title: AString;
}

/**
 *
 */
declare interface nsIBidiKeyboardType extends nsISupportsType {
    /**
     * Inspects the installed keyboards and resets the bidi keyboard state
     */
    reset(): void;
    /**
     * Determines if the current keyboard language is right-to-left
     * @throws NS_ERROR_FAILURE if no right-to-left keyboards are installed
     */
    isLangRTL(): boolean;
    /**
     * Determines whether the system has at least one keyboard of each direction
     * installed.
     *
     * @throws NS_ERROR_NOT_IMPLEMENTED if the widget layer does not provide this
     * information.
     */
    readonly haveBidiKeyboards: boolean;
}

/**
 *
 */
declare interface nsIBinaryHttpRequestType extends nsISupportsType {
    /**
     *
     */
    readonly method: ACString;
    /**
     *
     */
    readonly scheme: ACString;
    /**
     *
     */
    readonly authority: ACString;
    /**
     *
     */
    readonly path: ACString;
}

/**
 *
 */
declare interface nsIBinaryHttpResponseType extends nsISupportsType {
    /**
     *
     */
    readonly status: uint16_t;
}

/**
 *
 */
declare interface nsIBinaryHttpType extends nsISupportsType {
    /**
     *
     */
    decodeRequest(request: invalid): nsIBinaryHttpRequest;
    /**
     *
     */
    decodeResponse(response: invalid): nsIBinaryHttpResponse;
}

/**
 * This interface allows consumption of primitive data types from a "binary
 * stream" containing untagged, big-endian binary data, i.e. as produced by an
 * implementation of nsIBinaryOutputStream.  This might be used, for example,
 * to implement network protocols or to read from architecture-neutral disk
 * files, i.e. ones that can be read and written by both big-endian and
 * little-endian platforms.
 *
 * @See nsIBinaryOutputStream
 */
declare interface nsIBinaryInputStreamType extends nsIInputStreamType {
    /**
     *
     */
    setInputStream(aInputStream: nsIInputStreamType): void;
    /**
     * Read 8-bits from the stream.
     *
     * @return that byte to be treated as a boolean.
     */
    readBoolean(): boolean;
    /**
     *
     */
    read8(): uint8_t;
    /**
     *
     */
    read16(): uint16_t;
    /**
     *
     */
    read32(): uint32_t;
    /**
     *
     */
    read64(): uint64_t;
    /**
     *
     */
    readFloat(): float;
    /**
     *
     */
    readDouble(): double;
    /**
     * Read an 8-bit pascal style string from the stream.
     * 32-bit length field, followed by length 8-bit chars.
     */
    readCString(): ACString;
    /**
     * Read an 16-bit pascal style string from the stream.
     * 32-bit length field, followed by length PRUnichars.
     */
    readString(): AString;
    /**
     * Read an opaque byte array from the stream.
     *
     * @param aLength the number of bytes that must be read.
     *
     * @throws NS_ERROR_FAILURE if it can't read aLength bytes
     */
    readBytes(aLength: uint32_t, aString: string): void;
    /**
     * Read opaque bytes from the stream, storing the results in an ArrayBuffer.
     *
     * @param aLength the number of bytes that must be read
     * @param aArrayBuffer the arraybuffer in which to store the results
     * Note: passing view.buffer, where view is an ArrayBufferView of an
     * ArrayBuffer, is not valid unless view.byteOffset == 0.
     *
     * @return The number of bytes actually read into aArrayBuffer.
     */
    readArrayBuffer(aLength: uint64_t, aArrayBuffer: jsval): uint64_t;
}

/**
 * This interface allows writing of primitive data types (integers,
 * floating-point values, booleans, etc.) to a stream in a binary, untagged,
 * fixed-endianness format.  This might be used, for example, to implement
 * network protocols or to produce architecture-neutral binary disk files,
 * i.e. ones that can be read and written by both big-endian and little-endian
 * platforms.  Output is written in big-endian order (high-order byte first),
 * as this is traditional network order.
 *
 * @See nsIBinaryInputStream
 */
declare interface nsIBinaryOutputStreamType extends nsIOutputStreamType {
    /**
     *
     */
    setOutputStream(aOutputStream: nsIOutputStreamType): void;
    /**
     * Write a boolean as an 8-bit char to the stream.
     */
    writeBoolean(aBoolean: boolean): void;
    /**
     *
     */
    write8(aByte: uint8_t): void;
    /**
     *
     */
    write16(a16: uint16_t): void;
    /**
     *
     */
    write32(a32: uint32_t): void;
    /**
     *
     */
    write64(a64: uint64_t): void;
    /**
     *
     */
    writeFloat(aFloat: float): void;
    /**
     *
     */
    writeDouble(aDouble: double): void;
    /**
     * Write an 8-bit pascal style string to the stream.
     * 32-bit length field, followed by length 8-bit chars.
     */
    writeStringZ(aString: string): void;
    /**
     * Write a 16-bit pascal style string to the stream.
     * 32-bit length field, followed by length PRUnichars.
     */
    writeWStringZ(aString: wstring): void;
    /**
     * Write an 8-bit pascal style string (UTF8-encoded) to the stream.
     * 32-bit length field, followed by length 8-bit chars.
     */
    writeUtf8Z(aString: wstring): void;
    /**
     * Write an opaque byte array to the stream.
     */
    writeBytes(aString: string, aLength: uint32_t): void;
    /**
     * Write an opaque byte array to the stream.
     */
    writeByteArray(aBytes: invalid): void;
}

/**
 * An interface for interacting with Windows Background Intelligent Transfer
 * Service. This should only be used on Windows.
 *
 * It would be preferable for the functions in this interface to return
 * Promises, but this interface is implemented in Rust, which does not yet have
 * support for Promises. There is a JS wrapper around this class that should be
 * preferred over using this interface directly, located in Bits.sys.mjs.
 *
 * Methods of this class that take a nsIBitsNewRequestCallback do not return or
 * throw errors. All errors will be reported through the callback. The only
 * things that should cause methods to directly throw errors are null arguments.
 */
declare interface nsIBitsType extends nsISupportsType {
    /**
     * Indicates whether init() has been called.
     */
    readonly initialized: boolean;
    /**
     * Initializes the BITS interface. Unlike other functions here, this happens
     * synchronously.
     * init() should only be called only once.
     *
     * @param jobName
     * The name of the BITS job. This is used both to set the name during
     * job creation and to verify that a job is ours.
     * @param savePathPrefix
     * The directory that downloads will be saved to. Providing a safe
     * directory here ensures that the download path cannot be manipulated
     * to save files to a malicious location. Downloads are guaranteed to
     * be saved to this directory or a subdirectory.
     * @param monitorTimeoutMs
     * The amount of time to wait between download monitor notifications.
     * This should be larger than the largest monitorIntervalMs that will
     * be passed to startDownload(), monitorDownload(), or
     * changeMonitorInterval(). This value may not be 0.
     */
    init(jobName: AUTF8String, savePathPrefix: AUTF8String, monitorTimeoutMs: unsigned_long): void;
    /**
     * Downloads the specified URL to the specified location within the
     * savePathPrefix passed to init().
     *
     * @param downloadURL
     * The URL to be downloaded.
     * @param saveRelativePath
     * The location to download to. The path given should be a path
     * relative to the savePathPrefix passed to init(). If this attempts to
     * escape the directory specified by savePathPrefix, this call will
     * fail (ex: Don't pass "../filename").
     * @param proxy
     * Specifies what proxy to use when downloading. Valid values are
     * listed below.
     * @param noProgressTimeoutSecs
     * The number of seconds for the "no progress" timeout. After there has
     * been no download progress for this long, BITS will not retry the job
     * following a transient error, producing instead a permanent error.
     * @param monitorIntervalMs
     * The number of milliseconds between download status notifications.
     * @param observer
     * An observer to be notified of various events. OnStartRequest is
     * called once the BITS job has been created. OnStopRequest is called
     * when the file transfer has completed or when an error occurs. If
     * this object implements nsIProgressEventSink, then its OnProgress
     * method will be called as data is transferred.
     * IMPORTANT NOTE: When OnStopRequest is called, the download has
     * completed, but nsIBitsRequest::complete() still
     * needs to be called to save the file to the
     * filesystem.
     * @param context
     * User defined object forwarded to the observer's onProgress method.
     * This parameter, unlike others for this interface, can be passed a
     * null pointer.
     * @param callback
     * The callback used to relay the response from BITS.
     */
    startDownload(downloadURL: AUTF8String, saveRelativePath: AUTF8String, proxy: nsProxyUsage, noProgressTimeoutSecs: unsigned_long, monitorIntervalMs: unsigned_long, observer: nsIRequestObserverType, context: nsISupportsType, callback: nsIBitsNewRequestCallbackType): void;
    /**
     * Similar to startDownload, but connects to a BITS transfer that has already
     * been started.
     *
     * @param id
     * The GUID of the download to monitor.
     * @param monitorIntervalMs
     * The number of milliseconds between download status notifications.
     * @param observer
     * An observer to be notified of various events. OnStartRequest is
     * called once the BITS job has been created. OnStopRequest is called
     * when the file transfer has completed or when an error occurs. If
     * this object implements nsIProgressEventSink, then its OnProgress
     * method will be called as data is transferred.
     * IMPORTANT NOTE: When OnStopRequest is called, the download has
     * completed, but nsIBitsRequest::complete() still
     * needs to be called to save the file to the
     * filesystem.
     * @param context
     * User defined object forwarded to the observer's onProgress method.
     * This parameter, unlike others for this interface, can be passed a
     * null pointer.
     * @param callback
     * The callback used to relay the response from BITS.
     */
    monitorDownload(id: AUTF8String, monitorIntervalMs: unsigned_long, observer: nsIRequestObserverType, context: nsISupportsType, callback: nsIBitsNewRequestCallbackType): void;
}

/**
 * This callback interface is for use by the nsIBits interface for returning
 * results asynchronously to the caller.
 */
declare interface nsIBitsNewRequestCallbackType extends nsISupportsType {
    /**
     *
     */
    success(request: nsIBitsRequestType): void;
    /**
     *
     */
    failure(errorType: nsBitsErrorType, errorAction: nsBitsErrorAction, errorStage: nsBitsErrorStage): void;
    /**
     *
     */
    failureNsresult(errorType: nsBitsErrorType, errorAction: nsBitsErrorAction, errorStage: nsBitsErrorStage, errorCode: nsresult): void;
    /**
     *
     */
    failureHresult(errorType: nsBitsErrorType, errorAction: nsBitsErrorAction, errorStage: nsBitsErrorStage, errorCode: long): void;
    /**
     *
     */
    failureString(errorType: nsBitsErrorType, errorAction: nsBitsErrorAction, errorStage: nsBitsErrorStage, errorMessage: AUTF8String): void;
}

/**
 * An interface for managing a running BITS download.
 *
 * It would be preferable for the functions in this interface to return
 * Promises, but this interface is implemented in Rust, which does not yet have
 * support for Promises. There is a JS wrapper around this class that should be
 * preferred over using this interface directly, located in Bits.sys.mjs.
 *
 * Methods of this class that take a nsIBitsCallback do not return or throw
 * errors. All errors will be reported through the callback. The only
 * things that should cause methods to directly throw errors are null arguments.
 *
 * Note: Although the nsIBits interface derives from nsIRequest, implementations
 * may not implement the loadGroup or loadFlags attributes.
 *
 * Note: Once the file transfer has stopped (due to completion or error),
 * calling any method besides complete() or cancel() will result in an
 * error with type nsIBits::ERROR_TYPE_TRANSFER_ALREADY_COMPLETE.
 * Calling complete() or cancel() again after either has already been
 * called will also result in an ERROR_TYPE_TRANSFER_ALREADY_COMPLETE
 * error.
 * Attributes and nsIRequest::isPending() can still be accessed at any
 * time.
 */
declare interface nsIBitsRequestType extends nsIRequestType {
    /**
     * The BITS id of the download. This will be a string representing a UUID.
     */
    readonly bitsId: AUTF8String;
    /**
     * The transfer result of the download, meant to be accessed after the
     * transfer has stopped (i.e. after the observer's onStopRequest method has
     * been called). Will be nsIBits::ERROR_TYPE_SUCCESS if the transfer is
     * successful (and before transfer completion). If the transfer failed, this
     * will be a different nsBitsErrorType value indicating the cause of the
     * failure.
     */
    readonly transferError: nsBitsErrorType;
    /**
     * Requests a change to the frequency that Firefox is receiving download
     * status notifications.
     *
     * @param monitorIntervalMs
     * The new number of milliseconds between download status
     * notifications.
     * @param callback
     * The callback function used to relay success or failure.
     */
    changeMonitorInterval(monitorIntervalMs: unsigned_long, callback: nsIBitsCallbackType): void;
    /**
     * Cancels the download. This function is named this way to avoid conflict
     * with nsIRequest::cancel.
     *
     * @param status
     * The reason for cancelling the request. This must be a failure code
     * rather than a success code like NS_OK.
     * @param callback
     * The callback function used to relay success or failure.
     */
    cancelAsync(status: nsresult, callback: nsIBitsCallbackType): void;
    /**
     * Sets the priority of the BITS job to high (i.e. foreground download).
     *
     * @param callback
     * The callback function used to relay success or failure.
     */
    setPriorityHigh(callback: nsIBitsCallbackType): void;
    /**
     * Sets the priority of the BITS job to low (i.e. background download).
     *
     * @param callback
     * The callback function used to relay success or failure.
     */
    setPriorityLow(callback: nsIBitsCallbackType): void;
    /**
     * Sets the BITS "no progress" timeout for the job.
     *
     * @param timeoutSecs
     * The new number of seconds for the timeout. After there has been
     * no progress for this long, BITS will not retry the job following
     * a transient error, producing instead a permanent error.
     * @param callback
     * The callback function used to relay success or failure.
     */
    setNoProgressTimeout(timeoutSecs: unsigned_long, callback: nsIBitsCallbackType): void;
    /**
     * Completes the download, moving it out of the BITS system and onto the
     * disk location specified when startDownload was called.
     *
     * @param callback
     * The callback function used to relay success or failure.
     */
    complete(callback: nsIBitsCallbackType): void;
    /**
     * Suspends the download, preventing more data from being transferred until
     * the download is resumed. This function is named this way to avoid conflict
     * with nsIRequest::suspend.
     *
     * @param callback
     * The callback function used to relay success or failure.
     */
    suspendAsync(callback: nsIBitsCallbackType): void;
    /**
     * Resumes a previously suspended download. This function is named this way
     * to avoid conflict with nsIRequest::resume.
     *
     * @param callback
     * The callback function used to relay success or failure.
     */
    resumeAsync(callback: nsIBitsCallbackType): void;
}

/**
 * This callback interface is for use by the nsIBitsRequest interface for
 * returning results asynchronously to the caller.
 */
declare interface nsIBitsCallbackType extends nsISupportsType {
    /**
     *
     */
    success(): void;
    /**
     *
     */
    failure(errorType: nsBitsErrorType, errorAction: nsBitsErrorAction, errorStage: nsBitsErrorStage): void;
    /**
     *
     */
    failureNsresult(errorType: nsBitsErrorType, errorAction: nsBitsErrorAction, errorStage: nsBitsErrorStage, errorCode: nsresult): void;
    /**
     *
     */
    failureHresult(errorType: nsBitsErrorType, errorAction: nsBitsErrorAction, errorStage: nsBitsErrorStage, errorCode: long): void;
    /**
     *
     */
    failureString(errorType: nsBitsErrorType, errorAction: nsBitsErrorAction, errorStage: nsBitsErrorStage, errorMessage: AUTF8String): void;
}

/**
 *
 */
declare interface nsIBlocklistServiceType extends nsISupportsType {
    /**
     *
     */
    readonly isLoaded: boolean;
}

/**
 *
 */
declare interface nsIBounceTrackingProtectionType extends nsISupportsType {
    /**
     *
     */
    reset(): void;
    /**
     *
     */
    testRunPurgeBounceTrackers(): Promise;
    /**
     *
     */
    testAddBounceTrackerCandidate(aHost: ACString, aBounceTime: PRTime): void;
    /**
     *
     */
    testAddUserActivation(aHost: ACString, aActivationTime: PRTime): void;
}

/**
 *
 */
declare interface nsIBrowserType extends nsISupportsType {
    /**
     * Called by the child to inform the parent that links are dropped into
     * content area.
     *
     * @param links a flat array of url, name, and type for each link
     * @param triggeringPrincipal a principal that initiated loading
     * of the dropped links
     */
    dropLinks(links: invalid, triggeringPrincipal: nsIPrincipalType): void;
    /**
     * Swapping of frameloaders are usually initiated from a frameloader owner
     * or other components operating on frameloader owners. This is done by calling
     * swapFrameLoaders at MozFrameLoaderOwner webidl interface.
     *
     * This function aimed to provide the other way around -
     * if the swapping is initiated from frameloader itself or other platform level
     * components, it uses this interface to delegate the swapping request to
     * frameloader owners and ask them to re-initiate frameloader swapping, so that
     * frameloader owners such as <xul:browser> can setup their properties and /
     * or listeners properly on swapping.
     */
    swapBrowsers(aOtherBrowser: nsIBrowserType): void;
    /**
     * Close the browser (usually means to remove a tab).
     */
    closeBrowser(): void;
    /**
     * A browser can change from remote to non-remote and vice versa.
     * For example, when navigating from an in-process chrome page to
     * a web page, this value would change from false to true.
     */
    readonly isRemoteBrowser: boolean;
    /**
     * The browser's permanent key. This was added temporarily for Session Store,
     * and will be removed in bug 1716788.
     */
    readonly permanentKey: jsval;
    /**
     *
     */
    readonly contentPrincipal: nsIPrincipal;
    /**
     *
     */
    readonly contentPartitionedPrincipal: nsIPrincipal;
    /**
     *
     */
    readonly csp: nsIContentSecurityPolicy;
    /**
     *
     */
    readonly referrerInfo: nsIReferrerInfo;
    /**
     * Whether or not the browser is in the process of an nsIWebNavigation
     * navigation method.
     */
    isNavigating: boolean;
    /**
     * Whether or not the character encoding menu may be enabled.
     */
    mayEnableCharacterEncodingMenu: boolean;
    /**
     * Called by Gecko to update the browser when its state changes.
     *
     * @param aCharset the new character set of the document
     * @param aDocumentURI the URI of the current document
     * @param aContentType the content type of the document
     */
    updateForStateChange(aCharset: AString, aDocumentURI: nsIURIType, aContentType: AString): void;
    /**
     * Called by Gecko to update the nsIWebNavigation when a location change occurs.
     *
     * @param aCanGoBack whether or not the nsIWebNavigation can go backwards in
     * history
     * @param aCanGoForward whether or not the nsIWebNavigation can go
     * forward in history
     */
    updateWebNavigationForLocationChange(aCanGoBack: boolean, aCanGoForward: boolean): void;
    /**
     * Called by Gecko to update the browser when a location change occurs.
     *
     * @param aLocation the new location
     * @param aCharset the character set of the document
     * @param aMayEnableCharacterEncodingMenu whether or not the content encoding
     * menu may be enabled
     * @param aDocumentURI the URI of the new document
     * @param aTitle the title of the new doucment
     * @param aContentPrincipal the security principal of the new document
     * @param aContentPartitionedPrincipal the security principal for the new
     * document's storage
     * @param aCSP the content security policy of the new document
     * @param aReferrerInfo the referrer info of the new document
     * @param aIsSynthetic whether or not the document is synthetic
     * @param aHasRequestContextID whether or not the the request context has a
     * value (true) or null should be used (false)
     * @param aRequestContextID the request context ID
     * @param aContentType the content type of the document
     */
    updateForLocationChange(aLocation: nsIURIType, aCharset: AString, aMayEnableCharacterEncodingMenu: boolean, aDocumentURI: nsIURIType, aTitle: AString, aContentPrincipal: nsIPrincipalType, aContentPartitionedPrincipal: nsIPrincipalType, aCSP: nsIContentSecurityPolicyType, aReferrerInfo: nsIReferrerInfoType, aIsSynthetic: boolean, aHasRequestContextID: boolean, aRequestContextID: uint64_t, aContentType: AString): void;
    /**
     * Called to perform any async tasks which must be completed before changing
     * remoteness. Gecko will wait for the returned promise to resolve before
     * performing the process switch.
     */
    prepareToChangeRemoteness(): Promise;
    /**
     * Called immediately before changing remoteness
     */
    beforeChangeRemoteness(): void;
    /**
     * Called immediately after changing remoteness.
     *
     * If this method returns `true`, Gecko will assume frontend handled resuming
     * the load, and will not attempt to resume the load itself.
     */
    finishChangeRemoteness(aPendingSwitchId: uint64_t): bool;
}

/**
 *
 */
declare interface nsIBrowserChildType extends nsISupportsType {
    /**
     *
     */
    readonly messageManager: ContentFrameMessageManager;
    /**
     *
     */
    sendRequestFocus(canFocus: boolean, aCallerType: CallerType): void;
    /**
     *
     */
    remoteDropLinks(links: invalid): void;
    /**
     * Resolved after content has received a PBrowser::ChildToParentMatrix.
     */
    contentTransformsReceived(): Promise;
    /**
     *
     */
    readonly tabId: uint64_t;
    /**
     * Send a message from the BrowserChild to the BrowserParent that a
     * nsIWebNavigation navigation finished in the child.
     */
    notifyNavigationFinished(): void;
    /**
     * Id of the chrome window the tab is within.
     */
    readonly chromeOuterWindowID: uint64_t;
}

/**
 * This interface is used to accompany the nsIController for a
 * <browser> element. It is used to update the commands in the
 * parent process when the set of child command have changed.
 */
declare interface nsIBrowserControllerType extends nsISupportsType {
    /**
     *
     */
    enableDisableCommands(action: AString, enabledCommands: invalid, disabledCommands: invalid): void;
}

/**
 *
 */
declare interface nsIOpenURIInFrameParamsType extends nsISupportsType {
    /**
     *
     */
    readonly openWindowInfo: nsIOpenWindowInfo;
    /**
     *
     */
    referrerInfo: nsIReferrerInfo;
    /**
     *
     */
    readonly isPrivate: boolean;
    /**
     *
     */
    triggeringPrincipal: nsIPrincipal;
    /**
     *
     */
    csp: nsIContentSecurityPolicy;
    /**
     *
     */
    readonly openerBrowser: Element;
    /**
     *
     */
    readonly openerOriginAttributes: jsval;
}

/**
 * The C++ source has access to the browser script source through
 * nsIBrowserDOMWindow. It is intended to be attached to the chrome DOMWindow
 * of a toplevel browser window (a XUL window). A DOMWindow that does not
 * happen to be a browser chrome window will simply have no access to any such
 * interface.
 */
declare interface nsIBrowserDOMWindowType extends nsISupportsType {
    /**
     * Create the content window for the given URI.
     * @param aURI the URI to be opened in the window (can be null).
     * @param aWhere see possible values described above.
     * @param aOpenWindowInfo info about the creation (can be null).
     * @param aFlags flags which control the behavior of the load. The
     * OPEN_EXTERNAL/OPEN_NEW flag is only used when
     * aWhere == OPEN_DEFAULTWINDOW.
     * @param aTriggeringPrincipal the principal that would trigger the potential
     * load of aURI.
     * @param aCsp the CSP to use (if any) for the new window.
     * @return the window into which the URI would have been opened.
     */
    createContentWindow(aURI: nsIURIType, aOpenWindowInfo: nsIOpenWindowInfoType, aWhere: short, aFlags: long, aTriggeringPrincipal: nsIPrincipalType, aCsp: nsIContentSecurityPolicyType): BrowsingContext;
    /**
     * As above, but return the nsFrameLoaderOwner for the new window. Value is
     * returned as Element, QI'd back to nsFrameLoaderOwner as needed.
     *
     * Additional Parameters:
     * @param aName The name to give the window opened in the new tab.
     * @return The frame element for the newly opened window.
     */
    createContentWindowInFrame(aURI: nsIURIType, params: nsIOpenURIInFrameParamsType, aWhere: short, aFlags: long, aName: AString): Element;
    /**
     * Load a URI.
     * @param aURI the URI to open. null is not allowed. To create the window
     * without loading the URI, use createContentWindow instead.
     * @param aWhere see possible values described above.
     * @param aOpenWindowInfo info about the open (can be null).
     * @param aFlags flags which control the behavior of the load. The
     * OPEN_EXTERNAL/OPEN_NEW flag is only used when
     * aWhere == OPEN_DEFAULTWINDOW.
     * @param aTriggeringPrincipal the principal that triggered the load of aURI.
     * @param aCsp the CSP to be applied to the new load.
     * @return the window into which the URI was opened.
     */
    openURI(aURI: nsIURIType, aOpenWindowInfo: nsIOpenWindowInfoType, aWhere: short, aFlags: long, aTriggeringPrincipal: nsIPrincipalType, aCsp: nsIContentSecurityPolicyType): BrowsingContext;
    /**
     * As above, but return the nsFrameLoaderOwner for the new window. Value is
     * returned as Element, QI'd back to nsFrameLoaderOwner as needed.
     *
     * Additional Parameters:
     * @param aName The name to give the window opened in the new tab.
     * @return The frame element for the newly opened window.
     * // XXXbz is this the right API?
     * // See bug 537428
     */
    openURIInFrame(aURI: nsIURIType, params: nsIOpenURIInFrameParamsType, aWhere: short, aFlags: long, aName: AString): Element;
    /**
     * This function is responsible for calling
     * nsIContentViewer::PermitUnload on each frame in the window. It
     * returns true if closing the window is allowed. See canClose() in
     * BrowserUtils.sys.mjs for a simple implementation of this method.
     */
    canClose(): boolean;
    /**
     * The number browser tabs in the window. This number currently includes
     * lazy tabs, though for most uses it probably should not.
     */
    readonly tabCount: unsigned_long;
}

/**
 * Interface to the BrowserElementParent implementation. All methods
 * but setFrameLoader throw when the remote process is dead.
 */
declare interface nsIBrowserElementAPIType extends nsISupportsType {
    /**
     * Notify frame scripts that support the API to destroy.
     */
    destroyFrameScripts(): void;
    /**
     *
     */
    setFrameLoader(frameLoader: FrameLoader): void;
    /**
     *
     */
    sendMouseEvent(type: AString, x: uint32_t, y: uint32_t, button: uint32_t, clickCount: uint32_t, mifiers: uint32_t): void;
    /**
     *
     */
    goBack(): void;
    /**
     *
     */
    goForward(): void;
    /**
     *
     */
    reload(hardReload: boolean): void;
    /**
     *
     */
    stop(): void;
    /**
     *
     */
    getCanGoBack(): Promise;
    /**
     *
     */
    getCanGoForward(): Promise;
}

/**
 *
 */
declare interface nsIBrowserHandlerType extends nsISupportsType {
    /**
     *
     */
    startPage: AUTF8String;
    /**
     *
     */
    defaultArgs: AUTF8String;
    /**
     *
     */
    kiosk: boolean;
    /**
     *
     */
    majorUpgrade: boolean;
    /**
     *
     */
    firstRunProfile: boolean;
    /**
     * Extract the width and height specified on the command line, if present.
     * @return A feature string with a prepended comma, e.g. ",width=500,height=400"
     */
    getFeatures(aCmdLine: nsICommandLineType): AUTF8String;
}

/**
 *
 */
declare interface nsIBrowserUsageType extends nsISupportsType {
    /**
     * Returns the number of unique domains (eTLD+1) visited in the past
     * 24 hours by the user.
     */
    getUniqueDomainsVisitedInPast24Hours(): uint32_t;
}

/**
 *
 */
declare interface nsIVisibleTabType extends nsISupportsType {
    /**
     *
     */
    contentTitle: AString;
    /**
     *
     */
    browserId: int64_t;
}

/**
 *
 */
declare interface nsIBrowserWindowTrackerType extends nsISupportsType {
    /**
     * Return browser having given browser id.
     */
    getBrowserById(aBrowserId: uint64_t): nsISupports;
}

/**
 * An input stream that reads ahead and keeps a buffer coming from another input
 * stream so that fewer accesses to the underlying stream are necessary.
 */
declare interface nsIBufferedInputStreamType extends nsIInputStreamType {
    /**
     * @param fillFromStream - add buffering to this stream
     * @param bufferSize     - specifies the maximum buffer size
     */
    init(fillFromStream: nsIInputStreamType, bufferSize: unsigned_long): void;
    /**
     * Get the wrapped data stream
     */
    readonly data: nsIInputStream;
}

/**
 * An output stream that stores up data to write out to another output stream
 * and does the entire write only when the buffer is full, so that fewer writes
 * to the underlying output stream are necessary.
 */
declare interface nsIBufferedOutputStreamType extends nsIOutputStreamType {
    /**
     * @param sinkToStream - add buffering to this stream
     * @param bufferSize   - specifies the maximum buffer size
     */
    init(sinkToStream: nsIOutputStreamType, bufferSize: unsigned_long): void;
    /**
     * Get the wrapped data stream
     */
    readonly data: nsIOutputStream;
}

/**
 *
 */
declare interface nsIByteRangeRequestType extends nsISupportsType {
    /**
     * Returns true IFF this request is a byte range request, otherwise it
     * returns false (This is effectively the same as checking to see if
     * |startRequest| is zero and |endRange| is the content length.)
     */
    readonly isByteRangeRequest: boolean;
    /**
     * Absolute start position in remote file for this request.
     */
    readonly startRange: long_long;
    /**
     * Absolute end postion in remote file for this request
     */
    readonly endRange: long_long;
}

/**
 *
 */
declare interface nsICacheEntryType extends nsISupportsType {
    /**
     * Get the key identifying the cache entry.
     */
    readonly key: ACString;
    /**
     * The unique ID for every nsICacheEntry instance, which can be used to check
     * whether two pieces of information are from the same nsICacheEntry instance.
     */
    readonly cacheEntryId: uint64_t;
    /**
     * Whether the entry is memory/only or persisted to disk.
     * Note: private browsing entries are reported as persistent for consistency
     * while are not actually persisted to disk.
     */
    readonly persistent: boolean;
    /**
     * Get the number of times the cache entry has been opened.
     */
    readonly fetchCount: uint32_t;
    /**
     * Get the last time the cache entry was opened (in seconds since the Epoch).
     */
    readonly lastFetched: uint32_t;
    /**
     * Get the last time the cache entry was modified (in seconds since the Epoch).
     */
    readonly lastModified: uint32_t;
    /**
     * Get the expiration time of the cache entry (in seconds since the Epoch).
     */
    readonly expirationTime: uint32_t;
    /**
     * Set the time at which the cache entry should be considered invalid (in
     * seconds since the Epoch).
     */
    setExpirationTime(expirationTime: uint32_t): void;
    /**
     * Get the last network response times for onStartReqeust/onStopRequest (in ms).
     * @throws
     * - NS_ERROR_NOT_AVAILABLE if onStartTime/onStopTime does not exist.
     */
    readonly onStartTime: uint64_t;
    /**
     *
     */
    readonly onStopTime: uint64_t;
    /**
     * Set the network response times for onStartReqeust/onStopRequest (in ms).
     */
    setNetworkTimes(onStartTime: uint64_t, onStopTime: uint64_t): void;
    /**
     * Set content type. Available types are defined at the begining of this file.
     * The content type is used internally for cache partitioning and telemetry
     * purposes so there is no getter.
     */
    setContentType(contentType: uint8_t): void;
    /**
     * This method is intended to override the per-spec cache validation
     * decisions for a duration specified in seconds. The current state can
     * be examined with isForcedValid (see below). This value is not persisted,
     * so it will not survive session restart. Cache entries that are forced valid
     * will not be evicted from the cache for the duration of forced validity.
     * This means that there is a potential problem if the number of forced valid
     * entries grows to take up more space than the cache size allows.
     *
     * NOTE: entries that have been forced valid will STILL be ignored by HTTP
     * channels if they have expired AND the resource in question requires
     * validation after expiring. This is to avoid using known-stale content.
     *
     * @param aSecondsToTheFuture
     * the number of seconds the default cache validation behavior will be
     * overridden before it returns to normal
     */
    forceValidFor(aSecondsToTheFuture: unsigned_long): void;
    /**
     * The state variable for whether this entry is currently forced valid.
     * Defaults to false for normal cache validation behavior, and will return
     * true if the number of seconds set by forceValidFor() has yet to be reached.
     */
    readonly isForcedValid: boolean;
    /**
     * This method gets called to mark the actual use of the forced-valid entry.
     * This is necessary for telemetry, so when the entry eventually gets
     * evicted we can report whether it was ever used or not.
     * If the entry was not forced-valid, then this operation has no effect.
     */
    markForcedValidUse(): void;
    /**
     * Open blocking input stream to cache data.  Use the stream transport
     * service to asynchronously read this stream on a background thread.
     * The returned stream MAY implement nsISeekableStream.
     *
     * @param offset
     * read starting from this offset into the cached data.  an offset
     * beyond the end of the stream has undefined consequences.
     *
     * @return non-blocking, buffered input stream.
     */
    openInputStream(offset: long_long): nsIInputStream;
    /**
     * Open non-blocking output stream to cache data.  The returned stream
     * MAY implement nsISeekableStream.
     *
     * If opening an output stream to existing cached data, the data will be
     * truncated to the specified offset.
     *
     * @param offset
     * write starting from this offset into the cached data.  an offset
     * beyond the end of the stream has undefined consequences.
     * @param predictedSize
     * Predicted size of the data that will be written. It's used to decide
     * whether the resulting entry would exceed size limit, in which case
     * an error is thrown. If the size isn't known in advance, -1 should be
     * passed.
     *
     * @return blocking, buffered output stream.
     */
    openOutputStream(offset: long_long, predictedSize: long_long): nsIOutputStream;
    /**
     * Get/set security info on the cache entry for this descriptor.
     */
    securityInfo: nsITransportSecurityInfo;
    /**
     * Get the size of the cache entry data, as stored. This may differ
     * from the entry's dataSize, if the entry is compressed.
     */
    readonly storageDataSize: unsigned_long;
    /**
     * Asynchronously doom an entry. Listener will be notified about the status
     * of the operation. Null may be passed if caller doesn't care about the
     * result.
     */
    asyncDoom(listener: nsICacheEntryDoomCallbackType): void;
    /**
     * Methods for accessing meta data.  Meta data is a table of key/value
     * string pairs.  The strings do not have to conform to any particular
     * charset, but they must be null terminated.
     */
    getMetaDataElement(key: string): string;
    /**
     *
     */
    setMetaDataElement(key: string, value: string): void;
    /**
     * Obtain the list of metadata keys this entry keeps.
     *
     * NOTE: The callback is invoked under the CacheFile's lock.  It means
     * there should not be made any calls to the entry from the visitor and
     * if the values need to be processed somehow, it's better to cache them
     * and process outside the callback.
     */
    visitMetaData(visitor: nsICacheEntryMetaDataVisitorType): void;
    /**
     * Claims that all metadata on this entry are up-to-date and this entry
     * now can be delivered to other waiting consumers.
     *
     * We need such method since metadata must be delivered synchronously.
     */
    metaDataReady(): void;
    /**
     * Called by consumer upon 304/206 response from the server.  This marks
     * the entry content as positively revalidated.
     * Consumer uses this method after the consumer has returned ENTRY_NEEDS_REVALIDATION
     * result from onCacheEntryCheck and after successfull revalidation with the server.
     */
    setValid(): void;
    /**
     * Explicitly tell the cache backend this consumer is no longer going to modify
     * this cache entry data or metadata.  In case the consumer was responsible to
     * either of writing the cache entry or revalidating it, calling this method
     * reverts the state to initial (as never written) or as not-validated and
     * immediately notifies the next consumer in line waiting for this entry.
     * This is the way to prevent deadlocks when someone else than the responsible
     * channel references the cache entry being in a non-written or revalidating
     * state.
     */
    dismiss(): void;
    /**
     * Returns the size in kilobytes used to store the cache entry on disk.
     */
    readonly diskStorageSizeInKB: uint32_t;
    /**
     * Doom this entry and open a new, empty, entry for write.  Consumer has
     * to exchange the entry this method is called on for the newly created.
     * Used on 200 responses to conditional requests.
     *
     * @param aMemoryOnly
     * - whether the entry is to be created as memory/only regardless how
     * the entry being recreated persistence is set
     * @returns
     * - an entry that can be used to write to
     * @throws
     * - NS_ERROR_NOT_AVAILABLE when the entry cannot be from some reason
     * recreated for write
     */
    recreate(aMemoryOnly: boolean): nsICacheEntry;
    /**
     * Returns the length of data this entry holds.
     * @throws
     * NS_ERROR_IN_PROGRESS when the write is still in progress.
     */
    readonly dataSize: long_long;
    /**
     * Returns the length of data this entry holds.
     * @throws
     * - NS_ERROR_IN_PROGRESS when a write is still in progress (either real
     * content or alt data).
     * - NS_ERROR_NOT_AVAILABLE if alt data does not exist.
     */
    readonly altDataSize: long_long;
    /**
     * Returns the type of the saved alt data.
     * @throws
     * - NS_ERROR_NOT_AVAILABLE if alt data does not exist.
     */
    readonly altDataType: ACString;
    /**
     * Opens and returns an output stream that a consumer may use to save an
     * alternate representation of the data.
     *
     * @param type
     * type of the alternative data representation
     * @param predictedSize
     * Predicted size of the data that will be written. It's used to decide
     * whether the resulting entry would exceed size limit, in which case
     * an error is thrown. If the size isn't known in advance, -1 should be
     * passed.
     *
     * @throws
     * - NS_ERROR_NOT_AVAILABLE if the real data hasn't been written.
     * - NS_ERROR_IN_PROGRESS when the writing regular content or alt-data to
     * the cache entry is still in progress.
     *
     * If there is alt-data already saved, it will be overwritten.
     */
    openAlternativeOutputStream(type: ACString, predictedSize: long_long): nsIAsyncOutputStream;
    /**
     * Opens and returns an input stream that can be used to read the alternative
     * representation previously saved in the cache.
     * If this call is made while writing alt-data is still in progress, it is
     * still possible to read content from the input stream as it's being written.
     * @throws
     * - NS_ERROR_NOT_AVAILABLE if the alt-data representation doesn't exist at
     * all or if alt-data of the given type doesn't exist.
     */
    openAlternativeInputStream(type: ACString): nsIInputStream;
    /**
     * Get the nsILoadContextInfo of the cache entry
     */
    readonly loadContextInfo: nsILoadContextInfo;
    /**
     * **************************************************************************
     * The following methods might be added to some nsICacheEntryInternal
     * interface since we want to remove them as soon as the old cache backend is
     * completely removed.
     *
     * @deprecated
     * FOR BACKWARD COMPATIBILITY ONLY
     * When the old cache backend is eventually removed, this method
     * can be removed too.
     *
     * In the new backend: this method is no-op
     * In the old backend: this method delegates to nsICacheEntryDescriptor.close()
     */
    close(): void;
    /**
     * @deprecated
     * FOR BACKWARD COMPATIBILITY ONLY
     * Marks the entry as valid so that others can use it and get only readonly
     * access when the entry is held by the 1st writer.
     */
    markValid(): void;
    /**
     * @deprecated
     * FOR BACKWARD COMPATIBILITY ONLY
     * Marks the entry as valid when write access is acquired.
     */
    maybeMarkValid(): void;
    /**
     * @deprecated
     * FOR BACKWARD COMPATIBILITY ONLY / KINDA HACK
     * @param aWriteAllowed
     * Consumer indicates whether write to the entry is allowed for it.
     * Depends on implementation how the flag is handled.
     * @returns
     * true when write access is acquired for this entry,
     * false otherwise
     */
    hasWriteAccess(aWriteAllowed: boolean): boolean;
}

/**
 * Argument for nsICacheEntry.visitMetaData, provides access to all metadata
 * keys and values stored on the entry.
 */
declare interface nsICacheEntryMetaDataVisitorType extends nsISupportsType {
    /**
     * Called over each key / value pair.
     */
    onMetaDataElement(key: string, value: string): void;
}

/**
 *
 */
declare interface nsICacheEntryDoomCallbackType extends nsISupportsType {
    /**
     * Callback invoked after an entry or entries has/have been
     * doomed from the cache.
     */
    onCacheEntryDoomed(aResult: nsresult): void;
}

/**
 *
 */
declare interface nsICacheEntryOpenCallbackType extends nsISupportsType {
    /**
     * Callback to perform any validity checks before the entry should be used.
     * Called before onCacheEntryAvailable callback, depending on the result it
     * may be called more then one time.
     *
     * This callback is ensured to be called on the same thread on which asyncOpenURI
     * has been called, unless nsICacheStorage.CHECK_MULTITHREADED flag has been specified.
     * In that case this callback can be invoked on any thread, usually it is the cache I/O
     * or cache management thread.
     *
     * IMPORTANT NOTE:
     * This callback may be invoked sooner then respective asyncOpenURI call exits.
     *
     * @param aEntry
     * An entry to examine.  Consumer has a chance to decide whether the
     * entry is valid or not.
     * @return
     * State of the entry, see the constants just above.
     */
    onCacheEntryCheck(aEntry: nsICacheEntryType): unsigned_long;
    /**
     * Callback giving actual result of asyncOpenURI.  It may give consumer the cache
     * entry or a failure result when it's not possible to open it from some reason.
     * This callback is ensured to be called on the same thread on which asyncOpenURI
     * has been called.
     *
     * IMPORTANT NOTE:
     * This callback may be invoked sooner then respective asyncOpenURI call exits.
     *
     * @param aEntry
     * The entry bound to the originally requested URI.
     * @param aNew
     * Whether no data so far has been stored for this entry, i.e. reading
     * it will just fail.  When aNew is true, a server request should be
     * made and data stored to this new entry.
     * @param aResult
     * Result of the request.  This may be a failure only when one of these
     * issues occur:
     * - the cache storage service could not be started due to some unexpected
     * faulure
     * - there is not enough disk space to create new entries
     */
    onCacheEntryAvailable(aEntry: nsICacheEntryType, aNew: boolean, aResult: nsresult): void;
}

/**
 *
 */
declare interface nsIInputStreamReceiverType extends nsISupportsType {
    /**
     *
     */
    onInputStreamReady(aStream: nsIInputStreamType): void;
}

/**
 *
 */
declare interface nsICacheInfoChannelType extends nsISupportsType {
    /**
     * Get the number of times the cache entry has been opened. This attribute is
     * equivalent to nsICachingChannel.cacheToken.fetchCount.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if the cache entry or the alternate data
     * cache entry cannot be read.
     */
    readonly cacheTokenFetchCount: uint32_t;
    /**
     * Get expiration time from cache token. This attribute is equivalent to
     * nsICachingChannel.cacheToken.expirationTime.
     */
    readonly cacheTokenExpirationTime: uint32_t;
    /**
     * TRUE if this channel's data is being loaded from the cache.  This value
     * is undefined before the channel fires its OnStartRequest notification
     * and after the channel fires its OnStopRequest notification.
     */
    isFromCache(): boolean;
    /**
     * Returns true if the channel raced the cache and network requests.
     * In order to determine if the response is coming from the cache or the
     * network, the consumer can check isFromCache().
     * The method can only be called after the channel fires its OnStartRequest
     * notification.
     */
    isRacing(): boolean;
    /**
     * The unique ID of the corresponding nsICacheEntry from which the response is
     * retrieved. By comparing the returned value, we can judge whether the data
     * of two distinct nsICacheInfoChannels is from the same nsICacheEntry. This
     * scenario could be useful when verifying whether the alternative data from
     * one nsICacheInfochannel matches the main data from another one.
     *
     * Note: NS_ERROR_NOT_AVAILABLE is thrown when a nsICacheInfoChannel has no
     * valid corresponding nsICacheEntry.
     */
    getCacheEntryId(): uint64_t;
    /**
     * Set/get the cache key. This integer uniquely identifies the data in
     * the cache for this channel.
     *
     * A cache key retrieved from a particular instance of nsICacheInfoChannel
     * could be set on another instance of nsICacheInfoChannel provided the
     * underlying implementations are compatible and provided the new
     * channel instance was created with the same URI.  The implementation of
     * nsICacheInfoChannel would be expected to use the cache entry identified
     * by the cache token.  Depending on the value of nsIRequest::loadFlags,
     * the cache entry may be validated, overwritten, or simply read.
     *
     * The cache key may be 0 indicating that the URI of the channel is
     * sufficient to locate the same cache entry.  Setting a 0 cache key
     * is likewise valid.
     */
    cacheKey: unsigned_long;
    /**
     * Tells the channel to behave as if the LOAD_FROM_CACHE flag has been set,
     * but without affecting the loads for the entire loadGroup in case of this
     * channel being the default load group's channel.
     */
    allowStaleCacheContent: boolean;
    /**
     * Tells the priority for LOAD_CACHE is raised over LOAD_BYPASS_CACHE or
     * LOAD_BYPASS_LOCAL_CACHE in case those flags are set at the same time.
     */
    preferCacheLoadOverBypass: boolean;
    /**
     * Tells the channel to be force validated during soft reload.
     */
    forceValidateCacheContent: boolean;
    /**
     * Calling this method instructs the channel to serve the alternative data
     * if that was previously saved in the cache, otherwise it will serve the
     * real data.
     * @param type
     * a string identifying the alt-data format
     * @param contentType
     * the contentType for which the preference applies.
     * an empty contentType means the preference applies for ANY contentType
     * @param deliverAltData
     * if false, also if alt-data is available, the channel will deliver
     * the original data.
     *
     * The method may be called several times, with different type and contentType.
     *
     * Must be called before AsyncOpen.
     */
    preferAlternativeDataType(type: ACString, contentType: ACString, deliverAltData: nsICacheInfoChannel_PreferredAlternativeDataDeliveryTypeType): void;
    /**
     * Holds the type of the alternative data representation that the channel
     * is returning.
     * Is empty string if no alternative data representation was requested, or
     * if the requested representation wasn't found in the cache.
     * Can only be called during or after OnStartRequest.
     */
    readonly alternativeDataType: ACString;
    /**
     * If preferAlternativeDataType() has been called passing deliverAltData
     * equal to false, this attribute will expose the alt-data inputStream if
     * avaiable.
     */
    readonly alternativeDataInputStream: nsIInputStream;
    /**
     * Sometimes when the channel is delivering alt-data, we may want to somehow
     * access the original content too. This method asynchronously opens the
     * input stream and delivers it to the receiver.
     */
    getOriginalInputStream(aReceiver: nsIInputStreamReceiverType): void;
    /**
     * Opens and returns an output stream that a consumer may use to save an
     * alternate representation of the data.
     * Must be called after the OnStopRequest that delivered the real data.
     * The consumer may choose to replace the saved alt representation.
     * Opening the output stream will fail if there are any open input streams
     * reading the already saved alt representation. After successfully opening
     * an output stream, if there is an error before the entire alt data can be
     * written successfully, the client must signal failure by passing an error
     * code to CloseWithStatus().
     *
     * @param type
     * type of the alternative data representation
     * @param predictedSize
     * Predicted size of the data that will be written. It's used to decide
     * whether the resulting entry would exceed size limit, in which case
     * an error is thrown. If the size isn't known in advance, -1 should be
     * passed.
     */
    openAlternativeOutputStream(type: ACString, predictedSize: long_long): nsIAsyncOutputStream;
}

/**
 * This object is a wrapper of MultiInstanceLock.
 * It's intended to be used to ensure exclusive access to folders being
 * deleted by the purgeHTTPCache background task.
 */
declare interface nsICachePurgeLockType extends nsISupportsType {
    /**
     * Initializes the lock using the profile name and the current process's
     * path.
     * Will throw if a lock was already acquired successfully.
     */
    lock(profileName: AUTF8String): void;
    /**
     * Returns true if another instance also holds the lock.
     * Throws if called before lock was called, or after unlock was called.
     */
    isOtherInstanceRunning(): bool;
    /**
     * Releases the lock.
     * This object may be locked again, potentially using a different path
     * after unlocking.
     */
    unlock(): void;
    /**
     * Returns the file used to guarantee single access to a resource.
     * This method is used to remove the lock file when no longer necessary.
     */
    getLockFile(profileName: AUTF8String): nsIFile;
}

/**
 * Representation of a cache storage. There can be just-in-mem,
 * in-mem+on-disk, in-mem+on-disk+app-cache or just a specific
 * app-cache storage.
 */
declare interface nsICacheStorageType extends nsISupportsType {
    /**
     * Asynchronously opens a cache entry for the specified URI.
     * Result is fetched asynchronously via the callback.
     *
     * @param aURI
     * The URI to search in cache or to open for writting.
     * @param aIdExtension
     * Any string that will extend (distinguish) the entry.  Two entries
     * with the same aURI but different aIdExtension will be comletely
     * different entries.  If you don't know what aIdExtension should be
     * leave it empty.
     * @param aFlags
     * OPEN_NORMALLY - open cache entry normally for read and write
     * OPEN_TRUNCATE - delete any existing entry before opening it
     * OPEN_READONLY - don't create an entry if there is none
     * OPEN_PRIORITY - give this request a priority over others
     * OPEN_BYPASS_IF_BUSY - backward compatibility only, LOAD_BYPASS_LOCAL_CACHE_IF_BUSY
     * CHECK_MULTITHREADED - onCacheEntryCheck may be called on any thread, consumer
     * implementation is thread-safe
     * @param aCallback
     * The consumer that receives the result.
     * IMPORTANT: The callback may be called sooner the method returns.
     */
    asyncOpenURI(aURI: nsIURIType, aIdExtension: ACString, aFlags: uint32_t, aCallback: nsICacheEntryOpenCallbackType): void;
    /**
     * Immediately opens a new and empty cache entry in the storage, any existing
     * entries are immediately doomed.  This is similar to the recreate() method
     * on nsICacheEntry.
     *
     * Storage may not implement this method and throw NS_ERROR_NOT_IMPLEMENTED.
     * In that case consumer must use asyncOpen with OPEN_TRUNCATE flag and get
     * the new entry via a callback.
     *
     * @param aURI @see asyncOpenURI
     * @param aIdExtension @see asyncOpenURI
     */
    openTruncate(aURI: nsIURIType, aIdExtension: ACString): nsICacheEntry;
    /**
     * Synchronously check on existance of an entry.  In case of disk entries
     * this uses information from the cache index.  When the index data are not
     * up to date or index is still building, NS_ERROR_NOT_AVAILABLE is thrown.
     * The same error may throw any storage implementation that cannot determine
     * entry state without blocking the caller.
     */
    exists(aURI: nsIURIType, aIdExtension: ACString): boolean;
    /**
     * Synchronously check on existance of alternative data and size of the
     * content. When the index data are not up to date or index is still building,
     * NS_ERROR_NOT_AVAILABLE is thrown. The same error may throw any storage
     * implementation that cannot determine entry state without blocking the caller.
     */
    getCacheIndexEntryAttrs(aURI: nsIURIType, aIdExtension: ACString, aHasAltData: bool, aSizeInKB: uint32_t): void;
    /**
     * Asynchronously removes an entry belonging to the URI from the cache.
     */
    asyncDoomURI(aURI: nsIURIType, aIdExtension: ACString, aCallback: nsICacheEntryDoomCallbackType): void;
    /**
     * Asynchronously removes all cached entries under this storage.
     * NOTE: Disk storage also evicts memory storage.
     */
    asyncEvictStorage(aCallback: nsICacheEntryDoomCallbackType): void;
    /**
     * Visits the storage and its entries.
     * NOTE: Disk storage also visits memory storage.
     */
    asyncVisitStorage(aVisitor: nsICacheStorageVisitorType, aVisitEntries: boolean): void;
}

/**
 * Provides access to particual cache storages of the network URI cache.
 */
declare interface nsICacheStorageServiceType extends nsISupportsType {
    /**
     * Get storage where entries will only remain in memory, never written
     * to the disk.
     *
     * NOTE: Any existing disk entry for [URL|id-extension] will be doomed
     * prior opening an entry using this memory-only storage.  Result of
     * AsyncOpenURI will be a new and empty memory-only entry.  Using
     * OPEN_READONLY open flag has no effect on this behavior.
     *
     * @param aLoadContextInfo
     * Information about the loading context, this focuses the storage JAR and
     * respects separate storage for private browsing.
     */
    memoryCacheStorage(aLoadContextInfo: nsILoadContextInfoType): nsICacheStorage;
    /**
     * Get storage where entries will be written to disk when not forbidden by
     * response headers.
     */
    diskCacheStorage(aLoadContextInfo: nsILoadContextInfoType): nsICacheStorage;
    /**
     * Get storage where entries will be written to disk and marked as pinned.
     * These pinned entries are immune to over limit eviction and call of clear()
     * on this service.
     */
    pinningCacheStorage(aLoadContextInfo: nsILoadContextInfoType): nsICacheStorage;
    /**
     * Evict any cache entry having the same origin of aPrincipal.
     *
     * @param aPrincipal
     * The principal to compare the entries with.
     */
    clearOrigin(aPrincipal: nsIPrincipalType): void;
    /**
     * Evict any cache entry which belongs to a base domain. This includes entries
     * partitioned under aBaseDomain and entries which belong to aBaseDomain, but
     * are partitioned under other top level sites.
     * @param aBaseDomain
     * The base domain to clear cache for.
     */
    clearBaseDomain(aBaseDomain: AString): void;
    /**
     * Evict any cache entry having the same originAttributes.
     *
     * @param aOriginAttributes
     * The origin attributes in string format to compare the entries with.
     */
    clearOriginAttributes(aOriginAttributes: AString): void;
    /**
     * Evict the whole cache.
     */
    clear(): void;
    /**
     * Purges data we keep warmed in memory.  Use for tests and for
     * saving memory.
     */
    purgeFromMemory(aWhat: uint32_t): void;
    /**
     * I/O thread target to use for any operations on disk
     */
    readonly ioTarget: nsIEventTarget;
    /**
     * Asynchronously determine how many bytes of the disk space the cache takes.
     * @see nsICacheStorageConsumptionObserver
     * @param aObserver
     * A mandatory (weak referred) observer.  Documented at
     * nsICacheStorageConsumptionObserver.
     * NOTE: the observer MUST implement nsISupportsWeakReference.
     */
    asyncGetDiskConsumption(aObserver: nsICacheStorageConsumptionObserverType): void;
    /**
     * Asynchronously visits all storages of the disk cache and memory cache.
     * @see nsICacheStorageVisitor
     * @param aVisitor
     * A visitor callback.
     * @param aVisitEntries
     * A boolean indicates whether visits entries.
     */
    asyncVisitAllStorages(aVisitor: nsICacheStorageVisitorType, aVisitEntries: boolean): void;
}

/**
 *
 */
declare interface nsICacheStorageConsumptionObserverType extends nsISupportsType {
    /**
     * Callback invoked to answer asyncGetDiskConsumption call. Always triggered
     * on the main thread.
     * NOTE: implementers must also implement nsISupportsWeakReference.
     *
     * @param aDiskSize
     * The disk consumption in bytes.
     */
    onNetworkCacheDiskConsumption(aDiskSize: int64_t): void;
}

/**
 *
 */
declare interface nsICacheStorageVisitorType extends nsISupportsType {
    /**
     *
     */
    onCacheStorageInfo(aEntryCount: uint32_t, aConsumption: uint64_t, aCapacity: uint64_t, aDiskDirectory: nsIFileType): void;
    /**
     *
     */
    onCacheEntryInfo(aURI: nsIURIType, aIdEnhance: ACString, aDataSize: int64_t, aAltDataSize: int64_t, aFetchCount: uint32_t, aLastModifiedTime: uint32_t, aExpirationTime: uint32_t, aPinned: boolean, aInfo: nsILoadContextInfoType): void;
    /**
     *
     */
    onCacheEntryVisitCompleted(): void;
}

/**
 * This is an internal interface used only for testing purposes.
 *
 * THIS IS NOT AN API TO BE USED BY EXTENSIONS! ONLY USED BY MOZILLA TESTS.
 */
declare interface nsICacheTestingType extends nsISupportsType {
    /**
     *
     */
    suspendCacheIOThread(aLevel: uint32_t): void;
    /**
     *
     */
    resumeCacheIOThread(): void;
    /**
     *
     */
    flush(aObserver: nsIObserverType): void;
}

/**
 * A channel may optionally implement this interface to allow clients
 * to affect its behavior with respect to how it uses the cache service.
 *
 * This interface provides:
 * 1) Support for "stream as file" semantics (for JAR and plugins).
 * 2) Support for "pinning" cached data in the cache (for printing and save-as).
 * 3) Support for uniquely identifying cached data in cases when the URL
 * is insufficient (e.g., HTTP form submission).
 */
declare interface nsICachingChannelType extends nsICacheInfoChannelType {
    /**
     * Set/get the cache token... uniquely identifies the data in the cache.
     * Holding a reference to this token prevents the cached data from being
     * removed.
     *
     * A cache token retrieved from a particular instance of nsICachingChannel
     * could be set on another instance of nsICachingChannel provided the
     * underlying implementations are compatible.  The implementation of
     * nsICachingChannel would be expected to only read from the cache entry
     * identified by the cache token and not try to validate it.
     *
     * The cache token can be QI'd to a nsICacheEntryInfo if more detail
     * about the cache entry is needed (e.g., expiration time).
     */
    cacheToken: nsISupports;
    /**
     * Instructs the channel to only store the metadata of the entry, and not
     * the content. When reading an existing entry, this automatically sets
     * LOAD_ONLY_IF_MODIFIED flag.
     * Must be called before asyncOpen().
     */
    cacheOnlyMetadata: boolean;
    /**
     * Tells the channel to use the pinning storage.
     */
    pin: boolean;
    /**
     * Overrides cache validation for a time specified in seconds.
     *
     * @param aSecondsToTheFuture
     */
    forceCacheEntryValidFor(aSecondsToTheFuture: unsigned_long): void;
}

/**
 * This interface provides a means to cancel an operation that is in progress.
 */
declare interface nsICancelableType extends nsISupportsType {
    /**
     * Call this method to request that this object abort whatever operation it
     * may be performing.
     *
     * @param aReason
     * Pass a failure code to indicate the reason why this operation is
     * being canceled.  It is an error to pass a success code.
     */
    cancel(aReason: nsresult): void;
}

/**
 *
 */
declare interface nsICaptivePortalCallbackType extends nsISupportsType {
    /**
     * Preparation for network interface before captive portal detection started.
     */
    prepare(): void;
    /**
     * Invoke callbacks after captive portal detection finished.
     */
    complete(success: bool): void;
}

/**
 *
 */
declare interface nsICaptivePortalDetectorType extends nsISupportsType {
    /**
     * Perform captive portal detection on specific network interface.
     * @param ifname The name of network interface, exception will be thrwon
     * if the same interface has unfinished request.
     * @param callback Callbacks when detection procedure starts and finishes.
     */
    checkCaptivePortal(ifname: AString, callback: nsICaptivePortalCallbackType): void;
    /**
     * Abort captive portal detection for specific network interface
     * due to system failure, callback will not be invoked.
     * @param ifname The name of network interface.
     */
    abort(ifname: AString): void;
    /**
     * Cancel captive portal login procedure by user, callback will be invoked.
     * @param eventId Login event id provided in |captive-portal-login| event.
     */
    cancelLogin(eventId: AString): void;
    /**
     * Notify prepare phase is finished, routing and dns must be ready for sending
     * out XMLHttpRequest. this is callback for CaptivePortalDetector API user.
     * @param ifname The name of network interface, must be unique.
     */
    finishPreparation(ifname: AString): void;
}

/**
 *
 */
declare interface nsICaptivePortalServiceCallbackType extends nsISupportsType {
    /**
     * Invoke callbacks after captive portal detection finished.
     */
    complete(success: bool, error: nsresult): void;
}

/**
 * Service used for captive portal detection.
 * The service is only active in the main process. It is also available in the
 * content process, but only to mirror the captive portal state from the main
 * process.
 */
declare interface nsICaptivePortalServiceType extends nsISupportsType {
    /**
     * Called from XPCOM to trigger a captive portal recheck.
     * A network request will only be performed if no other checks are currently
     * ongoing.
     * Will not do anything if called in the content process.
     */
    recheckCaptivePortal(): void;
    /**
     * Returns the state of the captive portal.
     */
    readonly state: long;
    /**
     * Returns the time difference between NOW and the last time a request was
     * completed in milliseconds.
     */
    readonly lastChecked: unsigned_long_long;
}

/**
 * A consumer of a filter cascade, i.e. a cascaded bloom filter as generated by
 * https://github.com/mozilla/filter-cascade
 */
declare interface nsICascadeFilterType extends nsISupportsType {
    /**
     * Initialize with the data that represents the filter cascade.
     * This method can be called repeatedly.
     *
     * @throws NS_ERROR_INVALID_ARG if the input is malformed.
     */
    setFilterData(data: invalid): void;
    /**
     * Check whether a given key is a member of the filter cascade.
     * The result can only be relied upon if the key was known at the time of the
     * filter generation. If the key is unknown, the method may incorrectly
     * return true (due to the probabilistic nature of bloom filters).
     */
    has(key: ACString): boolean;
}

/**
 * nsICategoryManager
 */
declare interface nsICategoryEntryType extends nsISupportsCStringType {
    /**
     *
     */
    readonly entry: ACString;
    /**
     *
     */
    readonly value: ACString;
}

/**
 *
 */
declare interface nsICategoryManagerType extends nsISupportsType {
    /**
     * Get the value for the given category's entry.
     * @param aCategory The name of the category ("protocol")
     * @param aEntry The entry you're looking for ("http")
     * @return The value.
     */
    getCategoryEntry(aCategory: ACString, aEntry: ACString): ACString;
    /**
     * Add an entry to a category.
     * @param aCategory The name of the category ("protocol")
     * @param aEntry The entry to be added ("http")
     * @param aValue The value for the entry ("moz.httprulez.1")
     * @param aPersist Should this data persist between invocations?
     * @param aReplace Should we replace an existing entry?
     * @return Previous entry, if any
     */
    addCategoryEntry(aCategory: ACString, aEntry: ACString, aValue: ACString, aPersist: boolean, aReplace: boolean): ACString;
    /**
     * Delete an entry from the category.
     * @param aCategory The name of the category ("protocol")
     * @param aEntry The entry to be added ("http")
     * @param aPersist Delete persistent data from registry, if present?
     */
    deleteCategoryEntry(aCategory: ACString, aEntry: ACString, aPersist: boolean): void;
    /**
     * Delete a category and all entries.
     * @param aCategory The category to be deleted.
     */
    deleteCategory(aCategory: ACString): void;
    /**
     * Enumerate the entries in a category.
     * @param aCategory The category to be enumerated.
     * @return a simple enumerator, each result QIs to
     * nsICategoryEntry.
     */
    enumerateCategory(aCategory: ACString): nsISimpleEnumerator;
    /**
     * Enumerate all existing categories
     * @param aCategory The category to be enumerated.
     * @return a simple enumerator, each result QIs to
     * nsISupportsCString.
     */
    enumerateCategories(): nsISimpleEnumerator;
}

/**
 *
 */
declare interface nsICertOverrideType extends nsISupportsType {
    /**
     * The hostname of the server the override is used for.
     */
    readonly asciiHost: ACString;
    /**
     * The port of the server the override is used for.
     */
    readonly port: int32_t;
    /**
     * A combination of hostname and port in the form host:port.
     * Since the port can be -1 which is equivalent to port 433 we use an
     * existing function of nsCertOverrideService to create this property.
     */
    readonly hostPort: ACString;
    /**
     * The fingerprint for the associated certificate.
     */
    readonly fingerprint: ACString;
    /**
     * The origin attributes associated with this override.
     */
    readonly originAttributes: jsval;
}

/**
 *
 */
declare interface nsICertOverrideServiceType extends nsISupportsType {
    /**
     *
     */
    rememberValidityOverride(aHostName: AUTF8String, aPort: int32_t, aOriginAttributes: jsval, aCert: nsIX509CertType, aTemporary: boolean): void;
    /**
     *
     */
    hasMatchingOverride(aHostName: AUTF8String, aPort: int32_t, aOriginAttributes: jsval, aCert: nsIX509CertType, aIsTemporary: boolean): boolean;
    /**
     *
     */
    clearValidityOverride(aHostName: AUTF8String, aPort: int32_t, aOriginAttributes: jsval): void;
    /**
     * Remove all overrides.
     */
    clearAllOverrides(): void;
    /**
     * NOTE: This function is used only for testing!
     *
     * @param aDisable If true, disable all security check and make
     * hasMatchingOverride always return true.
     */
    setDisableAllSecurityChecksAndLetAttackersInterceptMyData(aDisable: boolean): void;
    /**
     *
     */
    readonly securityCheckDisabled: boolean;
}

/**
 * Callback type used to notify callers that an operation performed by
 * nsICertStorage has completed. Indicates the result of the requested
 * operation, as well as any data returned by the operation.
 */
declare interface nsICertStorageCallbackType extends nsISupportsType {
    /**
     *
     */
    done(rv: nsresult, result: nsIVariantType): void;
}

/**
 * A base interface for representing the revocation state of a certificate.
 * Implementing this interface by itself is insufficient; your type must
 * implement an inheriting interface that specifies the certificate by issuer
 * and serial number or by subject and public key hash.
 * Set state to nsICertStorage.STATE_UNSET to mark the certificate as not revoked.
 * Set state to nsICertStorage.STATE_ENFORCE to mark the certificate as revoked.
 */
declare interface nsIRevocationStateType extends nsISupportsType {
    /**
     *
     */
    readonly state: short;
}

/**
 * An interface representing the revocation state of a certificate by issuer
 * and serial number. Both issuer name and serial number are base64-encoded.
 */
declare interface nsIIssuerAndSerialRevocationStateType extends nsIRevocationStateType {
    /**
     *
     */
    readonly issuer: ACString;
    /**
     *
     */
    readonly serial: ACString;
}

/**
 * An interface representing the revocation state of a certificate by subject
 * and pub key hash (the hash algorithm should be SHA-256). Both subject name
 * and public key hash are base64-encoded.
 */
declare interface nsISubjectAndPubKeyRevocationStateType extends nsIRevocationStateType {
    /**
     *
     */
    readonly subject: ACString;
    /**
     *
     */
    readonly pubKey: ACString;
}

/**
 * An interface representing a set of certificates that are covered by a CRLite
 * filter. The set is represented by a certificate transparency log ID and a
 * pair of timestamps. The timestamps are such that the CRLite aggregator has
 * seen every certificate from the specified log with an SCT between the two
 * timestamps.
 * b64LogID is a base 64-encoded RFC 6962 LogID.
 * minTimestamp is the smallest timestamp that the CRLite filter covers.
 * maxTimestamp is the largest timestamp that the CRLite filter covers.
 */
declare interface nsICRLiteCoverageType extends nsISupportsType {
    /**
     *
     */
    readonly b64LogID: ACString;
    /**
     *
     */
    readonly minTimestamp: unsigned_long_long;
    /**
     *
     */
    readonly maxTimestamp: unsigned_long_long;
}

/**
 * An interface representing the id and timestamp fields from an RFC 6962
 * SignedCertificateTimestamp struct.
 * logID is the id field.
 * timestamp is the timestamp field.
 */
declare interface nsICRLiteTimestampType extends nsISupportsType {
    /**
     *
     */
    readonly timestamp: unsigned_long_long;
}

/**
 * An interface representing a certificate to add to storage. Consists of the
 * base64-encoded DER bytes of the certificate (cert), the base64-encoded DER
 * bytes of the subject distinguished name of the certificate (subject), and the
 * trust of the certificate (one of the nsICertStorage.TRUST_* constants).
 * (Note that this implementation does not validate that the given subject DN
 * actually matches the subject DN of the certificate, nor that the given cert
 * is a valid DER X.509 certificate.)
 */
declare interface nsICertInfoType extends nsISupportsType {
    /**
     *
     */
    readonly cert: ACString;
    /**
     *
     */
    readonly subject: ACString;
    /**
     *
     */
    readonly trust: short;
}

/**
 *
 */
declare interface nsICertStorageType extends nsISupportsType {
    /**
     * Asynchronously check if the backing storage has stored data of the given
     * type in the past. This is useful if the backing storage may have had to
     * have been deleted and recreated (as in bug 1546361 when we discovered that
     * moving from a 32-bit binary to a 64-bit binary caused the DB to become
     * unreadable, thus necessitating its deletion and recreation).
     */
    hasPriorData(type: octet, callback: nsICertStorageCallbackType): void;
    /**
     * Asynchronously set the revocation states of a set of certificates.
     * The given callback is called with the result of the operation when it
     * completes.
     * Must only be called from the main thread.
     */
    setRevocations(revocations: invalid, callback: nsICertStorageCallbackType): void;
    /**
     * Get the revocation state of a certificate. STATE_UNSET indicates the
     * certificate is not revoked. STATE_ENFORCE indicates the certificate is
     * revoked.
     * issuer - issuer name, DER encoded
     * serial - serial number, DER encoded
     * subject - subject name, DER encoded
     * pubkey - public key, DER encoded
     * In gecko, must not be called from the main thread. See bug 1541212.
     * xpcshell tests may call this from the main thread.
     */
    getRevocationState(issuer: invalid, serial: invalid, subject: invalid, pubkey: invalid): short;
    /**
     * Given the contents of a new CRLite filter, a list containing
     * `base64(sha256(subject DN || subject SPKI))` for each enrolled issuer, and
     * the filter's timestamp coverage, replaces any existing filter with the new
     * one. Also clears any previously-set incremental revocation updates
     * ("stashes").
     */
    setFullCRLiteFilter(filter: invalid, enrolledIssuers: invalid, coverage: invalid, callback: nsICertStorageCallbackType): void;
    /**
     * Given the DER-encoded issuer distinguished name, DER-encoded issuer subject public key info,
     * the bytes of the value of the serial number (so, not including the DER tag and length) of a
     * certificate, and the timestamps from that certificate's embedded SCTs, returns the result of
     * looking up the corresponding entry in the currently-saved CRLite filter (if any).
     * Returns
     * - STATE_ENFORCE if the lookup indicates the certificate is revoked via CRLite,
     * - STATE_UNSET if the lookup indicates the certificate is not revoked via CRLite,
     * - STATE_NOT_ENROLLED if the issuer is not enrolled in CRLite, or
     * - STATE_NOT_COVERED if the issuer is enrolled but the provided timestamps indicate
     * that the serial number is not covered by the current CRLite filter.
     * - STATE_NO_FILTER if there is no (usable) CRLite filter.
     * No lookup is performed in the STATE_NOT_ENROLLED and STATE_NOT_COVERED cases.
     */
    getCRLiteRevocationState(issuer: invalid, issuerSPKI: invalid, serialNumber: invalid, timestamps: invalid): short;
    /**
     * Given the contents of a CRLite incremental revocation update ("stash"), adds the revocation
     * information to the current set of stashed revocations. The basic unit of the stash file is an
     * issuer subject public key info hash (sha-256) followed by a number of serial numbers
     * corresponding to revoked certificates issued by that issuer. More specifically, each unit
     * consists of:
     * 4 bytes little-endian: the number of serial numbers following the issuer spki hash
     * 1 byte: the length of the issuer spki hash
     * issuer spki hash length bytes: the issuer spki hash
     * as many times as the indicated serial numbers:
     * 1 byte: the length of the serial number
     * serial number length bytes: the serial number
     * The stash file consists of any number of these units concatenated together.
     */
    addCRLiteStash(stash: invalid, callback: nsICertStorageCallbackType): void;
    /**
     * Given a DER-encoded issuer subject public key info and the bytes of the value of the serial
     * number (so, not including the DER tag and length), determines if the certificate identified by
     * this issuer SPKI and serial number is revoked according to the current set of stashed CRLite
     * revocation information.
     */
    isCertRevokedByStash(issuerSPKI: invalid, serialNumber: invalid): bool;
    /**
     * Asynchronously add a list of certificates to the backing storage.
     * See the documentation for nsICertInfo.
     * The given callback is called with the result of the operation when it
     * completes.
     * Must only be called from the main thread.
     */
    addCerts(certs: invalid, callback: nsICertStorageCallbackType): void;
    /**
     * Asynchronously remove the certificates with the given sha-256 hashes from
     * the backing storage.
     * hashes is an array of base64-encoded bytes of the sha-256 hashes of each
     * certificate's bytes (DER-encoded).
     * The given callback is called with the result of the operation when it
     * completes.
     * Must only be called from the main thread.
     */
    removeCertsByHashes(hashes: invalid, callback: nsICertStorageCallbackType): void;
    /**
     * Get the count of remaining async operations. Called to ensure we don't skip
     * or interrupt any operations during fast shutdown.
     * Must only be called from the main thread.
     */
    GetRemainingOperationCount(): int32_t;
}

/**
 *
 */
declare interface nsICertTreeItemType extends nsISupportsType {
    /**
     *
     */
    readonly cert: nsIX509Cert;
}

/**
 *
 */
declare interface nsICertTreeType extends nsITreeViewType {
    /**
     *
     */
    loadCertsFromCache(cache: invalid, type: unsigned_long): void;
    /**
     *
     */
    getCert(index: unsigned_long): nsIX509Cert;
    /**
     *
     */
    getTreeItem(index: unsigned_long): nsICertTreeItem;
    /**
     *
     */
    deleteEntryObject(index: unsigned_long): void;
}

/**
 * Functions that implement user interface dialogs to manage certificates.
 */
declare interface nsICertificateDialogsType extends nsISupportsType {
    /**
     * UI shown when a user is asked to download a new CA cert.
     * Provides user with ability to choose trust settings for the cert.
     * Asks the user to grant permission to import the certificate.
     *
     * @param ctx A user interface context.
     * @param cert The certificate that is about to get installed.
     * @param trust A bit mask of trust flags.
     * See nsIX509CertDB for possible values.
     *
     * @return true if the user allows to import the certificate.
     */
    confirmDownloadCACert(ctx: nsIInterfaceRequestorType, cert: nsIX509CertType, trust: unsigned_long): boolean;
    /**
     * UI shown when a user's personal certificate is going to be
     * exported to a backup file.
     * The implementation of this dialog should make sure to prompt the user to
     * type the password twice in order to confirm correct input.
     * The wording in the dialog should also motivate the user to enter a strong
     * password.
     *
     * @param ctx A user interface context.
     * @param password The password provided by the user.
     *
     * @return false if the user requests to cancel.
     */
    setPKCS12FilePassword(ctx: nsIInterfaceRequestorType, password: AString): boolean;
    /**
     * UI shown when a user is about to restore a personal
     * certificate from a backup file.
     * The user is requested to enter the password
     * that was used in the past to protect that backup file.
     *
     * @param ctx A user interface context.
     * @param password The password provided by the user.
     *
     * @return false if the user requests to cancel.
     */
    getPKCS12FilePassword(ctx: nsIInterfaceRequestorType, password: AString): boolean;
}

/**
 * The nsIChannel interface allows clients to construct "GET" requests for
 * specific protocols, and manage them in a uniform way.  Once a channel is
 * created (via nsIIOService::newChannel), parameters for that request may
 * be set by using the channel attributes, or by QI'ing to a subclass of
 * nsIChannel for protocol-specific parameters.  Then, the URI can be fetched
 * by calling nsIChannel::open or nsIChannel::asyncOpen.
 *
 * After a request has been completed, the channel is still valid for accessing
 * protocol-specific results.  For example, QI'ing to nsIHttpChannel allows
 * response headers to be retrieved for the corresponding http transaction.
 *
 * This interface must be used only from the XPCOM main thread.
 */
declare interface nsIChannelType extends nsIRequestType {
    /**
     * The original URI used to construct the channel. This is used in
     * the case of a redirect or URI "resolution" (e.g. resolving a
     * resource: URI to a file: URI) so that the original pre-redirect
     * URI can still be obtained.  This is never null.  Attempts to
     * set it to null must throw.
     *
     * NOTE: this is distinctly different from the http Referer (referring URI),
     * which is typically the page that contained the original URI (accessible
     * from nsIHttpChannel).
     *
     * NOTE: originalURI isn't yet set on the new channel when
     * asyncOnChannelRedirect is called.
     */
    originalURI: nsIURI;
    /**
     * The URI corresponding to the channel.  Its value is immutable.
     */
    readonly URI: nsIURI;
    /**
     * The owner, corresponding to the entity that is responsible for this
     * channel.  Used by the security manager to grant or deny privileges to
     * mobile code loaded from this channel.
     *
     * NOTE: this is a strong reference to the owner, so if the owner is also
     * holding a strong reference to the channel, care must be taken to
     * explicitly drop its reference to the channel.
     */
    owner: nsISupports;
    /**
     * The notification callbacks for the channel.  This is set by clients, who
     * wish to provide a means to receive progress, status and protocol-specific
     * notifications.  If this value is NULL, the channel implementation may use
     * the notification callbacks from its load group.  The channel may also
     * query the notification callbacks from its load group if its notification
     * callbacks do not supply the requested interface.
     *
     * Interfaces commonly requested include: nsIProgressEventSink, nsIPrompt,
     * and nsIAuthPrompt/nsIAuthPrompt2.
     *
     * When the channel is done, it must not continue holding references to
     * this object.
     *
     * NOTE: A channel implementation should take care when "caching" an
     * interface pointer queried from its notification callbacks.  If the
     * notification callbacks are changed, then a cached interface pointer may
     * become invalid and may therefore need to be re-queried.
     */
    notificationCallbacks: nsIInterfaceRequestor;
    /**
     * Transport-level security information (if any) corresponding to the
     * channel.
     *
     * NOTE: In some circumstances TLS information is propagated onto
     * non-nsIHttpChannel objects to indicate that their contents were likely
     * delivered over TLS all the same.
     *
     * FIXME(bz, bug 1528449) is that still true now that
     * document.open() doesn't do this?
     */
    readonly securityInfo: nsITransportSecurityInfo;
    /**
     * The MIME type of the channel's content if available.
     *
     * NOTE: the content type can often be wrongly specified (e.g., wrong file
     * extension, wrong MIME type, wrong document type stored on a server, etc.),
     * and the caller most likely wants to verify with the actual data.
     *
     * Setting contentType before the channel has been opened provides a hint
     * to the channel as to what the MIME type is.  The channel may ignore this
     * hint in deciding on the actual MIME type that it will report.
     *
     * Setting contentType after onStartRequest has been fired or after open()
     * is called will override the type determined by the channel.
     *
     * Setting contentType between the time that asyncOpen() is called and the
     * time when onStartRequest is fired has undefined behavior at this time.
     *
     * The value of the contentType attribute is a lowercase string.  A value
     * assigned to this attribute will be parsed and normalized as follows:
     * 1- any parameters (delimited with a ';') will be stripped.
     * 2- if a charset parameter is given, then its value will replace the
     * the contentCharset attribute of the channel.
     * 3- the stripped contentType will be lowercased.
     * Any implementation of nsIChannel must follow these rules.
     */
    contentType: ACString;
    /**
     * The character set of the channel's content if available and if applicable.
     * This attribute only applies to textual data.
     *
     * The value of the contentCharset attribute is a mixedcase string.
     */
    contentCharset: ACString;
    /**
     * The length of the data associated with the channel if available.  A value
     * of -1 indicates that the content length is unknown. Note that this is a
     * 64-bit value and obsoletes the "content-length" property used on some
     * channels.
     */
    contentLength: int64_t;
    /**
     * Synchronously open the channel.
     *
     * @return blocking input stream to the channel's data.
     *
     * NOTE: nsIChannel implementations are not required to implement this
     * method.  Moreover, since this method may block the calling thread, it
     * should not be called on a thread that processes UI events.  Like any
     * other nsIChannel method it must not be called on any thread other
     * than the XPCOM main thread.
     *
     * NOTE: Implementations should throw NS_ERROR_IN_PROGRESS if the channel
     * is reopened.
     */
    open(): nsIInputStream;
    /**
     * Asynchronously open this channel.  Data is fed to the specified stream
     * listener as it becomes available.  The stream listener's methods are
     * called on the thread that calls asyncOpen and are not called until
     * after asyncOpen returns.  If asyncOpen returns successfully, the
     * channel promises to call at least onStartRequest and onStopRequest.
     *
     * If the nsIRequest object passed to the stream listener's methods is not
     * this channel, an appropriate onChannelRedirect notification needs to be
     * sent to the notification callbacks before onStartRequest is called.
     * Once onStartRequest is called, all following method calls on aListener
     * will get the request that was passed to onStartRequest.
     *
     * If the channel's and loadgroup's notification callbacks do not provide
     * an nsIChannelEventSink when onChannelRedirect would be called, that's
     * equivalent to having called onChannelRedirect.
     *
     * If asyncOpen returns successfully, the channel is responsible for
     * keeping itself alive until it has called onStopRequest on aListener or
     * called onChannelRedirect.
     *
     * Implementations are allowed to synchronously add themselves to the
     * associated load group (if any).
     *
     * NOTE: Implementations should throw NS_ERROR_ALREADY_OPENED if the
     * channel is reopened.
     * NOTE: Implementations should throw an error if the channel has been
     * cancelled prior asyncOpen being called.
     *
     * @param aListener the nsIStreamListener implementation
     * @see nsIChannelEventSink for onChannelRedirect
     */
    asyncOpen(aListener: nsIStreamListenerType): void;
    /**
     * True if the channel has been canceled.
     */
    readonly canceled: boolean;
    /**
     * Access to the type implied or stated by the Content-Disposition header
     * if available and if applicable. This allows determining inline versus
     * attachment.
     *
     * Setting contentDisposition provides a hint to the channel about the
     * disposition.  If the hint is DISPOSITION_ATTACHMENT and a normal
     * Content-Disposition header is present, the hinted value will always be
     * used. If the hint is DISPOSITION_FORCE_INLINE then the disposition is
     * inline and the header is not used. The value from Content-Disposition
     * header is only used when the hinted value is not DISPOSITION_INLINE or
     * DISPOSITION_FORCE_INLINE.
     * If the header is missing the hinted value will be used if set.
     *
     * Implementations should throw NS_ERROR_NOT_AVAILABLE if the header either
     * doesn't exist for this type of channel or is empty, and return
     * DISPOSITION_ATTACHMENT if an invalid/noncompliant value is present.
     */
    contentDisposition: unsigned_long;
    /**
     * Access to the filename portion of the Content-Disposition header if
     * available and if applicable. This allows getting the preferred filename
     * without having to parse it out yourself.
     *
     * Setting contentDispositionFilename provides a hint to the channel about
     * the disposition.  If a normal Content-Disposition header is present its
     * value will always be used.  If it is missing the hinted value will be
     * used if set.
     *
     * Implementations should throw NS_ERROR_NOT_AVAILABLE if the header doesn't
     * exist for this type of channel, if the header is empty, if the header
     * doesn't contain a filename portion, or the value of the filename
     * attribute is empty/missing.
     */
    contentDispositionFilename: AString;
    /**
     * Access to the raw Content-Disposition header if available and applicable.
     *
     * Implementations should throw NS_ERROR_NOT_AVAILABLE if the header either
     * doesn't exist for this type of channel or is empty.
     *
     * @deprecated Use contentDisposition/contentDispositionFilename instead.
     */
    readonly contentDispositionHeader: ACString;
    /**
     * The LoadInfo object contains information about a network load, why it
     * was started, and how we plan on using the resulting response.
     * If a network request is redirected, the new channel will receive a new
     * LoadInfo object. The new object will contain mostly the same
     * information as the pre-redirect one, but updated as appropriate.
     * For detailed information about what parts of LoadInfo are updated on
     * redirect, see documentation on individual properties.
     */
    loadInfo: nsILoadInfo;
    /**
     * Returns true if the channel is used to create a document.
     * It returns true if the loadFlags have LOAD_DOCUMENT_URI set, or if
     * LOAD_HTML_OBJECT_DATA is set and the channel has the appropriate
     * MIME type.
     * Note: May have the wrong value if called before OnStartRequest as we
     * don't know the MIME type yet.
     */
    readonly isDocument: bool;
}

/**
 *
 */
declare interface nsIIdentChannelType extends nsIChannelType {
    /**
     * Unique ID of the channel, shared between parent and child. Needed if
     * the channel activity needs to be monitored across process boundaries,
     * like in devtools net monitor. See bug 1274556.
     */
    channelId: uint64_t;
}

/**
 *
 */
declare interface nsIUrlClassifierBlockedChannelType extends nsISupportsType {
    /**
     *
     */
    readonly reason: uint8_t;
    /**
     *
     */
    readonly tables: ACString;
    /**
     *
     */
    readonly url: AString;
    /**
     *
     */
    readonly tabId: uint64_t;
    /**
     *
     */
    readonly channelId: uint64_t;
    /**
     *
     */
    readonly isPrivateBrowsing: boolean;
    /**
     *
     */
    readonly topLevelUrl: AString;
    /**
     *
     */
    replace(): void;
    /**
     *
     */
    allow(): void;
}

/**
 *
 */
declare interface nsIChannelClassifierServiceType extends nsISupportsType {
    /**
     *
     */
    addListener(aObserver: nsIObserverType): void;
    /**
     *
     */
    removeListener(aObserver: nsIObserverType): void;
}

/**
 * Implement this interface to receive control over various channel events.
 * Channels will try to get this interface from a channel's
 * notificationCallbacks or, if not available there, from the loadGroup's
 * notificationCallbacks.
 *
 * These methods are called before onStartRequest.
 */
declare interface nsIChannelEventSinkType extends nsISupportsType {
    /**
     * Called when a redirect occurs. This may happen due to an HTTP 3xx status
     * code. The purpose of this method is to notify the sink that a redirect
     * is about to happen, but also to give the sink the right to veto the
     * redirect by throwing or passing a failure-code in the callback.
     *
     * Note that vetoing the redirect simply means that |newChannel| will not
     * be opened. It is important to understand that |oldChannel| will continue
     * loading as if it received a HTTP 200, which includes notifying observers
     * and possibly display or process content attached to the HTTP response.
     * If the sink wants to prevent this loading it must explicitly deal with
     * it, e.g. by calling |oldChannel->Cancel()|
     *
     * There is a certain freedom in implementing this method:
     *
     * If the return-value indicates success, a callback on |callback| is
     * required. This callback can be done from within asyncOnChannelRedirect
     * (effectively making the call synchronous) or at some point later
     * (making the call asynchronous). Repeat: A callback must be done
     * if this method returns successfully.
     *
     * If the return value indicates error (method throws an exception)
     * the redirect is vetoed and no callback must be done. Repeat: No
     * callback must be done if this method throws!
     *
     * NOTE: originalURI isn't yet set on the new channel when
     * asyncOnChannelRedirect is called.
     *
     * @see nsIAsyncVerifyRedirectCallback::onRedirectVerifyCallback()
     *
     * @param oldChannel
     * The channel that's being redirected.
     * @param newChannel
     * The new channel. This channel is not opened yet.
     * @param flags
     * Flags indicating the type of redirect. A bitmask consisting
     * of flags from above.
     * One of REDIRECT_TEMPORARY and REDIRECT_PERMANENT will always be
     * set.
     * @param callback
     * Object to inform about the async result of this method
     *
     * @throw <any> Throwing an exception will cause the redirect to be
     * cancelled
     */
    asyncOnChannelRedirect(oldChannel: nsIChannelType, newChannel: nsIChannelType, flags: unsigned_long, callback: nsIAsyncVerifyRedirectCallbackType): void;
}

/**
 * Implemented by content side of IPC protocols.
 */
declare interface nsIChildChannelType extends nsISupportsType {
    /**
     * Create the chrome side of the IPC protocol and join an existing 'real'
     * channel on the parent process.  The id is provided by
     * nsIRedirectChannelRegistrar on the chrome process and pushed to the child
     * protocol as an argument to event starting a redirect.
     *
     * Primarilly used in HttpChannelChild::Redirect1Begin on a newly created
     * child channel, where the new channel is intended to be created on the
     * child process.
     */
    connectParent(registrarId: uint32_t): void;
    /**
     * As AsyncOpen is called on the chrome process for redirect target channels,
     * we have to inform the child side of the protocol of that fact by a special
     * method.
     */
    completeRedirectSetup(aListener: nsIStreamListenerType): void;
}

/**
 *
 */
declare interface nsIChromeRegistryType extends nsISupportsType {
    /**
     * Resolve a chrome URL to an loadable URI using the information in the
     * registry. Does not modify aChromeURL.
     *
     * Chrome URLs are allowed to be specified in "shorthand", leaving the
     * "file" portion off. In that case, the URL is expanded to:
     *
     * chrome://package/provider/package.ext
     *
     * where "ext" is:
     *
     * "xul" for a "content" package,
     * "css" for a "skin" package, and
     * "dtd" for a "locale" package.
     *
     * @param aChromeURL the URL that is to be converted.
     */
    convertChromeURL(aChromeURL: nsIURIType): nsIURI;
    /**
     * refresh the chrome list at runtime, looking for new packages/etc
     */
    checkForNewChrome(): void;
}

/**
 *
 */
declare interface nsIXULChromeRegistryType extends nsIChromeRegistryType {
    /**
     *
     */
    isLocaleRTL(package: ACString): boolean;
    /**
     * Installable skin XBL is not always granted the same privileges as other
     * chrome. This asks the chrome registry whether scripts are allowed to be
     * run for a particular chrome URI. Do not pass non-chrome URIs to this
     * method.
     */
    allowScriptsForPackage(url: nsIURIType): boolean;
    /**
     * Content should only be allowed to load chrome JS from certain packages.
     * This method reflects the contentaccessible flag on packages.
     * Do not pass non-chrome URIs to this method.
     */
    allowContentToAccess(url: nsIURIType): boolean;
    /**
     * Returns true if the passed chrome URL is allowed to be loaded in a remote
     * process. This reflects the remoteenabled flag on packages.
     * Do not pass non-chrome URIs to this method.
     */
    canLoadURLRemotely(url: nsIURIType): boolean;
    /**
     * Returns true if the passed chrome URL must be loaded in a remote process.
     * This reflects the remoterequired flag on packages.
     * Do not pass non-chrome URIs to this method.
     */
    mustLoadURLRemotely(url: nsIURIType): boolean;
}

/**
 * Provides information about a specific implementation class.  If you want
 * your class to implement nsIClassInfo, see nsIClassInfoImpl.h for
 * instructions--you most likely do not want to inherit from nsIClassInfo.
 */
declare interface nsIClassInfoType extends nsISupportsType {
    /**
     * Return an object to assist XPConnect in supplying JavaScript-specific
     * behavior to callers of the instance object, or null if not needed.
     */
    getScriptableHelper(): nsIXPCScriptable;
    /**
     * A contract ID through which an instance of this class can be created
     * (or accessed as a service, if |flags & SINGLETON|), or null/void.
     */
    readonly contractID: AUTF8String;
    /**
     * A human readable string naming the class, or null/void.
     */
    readonly classDescription: AUTF8String;
    /**
     * A class ID through which an instance of this class can be created
     * (or accessed as a service, if |flags & SINGLETON|), or null.
     */
    readonly classID: nsCIDPtr;
    /**
     *
     */
    readonly flags: uint32_t;
    /**
     * Also a class ID through which an instance of this class can be created
     * (or accessed as a service, if |flags & SINGLETON|).  If the class does
     * not have a CID, it should return NS_ERROR_NOT_AVAILABLE.  This attribute
     * exists so C++ callers can avoid allocating and freeing a CID, as would
     * happen if they used classID.
     */
    readonly classIDNoAlloc: nsCID;
}

/**
 *
 */
declare interface nsIClassOfServiceType extends nsISupportsType {
    /**
     *
     */
    classFlags: unsigned_long;
    /**
     *
     */
    incremental: bool;
    /**
     *
     */
    clearClassFlags(flags: unsigned_long): void;
    /**
     *
     */
    addClassFlags(flags: unsigned_long): void;
    /**
     *
     */
    setClassOfService(s: ClassOfService): void;
}

/**
 * nsIClassifiedChannel
 *
 * A channel may optionally implement this interface if it carries classified
 * result information of channel classifier. The information contains, for
 * example, the name of matched table and the name of matched provider.
 */
declare interface nsIClassifiedChannelType extends nsISupportsType {
    /**
     * Sets matched info of the classified channel.
     *
     * @param aList
     * Name of the Safe Browsing list that matched (e.g. goog-phish-shavar).
     * @param aProvider
     * Name of the Safe Browsing provider that matched (e.g. google)
     * @param aFullHash
     * Full hash of URL that matched Safe Browsing list.
     */
    setMatchedInfo(aList: ACString, aProvider: ACString, aFullHash: ACString): void;
    /**
     * Name of the list that matched
     */
    readonly matchedList: ACString;
    /**
     * Name of provider that matched
     */
    readonly matchedProvider: ACString;
    /**
     * Full hash of URL that matched
     */
    readonly matchedFullHash: ACString;
    /**
     * Sets matched tracking info of the classified channel.
     *
     * @param aLists
     * Name of the Tracking Protection list that matched (e.g. content-track-digest256).
     * @param aFullHash
     * Full hash of URLs that matched Tracking Protection list.
     */
    setMatchedTrackingInfo(aLists: invalid, aFullHashes: invalid): void;
    /**
     * Returns the classification flags if the channel has been processed by
     * URL-Classifier features and is considered first-party.
     */
    readonly firstPartyClassificationFlags: unsigned_long;
    /**
     * Returns the classification flags if the channel has been processed by
     * URL-Classifier features and is considered third-party with the top
     * window URI.
     */
    readonly thirdPartyClassificationFlags: unsigned_long;
    /**
     * Returns the classification flags if the channel has been processed by
     * URL-Classifier features. This value is equal to
     * "firstPartyClassificationFlags || thirdPartyClassificationFlags".
     *
     * Note that top-level channels could be classified as well.
     * In order to identify third-party resources specifically, use
     * classificationThirdPartyFlags;
     */
    readonly classificationFlags: unsigned_long;
    /**
     * Returns true  if the channel has been processed by URL-Classifier features
     * and is considered third-party with the top window URI, and if it has loaded
     * a resource that is classified as a tracker.
     *
     * This is a helper attribute which returns the same value of
     * (thirdPartyClassificationFlags & CLASSIFIED_ANY_BASIC_TRACKING) or
     * (thirdPartyClassificationFlags & CLASSIFIED_ANY_STRICT_TRACKING) or
     * (thirdPartyClassificationFlags & CLASSIFIED_ANY_SOCIAL_TRACKING)
     */
    isThirdPartyTrackingResource(): boolean;
    /**
     * Returns true if the channel has loaded a 3rd party resource that is
     * classified as a social tracker.
     *
     * This is a helper attribute which returns the same value of
     * (classificationFlags & CLASSIFIED_ANY_SOCIAL_TRACKING)
     *
     * Note that top-level channels could be marked as tracking
     * resources. In order to identify third-party social tracking resources
     * specifically, check the flags manually or add a new helper here.
     */
    isThirdPartySocialTrackingResource(): boolean;
}

/**
 * nsIClearDataService
 *
 * Provides methods for cleaning data from a nsIPrincipal and/or from a time
 * range.
 */
declare interface nsIClearDataServiceType extends nsISupportsType {
    /**
     * Delete data owned by local files or other hostless schemes.
     * @param aIsUserRequest true if this request comes from a user interaction.
     * This information is important because if true, it's probably better
     * to remove more than less, for privacy reason. If false (e.g.
     * Clear-Site-Data header), we don't want to delete more than what is
     * strictly required.
     * @param aFlags List of flags. See below the accepted values.
     * Note that not all flags will make sense (e.g. we can't clear
     * certificates for local files). Nonsensical flags will be
     * ignored.
     * @param aCallback this callback will be executed when the operation is
     * completed.
     */
    deleteDataFromLocalFiles(aIsUserRequest: bool, aFlags: uint32_t, aCallback: nsIClearDataCallbackType): void;
    /**
     * Delete data owned by a host. For instance: mozilla.org. Data from any
     * possible originAttributes will be deleted.
     * @param aHost the host to be used.
     * @param aIsUserRequest true if this request comes from a user interaction.
     * This information is important because if true, it's probably better
     * to remove more than less, for privacy reason. If false (e.g.
     * Clear-Site-Data header), we don't want to delete more than what is
     * strictly required.
     * @param aFlags List of flags. See below the accepted values.
     * @param aCallback this callback will be executed when the operation is
     * completed.
     * @deprecated Use deleteDataFromBaseDomain instead.
     */
    deleteDataFromHost(aHost: AUTF8String, aIsUserRequest: bool, aFlags: uint32_t, aCallback: nsIClearDataCallbackType): void;
    /**
     * Delete data owned by or partitioned under a baseDomain (eTLD+1). For
     * instance: mozilla.org. Deletes data across all origin attributes. For
     * partitioned storage we clear both, data of the baseDomain in 1st-party and
     * 3rd-party context.
     * When handling user requests for clearing data using this method is
     * preferred over deleteDataFromPrincipal, since origins may share information
     * with their site (e.g. cookies) that are not deleted by principal.
     * @param aDomainOrHost the domain or host to be used. Will be converted to
     * baseDomain if needed.
     * @param aIsUserRequest true if this request comes from a user interaction.
     * This information is important because if true, it's probably better
     * to remove more than less, for privacy reason. If false (e.g.
     * Clear-Site-Data header), we don't want to delete more than what is
     * strictly required.
     * @param aFlags List of flags. See below the accepted values.
     * @param aCallback this callback will be executed when the operation is
     * completed.
     * @throws Throws if base domain can't be computed from aDomainOrHost. Callers
     * may fall back to clearing by principal or host.
     */
    deleteDataFromBaseDomain(aDomainOrHost: AUTF8String, aIsUserRequest: bool, aFlags: uint32_t, aCallback: nsIClearDataCallbackType): void;
    /**
     * Delete data owned by a principal.
     * @param aPrincipal the nsIPrincipal to be used.
     * @param aIsUserRequest true if this request comes from a user interaction.
     * This information is important because if true, it's probably better
     * to remove more than less, for privacy reason. If false (e.g.
     * Clear-Site-Data header), we don't want to delete more than what is
     * strictly required.
     * @param aFlags List of flags. See below the accepted values.
     * @param aCallback ths callback will be executed when the operation is
     * completed.
     */
    deleteDataFromPrincipal(aPrincipal: nsIPrincipalType, aIsUserRequest: bool, aFlags: uint32_t, aCallback: nsIClearDataCallbackType): void;
    /**
     * Delete all data in a time range. Limit excluded.
     * @param aFrom microseconds from the epoch
     * @param aTo microseconds from the epoch
     * @param aIsUserRequest true if this request comes from a user interaction.
     * This information is important because if true, it's probably better
     * to remove more than less, for privacy reason. If false (e.g.
     * Clear-Site-Data header), we don't want to delete more than what is
     * strictly required.
     * @param aFlags List of flags. See below the accepted values.
     * @param aCallback ths callback will be executed when the operation is
     * completed.
     */
    deleteDataInTimeRange(aFrom: PRTime, aTo: PRTime, aIsUserRequest: bool, aFlags: uint32_t, aCallback: nsIClearDataCallbackType): void;
    /**
     * Delete all data from any host, in any time range.
     * @param aFlags List of flags. See below the accepted values.
     * @param aCallback ths callback will be executed when the operation is
     * completed.
     */
    deleteData(aFlags: uint32_t, aCallback: nsIClearDataCallbackType): void;
    /**
     * Delete all data from an OriginAttributesPatternDictionary.
     * @param aOriginAttributesPattern the originAttributes dictionary.
     * @param aCallback the optional callback will be executed when the operation
     * is completed.
     */
    deleteDataFromOriginAttributesPattern(aOriginAttributesPattern: jsval, aCallback: nsIClearDataCallbackType): void;
    /**
     * This is a helper function to clear storageAccessAPI permissions
     * in a way that will not result in users getting logged out by
     * cookie purging. To that end we only clear permissions for principals
     * whose base domain does not have any storage associated with it.
     *
     * The principals to be considered will need to be passed by the API consumer.
     * It is recommended to use PrincipalsCollector.jsm for that.
     *
     * @param aPrincipalsWithStorage principals to be excluded from clearing
     * @param aFrom microseconds from the epoch
     * @param aCallback the optional callback will be executed when the operation
     * is completed.
     */
    deleteUserInteractionForClearingHistory(aPrincipalsWithStorage: invalid, aFrom: PRTime, aCallback: nsIClearDataCallbackType): void;
    /**
     * Some cleaners, namely QuotaCleaner, can opt in and treat things as deleted
     * without actually removing files at shutdown. This function will trigger
     * actual removal of them.
     */
    cleanupAfterDeletionAtShutdown(aFlags: uint32_t, aCallback: nsIClearDataCallbackType): void;
}

/**
 * This is a companion interface for
 * nsIClearDataService::deleteDataFromPrincipal().
 */
declare interface nsIClearDataCallbackType extends nsISupportsType {
    /**
     * Called to indicate that the data cleaning is completed.
     * @param aFailedFlags this value contains the flags that failed during the
     * cleanup. If nothing failed, aFailedFlags will be 0.
     */
    onDataDeleted(aFailedFlags: uint32_t): void;
}

/**
 * Rule to specify the CSS selector for detecting and clicking cookie banner.
 */
declare interface nsIClickRuleType extends nsISupportsType {
    /**
     * The CSS selector for detecting the presence of the cookie banner.
     */
    readonly presence: ACString;
    /**
     * Whether to skip checking if the banner is visible before clicking it.
     */
    readonly skipPresenceVisibilityCheck: boolean;
    /**
     * Where the click rule should be executed. See RunContext enum. Defaults to
     * RUN_TOP.
     */
    readonly runContext: nsIClickRule_RunContext;
    /**
     * The CSS selector for hiding the presence of the cookie banner. If this is
     * not given, we will use the presence selector to hide the banner.
     *
     * Note that we hide the cookie banner before we click it in order to prevent
     * flickers.
     */
    readonly hide: ACString;
    /**
     * The CSS selector to to select the element to click for the opt-out option
     * for the cookie banner.
     */
    readonly optOut: ACString;
    /**
     * The CSS selector to to select the element to click for the opt-in option
     * for the cookie banner.
     */
    readonly optIn: ACString;
}

/**
 *
 */
declare interface nsIClientAuthDialogCallbackType extends nsISupportsType {
    /**
     *
     */
    certificateChosen(cert: nsIX509CertType, rememberDecision: bool): void;
}

/**
 * Provides UI when a server requests a TLS client authentication certificate.
 */
declare interface nsIClientAuthDialogServiceType extends nsISupportsType {
    /**
     * Called when a user is asked to choose a certificate for client auth.
     *
     * @param hostname Hostname of the server.
     * @param certArray Array of certificates the user can choose from.
     * @param loadContext The nsILoadContext of the connection requesting a
     * certificate. May be null, in which case the
     * implementation will use the most recent window to show
     * UI.
     * @param callback The nsIClientAuthDialogCallback to call when a certificate
     * has been chosen (or no certificate).
     */
    chooseCertificate(hostname: AUTF8String, certArray: invalid, loadContext: nsILoadContextType, callback: nsIClientAuthDialogCallbackType): void;
}

/**
 * Provides UI for SSL client-auth dialogs.
 */
declare interface nsIClientAuthDialogsType extends nsISupportsType {
    /**
     * Called when a user is asked to choose a certificate for client auth.
     *
     * @param hostname Hostname of the server.
     * @param port Port of the server.
     * @param organization Organization field of the server cert.
     * @param issuerOrg Organization field of the issuer cert of the server cert.
     * @param certList List of certificates the user can choose from.
     * @param selectedIndex Index of the cert in |certList| that the user chose.
     * Ignored if the return value is false.
     * @param rememberClientAuthCertificate Whether to remember selection.
     * @return true if a certificate was chosen. false if the user canceled.
     */
    chooseCertificate(hostname: AUTF8String, port: long, organization: AUTF8String, issuerOrg: AUTF8String, certList: nsIArrayType, selectedIndex: unsigned_long, rememberClientAuthCertificate: boolean): boolean;
}

/**
 *
 */
declare interface nsIClientAuthRememberRecordType extends nsISupportsType {
    /**
     *
     */
    readonly asciiHost: ACString;
    /**
     *
     */
    readonly dbKey: ACString;
    /**
     *
     */
    readonly entryKey: ACString;
}

/**
 *
 */
declare interface nsIClientAuthRememberServiceType extends nsISupportsType {
    /**
     *
     */
    forgetRememberedDecision(key: ACString): void;
    /**
     *
     */
    rememberDecisionScriptable(aHostName: ACString, originAttributes: jsval, aClientCert: nsIX509CertType): void;
    /**
     *
     */
    hasRememberedDecisionScriptable(aHostName: ACString, originAttributes: jsval, aCertDBKey: ACString): bool;
    /**
     *
     */
    clearRememberedDecisions(): void;
    /**
     *
     */
    deleteDecisionsByHost(aHostName: ACString, aOriginAttributes: jsval): void;
}

/**
 *
 */
declare interface nsIAsyncSetClipboardDataType extends nsISupportsType {
    /**
     * Provide the data for the set request.
     *
     * @param  aTransferable
     * The transferable contains the data to be written.
     * @param  aOwner [optional]
     * The owner of the transferable.
     */
    setData(aTransferable: nsITransferableType, aOwner: nsIClipboardOwnerType): void;
    /**
     * Abort the request to set data.
     *
     * @param  aReason
     * The reason for the abort, can not be NS_OK.
     */
    abort(aReason: nsresult): void;
}

/**
 *
 */
declare interface nsIAsyncSetClipboardDataCallbackType extends nsISupportsType {
    /**
     * Indicates that the clipboard asyncSetData request has either succeeded or
     * been canceled.
     *
     * @param  aResult
     * The result of the request. NS_OK if successful, or another value
     * that indicates the reason for failure or cancellation.
     */
    onComplete(aResult: nsresult): void;
}

/**
 *
 */
declare interface nsIClipboardType extends nsISupportsType {
    /**
     * Given a transferable, set the data on the native clipboard
     *
     * @param  aTransferable The transferable
     * @param  anOwner The owner of the transferable
     * @param  aWhichClipboard Specifies the clipboard to which this operation applies.
     * @result NS_Ok if no errors
     */
    setData(aTransferable: nsITransferableType, anOwner: nsIClipboardOwnerType, aWhichClipboard: long): void;
    /**
     * Requests setting data to the native clipboard. The acutal set occur
     * when the data is provided by calling nsIAsyncSetClipboardData::setData().
     * The result will be notified by nsIClipboardCallback. A new set request
     * will cancel any prior pending requests, if any exist.
     *
     * @param  aWhichClipboard
     * Specifies the clipboard to which this operation applies.
     * @param  aCallback [optional]
     * The callback object that will be notified upon completion.
     * @return nsIAsyncSetClipboardData
     * The write request object. The actual write will occur when the
     * data is provided by calling nsIAsyncSetClipboardData::setData().
     */
    asyncSetData(aWhichClipboard: long, aCallback: nsIAsyncSetClipboardDataCallbackType): nsIAsyncSetClipboardData;
    /**
     * Filters the flavors aTransferable can import (see
     * `nsITransferable::flavorsTransferableCanImport`) and gets the data for the
     * first flavor. That data is set for aTransferable.
     *
     * @param  aTransferable The transferable
     * @param  aWhichClipboard Specifies the clipboard to which this operation applies.
     * @result NS_OK if no errors
     */
    getData(aTransferable: nsITransferableType, aWhichClipboard: long): void;
    /**
     * This empties the clipboard and notifies the clipboard owner.
     * This empties the "logical" clipboard. It does not clear the native clipboard.
     *
     * @param  aWhichClipboard Specifies the clipboard to which this operation applies.
     * @result NS_OK if successful.
     */
    emptyClipboard(aWhichClipboard: long): void;
    /**
     * This provides a way to give correct UI feedback about, for instance, a paste
     * should be allowed. It does _NOT_ actually retreive the data and should be a very
     * inexpensive call. All it does is check if there is data on the clipboard matching
     * any of the flavors in the given list.
     *
     * @param  aFlavorList     An array of ASCII strings.
     * @param  aWhichClipboard Specifies the clipboard to which this operation applies.
     * @outResult - if data is present matching one of
     * @result NS_OK if successful.
     */
    hasDataMatchingFlavors(aFlavorList: invalid, aWhichClipboard: long): boolean;
    /**
     * Allows clients to determine if the implementation supports the concept of a
     * separate clipboard.
     *
     * @param aWhichClipboard  Specifies the clipboard to which this operation applies.
     * @outResult  true if the implementaion supports specific clipboard type.
     * @result  NS_OK if successful.
     */
    isClipboardTypeSupported(aWhichClipboard: long): boolean;
}

/**
 * helper service for common uses of nsIClipboard.
 */
declare interface nsIClipboardHelperType extends nsISupportsType {
    /**
     * copy string to given clipboard
     *
     * @param aString, the string to copy to the clipboard
     * @param aClipboardID, the ID of the clipboard to copy to
     * (eg. kSelectionClipboard -- see nsIClipboard.idl)
     * @param aSensitive, optional flag to indicate that data is sensitive, like a password.
     * That will exclude data from Cloud Clipboard/Clipboard History on Windows.
     */
    copyStringToClipboard(aString: AString, aClipboardID: long, aSensitive: nsIClipboardHelper_SensitiveDataType): void;
    /**
     * copy string to (default) clipboard
     *
     * @param aString, the string to copy to the clipboard
     */
    copyString(aString: AString, aSensitive: nsIClipboardHelper_SensitiveDataType): void;
}

/**
 *
 */
declare interface nsIClipboardOwnerType extends nsISupportsType {
    /**
     * Notifies the owner of the clipboard transferable that the
     * transferable is being removed from the clipboard
     *
     * @param  aTransferable The transferable
     * @result NS_Ok if no errors
     */
    LosingOwnership(aTransferable: nsITransferableType): void;
}

/**
 *
 */
declare interface nsICloneableInputStreamType extends nsISupportsType {
    /**
     *
     */
    readonly cloneable: boolean;
    /**
     *
     */
    clone(): nsIInputStream;
}

/**
 *
 */
declare interface nsICloneableInputStreamWithRangeType extends nsICloneableInputStreamType {
    /**
     *
     */
    cloneWithRange(start: uint64_t, length: uint64_t): nsIInputStream;
}

/**
 * The nsICodeCoverage component allows controlling the code coverage counters
 * collected by Firefox during execution.
 * By flushing the counters, one can analyze the coverage information
 * for a subset of the program execution (e.g. startup code coverage).
 */
declare interface nsICodeCoverageType extends nsISupportsType {
    /**
     * Write the coverage counters to disk, and reset them in memory to 0.
     */
    flushCounters(): Promise;
}

/**
 * nsIColorPicker is representing colors as strings because the internal
 * representation will depend on the underlying backend.
 * The format of the colors taken in input and returned will always follow the
 * format of the <input type='color'> value as described in the HTML
 * specifications.
 */
declare interface nsIColorPickerShownCallbackType extends nsISupportsType {
    /**
     * Callback called when the color picker requests a color update.
     * This callback can not be called after done() was called.
     * When this callback is used, the consumer can assume that the color value has
     * changed.
     *
     * @param  color  The new selected color value following the format specifed on
     * top of this file.
     */
    update(color: AString): void;
    /**
     * Callback called when the color picker is dismissed.
     * When this callback is used, the color might have changed or could stay the
     * same.
     * If the color has not changed, the color parameter will be the empty string.
     *
     * @param  color  The new selected color value following the format specifed on
     * top of this file or the empty string.
     */
    done(color: AString): void;
}

/**
 *
 */
declare interface nsIColorPickerType extends nsISupportsType {
    /**
     * Initialize the color picker widget. The color picker will not be shown until
     * open() is called.
     * If the backend doesn't support setting a title to the native color picker
     * widget, the title parameter might be ignored.
     * If the initialColor parameter does not follow the format specified on top of
     * this file, the behavior will be unspecified. The initialColor could be the
     * one used by the underlying backend or an arbitrary one. The backend could
     * also assert.
     *
     * @param      parent       nsIDOMWindow parent. This dialog will be dependent
     * on this parent. parent must be non-null.
     * @param      title        The title for the color picker widget.
     * @param      initialColor The color to show when the widget is opened. The
     * parameter has to follow the format specified on top
     * of this file.
     */
    init(parent: mozIDOMWindowProxy, title: AString, initialColor: AString, defaultColors: invalid): void;
    /**
     * Opens the color dialog asynchrounously.
     * The results are provided via the callback object.
     */
    open(aColorPickerShownCallback: nsIColorPickerShownCallbackType): void;
}

/**
 * Represents the command line used to invoke a XUL application. This may be the
 * original command-line of this instance, or a command line remoted from another
 * instance of the application.
 *
 * DEFINITIONS:
 * "arguments" are any values found on the command line.
 * "flags" are switches. In normalized form they are preceded by a single dash.
 * Some flags may take "parameters", e.g. "--url <param>".
 */
declare interface nsICommandLineType extends nsISupportsType {
    /**
     * Number of arguments in the command line. The application name is not
     * part of the command line.
     */
    readonly length: long;
    /**
     * Get an argument from the array of command-line arguments.
     *
     * On windows, flags of the form /flag are normalized to -flag. /flag:param
     * are normalized to -flag param.
     *
     * On *nix and mac flags of the form --flag are normalized to -flag. --flag=param
     * are normalized to the form -flag param.
     *
     * @param aIndex The argument to retrieve. This index is 0-based, and does
     * not include the application name.
     * @return       The indexth argument.
     * @throws       NS_ERROR_ILLEGAL_VALUE if aIndex is out of bounds.
     */
    getArgument(aIndex: long): AString;
    /**
     * Find a command-line flag.
     *
     * @param aFlag          The flag name to locate. Do not include the initial
     * hyphen.
     * @param aCaseSensitive Whether to do case-sensitive comparisons.
     * @return               The position of the flag in the command line, or -1 if
     * not found.
     */
    findFlag(aFlag: AString, aCaseSensitive: boolean): long;
    /**
     * Remove arguments from the command line. This normally occurs after
     * a handler has processed the arguments.
     *
     * @param aStart  Index to begin removing.
     * @param aEnd    Index to end removing, inclusive.
     */
    removeArguments(aStart: long, aEnd: long): void;
    /**
     * A helper method which will find a flag and remove it in one step.
     *
     * @param aFlag  The flag name to find and remove.
     * @param aCaseSensitive Whether to do case-sensitive comparisons.
     * @return       Whether the flag was found.
     */
    handleFlag(aFlag: AString, aCaseSensitive: boolean): boolean;
    /**
     * Find a flag with a parameter and remove both. This is a helper
     * method that combines "findFlag" and "removeArguments" in one step.
     *
     * @return   null (a void astring) if the flag is not found. The parameter value
     * if found. Note that null and the empty string are not the same.
     * @throws   NS_ERROR_INVALID_ARG if the flag exists without a parameter
     *
     * @param aFlag The flag name to find and remove.
     * @param aCaseSensitive Whether to do case-sensitive flag search.
     */
    handleFlagWithParam(aFlag: AString, aCaseSensitive: boolean): AString;
    /**
     * The type of command line being processed.
     *
     * STATE_INITIAL_LAUNCH  is the first launch of the application instance.
     * STATE_REMOTE_AUTO     is a remote command line automatically redirected to
     * this instance.
     * STATE_REMOTE_EXPLICIT is a remote command line explicitly redirected to
     * this instance using xremote/windde/appleevents.
     */
    readonly state: unsigned_long;
    /**
     * There may be a command-line handler which performs a default action if
     * there was no explicit action on the command line (open a default browser
     * window, for example). This flag allows the default action to be prevented.
     */
    preventDefault: boolean;
    /**
     * The working directory for this command line. Use this property instead
     * of the working directory for the current process, since a redirected
     * command line may have had a different working directory.
     *
     * @throws NS_ERROR_NOT_INITIALIZED if the working directory was not specified.
     */
    readonly workingDirectory: nsIFile;
    /**
     * Resolve a file-path argument into an nsIFile. This method gracefully
     * handles relative or absolute file paths, according to the working
     * directory of this command line.
     * If the path is relative and there is no working directory available,
     * this may return null.
     *
     * @param aArgument  The path to resolve.
     */
    resolveFile(aArgument: AString): nsIFile;
    /**
     * Resolves a URI argument into a URI. This method has platform-specific
     * logic for converting an absolute URI or a relative file-path into the
     * appropriate URI object; it gracefully handles win32 C:\ paths which would
     * confuse the ioservice if passed directly.
     *
     * @param aArgument  The command-line argument to resolve.
     */
    resolveURI(aArgument: AString): nsIURI;
}

/**
 * Handles arguments on the command line of an XUL application.
 *
 * Each handler is registered in the category "command-line-handler".
 * The entries in this category are read in alphabetical order, and each
 * category value is treated as a service contractid implementing this
 * interface.
 *
 * By convention, handler with ordinary priority should begin with "m".
 *
 * Example:
 * Category             Entry          Value
 * command-line-handler c-extensions   @mozilla.org/extension-manager/clh;1
 * command-line-handler m-edit         @mozilla.org/composer/clh;1
 * command-line-handler m-irc          @mozilla.org/chatzilla/clh;1
 * command-line-handler y-final        @mozilla.org/browser/clh-final;1
 *
 * @note What do we do about localizing helpInfo? Do we make each handler do it,
 * or provide a generic solution of some sort? Don't freeze this interface
 * without thinking about this!
 */
declare interface nsICommandLineHandlerType extends nsISupportsType {
    /**
     * Process a command line. If this handler finds arguments that it
     * understands, it should perform the appropriate actions (such as opening
     * a window), and remove the arguments from the command-line array.
     *
     * @throw NS_ERROR_ABORT to immediately cease command-line handling
     * (if this is STATE_INITIAL_LAUNCH, quits the app).
     * All other exceptions are silently ignored.
     */
    handle(aCommandLine: nsICommandLineType): void;
    /**
     * When the app is launched with the --help argument, this attribute
     * is retrieved and displayed to the user (on stdout). The text should
     * have embedded newlines which wrap at 76 columns, and should include
     * a newline at the end. By convention, the right column which contains flag
     * descriptions begins at the 24th character.
     */
    readonly helpInfo: AUTF8String;
}

/**
 * Extension of nsICommandLine that allows for initialization of new command lines
 * and running the command line actions by processing the command line handlers.
 *
 * @status INTERNAL - This interface is not meant for use by embedders, and is
 * not intended to be frozen. If you are an embedder and need
 * functionality provided by this interface, talk to Benjamin
 * Smedberg <benjamin@smedbergs.us>.
 */
declare interface nsICommandLineRunnerType extends nsICommandLineType {
    /**
     * This method assumes a native character set, and is meant to be called
     * with the argc/argv passed to main(). Talk to bsmedberg if you need to
     * create a command line using other data. argv will not be altered in any
     * way.
     *
     * On Windows, the "native" character set is UTF-8, not the native codepage.
     *
     * @param workingDir The working directory for resolving file and URI paths.
     * Can be null, in which case resolving files will not
     * work, and only absolute URIs will be resolvable.
     * @param state      The nsICommandLine.state flag.
     */
    init(argc: long, argv: nsArgvArray, workingDir: nsIFileType, state: unsigned_long): void;
    /**
     * Process the command-line handlers in the proper order, calling "handle()" on
     * each.
     *
     * @throws NS_ERROR_ABORT if any handler throws NS_ERROR_ABORT. All other errors
     * thrown by handlers will be silently ignored.
     */
    run(): void;
    /**
     * Process and combine the help text provided by each command-line handler.
     */
    readonly helpText: AUTF8String;
}

/**
 * Validates arguments on the command line of an XUL application.
 *
 * Each validator is registered in the category "command-line-validator".
 * The entries in this category are read in alphabetical order, and each
 * category value is treated as a service contractid implementing this
 * interface.
 *
 * By convention, validator with ordinary priority should begin with "m".
 *
 * Example:
 * Category               Entry          Value
 * command-line-validator b-browser      @mozilla.org/browser/clh;1
 * command-line-validator m-edit         @mozilla.org/composer/clh;1
 * command-line-validator m-irc          @mozilla.org/chatzilla/clh;1
 */
declare interface nsICommandLineValidatorType extends nsISupportsType {
    /**
     * Process the command-line validators in the proper order, calling
     * "validate()" on each.
     *
     * @throws NS_ERROR_ABORT if any validator throws NS_ERROR_ABORT. All other
     * errors thrown by validators will be silently ignored.
     */
    validate(aCommandLine: nsICommandLineType): void;
}

/**
 * nsICommandManager is an interface used to executing user-level commands,
 * and getting the state of available commands.
 *
 * Commands are identified by strings, which are documented elsewhere.
 * In addition, the list of required and optional parameters for
 * each command, that are passed in via the nsICommandParams, are
 * also documented elsewhere. (Where? Need a good location for this).
 */
declare interface nsICommandManagerType extends nsISupportsType {
    /**
     * Register an observer on the specified command. The observer's Observe
     * method will get called when the state (enabled/disabled, or toggled etc)
     * of the command changes.
     *
     * You can register the same observer on multiple commmands by calling this
     * multiple times.
     */
    addCommandObserver(aCommandObserver: nsIObserverType, aCommandToObserve: string): void;
    /**
     * Stop an observer from observering the specified command. If the observer
     * was also registered on ther commands, they will continue to be observed.
     *
     * Passing an empty string in 'aCommandObserved' will remove the observer
     * from all commands.
     */
    removeCommandObserver(aCommandObserver: nsIObserverType, aCommandObserved: string): void;
    /**
     * Ask the command manager if the specified command is supported.
     * If aTargetWindow is null, the focused window is used.
     */
    isCommandSupported(aCommandName: string, aTargetWindow: mozIDOMWindowProxy): boolean;
    /**
     * Ask the command manager if the specified command is currently.
     * enabled.
     * If aTargetWindow is null, the focused window is used.
     */
    isCommandEnabled(aCommandName: string, aTargetWindow: mozIDOMWindowProxy): boolean;
    /**
     * Get the state of the specified commands.
     *
     * On input: aCommandParams filled in with values that the caller cares
     * about, most of which are command-specific (see the command documentation
     * for details). One boolean value, "enabled", applies to all commands,
     * and, in return will be set to indicate whether the command is enabled
     * (equivalent to calling isCommandEnabled).
     *
     * aCommandName is the name of the command that needs the state
     * aTargetWindow is the source of command controller
     * (null means use focus controller)
     * On output: aCommandParams: values set by the caller filled in with
     * state from the command.
     */
    getCommandState(aCommandName: string, aTargetWindow: mozIDOMWindowProxy, aCommandParams: nsICommandParamsType): void;
    /**
     * Execute the specified command.
     * The command will be executed in aTargetWindow if it is specified.
     * If aTargetWindow is null, it will go to the focused window.
     *
     * param: aCommandParams, a list of name-value pairs of command parameters,
     * may be null for parameter-less commands.
     */
    doCommand(aCommandName: string, aCommandParams: nsICommandParamsType, aTargetWindow: mozIDOMWindowProxy): void;
}

/**
 *
 */
declare interface nsICommandParamsType extends nsISupportsType {
    /**
     * getValueType
     *
     * Get the type of a specified parameter
     */
    getValueType(name: string): short;
    /**
     * get_Value
     *
     * Get the value of a specified parameter. Will return
     * an error if the parameter does not exist, or if the value
     * is of the wrong type (no coercion is performed for you).
     *
     * nsISupports values can contain any XPCOM interface,
     * as documented for the command. It is permissible
     * for it to contain nsICommandParams, but not *this*
     * one (i.e. self-containing is not allowed).
     */
    getBooleanValue(name: string): boolean;
    /**
     *
     */
    getLongValue(name: string): long;
    /**
     *
     */
    getDoubleValue(name: string): double;
    /**
     *
     */
    getStringValue(name: string): AString;
    /**
     *
     */
    getCStringValue(name: string): ACString;
    /**
     *
     */
    getISupportsValue(name: string): nsISupports;
    /**
     * set_Value
     *
     * Set the value of a specified parameter (thus creating
     * an entry for it).
     *
     * nsISupports values can contain any XPCOM interface,
     * as documented for the command. It is permissible
     * for it to contain nsICommandParams, but not *this*
     * one (i.e. self-containing is not allowed).
     */
    setBooleanValue(name: string, value: boolean): void;
    /**
     *
     */
    setLongValue(name: string, value: long): void;
    /**
     *
     */
    setDoubleValue(name: string, value: double): void;
    /**
     *
     */
    setStringValue(name: string, value: AString): void;
    /**
     *
     */
    setCStringValue(name: string, value: ACString): void;
    /**
     *
     */
    setISupportsValue(name: string, value: nsISupportsType): void;
    /**
     * removeValue
     *
     * Remove the specified parameter from the list.
     */
    removeValue(name: string): void;
}

/**
 *
 */
declare interface nsIComponentManagerType extends nsISupportsType {
    /**
     * getClassObject
     *
     * Returns the factory object that can be used to create instances of
     * CID aClass
     *
     * @param aClass The classid of the factory that is being requested
     */
    getClassObject(aClass: nsCIDRef, aIID: nsIIDRefType, result: nsQIResult): void;
    /**
     * getClassObjectByContractID
     *
     * Returns the factory object that can be used to create instances of
     * CID aClass
     *
     * @param aClass The classid of the factory that is being requested
     */
    getClassObjectByContractID(aContractID: string, aIID: nsIIDRefType, result: nsQIResult): void;
    /**
     * addBootstrappedManifestLocation
     *
     * Adds a bootstrapped manifest location on runtime.
     *
     * @param aLocation : A directory where chrome.manifest resides,
     * or an XPI with it on the root.
     */
    addBootstrappedManifestLocation(aLocation: nsIFileType): void;
    /**
     * removeBootstrappedManifestLocation
     *
     * Removes a bootstrapped manifest location on runtime.
     *
     * @param aLocation : A directory where chrome.manifest resides,
     * or an XPI with it on the root.
     */
    removeBootstrappedManifestLocation(aLocation: nsIFileType): void;
    /**
     * getManifestLocations
     *
     * Get an array of nsIURIs of all registered and builtin manifest locations.
     */
    getManifestLocations(): nsIArray;
    /**
     * Returns a list of JSM URLs which are used to create components. This
     * should only be used in automation.
     */
    getComponentJSMs(): nsIUTF8StringEnumerator;
    /**
     * Returns a list of ESM URLs which are used to create components. This
     * should only be used in automation.
     */
    getComponentESModules(): nsIUTF8StringEnumerator;
}

/**
 *
 */
declare interface nsIComponentRegistrarType extends nsISupportsType {
    /**
     * autoRegister
     *
     * Register a .manifest file, or an entire directory containing
     * these files. Registration lasts for this run only, and is not cached.
     *
     * @note Formerly this method would register component files directly. This
     * is no longer supported.
     */
    autoRegister(aSpec: nsIFileType): void;
    /**
     * registerFactory
     *
     * Register a factory with a given ContractID, CID and Class Name.
     *
     * @param aClass      : CID of object
     * @param aClassName  : Class Name of CID (unused)
     * @param aContractID : ContractID associated with CID aClass. May be null
     * if no contract ID is needed.
     * @param aFactory    : Factory that will be registered for CID aClass.
     * If aFactory is null, the contract will be associated
     * with a previously registered CID.
     */
    registerFactory(aClass: nsCIDRef, aClassName: string, aContractID: string, aFactory: nsIFactoryType): void;
    /**
     * unregisterFactory
     *
     * Unregister a factory associated with CID aClass.
     *
     * @param aClass   : CID being unregistered
     * @param aFactory : Factory previously registered to create instances of
     * CID aClass.
     *
     * @throws NS_ERROR* Method failure.
     */
    unregisterFactory(aClass: nsCIDRef, aFactory: nsIFactoryType): void;
    /**
     * isCIDRegistered
     *
     * Returns true if a factory is registered for the CID.
     *
     * @param aClass : CID queried for registeration
     * @return       : true if a factory is registered for CID
     * false otherwise.
     */
    isCIDRegistered(aClass: nsCIDRef): boolean;
    /**
     * isContractIDRegistered
     *
     * Returns true if a factory is registered for the contract id.
     *
     * @param aClass : contract id queried for registeration
     * @return       : true if a factory is registered for contract id
     * false otherwise.
     */
    isContractIDRegistered(aContractID: string): boolean;
    /**
     * contractIDToCID
     *
     * Returns the CID for a given Contract ID, if one exists and is registered.
     *
     * @return : Contract ID.
     */
    contractIDToCID(aContractID: string): nsCIDPtr;
}

/**
 * nsICompressConvStats
 *
 * This interface allows for the observation of decoded resource sizes
 */
declare interface nsICompressConvStatsType extends nsISupportsType {
    /**
     *
     */
    readonly decodedDataLength: uint64_t;
}

/**
 *
 */
declare interface nsIConsoleAPIStorageType extends nsISupportsType {
    /**
     * Get the events array by inner window ID or all events from all windows.
     *
     * @param string [aId]
     * Optional, the inner window ID for which you want to get the array of
     * cached events.
     * @returns array
     * The array of cached events for the given window. If no |aId| is
     * given this function returns all of the cached events, from any
     * window.
     */
    getEvents(aId: AString?): jsval;
    /**
     * Adds a listener to be notified of log events.
     *
     * @param jsval [aListener]
     * A JS listener which will be notified with the message object when
     * a log event occurs.
     * @param nsIPrincipal [aPrincipal]
     * The principal of the listener - used to determine if we need to
     * clone the message before forwarding it.
     */
    addLogEventListener(aListener: jsval?, aPrincipal: nsIPrincipalType?): void;
    /**
     * Removes a listener added with `addLogEventListener`.
     *
     * @param jsval [aListener]
     * A JS listener which was added with `addLogEventListener`.
     */
    removeLogEventListener(aListener: jsval?): void;
    /**
     * Record an event associated with the given window ID.
     *
     * @param string aId
     * The ID of the inner window for which the event occurred or "jsm" for
     * messages logged from JavaScript modules..
     * @param object aEvent
     * A JavaScript object you want to store.
     */
    recordEvent(aId: AString, aEvent: jsval): void;
    /**
     * Clear storage data for the given window.
     *
     * @param string [aId]
     * Optional, the inner window ID for which you want to clear the
     * messages. If this is not specified all of the cached messages are
     * cleared, from all window objects.
     */
    clearEvents(aId: AString?): void;
}

/**
 *
 */
declare interface nsIConsoleListenerType extends nsISupportsType {
    /**
     *
     */
    observe(aMessage: nsIConsoleMessageType): void;
}

/**
 * This is intended as a base interface; implementations may want to
 * provide an object that can be qi'ed to provide more specific
 * message information.
 */
declare interface nsIConsoleMessageType extends nsISupportsType {
    /**
     * The log level of this message.
     */
    readonly logLevel: uint32_t;
    /**
     * The time (in milliseconds from the Epoch) that the message instance
     * was initialised.
     * The timestamp is initialized as JS_now/1000 so that it can be
     * compared to Date.now in Javascript.
     */
    readonly timeStamp: long_long;
    /**
     * The time (in microseconds from the Epoch) that the message instance
     * was initialised.
     * The timestamp is initialized as JS_now.
     */
    readonly microSecondTimeStamp: long_long;
    /**
     *
     */
    readonly message: AString;
    /**
     *
     */
    isForwardedFromContentProcess: boolean;
    /**
     *
     */
    toString(): AUTF8String;
}

/**
 *
 */
declare interface nsIConsoleServiceType extends nsISupportsType {
    /**
     *
     */
    logMessage(message: nsIConsoleMessageType): void;
    /**
     *
     */
    callFunctionAndLogException(targetGlobal: jsval, _function: jsval): jsval;
    /**
     *
     */
    logMessageWithMode(message: nsIConsoleMessageType, mode: nsIConsoleService_OutputModeType): void;
    /**
     * Convenience method for logging simple messages.
     */
    logStringMessage(message: wstring): void;
    /**
     * To guard against stack overflows from listeners that could log
     * messages (it's easy to do this inadvertently from listeners
     * implemented in JavaScript), we don't call any listeners when
     * another error is already being logged.
     */
    registerListener(listener: nsIConsoleListenerType): void;
    /**
     * Each registered listener should also be unregistered.
     */
    unregisterListener(listener: nsIConsoleListenerType): void;
    /**
     * Clear the message buffer (e.g. for privacy reasons).
     */
    reset(): void;
    /**
     * Clear the message buffer for a given window.
     */
    resetWindow(windowInnerId: uint64_t): void;
}

/**
 * This file contains an interface to the ContentBlockingAllowList.
 */
declare interface nsIContentBlockingAllowListType extends nsISupportsType {
    /**
     * Computes a contentBlockingAllowList principal for a given content principal.
     *
     * @param aPrincipal the content principal for which the contentBlockingAllowList principal is computed.
     * @return a contentBlockingAllowList principal.
     */
    computeContentBlockingAllowListPrincipal(aPrincipal: nsIPrincipalType): nsIPrincipal;
}

/**
 * This is used to ask a user what they would like to do with a given piece of
 * content.
 */
declare interface nsIContentDispatchChooserType extends nsISupportsType {
    /**
     * Opens the handler associated with the given resource.
     * If the caller does not have permission or no handler is set, we ask the
     * user to grant permission and pick a handler.
     *
     * @param aHander
     * The interface describing the details of how this content should or
     * can be handled.
     * @param aURI
     * The URI of the resource that we are asking about.
     * @param aTriggeringPrincipal
     * The principal making the request.
     * @param aBrowsingContext
     * The browsing context where the load should happen.
     * @param aWasTriggeredExternally
     * True if the load was tripped by an external app.
     */
    handleURI(aHandler: nsIHandlerInfoType, aURI: nsIURIType, aTriggeringPrincipal: nsIPrincipalType, aBrowsingContext: BrowsingContext, aWasTriggeredExternally: bool): void;
}

/**
 *
 */
declare interface nsIContentHandlerType extends nsISupportsType {
    /**
     * Tells the content handler to take over handling the content. If this
     * function succeeds, the URI Loader will leave this request alone, ignoring
     * progress notifications. Failure of this method will cause the request to be
     * cancelled, unless the error code is NS_ERROR_WONT_HANDLE_CONTENT (see
     * below).
     *
     * @param aWindowContext
     * Window context, used to get things like the current nsIDOMWindow
     * for this request. May be null.
     * @param aContentType
     * The content type of aRequest
     * @param aRequest
     * A request whose content type is already known.
     *
     * @throw NS_ERROR_WONT_HANDLE_CONTENT Indicates that this handler does not
     * want to handle this content. A different way for handling this
     * content should be tried.
     */
    handleContent(aContentType: string, aWindowContext: nsIInterfaceRequestorType, aRequest: nsIRequestType): void;
}

/**
 * Interface provides the request type and its access.
 */
declare interface nsIContentPermissionTypeType extends nsISupportsType {
    /**
     * The type of the permission request, such as
     * "geolocation".
     */
    readonly type: ACString;
    /**
     * The array of available options.
     */
    readonly options: nsIArray;
}

/**
 * Interface allows access to a content to request
 * permission to perform a privileged operation such as
 * geolocation.
 */
declare interface nsIContentPermissionRequestType extends nsISupportsType {
    /**
     * The array will include the request types. Elements of this array are
     * nsIContentPermissionType object.
     */
    readonly types: nsIArray;
    /**
     * The principal of the permission request.
     */
    readonly principal: nsIPrincipal;
    /**
     * The principal of the top-level page the permission request comes from.
     */
    readonly topLevelPrincipal: nsIPrincipal;
    /**
     * The window or element that the permission request was
     * originated in.  Typically the element will be non-null
     * in when using out of process content.  window or
     * element can be null but not both.
     */
    readonly window: mozIDOMWindow;
    /**
     *
     */
    readonly element: Element;
    /**
     *
     */
    readonly hasValidTransientUserGestureActivation: boolean;
    /**
     * See nsIPermissionDelegateHandler.maybeUnsafePermissionDelegate.
     */
    readonly isRequestDelegatedToUnsafeThirdParty: boolean;
    /**
     * Get delegate principal of the permission request. This will return nullptr,
     * or request's principal or top level principal based on the delegate policy
     * will be applied for a given type.
     *
     * @param aType the permission type to get
     */
    getDelegatePrincipal(aType: ACString): nsIPrincipal;
    /**
     * allow or cancel the request
     */
    cancel(): void;
    /**
     *
     */
    allow(choices: jsval): void;
}

/**
 * Allows to show permission prompts via the UI for different types of requests,
 * e.g. geolocation.
 */
declare interface nsIContentPermissionPromptType extends nsISupportsType {
    /**
     * Called when a request has been made to access
     * privileged content apis
     */
    prompt(request: nsIContentPermissionRequestType): void;
}

/**
 * Interface for content policy mechanism.  Implementations of this
 * interface can be used to control loading of various types of out-of-line
 * content, or processing of certain types of in-line content.
 *
 * WARNING: do not block the caller from shouldLoad or shouldProcess (e.g.,
 * by launching a dialog to prompt the user for something).
 */
declare interface nsIContentPolicyType extends nsISupportsType {
    /**
     * Should the resource at this location be loaded?
     * ShouldLoad will be called before loading the resource at aContentLocation
     * to determine whether to start the load at all.
     *
     * @param aContentLocation  the location of the content being checked; must
     * not be null
     *
     * @param aLoadInfo         the loadinfo of the channel being evaluated.
     *
     * @param aMimeTypeGuess    OPTIONAL. a guess for the requested content's
     * MIME type, based on information available to
     * the request initiator (e.g., an OBJECT's type
     * attribute); does not reliably reflect the
     * actual MIME type of the requested content
     *
     * @return ACCEPT or REJECT_*
     *
     * @note shouldLoad can be called while the DOM and layout of the document
     * involved is in an inconsistent state.  This means that implementors of
     * this method MUST NOT do any of the following:
     * 1)  Modify the DOM in any way (e.g. setting attributes is a no-no).
     * 2)  Query any DOM properties that depend on layout (e.g. offset*
     * properties).
     * 3)  Query any DOM properties that depend on style (e.g. computed style).
     * 4)  Query any DOM properties that depend on the current state of the DOM
     * outside the "context" node (e.g. lengths of node lists).
     * 5)  [JavaScript implementations only] Access properties of any sort on any
     * object without using XPCNativeWrapper (either explicitly or
     * implicitly).  Due to various DOM0 things, this leads to item 4.
     * If you do any of these things in your shouldLoad implementation, expect
     * unpredictable behavior, possibly including crashes, content not showing
     * up, content showing up doubled, etc.  If you need to do any of the things
     * above, do them off timeout or event.
     */
    shouldLoad(aContentLocation: nsIURIType, aLoadInfo: nsILoadInfoType, aMimeTypeGuess: ACString): short;
    /**
     * Should the resource be processed?
     * ShouldProcess will be called once all the information passed to it has
     * been determined about the resource, typically after part of the resource
     * has been loaded.
     *
     * @param aContentLocation  OPTIONAL; the location of the resource being
     * requested: MAY be, e.g., a post-redirection URI
     * for the resource.
     *
     * @param aLoadInfo         the loadinfo of the channel being evaluated.
     *
     * @param aMimeType         the MIME type of the requested resource (e.g.,
     * image/png), as reported by the networking library,
     * if available (may be empty if inappropriate for
     * the type).
     *
     * @return ACCEPT or REJECT_*
     *
     * @note shouldProcess can be called while the DOM and layout of the document
     * involved is in an inconsistent state.  See the note on shouldLoad to see
     * what this means for implementors of this method.
     */
    shouldProcess(aContentLocation: nsIURIType, aLoadInfo: nsILoadInfoType, aMimeType: ACString): short;
}

/**
 *
 */
declare interface nsIContentPrefObserverType extends nsISupportsType {
    /**
     * Called when a content pref is set to a different value.
     *
     * @param    aGroup      the group to which the pref belongs, or null
     * if it's a global pref (applies to all sites)
     * @param    aName       the name of the pref that was set
     * @param    aValue      the new value of the pref
     * @param    aIsPrivate  an optional flag determining whether the
     * original context is private or not
     */
    onContentPrefSet(aGroup: AString, aName: AString, aValue: nsIVariantType, aIsPrivate: boolean): void;
    /**
     * Called when a content pref is removed.
     *
     * @param    aGroup      the group to which the pref belongs, or null
     * if it's a global pref (applies to all sites)
     * @param    aName       the name of the pref that was removed
     * @param    aIsPrivate  an optional flag determining whether the
     * original context is private or not
     */
    onContentPrefRemoved(aGroup: AString, aName: AString, aIsPrivate: boolean): void;
}

/**
 * Content Preferences
 *
 * Content preferences allow the application to associate arbitrary data, or
 * "preferences", with specific domains, or web "content".  Specifically, a
 * content preference is a structure with three values: a domain with which the
 * preference is associated, a name that identifies the preference within its
 * domain, and a value.  (See nsIContentPref below.)
 *
 * For example, if you want to remember the user's preference for a certain zoom
 * level on www.mozilla.org pages, you might store a preference whose domain is
 * "www.mozilla.org", whose name is "zoomLevel", and whose value is the numeric
 * zoom level.
 *
 * A preference need not have a domain, and in that case the preference is
 * called a "global" preference.  This interface doesn't impart any special
 * significance to global preferences; they're simply name-value pairs that
 * aren't associated with any particular domain.  As a consumer of this
 * interface, you might choose to let a global preference override all non-
 * global preferences of the same name, for example, for whatever definition of
 * "override" is appropriate for your use case.
 *
 *
 * Domain Parameters
 *
 * Many methods of this interface accept a "domain" parameter.  Domains may be
 * specified either exactly, like "example.com", or as full URLs, like
 * "http://example.com/foo/bar".  In the latter case the API extracts the full
 * domain from the URL, so if you specify "http://foo.bar.example.com/baz", the
 * domain is taken to be "foo.bar.example.com", not "example.com".
 *
 *
 * Private-Browsing Context Parameters
 *
 * Many methods also accept a "context" parameter.  This parameter relates to
 * private browsing and determines the kind of storage that a method uses,
 * either the usual permanent storage or temporary storage set aside for private
 * browsing sessions.
 *
 * Pass null to unconditionally use permanent storage.  Pass an nsILoadContext
 * to use storage appropriate to the context's usePrivateBrowsing attribute: if
 * usePrivateBrowsing is true, temporary private-browsing storage is used, and
 * otherwise permanent storage is used.  A context can be obtained from the
 * window or channel whose content pertains to the preferences being modified or
 * retrieved.
 *
 *
 * Callbacks
 *
 * The methods of callback objects are always called asynchronously.
 *
 * Observers are called after callbacks are called, but they are called in the
 * same turn of the event loop as callbacks.
 *
 * See nsIContentPrefCallback2 below for more information about callbacks.
 */
declare interface nsIContentPrefService2Type extends nsISupportsType {
    /**
     * Gets all the preferences with the given name.
     *
     * @param name      The preferences' name.
     * @param context   The private-browsing context, if any.
     * @param callback  handleResult is called once for each preference unless
     * no such preferences exist, in which case handleResult
     * is not called at all.
     */
    getByName(name: AString, context: nsILoadContextType, callback: nsIContentPrefCallback2Type): void;
    /**
     * Gets the preference with the given domain and name.
     *
     * @param domain    The preference's domain.
     * @param name      The preference's name.
     * @param context   The private-browsing context, if any.
     * @param callback  handleResult is called once unless no such preference
     * exists, in which case handleResult is not called at all.
     */
    getByDomainAndName(domain: AString, name: AString, context: nsILoadContextType, callback: nsIContentPrefCallback2Type): void;
    /**
     * Gets all preferences with the given name whose domains are either the same
     * as or subdomains of the given domain.
     *
     * @param domain    The preferences' domain.
     * @param name      The preferences' name.
     * @param context   The private-browsing context, if any.
     * @param callback  handleResult is called once for each preference.  If no
     * such preferences exist, handleResult is not called at all.
     */
    getBySubdomainAndName(domain: AString, name: AString, context: nsILoadContextType, callback: nsIContentPrefCallback2Type): void;
    /**
     * Gets the preference with no domain and the given name.
     *
     * @param name      The preference's name.
     * @param context   The private-browsing context, if any.
     * @param callback  handleResult is called once unless no such preference
     * exists, in which case handleResult is not called at all.
     */
    getGlobal(name: AString, context: nsILoadContextType, callback: nsIContentPrefCallback2Type): void;
    /**
     * Synchronously retrieves from the in-memory cache the preference with the
     * given domain and name.
     *
     * In addition to caching preference values, the cache also keeps track of
     * preferences that are known not to exist.  If the preference is known not to
     * exist, the value attribute of the returned object will be undefined
     * (nsIDataType::VTYPE_VOID).
     *
     * If the preference is neither cached nor known not to exist, then null is
     * returned, and get() must be called to determine whether the preference
     * exists.
     *
     * @param domain   The preference's domain.
     * @param name     The preference's name.
     * @param context  The private-browsing context, if any.
     * @return         The preference, or null if no such preference is known to
     * exist.
     */
    getCachedByDomainAndName(domain: AString, name: AString, context: nsILoadContextType): nsIContentPref;
    /**
     * Synchronously retrieves from the in-memory cache the preference with no
     * domain and the given name.
     *
     * As with getCachedByDomainAndName, if the preference is cached then it is
     * returned; if the preference is known not to exist, then the value attribute
     * of the returned object will be undefined; if the preference is neither
     * cached nor known not to exist, then null is returned.
     *
     * @param name     The preference's name.
     * @param context  The private-browsing context, if any.
     * @return         The preference, or null if no such preference is known to
     * exist.
     */
    getCachedGlobal(name: AString, context: nsILoadContextType): nsIContentPref;
    /**
     * Sets a preference.
     *
     * @param domain    The preference's domain.
     * @param name      The preference's name.
     * @param value     The preference's value.
     * @param context   The private-browsing context, if any.
     * @param callback  handleCompletion is called when the preference has been
     * stored.
     */
    set(domain: AString, name: AString, value: nsIVariantType, context: nsILoadContextType, callback: nsIContentPrefCallback2Type): void;
    /**
     * Sets a preference with no domain.
     *
     * @param name      The preference's name.
     * @param value     The preference's value.
     * @param context   The private-browsing context, if any.
     * @param callback  handleCompletion is called when the preference has been
     * stored.
     */
    setGlobal(name: AString, value: nsIVariantType, context: nsILoadContextType, callback: nsIContentPrefCallback2Type): void;
    /**
     * Removes the preference with the given domain and name.
     *
     * @param domain    The preference's domain.
     * @param name      The preference's name.
     * @param context   The private-browsing context, if any.
     * @param callback  handleCompletion is called when the operation completes.
     */
    removeByDomainAndName(domain: AString, name: AString, context: nsILoadContextType, callback: nsIContentPrefCallback2Type): void;
    /**
     * Removes all the preferences with the given name whose domains are either
     * the same as or subdomains of the given domain.
     *
     * @param domain    The preferences' domain.
     * @param name      The preferences' name.
     * @param context   The private-browsing context, if any.
     * @param callback  handleCompletion is called when the operation completes.
     */
    removeBySubdomainAndName(domain: AString, name: AString, context: nsILoadContextType, callback: nsIContentPrefCallback2Type): void;
    /**
     * Removes the preference with no domain and the given name.
     *
     * @param name      The preference's name.
     * @param context   The private-browsing context, if any.
     * @param callback  handleCompletion is called when the operation completes.
     */
    removeGlobal(name: AString, context: nsILoadContextType, callback: nsIContentPrefCallback2Type): void;
    /**
     * Removes all preferences with the given domain.
     *
     * @param domain    The preferences' domain.
     * @param context   The private-browsing context, if any.
     * @param callback  handleCompletion is called when the operation completes.
     */
    removeByDomain(domain: AString, context: nsILoadContextType, callback: nsIContentPrefCallback2Type): void;
    /**
     * Removes all preferences whose domains are either the same as or subdomains
     * of the given domain.
     *
     * @param domain    The preferences' domain.
     * @param context   The private-browsing context, if any.
     * @param callback  handleCompletion is called when the operation completes.
     */
    removeBySubdomain(domain: AString, context: nsILoadContextType, callback: nsIContentPrefCallback2Type): void;
    /**
     * Removes all preferences with the given name regardless of domain, including
     * global preferences with the given name.
     *
     * @param name      The preferences' name.
     * @param context   The private-browsing context, if any.
     * @param callback  handleCompletion is called when the operation completes.
     */
    removeByName(name: AString, context: nsILoadContextType, callback: nsIContentPrefCallback2Type): void;
    /**
     * Removes all non-global preferences -- in other words, all preferences that
     * have a domain.
     *
     * @param context   The private-browsing context, if any.
     * @param callback  handleCompletion is called when the operation completes.
     */
    removeAllDomains(context: nsILoadContextType, callback: nsIContentPrefCallback2Type): void;
    /**
     * Removes all non-global preferences created after and including |since|.
     *
     * @param since     Timestamp in milliseconds.
     * @param context   The private-browsing context, if any.
     * @param callback  handleCompletion is called when the operation completes.
     */
    removeAllDomainsSince(since: unsigned_long_long, context: nsILoadContextType, callback: nsIContentPrefCallback2Type): void;
    /**
     * Removes all global preferences -- in other words, all preferences that have
     * no domain.
     *
     * @param context   The private-browsing context, if any.
     * @param callback  handleCompletion is called when the operation completes.
     */
    removeAllGlobals(context: nsILoadContextType, callback: nsIContentPrefCallback2Type): void;
    /**
     * Registers an observer that will be notified whenever a preference with the
     * given name is set or removed.
     *
     * When a set or remove method is called, observers are called after the set
     * or removal completes and after the method's callback is called, and they
     * are called in the same turn of the event loop as the callback.
     *
     * The service holds a strong reference to the observer, so the observer must
     * be removed later to avoid leaking it.
     *
     * @param name      The name of the preferences to observe.  Pass null to
     * observe all preference changes regardless of name.
     * @param observer  The observer.
     */
    addObserverForName(name: AString, observer: nsIContentPrefObserverType): void;
    /**
     * Unregisters an observer for the given name.
     *
     * @param name      The name for which the observer was registered.  Pass null
     * if the observer was added with a null name.
     * @param observer  The observer.
     */
    removeObserverForName(name: AString, observer: nsIContentPrefObserverType): void;
    /**
     * Extracts and returns the domain from the given string representation of a
     * URI.  This is how the API extracts domains from URIs passed to it.
     *
     * @param str  The string representation of a URI, like
     * "http://example.com/foo/bar".
     * @return     If the given string is a valid URI, the domain of that URI is
     * returned.  Otherwise, the string itself is returned.
     */
    extractDomain(str: AString): AString;
}

/**
 * The callback used by the above methods.
 */
declare interface nsIContentPrefCallback2Type extends nsISupportsType {
    /**
     * For the retrieval methods, this is called once for each retrieved
     * preference.  It is not called for other methods.
     *
     * @param pref  The retrieved preference.
     */
    handleResult(pref: nsIContentPrefType): void;
    /**
     * Called when an error occurs.  This may be called multiple times before
     * handleCompletion is called.
     *
     * @param error  A number in Components.results describing the error.
     */
    handleError(error: nsresult): void;
    /**
     * Called when the method finishes.  This will be called exactly once for
     * each method invocation, and afterward no other callback methods will be
     * called.
     *
     * @param reason  One of the COMPLETE_* values indicating the manner in which
     * the method completed.
     */
    handleCompletion(reason: unsigned_short): void;
}

/**
 *
 */
declare interface nsIContentPrefType extends nsISupportsType {
    /**
     *
     */
    readonly domain: AString;
    /**
     *
     */
    readonly name: AString;
    /**
     *
     */
    readonly value: nsIVariant;
}

/**
 *
 */
declare interface nsIContentProcessInfoType extends nsISupportsType {
    /**
     * Is this content process alive?
     */
    readonly isAlive: boolean;
    /**
     * The content process's PID.
     * Throws if the process is not alive.
     */
    readonly processId: int32_t;
    /**
     * Number of opened tabs living in this content process.
     */
    readonly tabCount: int32_t;
    /**
     * The process manager for this ContentParent (so a process message manager
     * as opposed to a frame message manager.
     */
    readonly messageManager: nsISupports;
}

/**
 *
 */
declare interface nsIContentProcessProviderType extends nsISupportsType {
    /**
     * Given aAliveProcesses, choose which process of aType to use. Return
     * nsIContentProcessProvider.NEW_PROCESS to ask the caller to create a new
     * content process.
     */
    provideProcess(aType: AUTF8String, aAliveProcesses: invalid, aMaxCount: uint32_t): int32_t;
}

/**
 * nsIContentSecurityManager
 * Describes an XPCOM component used to perform security checks.
 */
declare interface nsIContentSecurityManagerType extends nsISupportsType {
    /**
     * Checks whether a channel is allowed to access the given URI and
     * whether the channel should be openend or should be blocked consulting
     * internal security checks like Same Origin Policy, Content Security
     * Policy, Mixed Content Blocker, etc.
     *
     * If security checks within performSecurityCheck fail, the function
     * throws an exception.
     *
     * @param aChannel
     * The channel about to be openend
     * @param aStreamListener
     * The Streamlistener of the channel potentially wrapped
     * into CORSListenerProxy.
     * @return
     * The StreamListener of the channel wrapped into CORSListenerProxy.
     *
     * @throws NS_ERROR_DOM_BAD_URI
     * If accessing the URI is not allowed (e.g. prohibted by SOP)
     * @throws NS_ERROR_CONTENT_BLOCKED
     * If any of the security policies (CSP, Mixed content) is violated
     */
    performSecurityCheck(aChannel: nsIChannelType, aStreamListener: nsIStreamListenerType): nsIStreamListener;
}

/**
 *
 */
declare interface nsIContentSecurityPolicyType extends nsISerializableType {
    /**
     * Accessor method for a read-only string version of the policy at a given
     * index.
     */
    getPolicy(index: unsigned_long): AString;
    /**
     * Returns the number of policies attached to this CSP instance.  Useful with
     * getPolicy().
     */
    readonly policyCount: unsigned_long;
    /**
     * Returns whether this policy uses the directive upgrade-insecure-requests.
     * Please note that upgrade-insecure-reqeusts also applies if the parent or
     * including document (context) makes use of the directive.
     */
    readonly upgradeInsecureRequests: bool;
    /**
     * Returns whether this policy uses the directive block-all-mixed-content.
     * Please note that block-all-mixed-content takes presedence in case the
     * directive upgrade-insecure-requests is defined in the same policy and
     * will therefore block all mixed content without even trying to perform
     * an upgrade.
     */
    readonly blockAllMixedContent: bool;
    /**
     * Returns whether this policy enforces the frame-ancestors directive.
     */
    readonly enforcesFrameAncestors: bool;
    /**
     * Parse and install a CSP policy.
     * @param aPolicy
     * String representation of the policy
     * (e.g., header value, meta content)
     * @param reportOnly
     * Should this policy affect content, script and style processing or
     * just send reports if it is violated?
     * @param deliveredViaMetaTag
     * Indicates whether the policy was delivered via the meta tag.
     */
    appendPolicy(policyString: AString, reportOnly: boolean, deliveredViaMetaTag: boolean): void;
    /**
     * Whether this policy allows inline script or style.
     * @param aContentPolicyType Either SCRIPT_SRC_(ELEM|ATTR)_DIRECTIVE or
     * STYLE_SRC_(ELEM|ATTR)_DIRECTIVE.
     * @param aHasUnsafeHash Only hash this when the 'unsafe-hashes' directive is
     * also specified.
     * @param aNonce The nonce string to check against the policy
     * @param aParserCreated If the script element was created by the HTML Parser
     * @param aTriggeringElement The script element of the inline resource to
     * hash. It can be null.
     * @param aContentOfPseudoScript The content of the psuedo-script to compare
     * to hash (and compare to the hashes listed in
     * the policy)
     * @param aLineNumber The line number of the inline resource
     * (used for reporting)
     * @param aColumnNumber The column number of the inline resource
     * (used for reporting)
     * @return
     * Whether or not the effects of the inline style should be allowed
     * (block the rules if false).
     */
    getAllowsInline(aDirective: nsIContentSecurityPolicy_CSPDirectiveType, aHasUnsafeHash: bool, aNonce: AString, aParserCreated: boolean, aTriggeringElement: Element, aCSPEventListener: nsICSPEventListenerType, aContentOfPseudoScript: AString, aLineNumber: unsigned_long, aColumnNumber: unsigned_long): boolean;
    /**
     * Whether this policy allows a navigation subject to the navigate-to
     * policy.
     * @param aURI The target URI
     * @param aIsFormSubmission True if the navigation was initiated by a form submission. This
     * is important since the form-action directive overrides navigate-to in that case.
     * @param aWasRedirect True if a redirect has happened. Important for path-sensitivity.
     * @param aEnforceAllowlist True if the allowlist of allowed targets must be enforced. If
     * this is true, the allowlist must be enforced even if 'unsafe-allow-redirects' is
     * used. If 'unsafe-allow-redirects' is not used then the allowlist is always enforced
     * @return
     * Whether or not the effects of the navigation is allowed
     */
    getAllowsNavigateTo(aURI: nsIURIType, aIsFormSubmission: boolean, aWasRedirected: boolean, aEnforceAllowlist: boolean): boolean;
    /**
     * Whether this policy allows eval and eval-like functions
     * such as setTimeout("code string", time).
     * @param shouldReportViolations
     * Whether or not the use of eval should be reported.
     * This function returns "true" when violating report-only policies, but
     * when any policy (report-only or otherwise) is violated,
     * shouldReportViolations is true as well.
     * @return
     * Whether or not the effects of the eval call should be allowed
     * (block the call if false).
     */
    getAllowsEval(shouldReportViolations: boolean): boolean;
    /**
     * Whether this policy allows the evaluation (and compilation) of
     * WASM code from functions like `WebAssembly.compile`.
     * @param shouldReportViolations
     * Whether or not the use of WASM evaluation should be reported.
     * This function returns "true" when violating report-only policies, but
     * when any policy (report-only or otherwise) is violated,
     * shouldReportViolations is true as well.
     * @return
     * Whether or not the effects of the WASM evaluation should be allowed
     * (block the call if false).
     */
    getAllowsWasmEval(shouldReportViolations: boolean): boolean;
    /**
     * Delegate method called by the service when the protected document is loaded.
     * Returns the union of all the sandbox flags contained in CSP policies. This is the most
     * restrictive interpretation of flags set in multiple policies.
     * See nsSandboxFlags.h for the possible flags.
     *
     * @return
     * sandbox flags or SANDBOXED_NONE if no sandbox directive exists
     */
    getCSPSandboxFlags(): uint32_t;
    /**
     * For each violated policy (of type violationType), log policy violation on
     * the Error Console and send a report to report-uris present in the violated
     * policies.
     *
     * @param violationType
     * one of the VIOLATION_TYPE_* constants, e.g. eval or wasm-eval
     * @param triggeringElement
     * the element that triggers this CSP violation. It can be null.
     * @param sourceFile
     * name of the source file containing the violation (if available)
     * @param contentSample
     * sample of the violating content (to aid debugging)
     * @param lineNum
     * source line number of the violation (if available)
     * @param columnNum
     * source column number of the violation (if available)
     * @param aNonce
     * (optional) If this is a nonce violation, include the nonce so we can
     * recheck to determine which policies were violated and send the
     * appropriate reports.
     * @param aContent
     * (optional) If this is a hash violation, include contents of the inline
     * resource in the question so we can recheck the hash in order to
     * determine which policies were violated and send the appropriate
     * reports.
     */
    logViolationDetails(violationType: unsigned_short, triggeringElement: Element, aCSPEventListener: nsICSPEventListenerType, sourceFile: AString, scriptSample: AString, lineNum: int32_t, columnNum: int32_t, nonce: AString, content: AString): void;
    /**
     * Called after the CSP object is created to fill in appropriate request
     * context. Either use
     * * aDocument (preferred), or if no document is available, then provide
     * * aPrincipal, aSelfURI, aReferrer, aInnerWindowId explicitly.
     */
    setRequestContextWithDocument(aDocument: Document): void;
    /**
     *
     */
    setRequestContextWithPrincipal(aRequestPrincipal: nsIPrincipalType, aSelfURI: nsIURIType, aReferrer: AString, aInnerWindowId: unsigned_long_long): void;
    /**
     * Get the various arguments needed to create a new request context for a CSP.
     */
    readonly requestPrincipal: nsIPrincipal;
    /**
     *
     */
    readonly selfURI: nsIURI;
    /**
     *
     */
    readonly referrer: AString;
    /**
     *
     */
    readonly innerWindowID: unsigned_long_long;
    /**
     * Warning: Do not set that attribute unless you know exactly what you are doing!
     *
     * Primarily used to allow Devtools to edit inline styles!
     */
    skipAllowInlineStyleCheck: boolean;
    /**
     * Verifies ancestry as permitted by the policy.
     *
     * NOTE: Calls to this may trigger violation reports when queried, so this
     * value should not be cached.
     *
     * @param aLoadInfo
     * The loadinfo of the channel containing the protected resource
     * @return
     * true if the frame's ancestors are all allowed by policy (except for
     * report-only policies, which will send reports and then return true
     * here when violated).
     */
    permitsAncestry(aLoadInfo: nsILoadInfoType): boolean;
    /**
     * Checks if a specific directive permits loading of a URI.
     *
     * @param aTriggeringElement
     * The element that triggers this CSP check. It can be null.
     * @param aURI
     * The URI about to be loaded or used.
     * @param aDir
     * The CSPDirective to query (see above constants *_DIRECTIVE).
     * @param aSpecific
     * If "true" and the directive is specified to fall back to "default-src"
     * when it's not explicitly provided, directivePermits will NOT try
     * default-src when the specific directive is not used.  Setting this to
     * "false" allows CSP to fall back to default-src.  This function
     * behaves the same for both values of canUseDefault when querying
     * directives that don't fall-back.
     * @param aSendViolationReports
     * If `true` and the uri is not allowed then trigger violation reports.
     * This should be `false` for caching or preloads.
     * @return
     * Whether or not the provided URI is allowed by CSP under the given
     * directive. (block the pending operation if false).
     */
    permits(aTriggeringElement: Element, aCSPEventListener: nsICSPEventListenerType, aURI: nsIURIType, aDir: nsIContentSecurityPolicy_CSPDirectiveType, aSpecific: boolean, aSendViolationReports: boolean): boolean;
    /**
     * Delegate method called by the service when sub-elements of the protected
     * document are being loaded.  Given a bit of information about the request,
     * decides whether or not the policy is satisfied.
     *
     * Calls to this may trigger violation reports when queried, so
     * this value should not be cached.
     *
     * aOriginalURIIfRedirect must be passed only if this loading is the result
     * of a redirect. In this case, aOriginalURIIfRedirect must be the original
     * URL.
     */
    shouldLoad(aContentType: nsContentPolicyType, aCSPEventListener: nsICSPEventListenerType, aLoadInfo: nsILoadInfoType, aContentLocation: nsIURIType, aOriginalURIIfRedirect: nsIURIType, aSendViolationReports: bool): short;
    /**
     * Returns the CSP in JSON notation.
     */
    toJSON(): AString;
}

/**
 * Listener for security policy violation event
 */
declare interface nsICSPEventListenerType extends nsISupportsType {
    /**
     *
     */
    onCSPViolationEvent(aJSON: AString): void;
}

/**
 * An interface for verifying content-signatures, inspired by
 * https://tools.ietf.org/html/draft-thomson-http-content-signature-00
 * described here https://github.com/franziskuskiefer/content-signature/tree/pki
 */
declare interface nsIContentSignatureVerifierType extends nsISupportsType {
    /**
     * Verifies that the data matches the data that was used to generate the
     * signature.
     *
     * @param aData                   The data to be tested.
     * @param aContentSignatureHeader The content-signature header,
     * url-safe base64 encoded.
     * @param aCertificateChain       The certificate chain to use for verification.
     * PEM encoded string.
     * @param aHostname               The hostname for which the end entity must
     * be valid.
     * @param aTrustedRoot            The identifier corresponding to the
     * expected root certificate of the
     * certificate chain (note that the root need
     * not actually be included in the chain).
     * @returns Promise that resolves with the value true if the signature
     * matches the data and aCertificateChain is valid within aContext,
     * and false if not. Rejects if another error occurred.
     */
    asyncVerifyContentSignature(aData: ACString, aContentSignatureHeader: ACString, aCertificateChain: ACString, aHostname: ACString, aTrustedRoot: AppTrustedRoot): Promise;
}

/**
 * Content sniffer interface. Components implementing this interface can
 * determine a MIME type from a chunk of bytes.
 */
declare interface nsIContentSnifferType extends nsISupportsType {
    /**
     * Given a chunk of data, determines a MIME type. Information from the given
     * request may be used in order to make a better decision.
     *
     * @param aRequest The request where this data came from. May be null.
     * @param aData Data to check
     * @param aLength Length of the data
     *
     * @return The content type
     *
     * @throw NS_ERROR_NOT_AVAILABLE if no MIME type could be determined.
     *
     * @note Implementations should consider the request read-only. Especially,
     * they should not attempt to set the content type property that subclasses of
     * nsIRequest might offer.
     */
    getMIMETypeFromContent(aRequest: nsIRequestType, aData: octet[], aLength: unsigned_long): ACString;
}

/**
 *
 */
declare interface nsIContentViewerType extends nsISupportsType {
    /**
     *
     */
    container: nsIDocShell;
    /**
     *
     */
    loadComplete(aStatus: nsresult): void;
    /**
     *
     */
    readonly loadCompleted: boolean;
    /**
     *
     */
    readonly isStopped: boolean;
    /**
     * Checks if the document wants to prevent unloading by firing beforeunload on
     * the document.
     * The result is returned.
     */
    permitUnload(aAction: nsIContentViewer_PermitUnloadActionType): boolean;
    /**
     * Exposes whether we're blocked in a call to permitUnload.
     */
    readonly inPermitUnload: boolean;
    /**
     * Exposes whether we're in the process of firing the beforeunload event.
     * In this case, the corresponding docshell will not allow navigation.
     */
    readonly beforeUnloadFiring: boolean;
    /**
     *
     */
    pageHide(isUnload: boolean): void;
    /**
     * All users of a content viewer are responsible for calling both
     * close() and destroy(), in that order.
     *
     * close() should be called when the load of a new page for the next
     * content viewer begins, and destroy() should be called when the next
     * content viewer replaces this one.
     *
     * |historyEntry| sets the session history entry for the content viewer.  If
     * this is null, then Destroy() will be called on the document by close().
     * If it is non-null, the document will not be destroyed, and the following
     * actions will happen when destroy() is called (*):
     * - Sanitize() will be called on the viewer's document
     * - The content viewer will set the contentViewer property on the
     * history entry, and release its reference (ownership reversal).
     * - hide() will be called, and no further destruction will happen.
     *
     * (*) unless the document is currently being printed, in which case
     * it will never be saved in session history.
     */
    close(historyEntry: nsISHEntryType): void;
    /**
     *
     */
    destroy(): void;
    /**
     *
     */
    stop(): void;
    /**
     * Returns the same thing as getDocument(), but for use from script
     * only.  C++ consumers should use getDocument().
     */
    readonly DOMDocument: Document;
    /**
     * The previous content viewer, which has been |close|d but not
     * |destroy|ed.
     */
    previousViewer: nsIContentViewer;
    /**
     *
     */
    move(aX: long, aY: long): void;
    /**
     *
     */
    show(): void;
    /**
     *
     */
    hide(): void;
    /**
     *
     */
    sticky: boolean;
    /**
     * Attach the content viewer to its DOM window and docshell.
     * @param aState A state object that might be useful in attaching the DOM
     * window.
     * @param aSHEntry The history entry that the content viewer was stored in.
     * The entry must have the docshells for all of the child
     * documents stored in its child shell list.
     */
    open(aState: nsISupportsType, aSHEntry: nsISHEntryType): void;
    /**
     * Clears the current history entry.  This is used if we need to clear out
     * the saved presentation state.
     */
    clearHistoryEntry(): void;
    /**
     * Change the layout to view the document with page layout (like print preview), but
     * dynamic and editable (like Galley layout).
     */
    setPageModeForTesting(aPageMode: boolean, aPrintSettings: nsIPrintSettingsType): void;
    /**
     * Sets the print settings for print / print-previewing a subdocument.
     */
    setPrintSettingsForSubdocument(aPrintSettings: nsIPrintSettingsType, aRemotePrintJob: RemotePrintJobChildPtr): void;
    /**
     * Get the history entry that this viewer will save itself into when
     * destroyed.  Can return null
     */
    readonly historyEntry: nsISHEntry;
    /**
     * Indicates when we're in a state where content shouldn't be allowed to
     * trigger a tab-modal prompt (as opposed to a window-modal prompt) because
     * we're part way through some operation (eg beforeunload) that shouldn't be
     * rentrant if the user closes the tab while the prompt is showing.
     * See bug 613800.
     */
    readonly isTabModalPromptAllowed: boolean;
    /**
     * Returns whether this content viewer is in a hidden state.
     *
     * @note Only Gecko internal code should set the attribute!
     */
    isHidden: boolean;
    /**
     *
     */
    readonly presShell: PresShellPtr;
    /**
     *
     */
    readonly presContext: nsPresContextPtr;
    /**
     * The actual full zoom in effect, as modified by the device context.
     * For a requested full zoom, the device context may choose a slightly
     * different effectiveFullZoom to accomodate integer rounding of app units
     * per dev pixel. This property returns the actual zoom amount in use,
     * though it may not be good user experience to report that a requested zoom
     * of 90% is actually 89.1%, for example. This value is provided primarily to
     * support media queries of dppx values, because those queries are matched
     * against the actual native device pixel ratio and the actual full zoom.
     *
     * You should only need this for testing.
     */
    readonly deviceFullZoomForTest: float;
    /**
     * Disable entire author style level (including HTML presentation hints),
     * for this viewer but not any child viewers.
     */
    authorStyleDisabled: boolean;
    /**
     * Returns the preferred width and height of the content, constrained to the
     * given maximum values. If either maxWidth or maxHeight is less than or
     * equal to zero, that dimension is not constrained.
     *
     * If a pref width is provided, it is max'd with the min-content size.
     *
     * All input and output values are in CSS pixels.
     */
    getContentSize(maxWidth: long, maxHeight: long, prefWidth: long, width: long, height: long): void;
}

/**
 *
 */
declare interface nsIContentViewerEditType extends nsISupportsType {
    /**
     *
     */
    clearSelection(): void;
    /**
     *
     */
    selectAll(): void;
    /**
     *
     */
    copySelection(): void;
    /**
     *
     */
    readonly copyable: boolean;
    /**
     *
     */
    copyLinkLocation(): void;
    /**
     *
     */
    readonly inLink: boolean;
    /**
     *
     */
    copyImage(aCopyFlags: long): void;
    /**
     *
     */
    readonly inImage: boolean;
    /**
     *
     */
    getContents(aMimeType: string, aSelectionOnly: boolean): AString;
    /**
     *
     */
    readonly canGetContents: boolean;
    /**
     *
     */
    setCommandNode(aNode: Node): void;
}

/**
 *
 */
declare interface nsIControllerType extends nsISupportsType {
    /**
     *
     */
    isCommandEnabled(command: string): boolean;
    /**
     *
     */
    supportsCommand(command: string): boolean;
    /**
     *
     */
    doCommand(command: string): void;
    /**
     *
     */
    onEvent(eventName: string): void;
}

/**
 *
 */
declare interface nsICommandControllerType extends nsISupportsType {
    /**
     *
     */
    getCommandStateWithParams(command: string, aCommandParams: nsICommandParamsType): void;
    /**
     *
     */
    doCommandWithParams(command: string, aCommandParams: nsICommandParamsType): void;
}

/**
 * nsIControllerCommand
 *
 * A generic command interface. You can register an nsIControllerCommand
 * with the nsIControllerCommandTable.
 */
declare interface nsIControllerCommandType extends nsISupportsType {
    /**
     * Returns true if the command is currently enabled. An nsIControllerCommand
     * can implement more than one commands; say, a group of related commands
     * (e.g. delete left/delete right). Because of this, the command name is
     * passed to each method.
     *
     * @param aCommandName  the name of the command for which we want the enabled
     * state.
     * @param aCommandContext    a cookie held by the nsIControllerCommandTable,
     * allowing the command to get some context information.
     * The contents of this cookie are implementation-defined.
     */
    isCommandEnabled(aCommandName: string, aCommandContext: nsISupportsType): boolean;
    /**
     *
     */
    getCommandStateParams(aCommandName: string, aParams: nsICommandParamsType, aCommandContext: nsISupportsType): void;
    /**
     * Execute the name command.
     *
     * @param aCommandName  the name of the command to execute.
     *
     * @param aCommandContext    a cookie held by the nsIControllerCommandTable,
     * allowing the command to get some context information.
     * The contents of this cookie are implementation-defined.
     */
    doCommand(aCommandName: string, aCommandContext: nsISupportsType): void;
    /**
     *
     */
    doCommandParams(aCommandName: string, aParams: nsICommandParamsType, aCommandContext: nsISupportsType): void;
}

/**
 * nsIControllerCommandTable
 *
 * An interface via which a controller can maintain a series of commands,
 * and efficiently dispatch commands to their respective handlers.
 *
 * Controllers that use an nsIControllerCommandTable should support
 * nsIInterfaceRequestor, and be able to return an interface to their
 * controller command table via getInterface().
 */
declare interface nsIControllerCommandTableType extends nsISupportsType {
    /**
     * Make this command table immutable, so that commands cannot
     * be registered or unregistered. Some command tables are made
     * mutable after command registration so that they can be
     * used as singletons.
     */
    makeImmutable(): void;
    /**
     * Register and unregister commands with the command table.
     *
     * @param aCommandName  the name of the command under which to register or
     * unregister the given command handler.
     *
     * @param aCommand      the handler for this command.
     */
    registerCommand(aCommandName: string, aCommand: nsIControllerCommandType): void;
    /**
     *
     */
    unregisterCommand(aCommandName: string, aCommand: nsIControllerCommandType): void;
    /**
     * Find the command handler which has been registered to handle the named command.
     *
     * @param aCommandName  the name of the command to find the handler for.
     */
    findCommandHandler(aCommandName: string): nsIControllerCommand;
    /**
     * Get whether the named command is enabled.
     *
     * @param aCommandName    the name of the command to test
     * @param aCommandRefCon  the command context data
     */
    isCommandEnabled(aCommandName: string, aCommandRefCon: nsISupportsType): boolean;
    /**
     * Tell the command to update its state (if it is a state updating command)
     *
     * @param aCommandName    the name of the command to update
     * @param aCommandRefCon  the command context data
     */
    updateCommandState(aCommandName: string, aCommandRefCon: nsISupportsType): void;
    /**
     * Get whether the named command is supported.
     *
     * @param aCommandName    the name of the command to test
     * @param aCommandRefCon  the command context data
     */
    supportsCommand(aCommandName: string, aCommandRefCon: nsISupportsType): boolean;
    /**
     * Execute the named command.
     *
     * @param aCommandName    the name of the command to execute
     * @param aCommandRefCon  the command context data
     */
    doCommand(aCommandName: string, aCommandRefCon: nsISupportsType): void;
    /**
     *
     */
    doCommandParams(aCommandName: string, aParam: nsICommandParamsType, aCommandRefCon: nsISupportsType): void;
    /**
     *
     */
    getCommandState(aCommandName: string, aParam: nsICommandParamsType, aCommandRefCon: nsISupportsType): void;
}

/**
 *
 */
declare interface nsIControllerContextType extends nsISupportsType {
    /**
     * Set a context on this controller, which is passed
     * to commands to give them some context when they execute.
     *
     * @param aCommandContext  the context passed to commands.
     * Note that this is *not* addreffed by the
     * controller, and so needs to outlive it,
     * or be nulled out.
     */
    setCommandContext(aCommandContext: nsISupportsType): void;
}

/**
 *
 */
declare interface nsIControllersType extends nsISupportsType {
    /**
     *
     */
    getControllerForCommand(command: string): nsIController;
    /**
     *
     */
    insertControllerAt(index: unsigned_long, controller: nsIControllerType): void;
    /**
     *
     */
    removeControllerAt(index: unsigned_long): nsIController;
    /**
     *
     */
    getControllerAt(index: unsigned_long): nsIController;
    /**
     *
     */
    appendController(controller: nsIControllerType): void;
    /**
     *
     */
    removeController(controller: nsIControllerType): void;
    /**
     * Return an ID for this controller which is unique to this
     * nsIControllers.
     */
    getControllerId(controller: nsIControllerType): unsigned_long;
    /**
     * Get the controller specified by the given ID.
     */
    getControllerById(controllerID: unsigned_long): nsIController;
    /**
     *
     */
    getControllerCount(): unsigned_long;
}

/**
 * A unichar input stream that wraps an input stream.
 * This allows reading unicode strings from a stream, automatically converting
 * the bytes from a selected character encoding.
 */
declare interface nsIConverterInputStreamType extends nsIUnicharInputStreamType {
    /**
     * Initialize this stream.
     * @param aStream
     * The underlying stream to read from.
     * @param aCharset
     * The character encoding to use for converting the bytes of the
     * stream. A null charset will be interpreted as UTF-8.
     * @param aBufferSize
     * How many bytes to buffer.
     * @param aReplacementChar
     * The character to replace unknown byte sequences in the stream
     * with. The standard replacement character is U+FFFD.
     * A value of 0x0000 will cause an exception to be thrown if unknown
     * byte sequences are encountered in the stream.
     */
    init(aStream: nsIInputStreamType, aCharset: string, aBufferSize: long, aReplacementChar: char16_t): void;
}

/**
 * This interface allows writing strings to a stream, doing automatic
 * character encoding conversion.
 */
declare interface nsIConverterOutputStreamType extends nsIUnicharOutputStreamType {
    /**
     * Initialize this stream. Must be called before any other method on this
     * interface, or you will crash. The output stream passed to this method
     * must not be null, or you will crash.
     *
     * @param aOutStream
     * The underlying output stream to which the converted strings will
     * be written.
     * @param aCharset
     * The character set to use for encoding the characters. A null
     * charset will be interpreted as UTF-8.
     */
    init(aOutStream: nsIOutputStreamType, aCharset: string): void;
}

/**
 *
 */
declare interface nsICookieType extends nsISupportsType {
    /**
     * the name of the cookie
     */
    readonly name: ACString;
    /**
     * the cookie value
     */
    readonly value: AUTF8String;
    /**
     * true if the cookie is a domain cookie, false otherwise
     */
    readonly isDomain: boolean;
    /**
     * the host (possibly fully qualified) of the cookie
     */
    readonly host: AUTF8String;
    /**
     * the host (possibly fully qualified) of the cookie,
     * without a leading dot to represent if it is a
     * domain cookie.
     */
    readonly rawHost: AUTF8String;
    /**
     * the path pertaining to the cookie
     */
    readonly path: AUTF8String;
    /**
     * true if the cookie was transmitted over ssl, false otherwise
     */
    readonly isSecure: boolean;
    /**
     * @DEPRECATED use nsICookie.expiry and nsICookie.isSession instead.
     *
     * expiration time in seconds since midnight (00:00:00), January 1, 1970 UTC.
     * expires = 0 represents a session cookie.
     * expires = 1 represents an expiration time earlier than Jan 1, 1970.
     */
    readonly expires: uint64_t;
    /**
     * the actual expiry time of the cookie, in seconds
     * since midnight (00:00:00), January 1, 1970 UTC.
     *
     * this is distinct from nsICookie::expires, which
     * has different and obsolete semantics.
     */
    readonly expiry: int64_t;
    /**
     * The origin attributes for this cookie
     */
    readonly originAttributes: jsval;
    /**
     * true if the cookie is a session cookie.
     * note that expiry time will also be honored
     * for session cookies (see below); thus, whichever is
     * the more restrictive of the two will take effect.
     */
    readonly isSession: boolean;
    /**
     * true if the cookie is an http only cookie
     */
    readonly isHttpOnly: boolean;
    /**
     * the creation time of the cookie, in microseconds
     * since midnight (00:00:00), January 1, 1970 UTC.
     */
    readonly creationTime: int64_t;
    /**
     * the last time the cookie was accessed (i.e. created,
     * modified, or read by the server), in microseconds
     * since midnight (00:00:00), January 1, 1970 UTC.
     *
     * note that this time may be approximate.
     */
    readonly lastAccessed: int64_t;
    /**
     * the SameSite attribute; this controls the cookie behavior for cross-site
     * requests as per
     * https://tools.ietf.org/html/draft-west-first-party-cookies-07
     *
     * This should be one of:
     * - SAMESITE_NONE - the SameSite attribute is not present
     * - SAMESITE_LAX - the SameSite attribute is present, but not strict
     * - SAMESITE_STRICT - the SameSite attribute is present and strict
     */
    readonly sameSite: int32_t;
    /**
     * Bitmap of schemes.
     */
    readonly schemeMap: nsICookie_schemeType;
}

/**
 * Service singleton for initializing and updating the list of cookie banner
 * handling rules.
 */
declare interface nsICookieBannerListServiceType extends nsISupportsType {
    /**
     * Initialize the service. This asynchronously imports the initial set of rules.
     */
    init(): void;
    /**
     * Same as init but returns a promise which resolves once init is done. Used
     * for testing when we need to wait for all rules to be imported.
     */
    initForTest(): Promise;
    /**
     * Shutdown the service. This disables any rule updates.
     */
    shutdown(): void;
    /**
     * Asynchronously import all rules from RemoteSettings.
     */
    importAllRules(): void;
}

/**
 * A rule containing instructions on how to handle a cookie banner for a specific
 * domain.
 */
declare interface nsICookieBannerRuleType extends nsISupportsType {
    /**
     *
     */
    id: ACString;
    /**
     * Clear both lists of opt-in and opt-out cookies.
     */
    clearCookies(): void;
    /**
     * Add an opt-in or opt-out cookie to the rule.
     * aIsOptOut - Whether this is an opt-out cookie (true) or opt-in cookie (false).
     * aExpiryRelative - See nsICookieRule.
     * aUnsetValue - See nsICookieRule.
     * For a description of the other fields see nsICookieManager#addNative.
     */
    addCookie(aIsOptOut: boolean, aName: ACString, aValue: AUTF8String, aHost: AUTF8String, aPath: AUTF8String, aExpiryRelative: int64_t, aUnsetValue: AUTF8String, aIsSecure: boolean, aIsHttpOnly: boolean, aIsSession: boolean, aSameSite: int32_t, aSchemeMap: nsICookie_schemeTypeType): void;
    /**
     *
     */
    readonly clickRule: nsIClickRule;
    /**
     * Add a click rule to the rule.
     *
     * aPresence - The CSS selector for detecting the presence of the cookie
     * banner
     * aSkipPresenceVisibilityCheck - Whether to skip checking if the banner is
     * visible before clicking it.
     * aHide - The CSS selector for hiding the cookie banner
     * aOptOut - The CSS selector for selecting the opt-out banner button
     * aOptIn - The CSS selector for selecting the opt-in banner button
     */
    addClickRule(aPresence: ACString, aSkipPresenceVisibilityCheck: bool, aRunContext: nsIClickRule_RunContextType, aHide: ACString, aOptOut: ACString, aOptIn: ACString): void;
    /**
     * Clear the click rule.
     */
    clearClickRule(): void;
}

/**
 * Service singleton which owns the cookie banner feature.
 * This service owns the cookie banner handling rules.
 * It initializes both the component for importing rules
 * (nsICookieBannerListService) and injecting cookies (nsICookieInjector).
 */
declare interface nsICookieBannerServiceType extends nsISupportsType {
    /**
     * Whether the feature / service is enabled.
     */
    readonly isEnabled: boolean;
    /**
     * Clears all imported rules. They will be imported again on startup and when
     * enabling the service. This is currently only used for testing.
     *
     * doImport - Whether to import initial rule list after reset. Passing false
     * will result in an empty rule list.
     */
    resetRules(doImport: boolean): void;
    /**
     * Insert a cookie banner rule for a domain. If there was previously a rule
     * stored with the same domain it will be overwritten.
     */
    insertRule(aRule: nsICookieBannerRuleType): void;
    /**
     * Remove a cookie banner rule.
     */
    removeRule(aRule: nsICookieBannerRuleType): void;
    /**
     * Computes whether we have a rule for the given browsing context or any of
     * its children. This takes the current cookie banner service mode into
     * consideration and whether the BC is in private browsing mode.
     *
     * This method only takes the global service mode into account. It will ignore
     * any per-site mode overrides. It is meant for callers to find out whether an
     * applicable rule exists, even if users have disabled the feature for the
     * given site.
     */
    hasRuleForBrowsingContextTree(aBrowsingContext: BrowsingContext): boolean;
    /**
     * Get the domain preference of the given top-level URI. It will return the
     * service mode if there is a site preference for the given URI. Otherwise, it
     * will return MODE_UNSET.
     */
    getDomainPref(aTopLevelURI: nsIURIType, aIsPrivate: boolean): nsICookieBannerService_Modes;
    /**
     * Set the domain preference of the given top-level URI.
     */
    setDomainPref(aTopLevelURI: nsIURIType, aMode: nsICookieBannerService_ModesType, aIsPrivate: boolean): void;
    /**
     * Set the domain preference of the given top-level URI. It will persist the
     * domain preference for private browsing.
     *
     * WARNING: setting permanent domain preference _will_ leak data in private
     * browsing. Only use if you understand the consequences and trade-offs. If
     * you are unsure, |setDomainPref| is very likely what you want to use
     * instead.
     */
    setDomainPrefAndPersistInPrivateBrowsing(aTopLevelURI: nsIURIType, aMode: nsICookieBannerService_ModesType): void;
    /**
     * Remove the domain preference of the given top-level URI.
     */
    removeDomainPref(aTopLevelURI: nsIURIType, aIsPrivate: boolean): void;
    /**
     * Remove all domain preferences.
     */
    removeAllDomainPrefs(aIsPrivate: boolean): void;
    /**
     * Clears the in-memory set that we use to maintain the domains that we have
     * reported telemetry. This function will clear the entry for the given
     * domain. If the domain was not given, it will clear all set.
     */
    resetDomainTelemetryRecord(aDomain: ACString): void;
}

/**
 * Cookie jar settings for top-level documents. Please see CookieJarSettings.h
 * for more details.
 */
declare interface nsICookieJarSettingsType extends nsISerializableType {
    /**
     * CookieBehavior at the loading of the document. Any other loadInfo
     * inherits it from its document's loadInfo. If there is not a document
     * involved, cookieBehavior is reject.
     */
    readonly cookieBehavior: unsigned_long;
    /**
     * First-Party Isolation state at the loading of the document.
     */
    readonly isFirstPartyIsolated: boolean;
    /**
     * Resist Fingerprinting state at the loading of the document.
     */
    readonly shouldResistFingerprinting: boolean;
    /**
     * Whether our cookie behavior mandates rejecting third-party contexts.
     */
    readonly rejectThirdPartyContexts: boolean;
    /**
     *
     */
    readonly limitForeignContexts: boolean;
    /**
     *
     */
    readonly blockingAllThirdPartyContexts: boolean;
    /**
     *
     */
    readonly blockingAllContexts: boolean;
    /**
     * Whether our cookie behavior mandates partitioning third-party content.
     */
    partitionForeign: boolean;
    /**
     * Whether the top-level document is on the content blocking allow list.
     */
    readonly isOnContentBlockingAllowList: boolean;
    /**
     * The key used for partitioning.
     */
    readonly partitionKey: AString;
    /**
     * CookiePermission at the loading of the document for a particular
     * principal. It returns the same cookiePermission also in case it changes
     * during the life-time of the top document.
     */
    cookiePermission(aPrincipal: nsIPrincipalType): unsigned_long;
    /**
     * Initiate the cookieJarSettings with a URI. The aURI will be used to build
     * the partition key for this cookieJarSettings. This function is added for
     * js code to be able to set the partitionKey from a first-party URI.
     *
     * The aIsPrivate indicates if this cookieJarSettings is initiated for the
     * private browsing mode or not. If aIsPrivate was true, it will get
     * cookieBehavior from the pref "network.cookie.cookieBehavior" which is for
     * the regular browsing mode. Otherwise, it will get from the pref
     * "network.cookie.cookieBehavior.pbmode" for the private browsing mode.
     */
    initWithURI(aURI: nsIURIType, aIsPrivate: boolean): void;
}

/**
 * An optional interface for accessing or removing the cookies
 * that are in the cookie list
 */
declare interface nsICookieManagerType extends nsISupportsType {
    /**
     * Called to remove all cookies from the cookie list
     */
    removeAll(): void;
    /**
     * Returns current effective value of the cookieBehavior. It will return the
     * different pref according to the aIsPrivate. If aIsPrivate is true, it will
     * return the pref "network.cookie.cookieBehavior". Otherwise, it will return
     * the pref "network.cookie.cookieBehavior.pbmode"
     */
    getCookieBehavior(aIsPrivate: boolean): uint32_t;
    /**
     * Called to remove an individual cookie from the cookie list, specified
     * by host, name, and path. If the cookie cannot be found, no exception
     * is thrown. Typically, the arguments to this method will be obtained
     * directly from the desired nsICookie object.
     *
     * @param aHost The host or domain for which the cookie was set. @see
     * nsICookieManager::add for a description of acceptable host
     * strings. If the target cookie is a domain cookie, a leading
     * dot must be present.
     * @param aName The name specified in the cookie
     * @param aPath The path for which the cookie was set
     * @param aOriginAttributes The originAttributes of this cookie.
     */
    remove(aHost: AUTF8String, aName: ACString, aPath: AUTF8String, aOriginAttributes: jsval): void;
    /**
     *
     */
    removeNative(aHost: AUTF8String, aName: ACString, aPath: AUTF8String, aOriginAttributes: OriginAttributesPtr): nsresult;
    /**
     * Add a cookie. nsICookieService is the normal way to do this. This
     * method is something of a backdoor.
     *
     * @param aHost
     * the host or domain for which the cookie is set. presence of a
     * leading dot indicates a domain cookie; otherwise, the cookie
     * is treated as a non-domain cookie (see RFC2109). The host string
     * will be normalized to ASCII or ACE; any trailing dot will be
     * stripped. To be a domain cookie, the host must have at least two
     * subdomain parts (e.g. '.foo.com', not '.com'), otherwise an
     * exception will be thrown. An empty string is acceptable
     * (e.g. file:// URI's).
     * @param aPath
     * path within the domain for which the cookie is valid
     * @param aName
     * cookie name
     * @param aValue
     * cookie data
     * @param aIsSecure
     * true if the cookie should only be sent over a secure connection.
     * @param aIsHttpOnly
     * true if the cookie should only be sent to, and can only be
     * modified by, an http connection.
     * @param aIsSession
     * true if the cookie should exist for the current session only.
     * see aExpiry.
     * @param aExpiry
     * expiration date, in seconds since midnight (00:00:00), January 1,
     * 1970 UTC. note that expiry time will also be honored for session cookies;
     * in this way, the more restrictive of the two will take effect.
     * @param aOriginAttributes
     * the originAttributes of this cookie.
     * @param aSameSite
     * the SameSite attribute.
     */
    add(aHost: AUTF8String, aPath: AUTF8String, aName: ACString, aValue: AUTF8String, aIsSecure: boolean, aIsHttpOnly: boolean, aIsSession: boolean, aExpiry: int64_t, aOriginAttributes: jsval, aSameSite: int32_t, aSchemeMap: nsICookie_schemeTypeType): void;
    /**
     *
     */
    addNative(aHost: AUTF8String, aPath: AUTF8String, aName: ACString, aValue: AUTF8String, aIsSecure: boolean, aIsHttpOnly: boolean, aIsSession: boolean, aExpiry: int64_t, aOriginAttributes: OriginAttributesPtr, aSameSite: int32_t, aSchemeMap: nsICookie_schemeTypeType): nsresult;
    /**
     * Find whether a given cookie already exists.
     *
     * @param aHost
     * the cookie's host to look for
     * @param aPath
     * the cookie's path to look for
     * @param aName
     * the cookie's name to look for
     * @param aOriginAttributes
     * the cookie's originAttributes to look for
     *
     * @return true if a cookie was found which matches the host, path, name and
     * originAttributes fields of aCookie
     */
    cookieExists(aHost: AUTF8String, aPath: AUTF8String, aName: ACString, aOriginAttributes: jsval): boolean;
    /**
     *
     */
    cookieExistsNative(aHost: AUTF8String, aPath: AUTF8String, aName: ACString, aOriginAttributes: OriginAttributesPtr, aExists: boolean): nsresult;
    /**
     * Get a specific cookie by host, path, name and OriginAttributes.
     *
     * @param aHost
     * the cookie's host to look for
     * @param aPath
     * the cookie's path to look for
     * @param aName
     * the cookie's name to look for
     * @param aOriginAttributes
     * the cookie's originAttributes to look for
     *
     * @return cookie matching the arguments or nullptr if not existing.
     */
    getCookieNative(aHost: AUTF8String, aPath: AUTF8String, aName: ACString, aOriginAttributes: OriginAttributesPtr, aCookie: nsICookieType): nsresult;
    /**
     * Count how many cookies exist within the base domain of 'aHost'.
     * Thus, for a host "weather.yahoo.com", the base domain would be "yahoo.com",
     * and any host or domain cookies for "yahoo.com" and its subdomains would be
     * counted.
     *
     * @param aHost
     * the host string to search for, e.g. "google.com". this should consist
     * of only the host portion of a URI. see @add for a description of
     * acceptable host strings.
     *
     * @return the number of cookies found.
     */
    countCookiesFromHost(aHost: AUTF8String): unsigned_long;
    /**
     * Remove all the cookies whose origin attributes matches aPattern
     *
     * @param aPattern origin attribute pattern in JSON format
     */
    removeCookiesWithOriginAttributes(aPattern: AString, aHost: AUTF8String): void;
    /**
     * Remove all the cookies whose origin attributes matches aPattern and the
     * host is exactly aHost (without subdomain matching).
     *
     * @param aHost the host to match
     * @param aPattern origin attribute pattern in JSON format
     */
    removeCookiesFromExactHost(aHost: AUTF8String, aPattern: AString): void;
    /**
     * Removes all cookies that were created on or after aSinceWhen, and returns
     * a Promise which will be resolved when the last such cookie has been
     * removed.
     *
     * @param aSinceWhen the starting point in time after which no cookies should
     * be created when the Promise returned from this method is resolved.
     */
    removeAllSince(aSinceWhen: int64_t): Promise;
}

/**
 * Meta object dispatched by cookie change notifications.
 */
declare interface nsICookieNotificationType extends nsISupportsType {
    /**
     * Describes the cookie operation this notification is for. Cookies may be
     * deleted, added or changed. See Action enum above for possible values.
     */
    readonly action: nsICookieNotification_Action;
    /**
     * The cookie the notification is for, may be null depending on the action.
     */
    readonly cookie: nsICookie;
    /**
     * Base domain of the cookie. May be empty if cookie is null.
     */
    readonly baseDomain: ACString;
    /**
     * List of cookies purged.
     * Only set when action == COOKIES_BATCH_DELETED.
     */
    readonly batchDeletedCookies: nsIArray;
    /**
     * The id of the BrowsingContext the cookie change was triggered from. Set
     * to 0 if there is not applicable BrowsingContext.
     */
    readonly browsingContextId: unsigned_long_long;
    /**
     * BrowsingContext associated with browsingContextId. May be nullptr.
     */
    readonly browsingContext: BrowsingContext;
}

/**
 * An interface to test for cookie permissions
 */
declare interface nsICookiePermissionType extends nsISupportsType {
}

/**
 * Rule which specifies a cookie to be set in order to handle a cookie banner.
 */
declare interface nsICookieRuleType extends nsISupportsType {
    /**
     * The cookie to set.
     * When calling this getter creation, expiry and last accessed time are
     * computed.
     */
    readonly cookie: nsICookie;
    /**
     * Expiry time of the cookie in seconds relative to the injection time.
     * If you want a cookie to expire in 1 month after it has been set, set this
     * to 2592000.
     * Defaults to 'cookiebanners.cookieInjector.defaultExpiryRelative'.
     */
    readonly expiryRelative: int64_t;
    /**
     * If an existing cookie sets this value it may be overwritten.
     * This is used for sites which set an explicit cookie state, even if a
     * cookie banner is still pending.
     */
    readonly unsetValue: AUTF8String;
}

/**
 * @see nsICookieService::runInTransaction
 */
declare interface nsICookieTransactionCallbackType extends nsISupportsType {
    /**
     *
     */
    callback(): void;
}

/**
 * nsICookieService
 *
 * Provides methods for setting and getting cookies in the context of a
 * page load.  See nsICookieManager for methods to manipulate the cookie
 * database directly.  This separation of interface is mainly historical.
 *
 * This service broadcasts the notifications detailed below when the cookie
 * list is changed, or a cookie is rejected.
 *
 * NOTE: observers of these notifications *must* not attempt to change profile
 * or switch into or out of private browsing mode from within the
 * observer. Doing so will cause undefined behavior. Mutating the cookie
 * list (e.g. by calling methods on nsICookieService and friends) is
 * allowed, but beware that there may be pending notifications you haven't
 * seen yet -- for instance, a COOKIES_BATCH_DELETED notification will likely be
 * immediately followed by COOKIE_ADDED. You may check the state of the cookie
 * list to determine if this is the case.
 *
 * topic  : "cookie-changed"
 * broadcast whenever the cookie list changes in some way. see
 * explanation of data strings below.
 * subject: The cookie notification. See nsICookieNotification for details.
 * data   : none. For possible actions see nsICookieNotification_Action.
 *
 * topic  : "cookie-rejected"
 * broadcast whenever a cookie was rejected from being set as a
 * result of user prefs.
 * subject: an nsIURI interface pointer representing the URI that attempted
 * to set the cookie.
 * data   : none.
 */
declare interface nsICookieServiceType extends nsISupportsType {
    /**
     * Get the complete cookie string associated with the document's principal.
     * This method is meant to be used for `document.cookie` only. Any security
     * check about storage-access permission and cookie behavior must be done by
     * the caller.
     *
     * @param aDocument
     * The document.
     *
     * @return the resulting cookie string
     */
    getCookieStringFromDocument(aDocument: Document): ACString;
    /**
     * Get the complete cookie string associated with the URI.
     *
     * This function is NOT redundant with getCookieString, as the result
     * will be different based on httponly (see bug 178993)
     *
     * @param aURI
     * The URI of the document for which cookies are being queried.
     * file:// URIs (i.e. with an empty host) are allowed, but any other
     * scheme must have a non-empty host. A trailing dot in the host
     * is acceptable, and will be stripped. This argument must not be null.
     * @param aChannel
     * the channel used to load the document.
     *
     * @return the resulting cookie string
     */
    getCookieStringFromHttp(aURI: nsIURIType, aChannel: nsIChannelType): ACString;
    /**
     * Set the cookie string associated with a Document. This method is meant to
     * be used for `document.cookie` only. Any security check about
     * storage-access permission and cookie behavior must be done by the caller.
     *
     * @param aDocument
     * The document.
     * @param aCookie
     * the cookie string to set.
     */
    setCookieStringFromDocument(aDocument: Document, aCookie: ACString): void;
    /**
     * Set the cookie string and expires associated with the URI.
     *
     * This function is NOT redundant with setCookieString, as the result
     * will be different based on httponly (see bug 178993)
     *
     * @param aURI
     * The URI of the document for which cookies are being queried.
     * file:// URIs (i.e. with an empty host) are allowed, but any other
     * scheme must have a non-empty host. A trailing dot in the host
     * is acceptable, and will be stripped. This argument must not be null.
     * @param aCookie
     * the cookie string to set.
     * @param aChannel
     * the channel used to load the document.
     */
    setCookieStringFromHttp(aURI: nsIURIType, aCookie: ACString, aChannel: nsIChannelType): void;
    /**
     * Batch SQLite operations into one transaction. By default each call to
     * CookieService that affects the underlying SQLite database (add, remove,
     * setCookieString etc.) runs in a separate transaction.  If you do this many
     * times in a row, it's faster and suggested to wrap them all in a single
     * transaction by setting all the operations into the callback parameter.
     * Example: test scripts that need to construct a large cookie database.
     * @param aCallback
     * nsICookieTransactionCallback interface to call
     * @throws NS_ERROR_FAILURE if aCallback() fails.
     * @throws NS_ERROR_NOT_AVAILABLE if the connection is not established.
     */
    runInTransaction(aCallback: nsICookieTransactionCallbackType): void;
}

/**
 * Provides access to crash reporting functionality.
 *
 * @status UNSTABLE - This interface is not frozen and will probably change in
 * future releases.
 */
declare interface nsICrashReporterType extends nsISupportsType {
    /**
     * Get the enabled status of the crash reporter.
     */
    readonly crashReporterEnabled: boolean;
    /**
     * Get or set the URL to which crash reports will be submitted.
     * Only https and http URLs are allowed, as the submission is handled
     * by OS-native networking libraries.
     *
     * @throw NS_ERROR_NOT_INITIALIZED if crash reporting is not initialized
     * @throw NS_ERROR_INVALID_ARG on set if a non-http(s) URL is assigned
     * @throw NS_ERROR_FAILURE on get if no URL is set
     */
    serverURL: nsIURL;
    /**
     * Get or set the path on the local system to which minidumps will be
     * written when a crash happens.
     *
     * @throw NS_ERROR_NOT_INITIALIZED if crash reporting is not initialized
     */
    minidumpPath: nsIFile;
    /**
     * Get the minidump file corresponding to the specified ID.
     *
     * @param id
     * ID of the crash. Likely a UUID.
     *
     * @return The minidump file associated with the ID.
     *
     * @throw NS_ERROR_FILE_NOT_FOUND if the minidump could not be found
     */
    getMinidumpForID(id: AString): nsIFile;
    /**
     * Get the extra file corresponding to the specified ID.
     *
     * @param id
     * ID of the crash. Likely a UUID.
     *
     * @return The extra file associated with the ID.
     *
     * @throw NS_ERROR_FILE_NOT_FOUND if the extra file could not be found
     */
    getExtraFileForID(id: AString): nsIFile;
    /**
     * Add some extra data to be submitted with a crash report.
     *
     * @param key
     * Name of a known crash annotation constant.
     * @param data
     * Data to be added.
     *
     * @throw NS_ERROR_NOT_INITIALIZED if crash reporting not initialized
     * @throw NS_ERROR_INVALID_ARG if key contains an invalid value or data
     * contains invalid characters.  Invalid
     * character for data is '\0'.
     */
    annotateCrashReport(key: AUTF8String, data: AUTF8String): void;
    /**
     * Remove a crash report annotation.
     *
     * @param key
     * Name of a known crash annotation constant.
     *
     * @throw NS_ERROR_NOT_INITIALIZED if crash reporting not initialized
     * @throw NS_ERROR_INVALID_ARG if key contains an invalid value.
     */
    removeCrashReportAnnotation(key: AUTF8String): void;
    /**
     * Checks if an annotation is allowlisted for inclusion in the crash ping.
     *
     * @param key
     * Name of a known crash annotation constant.
     *
     * @return True if the specified value is a valid annotation and can be
     * included in the crash ping, false otherwise.
     * @throw NS_ERROR_INVALID_ARG if key contains an invalid value.
     */
    isAnnotationAllowlistedForPing(value: ACString): boolean;
    /**
     * Append some data to the "Notes" field, to be submitted with a crash report.
     * Unlike annotateCrashReport, this method will append to existing data.
     *
     * @param data
     * Data to be added.
     *
     * @throw NS_ERROR_NOT_INITIALIZED if crash reporting not initialized
     * @throw NS_ERROR_INVALID_ARG if data contains invalid characters.
     * The only invalid character is '\0'.
     */
    appendAppNotesToCrashReport(data: ACString): void;
    /**
     * Register a given memory range to be included in the crash report.
     *
     * @param ptr
     * The starting address for the bytes.
     * @param size
     * The number of bytes to include.
     *
     * @throw NS_ERROR_NOT_INITIALIZED if crash reporting not initialized
     * @throw NS_ERROR_NOT_IMPLEMENTED if unavailable on the current OS
     */
    registerAppMemory(ptr: unsigned_long_long, size: unsigned_long_long): void;
    /**
     * User preference for submitting crash reports.
     */
    submitReports: boolean;
    /**
     * Cause the crash reporter to re-evaluate where crash events should go.
     *
     * This should be called during application startup and whenever profiles
     * change.
     */
    UpdateCrashEventsDir(): void;
    /**
     * Save an anonymized memory report file for inclusion in a future crash
     * report in this session.
     *
     * @throws NS_ERROR_NOT_INITIALIZED if crash reporting is disabled.
     */
    saveMemoryReport(): void;
}

/**
 *
 */
declare interface nsICrashServiceType extends nsISupportsType {
    /**
     * Records the occurrence of a crash.
     *
     * @param processType
     * One of the PROCESS_TYPE constants defined in nsIXULRuntime.
     * @param crashType
     * One of the CRASH_TYPE constants defined below.
     * @param id
     * Crash ID. Likely a UUID.
     *
     * @return A promise that resolves after the crash has been stored
     */
    addCrash(processType: long, crashType: long, id: AString): Promise;
}

/**
 * nsICryptoHash
 * This interface provides crytographic hashing algorithms.
 */
declare interface nsICryptoHashType extends nsISupportsType {
    /**
     * String value: "sha512"
     *
     * Initialize the hashing object. This method may be
     * called multiple times with different algorithm types.
     *
     * @param aAlgorithm the algorithm type to be used.
     * This value must be one of the above valid
     * algorithm types.
     *
     * @throws NS_ERROR_INVALID_ARG if an unsupported algorithm
     * type is passed.
     *
     * NOTE: This method or initWithString must be called
     * before any other method on this interface is called.
     */
    init(aAlgorithm: unsigned_long): void;
    /**
     * Initialize the hashing object. This method may be
     * called multiple times with different algorithm types.
     *
     * @param aAlgorithm the algorithm type to be used.
     *
     * @throws NS_ERROR_INVALID_ARG if an unsupported algorithm
     * type is passed.
     *
     * NOTE: This method or init must be called before any
     * other method on this interface is called.
     */
    initWithString(aAlgorithm: ACString): void;
    /**
     * @param aData a buffer to calculate the hash over
     *
     * @param aLen the length of the buffer |aData|
     *
     * @throws NS_ERROR_NOT_INITIALIZED If |init| has not been called.
     */
    update(aData: octet[], aLen: unsigned_long): void;
    /**
     * Calculates and updates a new hash based on a given data stream.
     *
     * @param aStream an input stream to read from.
     *
     * @param aLen How much to read from the given |aStream|. Passing UINT32_MAX
     * indicates that all data available will be used to update the hash.
     *
     * @throws NS_ERROR_NOT_INITIALIZED If |init| has not been called.
     *
     * @throws NS_ERROR_NOT_AVAILABLE If the requested amount of
     * data to be calculated into the hash is not available.
     */
    updateFromStream(aStream: nsIInputStreamType, aLen: unsigned_long): void;
    /**
     * Completes this hash object and produces the actual hash data.
     *
     * @param aASCII If true then the returned value is a base64 encoded string.
     * If false, then the returned value is binary data.
     *
     * @return a hash of the data that was read by this object.  This can
     * be either binary data or base 64 encoded.
     *
     * @throws NS_ERROR_NOT_INITIALIZED If |init| has not been called.
     *
     * NOTE: This method may be called any time after |init|
     * is called.  This call resets the object to its
     * pre-init state.
     */
    finish(aASCII: boolean): ACString;
}

/**
 * nsICycleCollectorHandler is the interface JS code should implement to
 * receive the results logged by an nsICycleCollectorListener
 * instance. Pass an instance of this to the logger's 'processNext' method
 * after the collection has run. This will describe the objects the cycle
 * collector visited, the edges it found, and the conclusions it reached
 * about the liveness of objects.
 *
 * In more detail:
 * - For each node in the graph:
 * - a call is made to either |noteRefCountedObject| or |noteGCedObject|, to
 * describe the node itself; and
 * - for each edge starting at that node, a call is made to |noteEdge|.
 *
 * - Then, a series of calls are made to:
 * - |describeRoot|, for reference-counted nodes that the CC has identified as
 * being alive because there are unknown references to those nodes.
 * - |describeGarbage|, for nodes the cycle collector has identified as garbage.
 *
 * Any node not mentioned in a call to |describeRoot| or |describeGarbage| is
 * neither a root nor garbage. The cycle collector was able to find all of the
 * edges implied by the node's reference count.
 */
declare interface nsICycleCollectorHandlerType extends nsISupportsType {
    /**
     *
     */
    noteRefCountedObject(aAddress: ACString, aRefCount: unsigned_long, aObjectDescription: ACString): void;
    /**
     *
     */
    noteGCedObject(aAddress: ACString, aMarked: boolean, aObjectDescription: ACString, aCompartmentAddress: ACString): void;
    /**
     *
     */
    noteEdge(aFromAddress: ACString, aToAddress: ACString, aEdgeName: ACString): void;
    /**
     *
     */
    describeRoot(aAddress: ACString, aKnownEdges: unsigned_long): void;
    /**
     *
     */
    describeGarbage(aAddress: ACString): void;
}

/**
 * This interface allows replacing the log-writing backend for an
 * nsICycleCollectorListener.  As this interface is also called while
 * the cycle collector is running, it cannot be implemented in JS.
 */
declare interface nsICycleCollectorLogSinkType extends nsISupportsType {
    /**
     *
     */
    closeGCLog(): void;
    /**
     *
     */
    closeCCLog(): void;
    /**
     *
     */
    filenameIdentifier: AString;
    /**
     *
     */
    processIdentifier: int32_t;
    /**
     *
     */
    readonly gcLog: nsIFile;
    /**
     *
     */
    readonly ccLog: nsIFile;
}

/**
 * This interface is used to configure some reporting options for the cycle
 * collector. This interface cannot be implemented by JavaScript code, as it
 * is called while the cycle collector is running.
 *
 * To analyze cycle collection data in JS:
 *
 * - Create an instance of nsICycleCollectorListener, which implements this
 * interface. In C++, this can be done by calling
 * nsCycleCollector_createLogger(). In JS, this can be done by calling
 * Components.utils.createCCLogger().
 *
 * - Set its |disableLog| property to true. This prevents the logger from
 * printing messages about each method call to a temporary log file.
 *
 * - Set its |wantAfterProcessing| property to true. This tells the logger
 * to record calls to its methods in memory. The |processNext| method
 * returns events from this record.
 *
 * - Perform a collection using the logger. For example, call
 * |nsIDOMWindowUtils|'s |garbageCollect| method, passing the logger as
 * the |aListener| argument.
 *
 * - When the collection is complete, loop calling the logger's
 * |processNext| method, passing a JavaScript object that implements
 * nsICycleCollectorHandler. This JS code is free to allocate and operate
 * on objects however it pleases: the cycle collector has finished its
 * work, and the JS code is simply consuming recorded data.
 */
declare interface nsICycleCollectorListenerType extends nsISupportsType {
    /**
     *
     */
    allTraces(): nsICycleCollectorListener;
    /**
     *
     */
    readonly wantAllTraces: boolean;
    /**
     *
     */
    disableLog: boolean;
    /**
     *
     */
    logSink: nsICycleCollectorLogSink;
    /**
     *
     */
    wantAfterProcessing: boolean;
    /**
     *
     */
    processNext(aHandler: nsICycleCollectorHandlerType): boolean;
}

/**
 *
 */
declare interface nsIDAPTelemetryType extends nsISupportsType {
    /**
     * Split measurement into shares and create a report with encrypted shares.
     *
     * @param leaderHpkeConfig  The leader share will be encrypted with this
     * config.
     * @param helperHpkeConfig  Same for the helper.
     * @param measurement       The data which will be encoded and shared.
     * @param task_id           Identifies which task this measurement is for
     * which influences both encoding and encryption.
     * @param time_precision    Determines the report timestamp.
     *
     * @return The raw bytes of a report, ready for sending.
     *
     * @note This can potentially run for a long time. Take care not to block
     * the main thread for too long.
     */
    GetReportU8(leaderHpkeConfig: invalid, helperHpkeConfig: invalid, measurement: uint8_t, task_id: invalid, time_precision: uint64_t, report: invalid): void;
    /**
     *
     */
    GetReportVecU16(leaderHpkeConfig: invalid, helperHpkeConfig: invalid, measurement: invalid, task_id: invalid, time_precision: uint64_t, report: invalid): void;
}

/**
 * This interface allows the proxy code to access the DHCP Options in a platform-specific way
 */
declare interface nsIDHCPClientType extends nsISupportsType {
    /**
     * returns the DHCP Option designated by the option parameter
     */
    getOption(option: uint8_t): ACString;
}

/**
 *
 */
declare interface nsIDNSAdditionalInfoType extends nsISupportsType {
    /**
     *
     */
    readonly port: int32_t;
    /**
     *
     */
    readonly resolverURL: ACString;
}

/**
 *
 */
declare interface nsIDNSByTypeRecordType extends nsIDNSRecordType {
    /**
     * Returns DNS request type that was made for this request.
     */
    readonly type: unsigned_long;
    /**
     *
     */
    readonly results: TypeResult;
}

/**
 *
 */
declare interface nsIDNSTXTRecordType extends nsISupportsType {
    /**
     *
     */
    getRecords(): CStringArrayRef;
    /**
     * Return concatenated strings.
     */
    getRecordsAsOneString(): ACString;
}

/**
 *
 */
declare interface nsISVCParamType extends nsISupportsType {
    /**
     *
     */
    readonly type: uint16_t;
}

/**
 *
 */
declare interface nsISVCParamAlpnType extends nsISupportsType {
}

/**
 *
 */
declare interface nsISVCParamNoDefaultAlpnType extends nsISupportsType {
}

/**
 *
 */
declare interface nsISVCParamPortType extends nsISupportsType {
    /**
     *
     */
    readonly port: uint16_t;
}

/**
 *
 */
declare interface nsISVCParamIPv4HintType extends nsISupportsType {
}

/**
 *
 */
declare interface nsISVCParamEchConfigType extends nsISupportsType {
    /**
     *
     */
    readonly echconfig: ACString;
}

/**
 *
 */
declare interface nsISVCParamIPv6HintType extends nsISupportsType {
}

/**
 *
 */
declare interface nsISVCParamODoHConfigType extends nsISupportsType {
    /**
     *
     */
    readonly ODoHConfig: ACString;
}

/**
 *
 */
declare interface nsISVCBRecordType extends nsISupportsType {
    /**
     *
     */
    readonly priority: uint16_t;
    /**
     *
     */
    readonly name: ACString;
    /**
     *
     */
    readonly port: MaybePort;
    /**
     *
     */
    readonly alpn: MaybeAlpnTuple;
    /**
     *
     */
    readonly selectedAlpn: ACString;
    /**
     *
     */
    readonly echConfig: ACString;
    /**
     *
     */
    readonly ODoHConfig: ACString;
    /**
     *
     */
    readonly hasIPHintAddress: bool;
}

/**
 *
 */
declare interface nsIDNSHTTPSSVCRecordType extends nsISupportsType {
    /**
     *
     */
    GetServiceModeRecord(aNoHttp2: boolean, aNoHttp3: boolean): nsISVCBRecord;
    /**
     * Returns true if one of SVCB records has IPv4 or IPv6 hint addresses.
     */
    readonly hasIPAddresses: boolean;
    /**
     * Returns true when all names of SVCB records are in exclusion list.
     */
    readonly allRecordsExcluded: boolean;
    /**
     * Returns the ttl of this record.
     */
    readonly ttl: uint32_t;
}

/**
 * nsIDNSListener
 */
declare interface nsIDNSListenerType extends nsISupportsType {
    /**
     * called when an asynchronous host lookup completes.
     *
     * @param aRequest
     * the value returned from asyncResolve.
     * @param aRecord
     * the DNS record corresponding to the hostname that was resolved.
     * this parameter is null if there was an error.
     * depending on the type parameter passed to asyncResolve() the
     * caller should QueryInterface to either nsIDNSAddrRecord or
     * nsIDNSByTypeRecord.
     * @param aStatus
     * if the lookup failed, this parameter gives the reason.
     */
    onLookupComplete(aRequest: nsICancelableType, aRecord: nsIDNSRecordType, aStatus: nsresult): void;
}

/**
 * nsIDNSRecord
 *
 * this interface represents the result of a DNS lookup.  since a DNS
 * query may return more than one resolved IP address, the record acts
 * like an enumerator, allowing the caller to easily step through the
 * list of IP addresses.
 */
declare interface nsIDNSRecordType extends nsISupportsType {
}

/**
 *
 */
declare interface nsIDNSAddrRecordType extends nsIDNSRecordType {
    /**
     * @return the canonical hostname for this record.  this value is empty if
     * the record was not fetched with the RESOLVE_CANONICAL_NAME flag.
     *
     * e.g., www.mozilla.org --> rheet.mozilla.org
     *
     * That the result, if IDN will be returned as punycode.
     * e.g., lve.w3c-test.org --> xn--lve-6lad.w3c-test.org
     */
    readonly canonicalName: ACString;
    /**
     * this function returns the value of the next IP address as a
     * scriptable address and increments the internal address iterator.
     *
     * @param aPort
     * A port number to initialize the nsINetAddr with.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if there is not another IP address in
     * the record.
     */
    getScriptableNextAddr(aPort: uint16_t): nsINetAddr;
    /**
     * this function returns the value of the next IP address as a
     * string and increments the internal address iterator.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if there is not another IP address in
     * the record.
     */
    getNextAddrAsString(): ACString;
    /**
     * this function returns true if there is another address in the record.
     */
    hasMore(): boolean;
    /**
     * this function resets the internal address iterator to the first
     * address in the record.
     */
    rewind(): void;
    /**
     * This function indicates that the last address obtained via getNextAddr*()
     * was not usuable and should be skipped in future uses of this
     * record if other addresses are available.
     *
     * @param aPort is the port number associated with the failure, if any.
     * It may be zero if not applicable.
     */
    reportUnusable(aPort: uint16_t): void;
    /**
     * Record retreived with TRR.
     */
    IsTRR(): bool;
    /**
     * Record is resolved in socket process.
     */
    resolvedInSocketProcess(): bool;
    /**
     * This attribute is only set if TRR is used and it measures time between
     * asyncOpen on a channel and the time parsing of response if done.
     * Thee time is measured in milliseconds.
     */
    readonly trrFetchDuration: double;
    /**
     * This attribute is only set if TRR is used and it measures time between
     * sending a request and the time response is received from the network.
     * This time is similat to the time above, but exludes a time needed to
     * make a connection and a time neededto parse results (this also does not
     * include delays that may be introduce because parsing is perform on the main
     * thread).
     * Thee time is measured in milliseconds.
     */
    readonly trrFetchDurationNetworkOnly: double;
    /**
     * The TRR mode this record is used.
     */
    readonly effectiveTRRMode: nsIRequest_TRRMode;
    /**
     * If the DNS request didn't use TRR, this value
     * contains the reason why that was skipped.
     */
    readonly trrSkipReason: nsITRRSkipReason_value;
    /**
     * Returns the ttl of this record.
     */
    readonly ttl: uint32_t;
}

/**
 * nsIDNSService
 */
declare interface nsIDNSServiceType extends nsISupportsType {
    /**
     * kicks off an asynchronous host lookup.
     *
     * @param aHostName
     * the hostname or IP-address-literal to resolve.
     * @param aType
     * one of RESOLVE_TYPE_*.
     * @param aFlags
     * a bitwise OR of the RESOLVE_ prefixed constants defined below.
     * @param aInfo
     * a AdditionalInfo object that holds information about:
     * - the resolver to be used such as TRR URL
     * - the port number that could be used to construct a QNAME
     * for HTTPS RR
     * If null we use the default configuration.
     * @param aListener
     * the listener to be notified when the result is available.
     * @param aListenerTarget
     * optional parameter (may be null).  if non-null, this parameter
     * specifies the nsIEventTarget of the thread on which the
     * listener's onLookupComplete should be called.  however, if this
     * parameter is null, then onLookupComplete will be called on an
     * unspecified thread (possibly recursively).
     * @param aOriginAttributes
     * the originAttribute for this resolving, the DNS cache will be
     * separated according to this originAttributes. This attribute is
     * optional to avoid breaking add-ons.
     *
     * @return An object that can be used to cancel the host lookup.
     */
    asyncResolve(aHostName: AUTF8String, aType: nsIDNSService_ResolveTypeType, aFlags: nsIDNSService_DNSFlagsType, aInfo: nsIDNSAdditionalInfoType, aListener: nsIDNSListenerType, aListenerTarget: nsIEventTargetType, aOriginAttributes: jsval): nsICancelable;
    /**
     *
     */
    asyncResolveNative(aHostName: AUTF8String, aType: nsIDNSService_ResolveTypeType, aFlags: nsIDNSService_DNSFlagsType, aInfo: nsIDNSAdditionalInfoType, aListener: nsIDNSListenerType, aListenerTarget: nsIEventTargetType, aOriginAttributes: OriginAttributes, aResult: nsICancelableType): nsresult;
    /**
     * Returns a new nsIDNSAdditionalInfo object containing the URL we pass to it.
     */
    newAdditionalInfo(aTrrURL: AUTF8String, aPort: int32_t): nsIDNSAdditionalInfo;
    /**
     * Attempts to cancel a previously requested async DNS lookup
     *
     * @param aHostName
     * the hostname or IP-address-literal to resolve.
     * @param aType
     * one of RESOLVE_TYPE_*.
     * @param aFlags
     * a bitwise OR of the RESOLVE_ prefixed constants defined below.
     * @param aInfo
     * a AdditionalInfo object that holds information about:
     * - the resolver to be used such as TRR URL
     * - the port number that could be used to construct a QNAME
     * for HTTPS RR
     * If null we use the default configuration.
     * @param aListener
     * the original listener which was to be notified about the host lookup
     * result - used to match request information to requestor.
     * @param aReason
     * nsresult reason for the cancellation
     * @param aOriginAttributes
     * the originAttribute for this resolving. This attribute is optional
     * to avoid breaking add-ons.
     */
    cancelAsyncResolve(aHostName: AUTF8String, aType: nsIDNSService_ResolveTypeType, aFlags: nsIDNSService_DNSFlagsType, aResolver: nsIDNSAdditionalInfoType, aListener: nsIDNSListenerType, aReason: nsresult, aOriginAttributes: jsval): void;
    /**
     *
     */
    cancelAsyncResolveNative(aHostName: AUTF8String, aType: nsIDNSService_ResolveTypeType, aFlags: nsIDNSService_DNSFlagsType, aResolver: nsIDNSAdditionalInfoType, aListener: nsIDNSListenerType, aReason: nsresult, aOriginAttributes: OriginAttributes): nsresult;
    /**
     * called to synchronously resolve a hostname.
     *
     * Since this method may block the calling thread for a long period of
     * time, it may not be accessed from the main thread.
     *
     * @param aHostName
     * the hostname or IP-address-literal to resolve.
     * @param aFlags
     * a bitwise OR of the RESOLVE_ prefixed constants defined below.
     * @param aOriginAttributes
     * the originAttribute for this resolving, the DNS cache will be
     * separated according to this originAttributes. This attribute is
     * optional to avoid breaking add-ons.
     *
     * @return DNS record corresponding to the given hostname.
     * @throws NS_ERROR_UNKNOWN_HOST if host could not be resolved.
     * @throws NS_ERROR_NOT_AVAILABLE if accessed from the main thread.
     */
    resolve(aHostName: AUTF8String, aFlags: nsIDNSService_DNSFlagsType, aOriginAttributes: jsval): nsIDNSRecord;
    /**
     *
     */
    resolveNative(aHostName: AUTF8String, aFlags: nsIDNSService_DNSFlagsType, aOriginAttributes: OriginAttributes, aResult: nsIDNSRecordType): nsresult;
    /**
     * Clears the DNS cache.
     * @param aTrrToo
     * If true we will clear TRR cached entries too. Since these
     * are resolved remotely it's not necessary to clear them when
     * the network status changes, but it's sometimes useful to do so
     * for tests or other situations.
     */
    clearCache(aTrrToo: boolean): void;
    /**
     * The method is used only for test purpose. We use this to recheck if
     * parental control is enabled or not.
     */
    reloadParentalControlEnabled(): void;
    /**
     * Notifies the TRR service of a TRR that was automatically detected based
     * on network preferences.
     */
    setDetectedTrrURI(aURI: AUTF8String): void;
    /**
     * Stores the result of the TRR heuristic detection.
     * Will be TRR_OK if no heuristics failed.
     */
    setHeuristicDetectionResult(value: nsITRRSkipReason_valueType): void;
    /**
     * Returns the result of the last TRR heuristic detection.
     * Will be TRR_OK if no heuristics failed.
     */
    readonly heuristicDetectionResult: nsITRRSkipReason_value;
    /**
     *
     */
    getTRRSkipReasonName(value: nsITRRSkipReason_valueType): ACString;
    /**
     * The channel status of the last TRR confirmation attempt.
     * In strict mode it reflects the channel status of the last TRR request.
     */
    readonly lastConfirmationStatus: nsresult;
    /**
     * The TRR skip reason of the last TRR confirmation attempt.
     * In strict mode it reflects the TRR skip reason of the last TRR request.
     */
    readonly lastConfirmationSkipReason: nsITRRSkipReason_value;
    /**
     * Returns a string containing the URI currently used by the TRR service.
     */
    readonly currentTrrURI: AUTF8String;
    /**
     * Returns the value of the TRR Service's current default mode.
     */
    readonly currentTrrMode: nsIDNSService_ResolverMode;
    /**
     * The TRRService's current confirmation state.
     * This is mostly for testing purposes.
     */
    readonly currentTrrConfirmationState: unsigned_long;
    /**
     * @return the hostname of the operating system.
     */
    readonly myHostName: AUTF8String;
    /**
     * returns the current TRR domain.
     */
    readonly trrDomain: ACString;
    /**
     * returns the telemetry key for current TRR domain.
     */
    readonly TRRDomainKey: ACString;
}

/**
 *
 */
declare interface nsIDOMChromeWindowType extends nsISupportsType {
    /**
     * browserDOMWindow provides access to yet another layer of
     * utility functions implemented by chrome script. It will be null
     * for DOMWindows not corresponding to browsers.
     */
    readonly browserDOMWindow: nsIBrowserDOMWindow;
}

/**
 * The nsIDOMEventListener interface is a callback interface for
 * listening to events in the Document Object Model.
 *
 * For more information on this interface please see
 * http://www.w3.org/TR/DOM-Level-2-Events/
 */
declare interface nsIDOMEventListenerType extends nsISupportsType {
    /**
     * This method is called whenever an event occurs of the type for which
     * the EventListener interface was registered.
     *
     * @param   evt The Event contains contextual information about the
     * event. It also contains the stopPropagation and
     * preventDefault methods which are used in determining the
     * event's flow and default action.
     */
    handleEvent(event: Event): void;
}

/**
 *
 */
declare interface nsIDOMGeoPositionType extends nsISupportsType {
    /**
     *
     */
    readonly timestamp: EpochTimeStamp;
    /**
     *
     */
    readonly coords: nsIDOMGeoPositionCoords;
}

/**
 *
 */
declare interface nsIDOMGeoPositionCallbackType extends nsISupportsType {
    /**
     *
     */
    handleEvent(position: nsIDOMGeoPositionType): void;
}

/**
 *
 */
declare interface nsIDOMGeoPositionCoordsType extends nsISupportsType {
    /**
     *
     */
    readonly latitude: double;
    /**
     *
     */
    readonly longitude: double;
    /**
     *
     */
    readonly altitude: double;
    /**
     *
     */
    readonly accuracy: double;
    /**
     *
     */
    readonly altitudeAccuracy: double;
    /**
     *
     */
    readonly heading: double;
    /**
     *
     */
    readonly speed: double;
}

/**
 *
 */
declare interface nsIDOMGeoPositionErrorCallbackType extends nsISupportsType {
    /**
     *
     */
    handleEvent(positionError: GeolocationPositionError): void;
}

/**
 *
 */
declare interface nsIDOMGlobalPropertyInitializerType extends nsISupportsType {
    /**
     * Initialize the global property.
     *
     * @param window the global object on which the property is being retrieved.
     *
     * @returns a JS Object to use use as the property's value.
     */
    init(window: mozIDOMWindow): jsval;
}

/**
 *
 */
declare interface nsIDOMMozBrowserFrameType extends nsISupportsType {
    /**
     * <iframe> element may have the mozbrowser attribute.
     *
     * The mozbrowser attribute has no effect unless the <iframe> element is
     * contained in a document privileged to create browser frames.
     *
     * An <iframe> element in a privileged document with the mozbrowser attribute
     * emits a variety of events when various things happen inside the frame.
     *
     * This will be documented eventually, but for more information at the moment,
     * see dom/browser-element/BrowserElement{Child,Parent}.js.
     */
    mozbrowser: boolean;
}

/**
 * Child actor interface for a process which can host DOM content.
 *
 * Implemented by either `InProcessChild` for the parent process, or
 * `ContentChild` for a content process.
 */
declare interface nsIDOMProcessChildType extends nsISupportsType {
    /**
     * Internal child process ID. `0` is reserved for the parent process.
     */
    readonly childID: unsigned_long_long;
    /**
     * Lookup a JSProcessActorChild managed by this interface by name.
     */
    getActor(name: ACString): JSProcessActorChild;
    /**
     *
     */
    getExistingActor(name: ACString): JSProcessActorChild;
    /**
     * Can the actor still send messages?
     */
    readonly canSend: boolean;
    /**
     *
     */
    AsContentChild(): ContentChildPtr;
    /**
     * Cast this nsIDOMProcessChild to a JSActorManager
     */
    AsJSActorManager(): JSActorManagerPtr;
}

/**
 * Parent actor interface for a process which can host DOM content.
 *
 * Implemented by either `InProcessParent` for the parent process, or
 * `ContentParent` for a content process.
 */
declare interface nsIDOMProcessParentType extends nsISupportsType {
    /**
     * Internal child process ID. `0` is reserved for the parent process.
     */
    readonly childID: unsigned_long_long;
    /**
     * OS ID of the process.
     */
    readonly osPid: long;
    /**
     * Lookup a JSProcessActorParent managed by this interface by name.
     */
    getActor(name: ACString): JSProcessActorParent;
    /**
     *
     */
    getExistingActor(name: ACString): JSProcessActorParent;
    /**
     * Can the actor still send messages?
     */
    readonly canSend: boolean;
    /**
     *
     */
    AsContentParent(): ContentParentPtr;
    /**
     * Cast this nsIDOMProcessParent to a JSActorManager
     */
    AsJSActorManager(): JSActorManagerPtr;
    /**
     * Remote type of the process.
     */
    readonly remoteType: ACString;
}

/**
 *
 */
declare interface nsIDOMRequestServiceType extends nsISupportsType {
    /**
     *
     */
    createRequest(window: mozIDOMWindow): DOMRequest;
    /**
     *
     */
    fireSuccess(request: DOMRequest, result: jsval): void;
    /**
     *
     */
    fireError(request: DOMRequest, error: AString): void;
    /**
     *
     */
    fireSuccessAsync(request: DOMRequest, result: jsval): void;
    /**
     *
     */
    fireErrorAsync(request: DOMRequest, error: AString): void;
}

/**
 * General purpose interface that has two implementations, for localStorage
 * with "@mozilla.org/dom/localStorage-manager;1".
 */
declare interface nsIDOMStorageManagerType extends nsISupportsType {
    /**
     * This starts async preloading of a storage cache for scope
     * defined by the principal and storage principal.
     *
     * Because of how multi-e10s support was implemented in bug 1285898, the
     * StorageCache instance can no longer use a timer to keep itself alive.  So a
     * Storage instance is returned if precaching believes the storage principal may
     * have localStorage data.  (Previously the StorageCache would be brought into
     * existence and kept alive by the timer so that it could be returned if a
     * call to createStorage was made due to a request by the page.)
     */
    precacheStorage(aPrincipal: nsIPrincipalType, aStoragePrincipal: nsIPrincipalType): Storage;
    /**
     * Returns instance of DOM storage object for given principal.
     * A new object is always returned and it is ensured there is
     * a storage for the scope created.
     *
     * @param aWindow
     * The parent window.
     * @param aPrincipal
     * Principal to bound storage to.
     * @param aStoragePrincipal
     * StoragePrincipal to bound storage to.
     * @param aDocumentURI
     * URL of the demanding document, used for DOM storage event only.
     * @param aPrivate
     * Whether the demanding document is running in Private Browsing mode or not.
     */
    createStorage(aWindow: mozIDOMWindow, aPrincipal: nsIPrincipalType, aStoragePrincipal: nsIPrincipalType, aDocumentURI: AString, aPrivate: bool): Storage;
    /**
     * DEPRECATED.  The only good reason to use this was if you were writing a
     * test and wanted to hackily determine if a preload happened.  That's now
     * covered by `nsILocalStorageManager.isPreloaded` and you should use that if
     * that's what you want.  If LSNG is in use, this will throw.
     *
     * Returns instance of DOM storage object for given principal.
     * If there is no storage managed for the scope, then null is returned and
     * no object is created.  Otherwise, an object (new) for the existing storage
     * scope is returned.
     *
     * @param aWindow
     * The parent window.
     * @param aPrincipal
     * Principal to bound storage to.
     * @param aStoragePrincipal
     * StoragePrincipal to bound storage to.
     * @param aPrivate
     * Whether the demanding document is running in Private Browsing mode or not.
     */
    getStorage(aWindow: mozIDOMWindow, aPrincipal: nsIPrincipalType, aStoragePrincipal: nsIPrincipalType, aPrivate: bool): Storage;
    /**
     * Clones given storage into this storage manager.
     *
     * @param aStorageToCloneFrom
     * The storage to copy all items from into this manager.  Manager will then
     * return a new and independent object that contains snapshot of data from
     * the moment this method was called.  Modification to this new object will
     * not affect the original storage content we cloned from and vice versa.
     */
    cloneStorage(aStorageToCloneFrom: Storage): void;
    /**
     * Returns true if the storage belongs to the given principal and is managed
     * (i.e. has been created and is cached) by this storage manager.
     *
     * @param aPrincipal
     * Principal to check the storage against.
     * @param aStorage
     * The storage object to examine.
     *
     * @result
     * true when the storage object is bound with the principal and is managed
     * by this storage manager.
     * false otherwise
     */
    checkStorage(aPrincipal: nsIPrincipalType, aStorage: Storage): bool;
}

/**
 *
 */
declare interface nsIDOMSessionStorageManagerType extends nsIDOMStorageManagerType {
}

/**
 *
 */
declare interface nsIDOMMozWakeLockListenerType extends nsISupportsType {
    /**
     * The callback will be called when a lock topic changes its lock
     * state.
     *
     * Possible states are:
     *
     * - "unlocked" - nobody holds the wake lock.
     *
     * - "locked-foreground" - at least one window holds the wake lock,
     * and it is visible.
     *
     * - "locked-background" - at least one window holds the wake lock,
     * but all of them are hidden.
     *
     * @param aTopic The resource name related to the wake lock.
     * @param aState The wake lock state
     */
    callback(aTopic: AString, aState: AString): void;
}

/**
 * Empty interface for compatibility with older versions.
 * @deprecated Use WebIDL for script visible features,
 * nsPIDOMWindow for C++ callers.
 */
declare interface nsIDOMWindowType extends nsISupportsType {
}

/**
 *
 */
declare interface nsIDOMWindowUtilsType extends nsISupportsType {
    /**
     * Image animation mode of the window. When this attribute's value
     * is changed, the implementation should set all images in the window
     * to the given value. That is, when set to kDontAnimMode, all images
     * will stop animating. The attribute's value must be one of the
     * animationMode values from imgIContainer.
     * @note Images may individually override the window's setting after
     * the window's mode is set. Therefore images given different modes
     * since the last setting of the window's mode may behave
     * out of line with the window's overall mode.
     * @note The attribute's value is the window's overall mode. It may
     * for example continue to report kDontAnimMode after all images
     * have subsequently been individually animated.
     * @note Only images immediately in this window are affected;
     * this is not recursive to subwindows.
     * @see imgIContainer
     */
    imageAnimationMode: unsigned_short;
    /**
     * Whether the charset of the window's current document has been forced by
     * the user.
     * Cannot be accessed from unprivileged context (not content-accessible)
     */
    readonly docCharsetIsForced: boolean;
    /**
     * Return the conversion of a physical millimeter in CSS pixels.
     */
    readonly physicalMillimeterInCSSPixels: float;
    /**
     * Function to get metadata associated with the window's current document
     * @param aName the name of the metadata.  This should be all lowercase.
     * @return the value of the metadata, or the empty string if it's not set
     *
     * Will throw a DOM security error if called without chrome privileges.
     */
    getDocumentMetadata(aName: AString): AString;
    /**
     * Relative to the top-level document.
     *
     * @param aX 0, if there's no such location.
     * @param aY 0, if there's no such location.
     */
    getLastOverWindowPointerLocationInCSSPixels(aX: float, aY: float): void;
    /**
     * Force a synchronous layer transaction for this window if necessary.
     */
    updateLayerTree(): void;
    /**
     * Get the last used layer transaction id for this window's refresh driver.
     */
    readonly lastTransactionId: unsigned_long_long;
    /**
     * Information retrieved from the <meta name="viewport"> tag.
     * See Document::GetViewportInfo for more information.
     */
    getViewportInfo(aDisplayWidth: uint32_t, aDisplayHeight: uint32_t, aDefaultZoom: double, aAllowZoom: boolean, aMinZoom: double, aMaxZoom: double, aWidth: uint32_t, aHeight: uint32_t, aAutoSize: boolean): void;
    /**
     * Information retrieved from the viewport-fit value of <meta name="viewport">
     * element.
     */
    getViewportFitInfo(): AString;
    /**
     * Information about the window size in device pixels.
     */
    getContentViewerSize(aDisplayWidth: uint32_t, aDisplayHeight: uint32_t): void;
    /**
     * For any scrollable element, this allows you to override the default
     * scroll behaviour and force autodir (which allows a mousewheel to
     * horizontally scroll regions that only scroll on that one axis).
     *
     * See the documentation for mousewheel.autodir.enabled and
     * mousewheel.autodir.honourroot for a more thorough explanation of
     * what these behaviours do.
     */
    setMousewheelAutodir(aElement: Element, aEnabled: boolean, aHonourRoot: boolean): void;
    /**
     * For any scrollable element, this allows you to override the
     * visible region and draw more than what is visible, which is
     * useful for asynchronous drawing. The "displayport" will be
     * <xPx, yPx, widthPx, heightPx> in units of CSS pixels,
     * regardless of the size of the enclosing container.  This
     * will *not* trigger reflow.
     *
     * For the root scroll area, pass in the root document element.
     * For scrollable elements, pass in the container element (for
     * instance, the element with overflow: scroll).
     *
     * <x, y> is relative to the top-left of what would normally be
     * the visible area of the element. This means that the pixels
     * rendered to the displayport take scrolling into account,
     * for example.
     *
     * It's legal to set a displayport that extends beyond the overflow
     * area in any direction (left/right/top/bottom).
     *
     * It's also legal to set a displayport that extends beyond the
     * area's bounds.  No pixels are rendered outside the area bounds.
     *
     * The caller of this method must have chrome privileges.
     *
     * Calling this will always force a recomposite, so it should be
     * avoided if at all possible. Client code should do checks before
     * calling this so that duplicate sets are not made with the same
     * displayport.
     *
     * aPriority is recorded along with the displayport rectangle. If this
     * method is called with a lower priority than the current priority, the
     * call is ignored.
     */
    setDisplayPortForElement(aXPx: float, aYPx: float, aWidthPx: float, aHeightPx: float, aElement: Element, aPriority: uint32_t): void;
    /**
     * An alternate way to represent a displayport rect as a set of margins and a
     * base rect to apply those margins to. A consumer of pixels may ask for as
     * many extra pixels as it would like in each direction. Layout then sets
     * the base rect to the "visible rect" of the element, which is just the
     * subrect of the element that is drawn (it does not take in account content
     * covering the element).
     *
     * If both a displayport rect and displayport margins with corresponding base
     * rect are set with the same priority then the margins will take precendence.
     *
     * Specifying an alignment value will ensure that after the base rect has
     * been expanded by the displayport margins, it will be further expanded so
     * that each edge is located at a multiple of the "alignment" value.
     *
     * Note that both the margin values and alignment are treated as values in
     * ScreenPixels. Refer to layout/base/Units.h for a description of this unit.
     * The base rect values are in app units.
     */
    setDisplayPortMarginsForElement(aLeftMargin: float, aTopMargin: float, aRightMargin: float, aBottomMargin: float, aElement: Element, aPriority: uint32_t): void;
    /**
     *
     */
    setDisplayPortBaseForElement(aX: int32_t, aY: int32_t, aWidth: int32_t, aHeight: int32_t, aElement: Element): void;
    /**
     * If |aElement| is a scroll container, returns the amount of layout
     * space taken up by its scrollbars (that is, the width of the vertical
     * scrollbar and the height of the horizontal scrollbar) in CSS pixels;
     * otherwise returns zero.
     *
     * Note that on some platforms, scrollbars don't take up layout space
     * ("overlay scrollbars"). On such platforms, the returned sizes are
     * always zero.
     *
     * Layout scrollbars that normally take up space but were only shown to
     * scroll the visual viewport inside the layout viewport (the layout viewport
     * cannot be scrolled) do not take up space but they still return their size
     * from this function.
     */
    getScrollbarSizes(aElement: Element, aVerticalScrollbarWidth: uint32_t, aHorizontalScrollbarHeight: uint32_t): void;
    /**
     * Get/set the resolution at which rescalable web content is drawn for
     * testing purposes.
     *
     * Setting a new resolution does *not* trigger reflow.  This API is
     * entirely separate from textZoom and fullZoom; a resolution scale
     * can be applied together with both textZoom and fullZoom.
     *
     * The effect of this API is for gfx code to allocate more or fewer
     * pixels for rescalable content by a factor of |resolution| in
     * both dimensions.
     *
     * In addition, the content is scaled by the amount of the resolution,
     * so that it is displayed at a correspondingly larger or smaller size,
     * without the need for the caller to set an additional transform.
     *
     * The purpose of this API is to allow tests to simulate many of the effects
     * a non-reflowing scale-zoom, e.g. for pinch-zoom on mobile platforms, and
     * should be only used for testing purposes.
     *
     * The caller of this method must have chrome privileges.
     *
     * This is intended to be used by test code only!
     */
    setResolutionAndScaleTo(aResolution: float): void;
    /**
     *
     */
    getResolution(): float;
    /**
     * Set a resolution on the presShell which is the "restored" from history.
     * The display dimensions are compared to their current values and used
     * to scale the resolution value if necessary, e.g. if the device was
     * rotated between saving and restoring of the session data.
     * This resolution should be used when painting for the first time. Calling
     * this too late may have no effect.
     */
    setRestoreResolution(aResolution: float, aDisplayWidth: uint32_t, aDisplayHeight: uint32_t): void;
    /**
     * Whether the next paint should be flagged as the first paint for a document.
     * This gives a way to track the next paint that occurs after the flag is
     * set. The flag gets cleared after the next paint.
     *
     * Can only be accessed with chrome privileges.
     */
    isFirstPaint: boolean;
    /**
     *
     */
    getPresShellId(): uint32_t;
    /**
     * Returns whether a given header and value is a CORS-safelisted request
     * header per https://fetch.spec.whatwg.org/#cors-safelisted-request-header
     */
    isCORSSafelistedRequestHeader(name: ACString, value: ACString): boolean;
    /**
     * Synthesize a mouse event. The event types supported are:
     * mousedown, mouseup, mousemove, mouseover, mouseout, mousecancel,
     * contextmenu, MozMouseHittest
     *
     * Events are sent in coordinates offset by aX and aY from the window.
     *
     * Note that additional events may be fired as a result of this call. For
     * instance, typically a click event will be fired as a result of a
     * mousedown and mouseup in sequence.
     *
     * Normally at this level of events, the mouseover and mouseout events are
     * only fired when the window is entered or exited. For inter-element
     * mouseover and mouseout events, a movemove event fired on the new element
     * should be sufficient to generate the correct over and out events as well.
     *
     * Cannot be accessed from unprivileged context (not content-accessible)
     * Will throw a DOM security error if called without chrome privileges.
     *
     * The event is dispatched via the toplevel window, so it could go to any
     * window under the toplevel window, in some cases it could never reach this
     * window at all.
     *
     * NOTE: mousecancel is used to represent the vanishing of an input device
     * such as a pen leaving its digitizer by synthesizing a WidgetMouseEvent,
     * whose mMessage is eMouseExitFromWidget and mExitFrom is
     * WidgetMouseEvent::eTopLevel.
     *
     * @param aType event type
     * @param aX x offset in CSS pixels
     * @param aY y offset in CSS pixels
     * @param aButton button to synthesize
     * @param aClickCount number of clicks that have been performed
     * @param aModifiers modifiers pressed, using constants defined as MODIFIER_*
     * @param aIgnoreRootScrollFrame whether the event should ignore viewport bounds
     * during dispatch
     * @param aPressure touch input pressure: 0.0 -> 1.0
     * @param aInputSourceArg input source, see MouseEvent for values,
     * defaults to mouse input.
     * @param aIsDOMEventSynthesized controls Event.isSynthesized value
     * that helps identifying test related events,
     * defaults to true
     * @param aIsWidgetEventSynthesized controls WidgetMouseEvent.mReason value
     * defaults to false (WidgetMouseEvent::eReal)
     * @param aIdentifier A unique identifier for the pointer causing the event,
     * defaulting to nsIDOMWindowUtils::DEFAULT_MOUSE_POINTER_ID.
     *
     * returns true if the page called prevent default on this event
     */
    sendMouseEvent(aType: AString, aX: float, aY: float, aButton: long, aClickCount: long, aModifiers: long, aIgnoreRootScrollFrame: boolean, aPressure: float, aInputSourceArg: unsigned_short, aIsDOMEventSynthesized: boolean, aIsWidgetEventSynthesized: boolean, aButtons: long, aIdentifier: unsigned_long): boolean;
    /**
     * Synthesize a touch event. The event types supported are:
     * touchstart, touchend, touchmove, and touchcancel
     *
     * Events are sent in coordinates offset by aX and aY from the window.
     *
     * Cannot be accessed from unprivileged context (not content-accessible)
     * Will throw a DOM security error if called without chrome privileges.
     *
     * The event is dispatched via the toplevel window, so it could go to any
     * window under the toplevel window, in some cases it could never reach this
     * window at all.
     *
     * @param aType event type
     * @param xs array of offsets in CSS pixels for each touch to be sent
     * @param ys array of offsets in CSS pixels for each touch to be sent
     * @param rxs array of radii in CSS pixels for each touch to be sent
     * @param rys array of radii in CSS pixels for each touch to be sent
     * @param rotationAngles array of angles in degrees for each touch to be sent
     * @param forces array of forces (floats from 0 to 1) for each touch to be sent
     * @param tiltXs array of tiltX for each touch to be sent
     * @param tiltYs array of tiltY for each touch to be sent
     * @param twists array of twist for each touch to be sent
     * @param count number of touches in this set
     * @param aModifiers modifiers pressed, using constants defined as MODIFIER_*
     * @param aIgnoreRootScrollFrame whether the event should ignore viewport bounds
     * during dispatch
     *
     * returns true if the page called prevent default on this touch event
     */
    sendTouchEvent(aType: AString, aIdentifiers: invalid, aXs: invalid, aYs: invalid, aRxs: invalid, aRys: invalid, aRotationAngles: invalid, aForces: invalid, aTiltXs: invalid, aTiltYs: invalid, aTwists: invalid, aModifiers: long, aIgnoreRootScrollFrame: boolean): boolean;
    /**
     * The same as sendMouseEvent but ensures that the event is dispatched to
     * this DOM window or one of its children.
     */
    sendMouseEventToWindow(aType: AString, aX: float, aY: float, aButton: long, aClickCount: long, aModifiers: long, aIgnoreRootScrollFrame: boolean, aPressure: float, aInputSourceArg: unsigned_short, aIsDOMEventSynthesized: boolean, aIsWidgetEventSynthesized: boolean, aButtons: long, aIdentifier: unsigned_long): void;
    /**
     * The same as sendTouchEvent but ensures that the event is dispatched to
     * this DOM window or one of its children.
     */
    sendTouchEventToWindow(aType: AString, aIdentifiers: invalid, aXs: invalid, aYs: invalid, aRxs: invalid, aRys: invalid, aRotationAngles: invalid, aForces: invalid, aTiltXs: invalid, aTiltYs: invalid, aTwists: invalid, aModifiers: long, aIgnoreRootScrollFrame: boolean): boolean;
    /**
     *
     */
    sendWheelEvent(aX: float, aY: float, aDeltaX: double, aDeltaY: double, aDeltaZ: double, aDeltaMode: unsigned_long, aModifiers: long, aLineOrPageDeltaX: long, aLineOrPageDeltaY: long, aOptions: unsigned_long): void;
    /**
     * See nsIWidget::SynthesizeNativeKeyEvent
     *
     * Cannot be accessed from unprivileged context (not content-accessible)
     * Will throw a DOM security error if called without chrome privileges.
     *
     * When you use this for tests, use the constants defined in NativeKeyCodes.js
     *
     * NOTE: The synthesized native event will be fired asynchronously, and upon
     * completion the observer, if provided, will be notified with a "keyevent"
     * topic.
     */
    sendNativeKeyEvent(aNativeKeyboardLayout: long, aNativeKeyCode: long, aModifierFlags: unsigned_long, aCharacters: AString, aUnmodifiedCharacters: AString, aObserver: nsIObserverType): void;
    /**
     *
     */
    sendNativeMouseEvent(aScreenX: long, aScreenY: long, aNativeMessage: unsigned_long, aButton: short, aModifierFlags: unsigned_long, aElementOnWidget: Element, aObserver: nsIObserverType): void;
    /**
     * Suppress animations that are applied to a window by OS when
     * resizing, moving, changing size mode, ...
     */
    suppressAnimation(aSuppress: boolean): void;
    /**
     * See nsIWidget::SynthesizeNativeMouseScrollEvent
     *
     * Will be called on the widget that contains aElement.
     * Cannot be accessed from unprivileged context (not content-accessible)
     * Will throw a DOM security error if called without chrome privileges.
     *
     * NOTE: The synthesized native event will be fired asynchronously, and upon
     * completion the observer, if provided, will be notified with a
     * "mousescrollevent" topic.
     *
     * @param aNativeMessage
     * On Windows:  WM_MOUSEWHEEL (0x020A), WM_MOUSEHWHEEL(0x020E),
     * WM_VSCROLL (0x0115) or WM_HSCROLL (0x114).
     */
    sendNativeMouseScrollEvent(aScreenX: long, aScreenY: long, aNativeMessage: unsigned_long, aDeltaX: double, aDeltaY: double, aDeltaZ: double, aModifierFlags: unsigned_long, aAdditionalFlags: unsigned_long, aElement: Element, aObserver: nsIObserverType): void;
    /**
     * Create a new or update an existing touch point on the digitizer.
     * To trigger os level gestures, individual touch points should
     * transition through a complete set of touch states which should be
     * sent as individual calls. For example:
     * tap - msg1:TOUCH_CONTACT, msg2:TOUCH_REMOVE
     * drag - msg1-n:TOUCH_CONTACT (moving), msgn+1:TOUCH_REMOVE
     * hover drag - msg1-n:TOUCH_HOVER (moving), msgn+1:TOUCH_REMOVE
     *
     * Widget support: Windows 8.0+, Winrt/Win32. Other widgets will throw.
     *
     * NOTE: The synthesized native event will be fired asynchronously, and upon
     * completion the observer, if provided, will be notified with a "touchpoint"
     * topic.
     *
     * @param aPointerId The touch point id to create or update.
     * @param aTouchState one or more of the touch states listed above
     * @param aScreenX, aScreenY screen coords of this event
     * @param aPressure 0.0 -> 1.0 float val indicating pressure
     * @param aOrientation 0 -> 359 degree value indicating the
     * orientation of the pointer. Use 90 for normal taps.
     */
    sendNativeTouchPoint(aPointerId: unsigned_long, aTouchState: unsigned_long, aScreenX: long, aScreenY: long, aPressure: double, aOrientation: unsigned_long, aObserver: nsIObserverType): void;
    /**
     * These values indicate touchpad pinch phase states :
     * PHASE_BEGIN
     * PHASE_UPDATE
     * PHASE_END
     * Widget support: Linux GTK 3.18+.
     * @param aEventPhase The touchpad pinch phase using states listed above.
     * @param aScale Events with PHASE_UPDATE will change the zoom level by
     * the ratio between the scale of the current event and the scale of the last event.
     * @param aScreenX, aScreenY screen coords of the focus point of this event.
     * @param aModifierFlags is expected to contain native modifier values.
     */
    sendNativeTouchpadPinch(aEventPhase: unsigned_long, aScale: float, aScreenX: long, aScreenY: long, aModifierFlags: long): void;
    /**
     * Simulates native touch based taps on the input digitizer. Events
     * triggered by this call are injected at the os level. Events do not
     * bypass widget level input processing and as such can be used to
     * test widget event logic and async pan-zoom controller functionality.
     * Cannot be accessed from an unprivileged context.
     *
     * Long taps (based on the aLongTap parameter) will be completed
     * asynchrnously after the call returns. Long tap delay is based on
     * the ui.click_hold_context_menus.delay pref or 1500 msec if pref
     * is not set.
     *
     * Widget support: Windows 8.0+, Winrt/Win32. Other widgets will
     * throw.
     *
     * NOTE: The synthesized native event will be fired asynchronously, and upon
     * completion the observer, if provided, will be notified, with a "touchtap"
     * topic.
     *
     * @param aScreenX, aScreenY screen coords of this event
     * @param aLongTap true if the tap should be long, false for a short
     * tap.
     */
    sendNativeTouchTap(aScreenX: long, aScreenY: long, aLongTap: boolean, aObserver: nsIObserverType): void;
    /**
     * Create a new or update an existing pen input on the digitizer.
     *
     * Widget support: Windows 10 1809+. Other widgets will throw.
     *
     * NOTE: The synthesized native event will be fired asynchronously, and upon
     * completion the observer, if provided, will be notified with a "peninput"
     * topic.
     *
     * @param aPointerId The touch point id to create or update.
     * @param aPointerState one or more of the TOUCH_* listed above
     * @param aScreenX x screen coord of this event
     * @param aScreenY y screen coord of this event
     * @param aPressure 0.0 -> 1.0 float val indicating pressure
     * @param aRotation 0 -> 359 degree value indicating the rotation of the
     * pointer. Use 0 for normal taps.
     * @param aTiltX -90 -> 90 degree value indicating the tilt along the x-axis
     * of the pointer. Use 0 for normal taps.
     * @param aTiltY -90 -> 90 degree value indicating the tilt along the y-axis
     * of the pointer. Use 0 for normal taps.
     * @param aButton Same as MouseEvent::button.
     */
    sendNativePenInput(aPointerId: unsigned_long, aPointerState: unsigned_long, aScreenX: long, aScreenY: long, aPressure: double, aRotation: unsigned_long, aTiltX: long, aTiltY: long, aButton: long, aObserver: nsIObserverType): void;
    /**
     * Cancel any existing touch points or long tap delays. Calling this is safe
     * even if you're sure there aren't any pointers recorded. You should call
     * this when tests shut down to reset the digitizer driver. Not doing so can
     * leave the digitizer in an undetermined state which can screw up subsequent
     * tests and native input.
     *
     * NOTE: The synthesized native event will be fired asynchronously, and upon
     * completion the observer, if provided, will be notified with a "cleartouch"
     * topic.
     */
    clearNativeTouchSequence(aObserver: nsIObserverType): void;
    /**
     * Send a native event as if the user double tapped the touchpad with two
     * fingers.
     *
     * Widget support: macOS.
     * @param aScreenX, aScreenY screen coords of the focus point of this event.
     * @param aModifierFlags is expected to contain native modifier values.
     */
    sendNativeTouchpadDoubleTap(aScreenX: long, aScreenY: long, aModifierFlags: long): void;
    /**
     * Send a native event as if the user panned on the touchpad with two
     * fingers.
     *
     * NOTE: The synthesized native event will be fired asynchronously, and upon
     * completion the observer, if provided, will be notified with a
     * "touchpadpanevent" topic.
     *
     * Widget support: Windows.
     * @param aScreenX, aScreenY screen coords of the focus point of this event.
     * @param aDeltaX, aDeltaY the amount of delta in the pan.
     * @param aModifierFlags is expected to contain native modifier values.
     */
    sendNativeTouchpadPan(aEventPhase: unsigned_long, aScreenX: long, aScreenY: long, aDeltaX: double, aDeltaY: double, aModifierFlags: long, aObserver: nsIObserverType): void;
    /**
     * Clears the SharedStyleSheetCache.
     */
    clearSharedStyleSheetCache(): void;
    /**
     * Returns the number of stylesheets that have been parsed on this document.
     * Useful to test caching.
     */
    readonly parsedStyleSheets: unsigned_long;
    /**
     * See nsIWidget::ActivateNativeMenuItemAt
     *
     * Cannot be accessed from unprivileged context (not content-accessible)
     * Will throw a DOM security error if called without chrome privileges.
     */
    activateNativeMenuItemAt(indexString: AString): void;
    /**
     * See nsIWidget::ForceUpdateNativeMenuAt
     *
     * Cannot be accessed from unprivileged context (not content-accessible)
     * Will throw a DOM security error if called without chrome privileges.
     */
    forceUpdateNativeMenuAt(indexString: AString): void;
    /**
     * Returns the current selection as plaintext. Note that the result may be
     * different from the result of sendQueryContentEvent(QUERY_SELECTED_TEXT).
     * This result is computed by native API with transferable data. In other
     * words, when the OS treats the selection as plaintext, it treats current
     * selection as this result.
     */
    GetSelectionAsPlaintext(): AString;
    /**
     * Force a garbage collection followed by a cycle collection.
     *
     * Will throw a DOM security error if called without chrome privileges in
     * non-debug builds. Available to all callers in debug builds.
     *
     * @param aListener listener that receives information about the CC graph
     */
    garbageCollect(aListener: nsICycleCollectorListenerType): void;
    /**
     * Force a cycle collection without garbage collection.
     *
     * Will throw a DOM security error if called without chrome privileges in
     * non-debug builds. Available to all callers in debug builds.
     *
     * @param aListener listener that receives information about the CC graph
     */
    cycleCollect(aListener: nsICycleCollectorListenerType): void;
    /**
     * Trigger whichever GC or CC timer is currently active and waiting to fire.
     * Don't do this too much for initiating heavy actions, like the start of a IGC.
     *
     * @param aReason the reason for the GC, from js/public/GCAPI.h. Defaults to
     * DOM_WINDOW_UTILS.
     */
    runNextCollectorTimer(aReason: ACString): void;
    /**
     * "Poke" the GC: set a timer to run a GC soon (usually 4 seconds), unless
     * another GC timer has already been set. This is used for testing.
     *
     * @param aReason the reason for the GC, from js/public/GCAPI.h. Defaults to
     * DOM_WINDOW_UTILS.
     */
    pokeGC(aReason: ACString): void;
    /**
     * Synthesize a simple gesture event for a window. The event types
     * supported are: MozSwipeGestureMayStart, MozSwipeGestureStart,
     * MozSwipeGestureUpdate, MozSwipeGestureEnd, MozSwipeGesture,
     * MozMagnifyGestureStart, MozMagnifyGestureUpdate, MozMagnifyGesture,
     * MozRotateGestureStart, MozRotateGestureUpdate, MozRotateGesture,
     * MozPressTapGesture, MozTapGesture, and MozEdgeUIGesture.
     *
     * Cannot be accessed from unprivileged context (not
     * content-accessible) Will throw a DOM security error if called
     * without chrome privileges.
     *
     * @param aType event type
     * @param aX x offset in CSS pixels
     * @param aY y offset in CSS pixels
     * @param aDirection direction, using constants defined in SimpleGestureEvent.webidl
     * @param aDelta  amount of magnification or rotation for magnify and rotation events
     * @param aModifiers modifiers pressed, using constants defined in Event.webidl
     * @param aClickCount For tap gestures, the number of taps.
     */
    sendSimpleGestureEvent(aType: AString, aX: float, aY: float, aDirection: unsigned_long, aDelta: double, aModifiers: long, aClickCount: unsigned_long): void;
    /**
     * Retrieve the element at point aX, aY in the window's document.
     *
     * @param aIgnoreRootScrollFrame whether or not to ignore the root scroll
     * frame when retrieving the element. If false, this method returns
     * null for coordinates outside of the viewport.
     * @param aFlushLayout flushes layout if true. Otherwise, no flush occurs.
     */
    elementFromPoint(aX: float, aY: float, aIgnoreRootScrollFrame: boolean, aFlushLayout: boolean): Element;
    /**
     * Retrieve all nodes that intersect a rect in the window's document.
     *
     * @param aX x reference for the rectangle in CSS pixels
     * @param aY y reference for the rectangle in CSS pixels
     * @param aTopSize How much to expand up the rectangle
     * @param aRightSize How much to expand right the rectangle
     * @param aBottomSize How much to expand down the rectangle
     * @param aLeftSize How much to expand left the rectangle
     * @param aIgnoreRootScrollFrame whether or not to ignore the root scroll
     * frame when retrieving the element. If false, this method returns
     * null for coordinates outside of the viewport.
     * @param aFlushLayout flushes layout if true. Otherwise, no flush occurs.
     * @param aOnlyVisible Set to true if you only want nodes that pass a visibility
     * hit test.
     * @param aTransparencyThreshold Only has an effect if aOnlyVisible is true.
     * Returns what amount of transparency is considered "opaque enough"
     * to consider elements "not visible". The default is effectively "1"
     * (so, only opaque elements will stop an element from being
     * "visible").
     */
    nodesFromRect(aX: float, aY: float, aTopSize: float, aRightSize: float, aBottomSize: float, aLeftSize: float, aIgnoreRootScrollFrame: boolean, aFlushLayout: boolean, aOnlyVisible: boolean, aTransparencyThreshold: float): NodeList;
    /**
     * Get a list of nodes that have meaningful textual content to
     * be translated. The implementation of this algorithm is in flux
     * as we experiment and refine which approach works best.
     *
     * This method requires chrome privileges.
     */
    getTranslationNodes(aRoot: Node): nsITranslationNodeList;
    /**
     * Compare the two canvases, returning the number of differing pixels and
     * the maximum difference in a channel.  This will throw an error if
     * the dimensions of the two canvases are different.
     *
     * This method requires chrome privileges.
     */
    compareCanvases(aCanvas1: nsISupportsType, aCanvas2: nsISupportsType, aMaxDifference: unsigned_long): uint32_t;
    /**
     * Returns true if a MozAfterPaint event has been queued but not yet
     * fired.
     */
    readonly isMozAfterPaintPending: boolean;
    /**
     * Returns true if the InputTaskManager is suspended.
     */
    readonly isInputTaskManagerSuspended: boolean;
    /**
     * Suppresses/unsuppresses user initiated event handling in window's document
     * and subdocuments.
     *
     * @throw NS_ERROR_DOM_SECURITY_ERR if called without chrome privileges and
     * NS_ERROR_FAILURE if window doesn't have a document.
     */
    suppressEventHandling(aSuppress: boolean): void;
    /**
     * Disable or enable non synthetic test mouse events on *all* windows.
     *
     * Cannot be accessed from unprivileged context (not content-accessible).
     * Will throw a DOM security error if called without chrome privileges.
     *
     * @param aDisable  If true, disable all non synthetic test mouse events
     * on all windows.  Otherwise, enable them.
     */
    disableNonTestMouseEvents(aDisable: boolean): void;
    /**
     * Returns the scroll position of the window's currently loaded document.
     *
     * @param aFlushLayout flushes layout if true. Otherwise, no flush occurs.
     * @see nsIDOMWindow::scrollX/Y
     */
    getScrollXY(aFlushLayout: boolean, aScrollX: long, aScrollY: long): void;
    /**
     * Returns the scroll position of the window's currently loaded document.
     *
     * @param aFlushLayout flushes layout if true. Otherwise, no flush occurs.
     * @see nsIDOMWindow::scrollX/Y
     */
    getScrollXYFloat(aFlushLayout: boolean, aScrollX: float, aScrollY: float): void;
    /**
     * Returns the scrollbar width of the window's scroll frame.
     *
     * @param aFlushLayout flushes layout if true. Otherwise, no flush occurs.
     */
    getScrollbarSize(aFlushLayout: boolean, aWidth: long, aHeight: long): void;
    /**
     * Returns the given element's bounds without flushing pending layout changes.
     */
    getBoundsWithoutFlushing(aElement: Element): DOMRect;
    /**
     *
     */
    scrollToVisual(aOffsetX: float, aOffsetY: float, aUpdateType: long, aScrollMode: long): void;
    /**
     * Returns the offset of the window's visual viewport relative to the
     * layout viewport.
     */
    getVisualViewportOffsetRelativeToLayoutViewport(aOffsetX: float, aOffsetY: float): void;
    /**
     * Returns the scroll position of the window's visual viewport.
     */
    getVisualViewportOffset(aOffsetX: long, aOffsetY: long): void;
    /**
     * Transforms the passed in rect from layout relative coords (relative to
     * this document) to be is visual coords.
     */
    transformRectLayoutToVisual(aX: float, aY: float, aWidth: float, aHeight: float): DOMRect;
    /**
     * Transform a rectangle given in coordinates relative to this document
     * into CSS coordinates relative to the screen.
     */
    toScreenRectInCSSUnits(aX: float, aY: float, aWidth: float, aHeight: float): DOMRect;
    /**
     * Transform a rectangle given in coordinates relative to this document
     * to the screen.
     */
    toScreenRect(aX: float, aY: float, aWidth: float, aHeight: float): DOMRect;
    /**
     * Transform a rectangle given in coordinates relative to the top level
     * parent process widget to the local widget. This window should be in a
     * child process.
     */
    convertFromParentProcessWidgetToLocal(aX: float, aY: float, aWidth: float, aHeight: float): DOMRect;
    /**
     * Sets the maximum height of the dynamic toolbar in Screen pixel units.
     */
    setDynamicToolbarMaxHeight(aHeightInScreen: uint32_t): void;
    /**
     * Returns true if a flush of the given type is needed.
     */
    needsFlush(aFlushtype: long): bool;
    /**
     * Flush pending layout-type notification without flushing throttled
     * animations.
     */
    flushLayoutWithoutThrottledAnimations(): void;
    /**
     * Returns the bounds of the window's currently loaded document. This will
     * generally be (0, 0, pageWidth, pageHeight) but in some cases (e.g. RTL
     * documents) may have a negative left value.
     */
    getRootBounds(): DOMRect;
    /**
     * Get IME open state. TRUE means 'Open', otherwise, 'Close'.
     * This property works only when IMEEnabled is IME_STATUS_ENABLED.
     */
    readonly IMEIsOpen: boolean;
    /**
     * Get IME status, see above IME_STATUS_* definitions.
     */
    readonly IMEStatus: unsigned_long;
    /**
     * Get the document URI which may be retrieved by native IME.
     */
    readonly inputContextURI: nsIURI;
    /**
     *
     */
    readonly inputContextOrigin: unsigned_long;
    /**
     * Get a root node which is observed by IMEContentObserver.
     */
    readonly nodeObservedByIMEContentObserver: Node;
    /**
     * Dispatches aEvent as a synthesized trusted event for tests via the
     * PresShell object of the window's document.
     * The event is dispatched to aTarget, which should be an object
     * which implements nsIContent interface (#element, #text, etc).
     *
     * Cannot be accessed from unprivileged context (not
     * content-accessible) Will throw a DOM security error if called
     * without chrome privileges.
     *
     * @note Event handlers won't get aEvent as parameter, but a similar event.
     * Also, aEvent should not be reused.
     */
    dispatchDOMEventViaPresShellForTesting(aTarget: Node, aEvent: Event): boolean;
    /**
     * Sets WidgetEvent::mFlags::mOnlyChromeDispatch to true to ensure that
     * the event is propagated only to chrome.
     * Event's .target property will be aTarget.
     * Returns the same value as what EventTarget.dispatchEvent does.
     */
    dispatchEventToChromeOnly(aTarget: EventTarget, aEvent: Event): boolean;
    /**
     * Returns the real classname (possibly of the mostly-transparent security
     * wrapper) of aObj.
     */
    getClassName(aObject: jsval): string;
    /**
     * Generate a content command event.
     *
     * Cannot be accessed from unprivileged context (not content-accessible)
     * Will throw a DOM security error if called without chrome privileges.
     *
     * @param aType Type of command content event to send.  Can be one of "cut",
     * "copy", "paste", "delete", "undo", "redo", "insertText" or
     * "pasteTransferable".
     * @param aTransferable an instance of nsITransferable when aType is
     * "pasteTransferable"
     * @param aString The string to be inserted into focused editor when aType is
     * "insertText"
     */
    sendContentCommandEvent(aType: AString, aTransferable: nsITransferableType, aString: AString): void;
    /**
     * Synthesize a query content event. Note that the result value returned here
     * is in LayoutDevice pixels rather than CSS pixels.
     *
     * @param aType  One of the following const values.  And see also each comment
     * for the other parameters and the result.
     * @param aAdditionalFlags See the description of QUERY_CONTENT_FLAG_*.
     */
    sendQueryContentEvent(aType: unsigned_long, aOffset: long_long, aLength: unsigned_long, aX: long, aY: long, aAdditionalFlags: unsigned_long): nsIQueryContentEventResult;
    /**
     * Called when the remote child frame has changed its fullscreen state,
     * when entering fullscreen, and when the origin which is fullscreen changes.
     * aFrameElement is the iframe element which contains the child-process
     * fullscreen document.
     */
    remoteFrameFullscreenChanged(aFrameElement: Element): void;
    /**
     * Called when the remote frame has popped all fullscreen elements off its
     * stack, so that the operation can complete on the parent side.
     */
    remoteFrameFullscreenReverted(): void;
    /**
     * Calls the document to handle any pending fullscreen requests.
     * It is called when the parent document has entered fullscreen, and
     * we want to put the current document into fullscreen as well.
     * The return value indicates whether there is any fullscreen request
     * handled by this call.
     */
    handleFullscreenRequests(): boolean;
    /**
     * Called when the child frame has fully exit fullscreen, so that the parent
     * process can also fully exit.
     *
     * @param aDontResoreViewSize false if content view size is restored by
     * original view size that is on entering full
     * screen.
     */
    exitFullscreen(aDontRestoreViewSize: boolean): void;
    /**
     * Synthesize a selection set event to the window.
     *
     * This sets the selection as the specified information.
     * Note that for avoiding unnecessary update from user and web app point of
     * view, it compares aOffset and aLength with selection cache which is same
     * as what is notified with NOTIFY_IME_OF_SELECTION_CHANGE.  Therefore, if
     * the notification is still queued, this works different from user's
     * scenario.  Therefore, before calling this, the caller should wait at least
     * 2 animation frames if `Selection` was changed before.
     *
     * @param aOffset  The caret offset of the selection start.
     * @param aLength  The length of the selection.  If this is too long, the
     * extra length is ignored.
     * @param aAdditionalFlags See the description of SELECTION_SET_FLAG_*.
     * @return True, if succeeded.  Otherwise, false.
     */
    sendSelectionSetEvent(aOffset: unsigned_long, aLength: unsigned_long, aAdditionalFlags: unsigned_long): boolean;
    /**
     * Select content at a client point based on a selection behavior if the
     * underlying content is selectable. Selection will accumulate with any
     * existing selection, callers should clear selection prior if needed.
     * May fire selection changed events. Calls nsFrame's SelectByTypeAtPoint.
     *
     * @param aX, aY The selection point in client coordinates.
     * @param aSelectType The selection behavior requested.
     * @return True if a selection occured, false otherwise.
     * @throw NS_ERROR_DOM_SECURITY_ERR, NS_ERROR_UNEXPECTED for utils
     * issues, and NS_ERROR_INVALID_ARG for coordinates that are outside
     * this window.
     */
    selectAtPoint(aX: float, aY: float, aSelectBehavior: unsigned_long): boolean;
    /**
     * Perform the equivalent of:
     * window.getComputedStyle(aElement, aPseudoElement).
     * getPropertyValue(aPropertyName)
     * except that, when the link whose presence in history is allowed to
     * influence aElement's style is visited, get the value the property
     * would have if allowed all properties to change as a result of
     * :visited selectors (except for cases where getComputedStyle uses
     * data from the frame).
     *
     * This is easier to implement than adding our property restrictions
     * to this API, and is sufficient for the present testing
     * requirements (which are essentially testing 'color').
     */
    getVisitedDependentComputedStyle(aElement: Element, aPseudoElement: AString, aPropertyName: AString): AString;
    /**
     * Put the window into a state where scripts are frozen and events
     * suppressed, for use when the window has launched a modal prompt.
     */
    enterModalState(): void;
    /**
     * Resume normal window state, where scripts can run and events are
     * delivered.
     */
    leaveModalState(): void;
    /**
     * Is the window is in a modal state? [See enterModalState()]
     */
    isInModalState(): boolean;
    /**
     * Suspend/resume timeouts on this window and its descendant windows.
     */
    suspendTimeouts(): void;
    /**
     *
     */
    resumeTimeouts(): void;
    /**
     * What type of layer manager the widget associated with this window is
     * using. "Basic" is unaccelerated; other types are accelerated. Throws an
     * error if there is no widget associated with this window.
     */
    readonly layerManagerType: AString;
    /**
     * True if the layer manager for the widget associated with this window is
     * forwarding layers to a remote compositor, false otherwise. Throws an
     * error if there is no widget associated with this window.
     */
    readonly layerManagerRemote: boolean;
    /**
     * True if webrender was requested by the user (via pref or env-var), false
     * otherwise. Note that this doesn't represent whether or not webrender is
     * *actually* enabled, just whether or not it was requested.
     */
    readonly isWebRenderRequested: boolean;
    /**
     * Returns the current audio backend as a free-form string.
     */
    readonly currentAudioBackend: AString;
    /**
     * Returns the max channel counts of the current audio device.
     */
    readonly currentMaxAudioChannels: unsigned_long;
    /**
     * Returns the mean round trip latency in seconds for the default input and
     * output device, and the stddev of this latency, as a two element array when
     * the Promise succeeds.
     */
    defaultDevicesRoundTripLatency(): Promise;
    /**
     * Returns the preferred sample rate of the current audio device.
     */
    readonly currentPreferredSampleRate: unsigned_long;
    /**
     *
     */
    audioDevices(aSide: unsigned_short): nsIArray;
    /**
     * Record (and return) frame-intervals for frames which were presented
     * between calling StartFrameTimeRecording and StopFrameTimeRecording.
     *
     * - Uses a cyclic buffer and serves concurrent consumers, so if Stop is called too late
     * (elements were overwritten since Start), result is considered invalid and hence empty.
     * - Buffer is capable of holding 10 seconds @ 60fps (or more if frames were less frequent).
     * Can be changed (up to 1 hour) via pref: toolkit.framesRecording.bufferSize.
     * - Note: the first frame-interval may be longer than expected because last frame
     * might have been presented some time before calling StartFrameTimeRecording.
     *
     * Returns a handle which represents current recording start position.
     */
    startFrameTimeRecording(startIndex: unsigned_long): void;
    /**
     * The DPI of the display
     */
    readonly displayDPI: float;
    /**
     * advanceTimeAndRefresh allows the caller to take over the refresh
     * driver timing for a window.  A call to advanceTimeAndRefresh does
     * three things:
     * (1) It marks the refresh driver for this presentation so that it
     * no longer refreshes on its own, but is instead driven entirely
     * by the caller (except for the refresh that happens when a
     * document comes out of the bfcache).
     * (2) It advances the refresh driver's current refresh time by the
     * argument given.  Negative advances are permitted.
     * (3) It does a refresh (i.e., notifies refresh observers) at that
     * new time.
     *
     * Note that this affects other connected docshells of the same type
     * in the same docshell tree, such as parent frames.
     *
     * When callers have completed their use of advanceTimeAndRefresh,
     * they must call restoreNormalRefresh.
     */
    advanceTimeAndRefresh(aMilliseconds: long_long): void;
    /**
     * Undoes the effects of advanceTimeAndRefresh.
     */
    restoreNormalRefresh(): void;
    /**
     * Reports whether the current state is test-controlled refreshes
     * (see advanceTimeAndRefresh and restoreNormalRefresh above).
     */
    readonly isTestControllingRefreshes: bool;
    /**
     * Reports whether APZ is enabled on the widget that this window is attached
     * to. If there is no widget it will report the default platform value of
     * whether or not APZ is enabled.
     */
    readonly asyncPanZoomEnabled: bool;
    /**
     * Set async scroll offset on an element. The next composite will render
     * with that offset if async scrolling is enabled, and then the offset
     * will be removed. Only call this while test-controlled refreshes is enabled.
     */
    setAsyncScrollOffset(aElement: Element, aX: float, aY: float): void;
    /**
     * Set async zoom value. aRootElement should be the document element of our
     * document. The next composite will render with that zoom added to any
     * existing zoom if async scrolling is enabled, and then the zoom will be
     * removed. Only call this while test-controlled refreshes is enabled.
     */
    setAsyncZoom(aRootElement: Element, aValue: float): void;
    /**
     * Do a round-trip to the compositor to ensure any pending APZ repaint requests
     * get flushed to the main thread. If the function returns true, the flush was
     * triggered and an "apz-repaints-flushed" notification will be dispatched via
     * the observer service once the flush is complete. If the function returns
     * false, an error occurred or a flush is not needed, and the notification
     * will not fire. This is intended to be used by test code only!
     */
    flushApzRepaints(): bool;
    /**
     * Sets a flag on the element to forcibly disable APZ on it. This affects
     * the result of nsLayoutUtils::ShouldDisableApzForElement when called on
     * this element. This function also schedules a repaint to ensure that the
     * change takes effect. Note that this is not reversible; it is intended for
     * use by test code only.
     */
    disableApzForElement(aElement: Element): void;
    /**
     * Ask APZ to pan and zoom to the focused input element.
     */
    zoomToFocusedInput(): void;
    /**
     * Method for testing StyleAnimationValue::ComputeDistance.
     *
     * Returns the distance between the two values as reported by
     * StyleAnimationValue::ComputeDistance for the given element and
     * property.
     */
    computeAnimationDistance(element: Element, property: AString, value1: AString, value2: AString): double;
    /**
     * Returns the computed style for the specified property of given pseudo type
     * on the given element after removing styles from declarative animations.
     * @param aElement - A target element
     * @param aPseudoElement - A pseudo type (e.g. '::before' or null)
     * @param aProperty - A longhand CSS property (e.g. 'background-color')
     * @param aFlushType - FLUSH_NONE if any pending styles should not happen,
     * FLUSH_STYLE to flush pending styles.
     */
    getUnanimatedComputedStyle(aElement: Element, aPseudoElement: AString, aProperty: AString, aFlushType: long): AString;
    /**
     * Returns the effective canvas background color for the window.
     */
    readonly canvasBackgroundColor: AString;
    /**
     * Get the type of the currently focused html input, if any.
     */
    readonly focusedInputType: AString;
    /**
     * Get the action hint of the currently focused html input, if any.
     */
    readonly focusedActionHint: AString;
    /**
     * Get the inputmode of the currently focused editing host, if any.
     */
    readonly focusedInputMode: AString;
    /**
     * Get the autocapitalize of the currently focused editing host, if any.
     */
    readonly focusedAutocapitalize: AString;
    /**
     * Find the view ID for a given element. This is the reverse of
     * findElementWithViewId().
     */
    getViewId(aElement: Element): nsViewID;
    /**
     * Check if any PaintedLayer painting has been done for this element,
     * clears the painted flags if they have.
     */
    checkAndClearPaintedState(aElement: Element): boolean;
    /**
     * Check if any display list building has been done for this element,
     * clears the display list flags if they have.
     */
    checkAndClearDisplayListState(aElement: Element): boolean;
    /**
     * Check whether all display items of the primary frame of aElement have been
     * assigned to the same single PaintedLayer in the last paint. If that is the
     * case, returns whether that PaintedLayer is opaque; if it's not the case, an
     * exception is thrown.
     */
    isPartOfOpaqueLayer(aElement: Element): boolean;
    /**
     * Count the number of different PaintedLayers that the supplied elements have
     * been assigned to in the last paint. Throws an exception if any of the
     * elements doesn't have a primary frame, or if that frame's display items are
     * assigned to any other layers than just a single PaintedLayer per element.
     */
    numberOfAssignedPaintedLayers(aElements: invalid): unsigned_long;
    /**
     * Get internal id of the stored blob, file or file handle.
     */
    getFileId(aFile: jsval): long_long;
    /**
     * Get internal file path of the stored file or file handle.
     *
     * TODO: File handle objects are actually not supported at the moment.
     */
    getFilePath(aFile: jsval): AString;
    /**
     * Get file ref count info for given database and file id.
     */
    getFileReferences(aDatabaseName: AString, aId: long_long, aRefCnt: long, aDBRefCnt: long): boolean;
    /**
     *
     */
    flushPendingFileDeletions(): void;
    /**
     * Begin opcode-level profiling of all JavaScript execution in the window's
     * runtime.
     */
    startPCCountProfiling(): void;
    /**
     * Stop opcode-level profiling of JavaScript execution in the runtime, and
     * collect all counts for use by getPCCount methods.
     */
    stopPCCountProfiling(): void;
    /**
     * Purge collected PC counters.
     */
    purgePCCounts(): void;
    /**
     * Get the number of scripts with opcode-level profiling information.
     */
    getPCCountScriptCount(): long;
    /**
     * Get a JSON string for a short summary of a script and the PC counts
     * accumulated for it.
     */
    getPCCountScriptSummary(script: long): AString;
    /**
     * Get a JSON string with full information about a profiled script,
     * including the decompilation of the script and placement of decompiled
     * operations within it, and PC counts for each operation.
     */
    getPCCountScriptContents(script: long): AString;
    /**
     * Returns true if painting is suppressed for this window and false
     * otherwise.
     */
    readonly paintingSuppressed: boolean;
    /**
     * Set the viewport size for the purposes of clamping scroll positions for
     * the root scroll frame of this document to be (aWidth,aHeight) in CSS pixels.
     *
     * The caller of this method must have chrome privileges.
     */
    setVisualViewportSize(aWidth: float, aHeight: float): void;
    /**
     * These are used to control whether dialogs (alert, prompt, confirm) are
     * allowed, and to reset the inernal state that controls whether dialogs
     * are currently blocked or not.
     */
    disableDialogs(): void;
    /**
     *
     */
    enableDialogs(): void;
    /**
     *
     */
    areDialogsEnabled(): bool;
    /**
     *
     */
    resetDialogAbuseState(): void;
    /**
     * Synchronously loads a style sheet from |sheetURI| and adds it to the list
     * of additional style sheets of the document.
     *
     * These additional style sheets are very much like user/agent sheets loaded
     * with loadAndRegisterSheet. The only difference is that they are applied only
     * on the document owned by this window.
     *
     * Sheets added via this API take effect immediately on the document.
     */
    loadSheet(sheetURI: nsIURIType, type: unsigned_long): void;
    /**
     * Same as the above method but allows passing the URI as a string.
     */
    loadSheetUsingURIString(sheetURI: ACString, type: unsigned_long): void;
    /**
     * Adds a style sheet to the list of additional style sheets of the document.
     *
     * Style sheets can be preloaded with nsIStyleSheetService.preloadSheet.
     *
     * Sheets added via this API take effect immediately on the document.
     */
    addSheet(sheet: nsIPreloadedStyleSheetType, type: unsigned_long): void;
    /**
     * Remove the document style sheet at |sheetURI| from the list of additional
     * style sheets of the document.  The removal takes effect immediately.
     */
    removeSheet(sheetURI: nsIURIType, type: unsigned_long): void;
    /**
     * Same as the above method but allows passing the URI as a string.
     */
    removeSheetUsingURIString(sheetURI: ACString, type: unsigned_long): void;
    /**
     * Returns true if a user input is being handled.
     *
     * This calls EventStateManager::IsHandlingUserInput().
     */
    readonly isHandlingUserInput: boolean;
    /**
     * Returns milliseconds elapsed since last user input was started.
     * Returns -1 if there wasn't any previous user input.
     *
     * This relies on EventStateManager::LatestUserInputStart()
     */
    readonly millisSinceLastUserInput: double;
    /**
     * After calling the method, the window for which this DOMWindowUtils
     * was created can be closed using scripts.
     */
    allowScriptsToClose(): void;
    /**
     * Is the parent window's main widget visible?  If it isn't, we probably
     * don't want to display any dialogs etc it may request.  This corresponds
     * to the visibility check in nsWindowWatcher::OpenWindowInternal().
     *
     * Will throw a DOM security error if called without chrome privileges or
     * NS_ERROR_NOT_AVAILABLE in the unlikely event that the parent window's
     * main widget can't be reached.
     */
    readonly isParentWindowMainWidgetVisible: boolean;
    /**
     * In certain cases the event handling of nodes, form controls in practice,
     * may be disabled. Such cases are for example the existence of disabled
     * attribute or -moz-user-input: none.
     */
    isNodeDisabledForEvents(aNode: Node): boolean;
    /**
     * Returns the value of a given property animated on the compositor thread.
     * If the property is NOT currently being animated on the compositor thread,
     * returns an empty string.
     * NOTE: Do not use this function for elements that there was another
     * animation running on the compositor before.
     */
    getOMTAStyle(aElement: Element, aProperty: AString, aPseudoElement: AString): AString;
    /**
     * Returns true if the given animation is being tracked by the pending
     * animation tracker for the current document.
     */
    isAnimationInPendingTracker(aAnimation: Animation): bool;
    /**
     * If aHandlingInput is true, this informs the event state manager that
     * we're handling user input, and provides transient user activation.
     * Otherwise, this is a no-op (as by default we're not handling user input).
     * Remember to call destruct() on the return value!
     * See also nsIDOMWindowUtils::isHandlingUserInput.
     */
    setHandlingUserInput(aHandlingInput: boolean): nsIJSRAIIHelper;
    /**
     * Returns true if a keyboard event qualifies as "user activity" such that
     * it would mark the document with the ChromeOnly userHasInteracted
     * property.
     */
    isKeyboardEventUserActivity(aKeyboardEvent: Event): bool;
    /**
     * Get the content- and compositor-side APZ test data instances.
     * The return values are of type APZTestData (see APZTestData.webidl).
     */
    getContentAPZTestData(): jsval;
    /**
     *
     */
    getCompositorAPZTestData(): jsval;
    /**
     * Posts an RestyleHint::RESTYLE_SELF restyle event for the given element.
     */
    postRestyleSelfEvent(aElement: Element): void;
    /**
     * This method doesn't do anything useful.  It was solely added for the
     * purpose of the test for bug 503926.
     */
    xpconnectArgument(aObj: nsISupportsType): void;
    /**
     * Helper for JS components that need to send permission requests with
     * e10s support properly.
     */
    askPermission(aRequest: nsIContentPermissionRequestType): void;
    /**
     * Restyle generation for the current document.
     *
     * May throw NS_ERROR_NOT_AVAILABLE.
     */
    readonly restyleGeneration: unsigned_long_long;
    /**
     * Number of frames constructed (excluding breaking) for the curent
     * document.
     *
     * May throw NS_ERROR_NOT_AVAILABLE.
     */
    readonly framesConstructed: unsigned_long_long;
    /**
     * Number of frames reflowed for the curent document.
     *
     * May throw NS_ERROR_NOT_AVAILABLE.
     */
    readonly framesReflowed: unsigned_long_long;
    /**
     * Number of restyles triggered by animations.
     */
    readonly animationTriggeredRestyles: unsigned_long_long;
    /**
     * Indicates whether the current frame's refresh driver has a pending tick,
     * as reported by nsRefreshDriver::HasPendingTick.
     *
     * May throw NS_ERROR_NOT_AVAILABLE.
     */
    readonly refreshDriverHasPendingTick: bool;
    /**
     * Controls the amount of chrome that should be visible on each side of
     * the window. Works like the chromemargin xul:window attribute.
     * This should only be used with non-XUL windows.
     */
    setChromeMargin(aTop: int32_t, aRight: int32_t, aBottom: int32_t, aLeft: int32_t): void;
    /**
     * Controls the amount of space on each edge of the window that can be
     * dragged to resize the window in that direction.
     *
     * @param aResizeMargin  In CSS pixels, will apply to all four window sides.
     */
    setResizeMargin(aResizeMargin: int32_t): void;
    /**
     * Returns a JSObject which contains a list of frame uniformities
     * when the pref gfx.vsync.collect-scroll-data is enabled.
     * Every result contains a layer address and a frame uniformity for that layer.
     * A negative frame uniformity value indicates an invalid frame uniformity and an error has occured.
     */
    getFrameUniformityTestData(): jsval;
    /**
     * Increase the chaos mode activation level. An equivalent number of
     * calls to leaveChaosMode must be made in order to restore the original
     * chaos mode state. If the activation level is nonzero all chaos mode
     * features are activated.
     */
    enterChaosMode(): void;
    /**
     * Decrease the chaos mode activation level. See enterChaosMode().
     */
    leaveChaosMode(): void;
    /**
     * Alerts Gecko of a device reset
     */
    triggerDeviceReset(): void;
    /**
     * Returns whether the document's style set's rule processor for the
     * specified level of the cascade is shared by multiple style sets.
     * (Used by tests to ensure that certain optimizations do not regress.)
     *
     * @param aSheetType One of the nsIStyleSheetService.*_SHEET constants.
     */
    hasRuleProcessorUsedByMultipleStyleSets(aSheetType: unsigned_long): bool;
    /**
     * Enable or disable displayport suppression. This is intended to be used by
     * testing code, to provide more deterministic behaviour over the displayport
     * suppression during tests. Note that this updates a flag, so whatever value
     * was last provided is what will be used.
     */
    respectDisplayPortSuppression(aEnabled: boolean): void;
    /**
     * Set a flag that forces the next reflow interrupt check to return true. This
     * can be used by tests to force execution of the interrupted reflow codepaths.
     */
    forceReflowInterrupt(): void;
    /**
     * Terminate the GPU process. Used for testing GPU process restarts.
     */
    terminateGPUProcess(): void;
    /**
     * Returns the GPU process pid, or -1 if there is no GPU process.
     */
    readonly gpuProcessPid: int32_t;
    /**
     * Adds an ElementState bit to the element.
     *
     * The state string must be one of the following:
     * * (none yet; but for example "higlighted" for ElementState::HIGHLIGHTED)
     *
     * The supported state strings are defined in kManuallyManagedStates
     * in nsDOMWindowUtils.cpp.
     */
    addManuallyManagedState(element: Element, state: AString): void;
    /**
     * Removes the specified ElementState bits from the element.
     *
     * See above for the strings that can be passed for |state|.
     */
    removeManuallyManagedState(element: Element, state: AString): void;
    /**
     * Returns usage data for a given storage object.
     *
     * @param aStorage
     * The storage object to get usage data for.
     */
    getStorageUsage(aStorage: Storage): int64_t;
    /**
     * Returns the directionality of a string using the first-strong character
     * algorithm defined in http://unicode.org/reports/tr9/#P2.
     *
     * @param aString the string to retrieve the direction for.
     * @return one of DIRECTION_LTR, DIRECTION_RTL or DIRECTION_NOT_SET depending
     * on the first-strong character found in the string.
     */
    getDirectionFromText(aString: AString): long;
    /**
     * Calls FrameNeedsReflow on that root frame so that a layout flush
     * will be necessary.
     *
     * This should only be used for testing.
     */
    ensureDirtyRootFrame(): void;
    /**
     * Capture the contents of the current WebRender frame and
     * save them to a folder relative to the current working directory.
     */
    wrCapture(): void;
    /**
     * Start capturing each WebRender frame to disk.
     *
     * |aPath| is the name of a new directory to be created to hold the captures.
     * it is relative to:
     * - the |PUBLIC_STORAGE| environment variable, if set, else
     * - the |MOZ_UPLOAD_DIR| environment variable, if set, else
     * - the user's home directory, if known, else
     * the current directory.
     *
     * If there is already a directory with the given name, a numeric suffix is
     * added to ensure a fresh directory is created. This means that you can't
     * be sure your capture directory is actually named |aPath|.
     *
     * |aFlags| is a set of flags from |webrender::render_api::CaptureBits|.
     *
     * If there is already a sequence capture in progress, stop it and start a new
     * one, with the new path and flags.
     */
    wrStartCaptureSequence(aPath: ACString, aFlags: uint32_t): void;
    /**
     * Stop a capture begun with |wrStartCaptureSequence|.
     */
    wrStopCaptureSequence(): void;
    /**
     * Toggle recording of composition on and off.
     *
     * This is equivalent to calling |startCompositionRecorder()| or
     * |stopCompositionRecorder(true)|.
     */
    setCompositionRecording(aValue: boolean): Promise;
    /**
     * Start the composition recorder.
     *
     * @return A promise that is resolved to true if the composion recorder was
     * started successfully.
     */
    startCompositionRecording(): Promise;
    /**
     * Stop the composition recorder.
     *
     * @param aWriteToDisk Whether or not the frames should be written to disk.
     * If false, they will be returned in the promise.
     * @return A promise that resolves when the frames have been collected.
     * When |aWriteToDisk| is true, the promise will resolve to |undefined|.
     * Otherwise, the promise will resolve to a |DOMCollectedFrames| dictionary,
     * which contains the timestamps and contents of the captured frames.
     */
    stopCompositionRecording(aWriteToDisk: boolean): Promise;
    /**
     * Returns whether the document we're associated to has recorded a given CSS
     * property via the use counter mechanism.
     *
     * Throws if there's no document or the property is invalid.
     */
    isCssPropertyRecordedInUseCounter(aProperty: ACString): bool;
    /**
     * Calls SetInitialViewport on the MobileViewportManager, which effectively
     * causes it to refresh all of its internal state and update things that
     * need updating.
     */
    resetMobileViewportManager(): void;
    /**
     *
     */
    isCoepCredentialless(): bool;
    /**
     * Change the DPI setting for the primary monitor.
     * This setHiDPIMode and restoreHiDPIMode below are only available on debug
     * builds since these APIs are supposed to be used in tests.
     *
     * Note that on Mac, this API doesn't change the system DPI setting, rather it
     * changes our internal state of DPI settings, thus it will not invoke the
     * exact same stuff when the system DPI setting is changed.
     */
    setHiDPIMode(aHiDPI: boolean): void;
    /**
     * Restore the modified HiDPI mode.
     */
    restoreHiDPIMode(): void;
    /**
     * NOTE: Currently works only on GTK+.
     */
    systemFont: ACString;
    /**
     * Returns the number of times this document for this window has
     * been painted to the screen.
     */
    readonly paintCount: unsigned_long_long;
    /**
     *
     */
    syncFlushCompositor(): void;
    /**
     *
     */
    getLayersId(): unsigned_long_long;
    /**
     *
     */
    readonly effectivelyThrottlesFrameRequests: bool;
    /**
     *
     */
    readonly webrtcRawDeviceId: AString;
    /**
     *
     */
    readonly suspendedByBrowsingContextGroup: bool;
    /**
     *
     */
    readonly hasScrollLinkedEffect: bool;
    /**
     *
     */
    readonly orientationLock: uint32_t;
    /**
     *
     */
    getWheelScrollTarget(): Element;
}

/**
 *
 */
declare interface nsITranslationNodeListType extends nsISupportsType {
    /**
     *
     */
    readonly length: unsigned_long;
    /**
     *
     */
    item(index: unsigned_long): Node;
    /**
     *
     */
    isTranslationRootAtIndex(index: unsigned_long): boolean;
}

/**
 * JS doesn't do RAII very well. We can use this interface to make remembering
 * to destruct an object in a finally clause easier.
 */
declare interface nsIJSRAIIHelperType extends nsISupportsType {
    /**
     *
     */
    destruct(): void;
}

/**
 *
 */
declare interface nsIDOMXULButtonElementType extends nsIDOMXULControlElementType {
    /**
     *
     */
    type: AString;
    /**
     *
     */
    open: boolean;
    /**
     *
     */
    checked: boolean;
    /**
     *
     */
    group: AString;
}

/**
 *
 */
declare interface nsIDOMXULCommandDispatcherType extends nsISupportsType {
    /**
     *
     */
    focusedElement: Element;
    /**
     *
     */
    focusedWindow: mozIDOMWindowProxy;
    /**
     *
     */
    addCommandUpdater(updater: Element, events: AString, targets: AString): void;
    /**
     *
     */
    removeCommandUpdater(updater: Element): void;
    /**
     *
     */
    updateCommands(eventName: AString): void;
    /**
     *
     */
    getControllerForCommand(command: string): nsIController;
    /**
     *
     */
    getControllers(): nsIControllers;
    /**
     *
     */
    advanceFocus(): void;
    /**
     *
     */
    rewindFocus(): void;
    /**
     *
     */
    advanceFocusIntoSubtree(elt: Element): void;
    /**
     *
     */
    lock(): void;
    /**
     *
     */
    unlock(): void;
}

/**
 *
 */
declare interface nsIDOMXULContainerItemElementType extends nsISupportsType {
    /**
     * Returns the parent container if any.
     */
    readonly parentContainer: Element;
}

/**
 *
 */
declare interface nsIDOMXULContainerElementType extends nsIDOMXULContainerItemElementType {
}

/**
 *
 */
declare interface nsIDOMXULControlElementType extends nsISupportsType {
    /**
     *
     */
    disabled: boolean;
}

/**
 *
 */
declare interface nsIDOMXULMenuListElementType extends nsIDOMXULSelectControlElementType {
    /**
     *
     */
    editable: boolean;
    /**
     *
     */
    open: boolean;
    /**
     *
     */
    readonly label: AString;
    /**
     *
     */
    image: AString;
}

/**
 *
 */
declare interface nsIDOMXULMultiSelectControlElementType extends nsIDOMXULSelectControlElementType {
    /**
     *
     */
    selType: AString;
    /**
     *
     */
    currentItem: Element;
    /**
     *
     */
    currentIndex: long;
    /**
     *
     */
    readonly selectedItems: NodeList;
    /**
     *
     */
    addItemToSelection(item: nsIDOMXULSelectControlItemElementType): void;
    /**
     *
     */
    removeItemFromSelection(item: nsIDOMXULSelectControlItemElementType): void;
    /**
     *
     */
    toggleItemSelection(item: nsIDOMXULSelectControlItemElementType): void;
    /**
     *
     */
    selectItem(item: nsIDOMXULSelectControlItemElementType): void;
    /**
     *
     */
    selectItemRange(startItem: nsIDOMXULSelectControlItemElementType, item: nsIDOMXULSelectControlItemElementType): void;
    /**
     *
     */
    selectAll(): void;
    /**
     *
     */
    clearSelection(): void;
    /**
     *
     */
    readonly selectedCount: long;
    /**
     *
     */
    getSelectedItem(index: long): Element;
}

/**
 *
 */
declare interface nsIDOMXULRadioGroupElementType extends nsISupportsType {
    /**
     *
     */
    focusedItem: Element;
}

/**
 *
 */
declare interface nsIDOMXULRelatedElementType extends nsISupportsType {
    /**
     * Retrun an element associated with the given element. It's implemented
     * by container elements having relation between their items. For example,
     * this interface is implemented by XUL tabs and XUL tabpanels elements
     * and used to get XUL tab element by linked tab panel and vice versa.
     */
    getRelatedElement(aElement: Node): Element;
}

/**
 *
 */
declare interface nsIDOMXULSelectControlElementType extends nsIDOMXULControlElementType {
    /**
     *
     */
    selectedItem: Element;
    /**
     *
     */
    selectedIndex: long;
    /**
     *
     */
    value: AString;
    /**
     *
     */
    readonly itemCount: unsigned_long;
    /**
     *
     */
    getIndexOfItem(item: nsIDOMXULSelectControlItemElementType): long;
    /**
     *
     */
    getItemAtIndex(index: long): Element;
}

/**
 *
 */
declare interface nsIDOMXULSelectControlItemElementType extends nsISupportsType {
    /**
     *
     */
    disabled: boolean;
    /**
     *
     */
    image: AString;
    /**
     *
     */
    label: AString;
    /**
     *
     */
    accessKey: AString;
    /**
     *
     */
    command: AString;
    /**
     *
     */
    value: AString;
    /**
     *
     */
    readonly selected: boolean;
    /**
     *
     */
    readonly control: Element;
}

/**
 * A JavaScript callback function that takes a JSON as its parameter.
 * The returned JSON contains arrays with data
 */
declare interface nsINetDashboardCallbackType extends nsISupportsType {
    /**
     *
     */
    onDashboardDataAvailable(data: jsval): void;
}

/**
 * The dashboard service.
 * The async API returns JSONs, which hold arrays with the required info.
 * Only one request of each type may be pending at any time.
 */
declare interface nsIDashboardType extends nsISupportsType {
    /**
     * Arrays: host, port, tcp, active, socksent, sockreceived
     * Values: sent, received
     */
    requestSockets(cb: nsINetDashboardCallbackType): void;
    /**
     * Arrays: host, port, spdy, ssl
     * Array of arrays: active, idle
     */
    requestHttpConnections(cb: nsINetDashboardCallbackType): void;
    /**
     * Arrays: hostport, encrypted, msgsent, msgreceived, sentsize, receivedsize
     */
    requestWebsocketConnections(cb: nsINetDashboardCallbackType): void;
    /**
     * Arrays: hostname, family, hostaddr, expiration
     */
    requestDNSInfo(cb: nsINetDashboardCallbackType): void;
    /**
     * aProtocol: a transport layer protocol:
     * ex: "ssl", "tcp", default is "tcp".
     * aHost: the host's name
     * aPort: the port which the connection will open on
     * aTimeout: the timespan before the connection will be timed out
     */
    requestConnection(aHost: ACString, aPort: unsigned_long, aProtocol: string, aTimeout: unsigned_long, cb: nsINetDashboardCallbackType): void;
    /**
     * When true, the service will log websocket events
     */
    enableLogging: boolean;
    /**
     * DNS resolver for host name
     * aHost: host name
     */
    requestDNSLookup(aHost: ACString, cb: nsINetDashboardCallbackType): void;
    /**
     * Resolve HTTPS RRs for host name
     * aHost: host name
     */
    requestDNSHTTPSRRLookup(aHost: ACString, cb: nsINetDashboardCallbackType): void;
    /**
     * Asyncly returns stats regarding the "Race Cache With Network" feature.
     */
    requestRcwnStats(cb: nsINetDashboardCallbackType): void;
    /**
     *
     */
    getLogPath(): AUTF8String;
}

/**
 *
 */
declare interface nsIDashboardEventNotifierType extends nsISupportsType {
    /**
     * These methods are called to register a websocket event with the dashboard
     *
     * A host is identified by the (aHost, aSerial) pair.
     * aHost: the host's name: example.com
     * aSerial: a number that uniquely identifies the websocket
     *
     * aEncrypted: if the connection is encrypted
     * aLength: the length of the message in bytes
     */
    addHost(aHost: ACString, aSerial: unsigned_long, aEncrypted: boolean): void;
    /**
     *
     */
    removeHost(aHost: ACString, aSerial: unsigned_long): void;
    /**
     *
     */
    newMsgSent(aHost: ACString, aSerial: unsigned_long, aLength: unsigned_long): void;
    /**
     *
     */
    newMsgReceived(aHost: ACString, aSerial: unsigned_long, aLength: unsigned_long): void;
}

/**
 *
 */
declare interface nsIDataStorageManagerType extends nsISupportsType {
    /**
     *
     */
    get(dataStorage: nsIDataStorageManager_DataStorageType): nsIDataStorage;
}

/**
 * nsIDataStorage is a threadsafe, generic, narrow string-based hash map that
 * persists data on disk and additionally handles private (temporary) data.
 * The file format is portable across architectures. If used in a context where
 * there is no profile directory, data will not be persisted.
 *
 * Its lifecycle is as follows:
 * - Use nsIDataStorageManager to obtain the nsIDataStorage of a particular
 * purpose. Its backing file will be read on a background thread.
 * - Should the profile directory not be available, (e.g. in xpcshell),
 * nsIDataStorage will not read any persistent data.
 * - When data in the nsIDataStorage changes, those changes will be written
 * to the backing file on a background thread. If the program crashes or is
 * closed unexpectedly before the write completes, the changes may be lost.
 * If the changes were an update to previously stored data, the original data
 * may be lost as well. A checksum associated with each entry helps identify
 * incompletely written entries.
 * - nsIDataStorage does not support transactions. Each entry is independent of
 * the others.
 * - When an nsIDataStorage instance observes the topic "profile-before-change"
 * in anticipation of shutdown, no more changes will be written to the
 * backing file. To ensure no data is lost, users of nsIDataStorage should
 * not attempt to change any data after this point.
 * If "profile-before-change" is not observed, this happens upon observing
 * "xpcom-shutdown-threads".
 * - To prevent unbounded memory and disk use, the number of entries in each
 * table is limited to 2048. Evictions are handled in by a modified LRU scheme
 * (see implementation comments).
 * - Note that instances of nsIDataStorage have long lifetimes because they are
 * strong observers of events and won't go away until the observer service
 * does.
 *
 * For each key/value:
 * - The key must have a length no more than 256.
 * - The value have a length no more than 1024 (24 for the site security
 * service state).
 * The length limits are to prevent unbounded disk and memory usage, and
 * nsIDataStorage will throw/return an error if given keys or values of
 * excess length.
 * Take care when storing data containing bytes that may be 0. When read
 * from disk, all trailing 0 bytes from keys and values are stripped.
 */
declare interface nsIDataStorageType extends nsISupportsType {
    /**
     *
     */
    get(key: ACString, type: nsIDataStorage_DataTypeType): ACString;
    /**
     *
     */
    put(key: ACString, value: ACString, type: nsIDataStorage_DataTypeType): void;
    /**
     *
     */
    remove(key: ACString, type: nsIDataStorage_DataTypeType): void;
    /**
     *
     */
    clear(): void;
    /**
     *
     */
    isReady(): bool;
}

/**
 *
 */
declare interface nsIDataStorageItemType extends nsISupportsType {
    /**
     *
     */
    readonly key: ACString;
    /**
     *
     */
    readonly value: ACString;
    /**
     *
     */
    readonly type: nsIDataStorage_DataType;
}

/**
 * @note C/C++ consumers who are planning to use the nsIDebug2 interface with
 * the "@mozilla.org/xpcom;1" contract should use NS_DebugBreak from xpcom
 * glue instead.
 */
declare interface nsIDebug2Type extends nsISupportsType {
    /**
     * Whether XPCOM was compiled with DEBUG defined.  This often
     * correlates to whether other code (e.g., Firefox, XULRunner) was
     * compiled with DEBUG defined.
     */
    readonly isDebugBuild: boolean;
    /**
     * The number of assertions since process start.
     */
    readonly assertionCount: long;
    /**
     * Whether a debugger is currently attached.
     * Supports Windows + Mac
     */
    readonly isDebuggerAttached: bool;
    /**
     * Show an assertion and trigger nsIDebug2.break().
     *
     * @param aStr assertion message
     * @param aExpr expression that failed
     * @param aFile file containing assertion
     * @param aLine line number of assertion
     */
    assertion(aStr: string, aExpr: string, aFile: string, aLine: long): void;
    /**
     * Show a warning.
     *
     * @param aStr warning message
     * @param aFile file containing assertion
     * @param aLine line number of assertion
     */
    warning(aStr: string, aFile: string, aLine: long): void;
    /**
     * Request to break into a debugger.
     *
     * @param aFile file containing break request
     * @param aLine line number of break request
     */
    break(aFile: string, aLine: long): void;
    /**
     * Request the process to trigger a fatal abort.
     *
     * @param aFile file containing abort request
     * @param aLine line number of abort request
     */
    abort(aFile: string, aLine: long): void;
    /**
     * Request the process to trigger a fatal panic!() from Rust code.
     *
     * @param aMessage the string to pass to panic!().
     */
    rustPanic(aMessage: string): void;
    /**
     * Request the process to log a message for a target and level from Rust code.
     *
     * @param aTarget the string representing the log target.
     * @param aMessage the string representing the log message.
     */
    rustLog(aTarget: string, aMessage: string): void;
    /**
     * Cause an Out of Memory Crash.
     */
    crashWithOOM(): void;
}

/**
 *
 */
declare interface nsIDeviceSensorDataType extends nsISupportsType {
    /**
     *
     */
    readonly type: unsigned_long;
    /**
     *
     */
    readonly x: double;
    /**
     *
     */
    readonly y: double;
    /**
     *
     */
    readonly z: double;
}

/**
 *
 */
declare interface nsIDeviceSensorsType extends nsISupportsType {
    /**
     * Returns true if the given window has any listeners of the given type
     */
    hasWindowListener(aType: unsigned_long, aWindow: nsIDOMWindowType): bool;
}

/**
 * An interface to pass strings, integers and nsISupports to a dialog
 */
declare interface nsIDialogParamBlockType extends nsISupportsType {
    /**
     * Get or set an integer to pass.
     * Index must be in the range 0..7
     */
    GetInt(inIndex: int32_t): int32_t;
    /**
     *
     */
    SetInt(inIndex: int32_t, inInt: int32_t): void;
    /**
     * Set the maximum number of strings to pass. Default is 16.
     * Use before setting any string (If you want to change it from the default).
     */
    SetNumberStrings(inNumStrings: int32_t): void;
    /**
     * Get or set an string to pass.
     * Index starts at 0
     */
    GetString(inIndex: int32_t): wstring;
    /**
     *
     */
    SetString(inIndex: int32_t, inString: wstring): void;
    /**
     * A place where you can store an nsIMutableArray to pass nsISupports
     */
    objects: nsIMutableArray;
}

/**
 * A class holding information about a directory index.
 * These have no reference back to their original source -
 * changing these attributes won't affect the directory
 */
declare interface nsIDirIndexType extends nsISupportsType {
    /**
     * The type of the entry - one of the constants above
     */
    type: unsigned_long;
    /**
     * The content type - may be null if it is unknown.
     * Unspecified for directories
     */
    contentType: ACString;
    /**
     * The fully qualified filename, expressed as a uri
     *
     * This is encoded with the encoding specified in
     * the nsIDirIndexParser, and is also escaped.
     */
    location: ACString;
    /**
     * A description for the filename, which should be
     * displayed by a viewer
     */
    description: AString;
    /**
     * File size, with -1 meaning "unknown"
     */
    size: long_long;
    /**
     * Last-modified time in seconds-since-epoch.
     * -1 means unknown - this is valid, because there were no
     * ftp servers in 1969
     */
    lastModified: PRTime;
}

/**
 * This interface is used to receive contents of directory index listings
 * from a protocol. They can then be transformed into an output format
 * (such as rdf, html, etc)
 */
declare interface nsIDirIndexListenerType extends nsISupportsType {
    /**
     * Called for each directory entry
     *
     * @param request - the request
     * @param index - new index to add
     */
    onIndexAvailable(aRequest: nsIRequestType, aIndex: nsIDirIndexType): void;
    /**
     * Called for each information line
     *
     * @param request - the request
     * @param info - new info to add
     */
    onInformationAvailable(aRequest: nsIRequestType, aInfo: AString): void;
}

/**
 * A parser for application/http-index-format
 */
declare interface nsIDirIndexParserType extends nsIStreamListenerType {
    /**
     * The interface to use as a callback for new entries
     */
    listener: nsIDirIndexListener;
    /**
     * The comment given, if any
     * This result is only valid _after_ OnStopRequest has occurred,
     * because it can occur anywhere in the datastream
     */
    readonly comment: string;
    /**
     * The encoding to use
     */
    encoding: string;
}

/**
 * The primary use of this interface is to allow any nsISerialEventTarget to
 * provide Direct Task dispatching which is similar (but not identical to) the
 * microtask semantics of JS promises.
 * New direct task may be dispatched when a current direct task is running. In
 * which case they will be run in FIFO order.
 */
declare interface nsIDirectTaskDispatcherType extends nsISupportsType {
}

/**
 * This interface provides a means for enumerating the contents of a directory.
 * It is similar to nsISimpleEnumerator except the retrieved entries are QI'ed
 * to nsIFile, and there is a mechanism for closing the directory when the
 * enumeration is complete.
 */
declare interface nsIDirectoryEnumeratorType extends nsISimpleEnumeratorType {
    /**
     * Retrieves the next file in the sequence. The "nextFile" element is the
     * first element upon the first call. This attribute is null if there is no
     * next element.
     */
    readonly nextFile: nsIFile;
    /**
     * Closes the directory being enumerated, releasing the system resource.
     * @throws NS_OK if the call succeeded and the directory was closed.
     * NS_ERROR_FAILURE if the directory close failed.
     * It is safe to call this function many times.
     */
    close(): void;
}

/**
 * nsIDirectoryServiceProvider
 *
 * Used by Directory Service to get file locations.
 */
declare interface nsIDirectoryServiceProviderType extends nsISupportsType {
    /**
     * getFile
     *
     * Directory Service calls this when it gets the first request for
     * a prop or on every request if the prop is not persistent.
     *
     * @param prop         The symbolic name of the file.
     * @param persistent   TRUE - The returned file will be cached by Directory
     * Service. Subsequent requests for this prop will
     * bypass the provider and use the cache.
     * FALSE - The provider will be asked for this prop
     * each time it is requested.
     *
     * @return             The file represented by the property.
     */
    getFile(prop: string, persistent: boolean): nsIFile;
}

/**
 * nsIDirectoryServiceProvider2
 *
 * An extension of nsIDirectoryServiceProvider which allows
 * multiple files to be returned for the given key.
 */
declare interface nsIDirectoryServiceProvider2Type extends nsIDirectoryServiceProviderType {
    /**
     * getFiles
     *
     * Directory Service calls this when it gets a request for
     * a prop and the requested type is nsISimpleEnumerator.
     *
     * @param prop         The symbolic name of the file list.
     *
     * @return             An enumerator for a list of file locations.
     * The elements in the enumeration are nsIFile
     * @returnCode         NS_SUCCESS_AGGREGATE_RESULT if this result should be
     * aggregated with other "lower" providers.
     */
    getFiles(prop: string): nsISimpleEnumerator;
}

/**
 * nsIDirectoryService
 */
declare interface nsIDirectoryServiceType extends nsISupportsType {
    /**
     * init
     *
     * Must be called. Used internally by XPCOM initialization.
     */
    init(): void;
    /**
     * registerProvider
     *
     * Register a provider with the service.
     *
     * @param prov            The service will keep a strong reference
     * to this object. It will be released when
     * the service is released.
     */
    registerProvider(prov: nsIDirectoryServiceProviderType): void;
    /**
     * unregisterProvider
     *
     * Unregister a provider with the service.
     *
     * @param prov
     */
    unregisterProvider(prov: nsIDirectoryServiceProviderType): void;
}

/**
 *
 */
declare interface nsIDisplayInfoType extends nsISupportsType {
    /**
     *
     */
    readonly id: long;
    /**
     *
     */
    readonly connected: boolean;
}

/**
 *
 */
declare interface nsIDocShellType extends nsIDocShellTreeItemType {
    /**
     *
     */
    setCancelContentJSEpoch(aEpoch: long): void;
    /**
     * Do either a history.pushState() or history.replaceState() operation,
     * depending on the value of aReplace.
     */
    addState(aData: jsval, aTitle: AString, aURL: AString, aReplace: boolean): void;
    /**
     * Reset state to a new content model within the current document and the document
     * viewer.  Called by the document before initiating an out of band document.write().
     */
    prepareForNewContentModel(): void;
    /**
     * Helper for the session store to change the URI associated with the
     * document.
     */
    setCurrentURIForSessionStore(aURI: nsIURIType): void;
    /**
     * Presentation context for the currently loaded document.  This may be null.
     */
    readonly presContext: nsPresContext;
    /**
     * Presentation shell for the currently loaded document.  This may be null.
     */
    readonly presShell: PresShell;
    /**
     * Presentation shell for the oldest document, if this docshell is
     * currently transitioning between documents.
     */
    readonly eldestPresShell: PresShell;
    /**
     * Content Viewer that is currently loaded for this DocShell.  This may
     * change as the underlying content changes.
     */
    readonly contentViewer: nsIContentViewer;
    /**
     * Get the id of the outer window that is or will be in this docshell.
     */
    readonly outerWindowID: unsigned_long_long;
    /**
     * This attribute allows chrome to tie in to handle DOM events that may
     * be of interest to chrome.
     */
    chromeEventHandler: EventTarget;
    /**
     * This allows chrome to set a custom User agent on a specific docshell
     */
    customUserAgent: AString;
    /**
     * Whether CSS error reporting is enabled.
     */
    cssErrorReportingEnabled: boolean;
    /**
     * Whether to allow plugin execution
     */
    allowPlugins: boolean;
    /**
     * Attribute stating if refresh based redirects can be allowed
     */
    allowMetaRedirects: boolean;
    /**
     * Attribute stating if it should allow subframes (framesets/iframes) or not
     */
    allowSubframes: boolean;
    /**
     * Attribute stating whether or not images should be loaded.
     */
    allowImages: boolean;
    /**
     * Attribute stating whether or not media (audio/video) should be loaded.
     */
    allowMedia: boolean;
    /**
     * Attribute that determines whether DNS prefetch is allowed for this subtree
     * of the docshell tree.  Defaults to true.  Setting this will make it take
     * effect starting with the next document loaded in the docshell.
     */
    allowDNSPrefetch: boolean;
    /**
     * Attribute that determines whether window control (move/resize) is allowed.
     */
    allowWindowControl: boolean;
    /**
     * True if the docshell allows its content to be handled by a content listener
     * other than the docshell itself, including the external helper app service,
     * and false otherwise.  Defaults to true.
     */
    allowContentRetargeting: boolean;
    /**
     * True if new child docshells should allow content retargeting.
     * Setting allowContentRetargeting also overwrites this value.
     */
    allowContentRetargetingOnChildren: boolean;
    /**
     *
     */
    appType: nsIDocShell_AppType;
    /**
     * certain docshells (like the message pane)
     * should not throw up auth dialogs
     * because it can act as a password trojan
     */
    allowAuth: boolean;
    /**
     * Set/Get the document scale factor.  When setting this attribute, a
     * NS_ERROR_NOT_IMPLEMENTED error may be returned by implementations
     * not supporting zoom.  Implementations not supporting zoom should return
     * 1.0 all the time for the Get operation.  1.0 by the way is the default
     * of zoom.  This means 100% of normal scaling or in other words normal size
     * no zoom.
     */
    zoom: float;
    /**
     * Tells the docshell to offer focus to its tree owner.
     * This is currently only necessary for embedding chrome.
     * If forDocumentNavigation is true, then document navigation should be
     * performed, where only the root of documents are selected. Otherwise, the
     * next element in the parent should be returned. Returns true if focus was
     * successfully taken by the tree owner.
     */
    tabToTreeOwner(forward: boolean, forDocumentNavigation: boolean): bool;
    /**
     *
     */
    readonly busyFlags: nsIDocShell_BusyFlags;
    /**
     * Attribute to access the loadtype for the document. LoadType Enum is
     * defined in nsDocShellLoadTypes.h
     */
    loadType: unsigned_long;
    /**
     * Default load flags (as defined in nsIRequest) that will be set on all
     * requests made by this docShell and propagated to all child docShells and
     * to nsILoadGroup::defaultLoadFlags for the docShell's loadGroup.
     * Default is no flags.  Once set, only future requests initiated by the
     * docShell are affected, so in general, these flags should be set before
     * the docShell loads any content.
     */
    defaultLoadFlags: nsLoadFlags;
    /**
     * returns true if the docshell is being destroyed, false otherwise
     */
    isBeingDestroyed(): boolean;
    /**
     * Returns true if the docshell is currently executing the onLoad Handler
     */
    readonly isExecutingOnLoadHandler: boolean;
    /**
     *
     */
    layoutHistoryState: nsILayoutHistoryState;
    /**
     * Object used to delegate URI loading to an upper context.
     * Currently only set for GeckoView to allow handling of load requests
     * at the application level.
     */
    readonly loadURIDelegate: nsILoadURIDelegate;
    /**
     * Cancel the XPCOM timers for each meta-refresh URI in this docshell,
     * and this docshell's children, recursively. The meta-refresh timers can be
     * restarted using resumeRefreshURIs().  If the timers are already suspended,
     * this has no effect.
     */
    suspendRefreshURIs(): void;
    /**
     * Restart the XPCOM timers for each meta-refresh URI in this docshell,
     * and this docshell's children, recursively.  If the timers are already
     * running, this has no effect.
     */
    resumeRefreshURIs(): void;
    /**
     * Begin firing WebProgressListener notifications for restoring a page
     * presentation. |viewer| is the content viewer whose document we are
     * starting to load.  If null, it defaults to the docshell's current content
     * viewer, creating one if necessary.  |top| should be true for the toplevel
     * docshell that is being restored; it will be set to false when this method
     * is called for child docshells.  This method will post an event to
     * complete the simulated load after returning to the event loop.
     */
    beginRestore(viewer: nsIContentViewerType, top: boolean): void;
    /**
     * Finish firing WebProgressListener notifications and DOM events for
     * restoring a page presentation.  This should only be called via
     * beginRestore().
     */
    finishRestore(): void;
    /**
     *
     */
    clearCachedUserAgent(): void;
    /**
     *
     */
    clearCachedPlatform(): void;
    /**
     * Track whether we're currently restoring a document presentation.
     */
    readonly restoringDocument: boolean;
    /**
     * attribute to access whether error pages are enabled
     */
    useErrorPages: boolean;
    /**
     * Display a load error in a frame while keeping that frame's currentURI
     * pointing correctly to the page where the error ocurred, rather than to
     * the error document page. You must provide either the aURI or aURL parameter.
     *
     * @param  aError         The error code to be displayed
     * @param  aURI           nsIURI of the page where the error happened
     * @param  aURL           wstring of the page where the error happened
     * @param  aFailedChannel The channel related to this error
     *
     * Returns whether or not we displayed an error page (note: will always
     * return false if in-content error pages are disabled!)
     */
    displayLoadError(aError: nsresult, aURI: nsIURIType, aURL: wstring, aFailedChannel: nsIChannelType): boolean;
    /**
     * The channel that failed to load and resulted in an error page.
     * May be null. Relevant only to error pages.
     */
    readonly failedChannel: nsIChannel;
    /**
     * Keeps track of the previous nsISHEntry index and the current
     * nsISHEntry index at the time that the doc shell begins to load.
     * Used for ContentViewer eviction.
     */
    readonly previousEntryIndex: long;
    /**
     *
     */
    readonly loadedEntryIndex: long;
    /**
     * Notification that entries have been removed from the beginning of a
     * nsSHistory which has this as its rootDocShell.
     *
     * @param numEntries - The number of entries removed
     */
    historyPurged(numEntries: long): void;
    /**
     * Gets the channel for the currently loaded document, if any.
     * For a new document load, this will be the channel of the previous document
     * until after OnLocationChange fires.
     */
    readonly currentDocumentChannel: nsIChannel;
    /**
     * Find out whether the docshell is currently in the middle of a page
     * transition. This is set just before the pagehide/unload events fire.
     */
    readonly isInUnload: boolean;
    /**
     * Propagated to the print preview document viewer.  Must only be called on
     * a document viewer that has been initialized for print preview.
     */
    exitPrintPreview(): void;
    /**
     * The ID of the docshell in the session history.
     */
    readonly historyID: nsIDRef;
    /**
     * Create a new about:blank document and content viewer.
     * @param aPrincipal the principal to use for the new document.
     * @param aPartitionedPrincipal the partitioned principal to use for the new
     * document.
     * @param aCsp the CSP to use for the new document.
     */
    createAboutBlankContentViewer(aPrincipal: nsIPrincipalType, aPartitionedPrincipal: nsIPrincipalType, aCSP: nsIContentSecurityPolicyType): void;
    /**
     * Upon getting, returns the canonical encoding label of the document
     * currently loaded into this docshell.
     */
    readonly charset: ACString;
    /**
     *
     */
    forceEncodingDetection(): void;
    /**
     * Whether the docShell records profile timeline markers at the moment
     */
    recordProfileTimelineMarkers: boolean;
    /**
     * Return a DOMHighResTimeStamp representing the number of
     * milliseconds from an arbitrary point in time.  The reference
     * point is shared by all DocShells and is also used by timestamps
     * on markers.
     */
    now(): DOMHighResTimeStamp;
    /**
     * Returns and flushes the profile timeline markers gathered by the docShell
     */
    popProfileTimelineMarkers(): jsval;
    /**
     * Add an observer to the list of parties to be notified when this docshell's
     * private browsing status is changed. |obs| must support weak references.
     */
    addWeakPrivacyTransitionObserver(obs: nsIPrivacyTransitionObserverType): void;
    /**
     * Add an observer to the list of parties to be notified when reflows are
     * occurring. |obs| must support weak references.
     */
    addWeakReflowObserver(obs: nsIReflowObserverType): void;
    /**
     * Remove an observer from the list of parties to be notified about reflows.
     */
    removeWeakReflowObserver(obs: nsIReflowObserverType): void;
    /**
     * Returns true if this docshell is the top level content docshell.
     */
    readonly isTopLevelContentDocShell: boolean;
    /**
     * Like nsIDocShellTreeItem::GetSameTypeParent, except this ignores <iframe
     * mozbrowser> boundaries. Which no longer exist.
     *
     * @deprecated: Use `BrowsingContext::GetParent()` in the future.
     */
    getSameTypeInProcessParentIgnoreBrowserBoundaries(): nsIDocShell;
    /**
     * True iff asynchronous panning and zooming is enabled for this
     * docshell.
     */
    readonly asyncPanZoomEnabled: bool;
    /**
     * Indicates whether the UI may enable the character encoding menu. The UI
     * must disable the menu when this property is false.
     */
    readonly mayEnableCharacterEncodingMenu: boolean;
    /**
     *
     */
    editor: nsIEditor;
    /**
     *
     */
    readonly editable: boolean;
    /**
     * this docShell is editable
     */
    readonly hasEditingSession: boolean;
    /**
     * this docShell has an editing session
     *
     * Make this docShell editable, setting a flag that causes
     * an editor to get created, either immediately, or after
     * a url has been loaded.
     * @param  inWaitForUriLoad    true to wait for a URI before
     * creating the editor.
     */
    makeEditable(inWaitForUriLoad: boolean): void;
    /**
     * Returns false for mLSHE, true for mOSHE
     */
    getCurrentSHEntry(aEntry: nsISHEntryType): boolean;
    /**
     * Cherry picked parts of nsIController.
     * They are here, because we want to call these functions
     * from JS.
     */
    isCommandEnabled(command: string): boolean;
    /**
     *
     */
    doCommand(command: string): void;
    /**
     *
     */
    doCommandWithParams(command: string, aParams: nsICommandParamsType): void;
    /**
     * This attribute determines whether a document which is not about:blank has
     * already be loaded by this docShell.
     */
    readonly hasLoadedNonBlankURI: boolean;
    /**
     * Allow usage of -moz-window-dragging:drag for content docshells.
     * True for top level chrome docshells. Throws if set to false with
     * top level chrome docshell.
     */
    windowDraggingAllowed: boolean;
    /**
     * Sets/gets the current scroll restoration mode.
     * @see https://html.spec.whatwg.org/#dom-history-scroll-restoration
     */
    currentScrollRestorationIsManual: boolean;
    /**
     * Setter and getter for the origin attributes living on this docshell.
     */
    getOriginAttributes(): jsval;
    /**
     *
     */
    setOriginAttributes(aAttrs: jsval): void;
    /**
     * The editing session for this docshell.
     */
    readonly editingSession: nsIEditingSession;
    /**
     * The browser child for this docshell.
     */
    readonly browserChild: nsIBrowserChild;
    /**
     * This allows chrome to override the default choice of whether the
     * <meta name="viewport"> tag is respected in a specific docshell.
     * Possible values are listed above.
     */
    metaViewportOverride: nsIDocShell_MetaViewportOverride;
    /**
     * Attribute that determines whether tracking protection is enabled.
     */
    useTrackingProtection: boolean;
    /**
     *
     */
    setColorMatrix(aMatrix: invalid): void;
    /**
     * Returns true if the current load is a forced reload,
     * e.g. started by holding shift whilst triggering reload.
     */
    readonly isForceReloading: bool;
    /**
     * The message manager for this docshell.  This does not throw, but
     * can return null if the docshell has no message manager.
     */
    readonly messageManager: ContentFrameMessageManager;
    /**
     * This returns a Promise which resolves to a boolean. True when the
     * document has Tracking Content that has been blocked from loading, false
     * otherwise.
     */
    getHasTrackingContentBlocked(): Promise;
    /**
     * Return whether this docshell is "attempting to navigate" in the
     * sense that's relevant to document.open.
     */
    readonly isAttemptingToNavigate: boolean;
    /**
     * Whether or not this docshell is executing a nsIWebNavigation navigation
     * method.
     *
     * This will be true when the following methods are executing:
     * nsIWebNavigation.binaryLoadURI
     * nsIWebNavigation.goBack
     * nsIWebNavigation.goForward
     * nsIWebNavigation.gotoIndex
     * nsIWebNavigation.loadURI
     */
    readonly isNavigating: boolean;
    /**
     * @see nsISHEntry synchronizeLayoutHistoryState().
     */
    synchronizeLayoutHistoryState(): void;
    /**
     * This attempts to save any applicable layout history state (like
     * scroll position) in the nsISHEntry. This is normally done
     * automatically when transitioning from page to page in the
     * same process. We expose this function to support transitioning
     * from page to page across processes as a workaround for bug 1630234
     * until session history state is moved into the parent process.
     */
    persistLayoutHistoryState(): void;
}

/**
 * The nsIDocShellTreeItem supplies the methods that are required of any item
 * that wishes to be able to live within the docshell tree either as a middle
 * node or a leaf.
 */
declare interface nsIDocShellTreeItemType extends nsISupportsType {
    /**
     * name of the DocShellTreeItem
     */
    name: AString;
    /**
     * Compares the provided name against the item's name and
     * returns the appropriate result.
     *
     * @return `PR_TRUE` if names match;
     * `PR_FALSE` otherwise.
     */
    nameEquals(name: AString): boolean;
    /**
     * The type this item is.
     */
    readonly itemType: long;
    /**
     * Parent DocShell.
     *
     * @deprecated: Use `BrowsingContext::GetParent()` instead.
     * (NOTE: `BrowsingContext::GetParent()` will not cross isolation boundaries)
     */
    readonly parent: nsIDocShellTreeItem;
    /**
     * This getter returns the same thing parent does however if the parent
     * is of a different itemType, or if the parent is an <iframe mozbrowser>.
     * It will instead return nullptr.  This call is a convience function for
     * Ithose wishing to not cross the boundaries at which item types change.
     *
     * @deprecated: Use `BrowsingContext::GetParent()` instead.
     */
    readonly sameTypeParent: nsIDocShellTreeItem;
    /**
     * Returns the root DocShellTreeItem.  This is a convience equivalent to
     * getting the parent and its parent until there isn't a parent.
     *
     * @deprecated: Use `BrowsingContext::Top()` instead.
     * (NOTE: `BrowsingContext::Top()` will not cross isolation boundaries)
     */
    readonly rootTreeItem: nsIDocShellTreeItem;
    /**
     * Returns the root DocShellTreeItem of the same type.  This is a convience
     * equivalent to getting the parent of the same type and its parent until
     * there isn't a parent.
     *
     * @deprecated: Use `BrowsingContext::Top()` instead.
     */
    readonly sameTypeRootTreeItem: nsIDocShellTreeItem;
    /**
     * The owner of the DocShell Tree.  This interface will be called upon when
     * the docshell has things it needs to tell to the owner of the docshell.
     * Note that docShell tree ownership does not cross tree types.  Meaning
     * setting ownership on a chrome tree does not set ownership on the content
     * sub-trees.  A given tree's boundaries are identified by the type changes.
     * Trees of different types may be connected, but should not be traversed
     * for things such as ownership.
     *
     * Note implementers of this interface should NOT effect the lifetime of the
     * parent DocShell by holding this reference as it creates a cycle.  Owners
     * when releasing this interface should set the treeOwner to nullptr.
     * Implementers of this interface are guaranteed that when treeOwner is
     * set that the poitner is valid without having to addref.
     *
     * Further note however when others try to get the interface it should be
     * addref'd before handing it to them.
     */
    readonly treeOwner: nsIDocShellTreeOwner;
    /**
     * The current number of DocShells which are immediate children of the
     * this object.
     *
     *
     * @deprecated: Prefer using `BrowsingContext::Children()`, as this count will
     * not include out-of-process iframes.
     */
    readonly childCount: long;
    /**
     * Return the child at the index requested.  This is 0-based.
     *
     * @deprecated: Prefer using `BrowsingContext::Children()`, as this will not
     * include out-of-process iframes.
     *
     * @throws NS_ERROR_UNEXPECTED if the index is out of range
     */
    getChildAt(index: long): nsIDocShellTreeItem;
    /**
     * BrowsingContext associated with the DocShell.
     */
    readonly browsingContext: BrowsingContext;
    /**
     * Returns the DOM outer window for the content viewer.
     */
    readonly domWindow: mozIDOMWindowProxy;
}

/**
 *
 */
declare interface nsIDocShellTreeOwnerType extends nsISupportsType {
    /**
     * Called when a content shell is added to the docshell tree.  This is
     * _only_ called for "root" content shells (that is, ones whose parent is a
     * chrome shell).
     *
     * @param aContentShell the shell being added.
     * @param aPrimary whether the shell is primary.
     */
    contentShellAdded(aContentShell: nsIDocShellTreeItemType, aPrimary: boolean): void;
    /**
     * Called when a content shell is removed from the docshell tree.  This is
     * _only_ called for "root" content shells (that is, ones whose parent is a
     * chrome shell).  Note that if aContentShell was never added,
     * contentShellRemoved should just do nothing.
     *
     * @param aContentShell the shell being removed.
     */
    contentShellRemoved(aContentShell: nsIDocShellTreeItemType): void;
    /**
     * Returns the Primary Content Shell
     */
    readonly primaryContentShell: nsIDocShellTreeItem;
    /**
     *
     */
    remoteTabAdded(aTab: nsIRemoteTabType, aPrimary: boolean): void;
    /**
     *
     */
    remoteTabRemoved(aTab: nsIRemoteTabType): void;
    /**
     * In multiprocess case we may not have primaryContentShell but
     * primaryRemoteTab.
     */
    readonly primaryRemoteTab: nsIRemoteTab;
    /**
     * Get the BrowsingContext associated with either the primary content shell or
     * primary remote tab, depending on which is available.
     */
    readonly primaryContentBrowsingContext: BrowsingContext;
    /**
     * Tells the tree owner to size its window or parent window in such a way
     * that the shell passed along will be the size specified.
     */
    sizeShellTo(shell: nsIDocShellTreeItemType, cx: long, cy: long): void;
    /**
     * Gets the size of the primary content area in device pixels. This should work
     * for both in-process and out-of-process content areas.
     */
    getPrimaryContentSize(width: long, height: long): void;
    /**
     * Sets the size of the primary content area in device pixels. This should work
     * for both in-process and out-of-process content areas.
     */
    setPrimaryContentSize(width: long, height: long): void;
    /**
     * Gets the size of the root docshell in device pixels.
     */
    getRootShellSize(width: long, height: long): void;
    /**
     * Sets the size of the root docshell in device pixels.
     */
    setRootShellSize(width: long, height: long): void;
    /**
     * Sets the persistence of different attributes of the window.
     */
    setPersistence(aPersistPosition: boolean, aPersistSize: boolean, aPersistSizeMode: boolean): void;
    /**
     * Gets the current persistence states of the window.
     */
    getPersistence(aPersistPosition: boolean, aPersistSize: boolean, aPersistSizeMode: boolean): void;
    /**
     * Gets the number of tabs currently open in our window, assuming
     * this tree owner has such a concept.
     */
    readonly tabCount: unsigned_long;
    /**
     * Returns true if there is a primary content shell or a primary
     * remote tab.
     */
    readonly hasPrimaryContent: bool;
}

/**
 *
 */
declare interface nsIDocumentEncoderNodeFixupType extends nsISupportsType {
    /**
     * Create a fixed up version of a node. This method is called before
     * each node in a document is about to be persisted. The implementor
     * may return a new node with fixed up attributes or null. If null is
     * returned the node should be used as-is.
     * @param aNode Node to fixup.
     * @param [OUT] aSerializeCloneKids True if the document encoder should
     * apply recursive serialization to the children of the fixed up node
     * instead of the children of the original node.
     * @return The resulting fixed up node.
     */
    fixupNode(aNode: Node, aSerializeCloneKids: boolean): Node;
}

/**
 *
 */
declare interface nsIDocumentEncoderType extends nsISupportsType {
    /**
     * Initialize with a pointer to the document and the mime type.
     * Resets wrap column to 72 and resets node fixup.
     * @param aDocument Document to encode.
     * @param aMimeType MimeType to use. May also be set by SetMimeType.
     * @param aFlags Flags to use while encoding. May also be set by SetFlags.
     */
    init(aDocument: Document, aMimeType: AString, aFlags: unsigned_long): void;
    /**
     * If the selection is set to a non-null value, then the
     * selection is used for encoding, otherwise the entire
     * document is encoded.
     * @param aSelection The selection to encode.
     */
    setSelection(aSelection: Selection): void;
    /**
     * If the range is set to a non-null value, then the
     * range is used for encoding, otherwise the entire
     * document or selection is encoded.
     * @param aRange The range to encode.
     */
    setRange(aRange: Range): void;
    /**
     * If the node is set to a non-null value, then the
     * node is used for encoding, otherwise the entire
     * document or range or selection is encoded.
     * @param aNode The node to encode.
     */
    setNode(aNode: Node): void;
    /**
     * If the container is set to a non-null value, then its
     * child nodes are used for encoding, otherwise the entire
     * document or range or selection or node is encoded.
     * @param aContainer The node which child nodes will be encoded.
     */
    setContainerNode(aContainer: Node): void;
    /**
     * Documents typically have an intrinsic character set,
     * but if no intrinsic value is found, the platform character set
     * is used. This function overrides both the intrinisc and platform
     * charset.
     * @param aCharset Overrides the both the intrinsic or platform
     * character set when encoding the document.
     *
     * Possible result codes: NS_ERROR_NO_CHARSET_CONVERTER
     */
    setCharset(aCharset: ACString): void;
    /**
     * Set a wrap column.  This may have no effect in some types of encoders.
     * @param aWrapColumn Column to which to wrap. If 0, wrapping is disabled.
     */
    setWrapColumn(aWrapColumn: unsigned_long): void;
    /**
     * The mime type preferred by the encoder.  This piece of api was
     * added because the copy encoder may need to switch mime types on you
     * if you ask it to copy html that really represents plaintext content.
     * Call this AFTER Init() and SetSelection() have both been called.
     */
    readonly mimeType: AString;
    /**
     * Encode the document and send the result to the nsIOutputStream.
     *
     * Possible result codes are the stream errors which might have
     * been encountered.
     * @param aStream Stream into which to encode.
     */
    encodeToStream(aStream: nsIOutputStreamType): void;
    /**
     * Encode the document into a string.
     *
     * @return The document encoded into a string.
     */
    encodeToString(): AString;
    /**
     * Encode the document into a string. Stores the extra context information
     * into the two arguments.
     * @param [OUT] aContextString The string where the parent hierarchy
     * information will be stored.
     * @param [OUT] aInfoString The string where extra context info will
     * be stored.
     * @return The document encoded as a string.
     */
    encodeToStringWithContext(aContextString: AString, aInfoString: AString): AString;
    /**
     * Encode the document into a string of limited size.
     * @param aMaxLength After aMaxLength characters, the encoder will stop
     * encoding new data.
     * Only values > 0 will be considered.
     * The returned string may be slightly larger than
     * aMaxLength because some serializers (eg. HTML)
     * may need to close some tags after they stop
     * encoding new data, or finish a line (72 columns
     * by default for the plain text serializer).
     *
     * @return The document encoded into a string.
     */
    encodeToStringWithMaxLength(aMaxLength: unsigned_long): AString;
    /**
     * Set the fixup object associated with node persistence.
     * @param aFixup The fixup object.
     */
    setNodeFixup(aFixup: nsIDocumentEncoderNodeFixupType): void;
}

/**
 * An nsIDocumentLoader is an interface responsible for tracking groups of
 * loads that belong together (images, external scripts, etc) and subdocuments
 * (<iframe>, <frame>, etc). It is also responsible for sending
 * nsIWebProgressListener notifications.
 * XXXbz this interface should go away, we think...
 */
declare interface nsIDocumentLoaderType extends nsISupportsType {
    /**
     *
     */
    stop(): void;
    /**
     *
     */
    readonly container: nsISupports;
    /**
     *
     */
    readonly loadGroup: nsILoadGroup;
    /**
     *
     */
    readonly documentChannel: nsIChannel;
}

/**
 * To get a component that implements nsIDocumentLoaderFactory
 * for a given mimetype, use nsICategoryManager to find an entry
 * with the mimetype as its name in the category "Gecko-Content-Viewers".
 * The value of the entry is the contractid of the component.
 * The component is a service, so use GetService, not CreateInstance to get it.
 */
declare interface nsIDocumentLoaderFactoryType extends nsISupportsType {
    /**
     *
     */
    createInstance(aCommand: string, aChannel: nsIChannelType, aLoadGroup: nsILoadGroupType, aContentType: ACString, aContainer: nsIDocShellType, aExtraInfo: nsISupportsType, aDocListenerResult: nsIStreamListenerType): nsIContentViewer;
    /**
     *
     */
    createInstanceForDocument(aContainer: nsISupportsType, aDocument: Document, aCommand: string): nsIContentViewer;
}

/**
 * Due to the historical reason, this listener interface says "document state",
 * but this listener listens to HTML editor state.
 */
declare interface nsIDocumentStateListenerType extends nsISupportsType {
    /**
     * NotifyDocumentWillBeDestroyed() is called when HTML editor instance is
     * being destroyed.  Note that related objects may have already gone when
     * this is called because that may cause destroying HTML editor.
     */
    NotifyDocumentWillBeDestroyed(): void;
    /**
     * NotifyDocumentStateChanged() is called when dirty state of HTML editor
     * is changed.
     *
     * @param aNowDirty   if true, this is called when the HTML editor becomes
     * dirty.  Otherwise, called when it becomes not dirty.
     */
    NotifyDocumentStateChanged(aNowDirty: boolean): void;
}

/**
 * When a domain policy is instantiated by invoking activateDomainPolicy() on
 * nsIScriptSecurityManager, these domain sets are consulted when each new
 * global is created (they have no effect on already-created globals).
 * If javascript is globally enabled with |javascript.enabled|, the blocklists
 * are consulted. If globally disabled, the allowlists are consulted. Lookups
 * on blocklist and allowlist happen with contains(), and lookups on
 * superBlocklist and superAllowlist happen with containsSuperDomain().
 *
 * When deactivate() is invoked, the domain sets are emptied, and the
 * nsIDomainPolicy ceases to have any effect on the system.
 */
declare interface nsIDomainPolicyType extends nsISupportsType {
    /**
     *
     */
    readonly blocklist: nsIDomainSet;
    /**
     *
     */
    readonly superBlocklist: nsIDomainSet;
    /**
     *
     */
    readonly allowlist: nsIDomainSet;
    /**
     *
     */
    readonly superAllowlist: nsIDomainSet;
    /**
     *
     */
    deactivate(): void;
}

/**
 *
 */
declare interface nsIDomainSetType extends nsISupportsType {
    /**
     * Add a domain to the set. No-op if it already exists.
     */
    add(aDomain: nsIURIType): void;
    /**
     * Remove a domain from the set. No-op if it doesn't exist.
     */
    remove(aDomain: nsIURIType): void;
    /**
     * Remove all entries from the set.
     */
    clear(): void;
    /**
     * Returns true if a given domain is in the set.
     */
    contains(aDomain: nsIURIType): bool;
    /**
     * Returns true if a given domain is a subdomain of one of the entries in
     * the set.
     */
    containsSuperDomain(aDomain: nsIURIType): bool;
}

/**
 * nsIDownloader
 *
 * A downloader is a special implementation of a nsIStreamListener that will
 * make the contents of the stream available as a file.  This may utilize the
 * disk cache as an optimization to avoid an extra copy of the data on disk.
 * The resulting file is valid from the time the downloader completes until
 * the last reference to the downloader is released.
 */
declare interface nsIDownloaderType extends nsIStreamListenerType {
    /**
     * Initialize this downloader
     *
     * @param observer
     * the observer to be notified when the download completes.
     * @param downloadLocation
     * the location where the stream contents should be written.
     * if null, the downloader will select a location and the
     * resulting file will be deleted (or otherwise made invalid)
     * when the downloader object is destroyed.  if an explicit
     * download location is specified then the resulting file will
     * not be deleted, and it will be the callers responsibility
     * to keep track of the file, etc.
     */
    init(observer: nsIDownloadObserverType, downloadLocation: nsIFileType): void;
}

/**
 *
 */
declare interface nsIDownloadObserverType extends nsISupportsType {
    /**
     * Called to signal a download that has completed.
     */
    onDownloadComplete(downloader: nsIDownloaderType, request: nsIRequestType, status: nsresult, result: nsIFileType): void;
}

/**
 *
 */
declare interface nsIDragServiceType extends nsISupportsType {
    /**
     * Starts a modal drag session with an array of transaferables.
     *
     * Note: This method is deprecated for non-native code.
     *
     * @param  aPrincipal - the triggering principal of the drag, or null if
     * it's from browser chrome or OS
     * @param aCsp - The csp of the triggering Document
     * @param  aTransferables - an array of transferables to be dragged
     * @param  aActionType - specified which of copy/move/link are allowed
     * @param  aContentPolicyType - the contentPolicyType that will be
     * passed to the loadInfo when creating a new channel
     * (defaults to TYPE_OTHER)
     */
    invokeDragSession(aDOMNode: Node, aPrincipal: nsIPrincipalType, aCsp: nsIContentSecurityPolicyType, aCookieJarSettings: nsICookieJarSettingsType, aTransferables: nsIArrayType, aActionType: unsigned_long, aContentPolicyType: nsContentPolicyType): void;
    /**
     * Start a modal drag session using the selection as the drag image.
     * The aDragEvent must be supplied as the current screen coordinates of the
     * event are needed to calculate the image location.
     *
     * Note: This method is deprecated for non-native code.
     */
    invokeDragSessionWithSelection(aSelection: Selection, aPrincipal: nsIPrincipalType, aCsp: nsIContentSecurityPolicyType, aCookieJarSettings: nsICookieJarSettingsType, aTransferableArray: nsIArrayType, aActionType: unsigned_long, aDragEvent: DragEvent, aDataTransfer: DataTransferPtr): void;
    /**
     * Returns the current Drag Session
     */
    getCurrentSession(): nsIDragSession;
    /**
     * Tells the Drag Service to start a drag session. This is called when
     * an external drag occurs
     */
    startDragSession(): void;
    /**
     * Similar to startDragSession(), automated tests may want to start
     * session for emulating an external drag.  At that time, this should
     * be used instead of startDragSession().
     *
     * @param aAllowedEffect Set default drag action which means allowed effects
     * in the session and every DnD events are initialized
     * with one of specified value.  So, the value can be
     * DRAGDROP_ACTION_NONE, or one or more values of
     * DRAGDROP_ACTION_(MOVE|COPY|LINK).
     */
    startDragSessionForTests(aAllowedEffect: unsigned_long): void;
    /**
     * Tells the Drag Service to end a drag session. This is called when
     * an external drag occurs
     *
     * If aDoneDrag is true, the drag has finished, otherwise the drag has
     * just left the window.
     */
    endDragSession(aDoneDrag: boolean, aKeyModifiers: unsigned_long): void;
    /**
     * Increase/decrease dragging suppress level by one.
     * If level is greater than one, dragging is disabled.
     */
    suppress(): void;
    /**
     *
     */
    unsuppress(): void;
    /**
     *
     */
    maybeAddChildProcess(aChild: ContentParentPtr): boolean;
    /**
     *
     */
    removeAllChildProcesses(): boolean;
}

/**
 *
 */
declare interface nsIDragSessionType extends nsISupportsType {
    /**
     * Set the current state of the drag, whether it can be dropped or not.
     * usually the target "frame" sets this so the native system can render the correct feedback
     */
    canDrop: boolean;
    /**
     * Indicates if the drop event should be dispatched only to chrome.
     */
    onlyChromeDrop: boolean;
    /**
     * Sets the action (copy, move, link, et.c) for the current drag
     */
    dragAction: unsigned_long;
    /**
     * Get the number of items that were dropped
     */
    readonly numDropItems: unsigned_long;
    /**
     * The window context where the drag was started, which will be null if the
     * drag originated outside the application. Useful for determining if a drop
     * originated in the same window context.
     */
    sourceWindowContext: WindowContext;
    /**
     * The top-level window context where the drag was started, which will be
     * null if the drag originated outside the application. Useful for
     * determining if a drop originated in the same top-level window context.
     */
    sourceTopWindowContext: WindowContext;
    /**
     * The dom node that was originally dragged to start the session, which will be null if the
     * drag originated outside the application.
     */
    readonly sourceNode: Node;
    /**
     * Replace source node and selection with new ones.
     * If sourceNode is a native anonymous node, it may be replaced at reframing.
     * If sourceNode is disconnected from the document, we cannot dispatch
     * `dragend` event properly.
     * When this is called, sourceNode or aNewSourceNode should be a native
     * anonymous node.
     */
    updateSource(aNewSourceNode: Node, aNewSelection: Selection): void;
    /**
     * the triggering principal.  This may be different than sourceNode's
     * principal when sourceNode is xul:browser and the drag is
     * triggered in a browsing context inside it.
     */
    triggeringPrincipal: nsIPrincipal;
    /**
     * the triggering csp.  This may be different than sourceNode's
     * csp when sourceNode is xul:browser and the drag is
     * triggered in a browsing context inside it.
     */
    csp: nsIContentSecurityPolicy;
    /**
     * The data transfer object for the current drag.
     */
    dataTransfer: DataTransfer;
    /**
     *
     */
    getDataTransfer(): DataTransfer;
    /**
     *
     */
    setDataTransfer(aDataTransfer: DataTransfer): void;
    /**
     * Get data from a Drag&Drop. Can be called while the drag is in process
     * or after the drop has completed.
     *
     * @param  aTransferable the transferable for the data to be put into
     * @param  aItemIndex which of multiple drag items, zero-based
     */
    getData(aTransferable: nsITransferableType, aItemIndex: unsigned_long): void;
    /**
     * Check to set if any of the native data on the clipboard matches this data flavor
     */
    isDataFlavorSupported(aDataFlavor: string): boolean;
    /**
     *
     */
    userCancelled(): void;
    /**
     *
     */
    dragEventDispatchedToChildProcess(): void;
    /**
     *
     */
    updateDragEffect(): void;
    /**
     *
     */
    updateDragImage(aImage: Node, aImageX: long, aImageY: long): void;
    /**
     * Returns effects allowed at starting the session for tests.
     */
    getEffectAllowedForTests(): unsigned_long;
    /**
     * Returns true if current session was started with synthesized drag start.
     */
    isSynthesizedForTests(): bool;
    /**
     * Sets drag end point of synthesized session when the test does not dispatch
     * "drop" event.
     */
    setDragEndPointForTests(aScreenX: long, aScreenY: long): void;
    /**
     * Returns true if the session is for dragging text in a text in text control
     * element.
     */
    isDraggingTextInTextControl(): bool;
}

/**
 *
 */
declare interface nsIDroppedLinkItemType extends nsISupportsType {
    /**
     * Returns the URL of the link.
     */
    readonly url: AString;
    /**
     * Returns the link name.
     */
    readonly name: AString;
    /**
     * Returns the MIME-Type.
     */
    readonly type: AString;
}

/**
 *
 */
declare interface nsIDroppedLinkHandlerType extends nsISupportsType {
    /**
     * Determines if a link being dragged can be dropped and returns true if so.
     * aEvent should be a dragenter or dragover event.
     *
     * If aAllowSameDocument is false, drops are only allowed if the document
     * of the source of the drag is different from the destination. This check
     * includes any parent, sibling and child frames in the same content tree.
     * If true, the source is not checked.
     */
    canDropLink(aEvent: DragEvent, aAllowSameDocument: boolean): boolean;
    /**
     * Given a drop event aEvent, validate the extra URIs for the event,
     * this is used when the caller extracts yet another URIs from the dropped
     * text, like home button that splits the text with "|".
     */
    validateURIsForDrop(aEvent: DragEvent, aURIs: invalid, aDisallowInherit: boolean): void;
    /**
     * Given a drop event aEvent, determines the triggering principal for the
     * event and returns it.
     */
    getTriggeringPrincipal(aEvent: DragEvent): nsIPrincipal;
    /**
     * Given a drop event aEvent, determines the CSP for the event and returns it.
     */
    getCsp(aEvent: DragEvent): nsIContentSecurityPolicy;
}

/**
 * C++ exposed interface for the `E10SUtils` object from the
 * `resource://gre/modules/E10SUtils.sys.mjs` module.
 */
declare interface nsIE10SUtilsType extends nsISupportsType {
    /**
     * Determine what remote type should be used to launch a worker script with
     * the given principal.
     *
     * @param aPrincipal
     * The result principal for the document being loaded.
     * @param aWorkerTypeName
     * The type of remote worker being launched (Ci.nsIE10SUtils.REMOTE_WORKER_TYPE_*).
     * @param aIsMultiProcess
     * A boolean to indicate if e10s enabled.
     * @param aIsFission
     * A boolean to indicate if fission is enabled.
     * @param aPreferredRemoteType
     * If multiple remote types are compatible with the worker,
     * prefer staying in this remote type.
     *
     * @return  The remote type to launch the worker in.
     */
    getRemoteTypeForWorkerPrincipal(aPrincipal: nsIPrincipalType, aWorkerType: nsIE10SUtils_RemoteWorkerTypeType, aIsMultiProcess: boolean, aIsFission: boolean, aPreferredRemoteType: AUTF8String): AUTF8String;
}

/**
 *
 */
declare interface nsIEarlyHintObserverType extends nsISupportsType {
    /**
     * This method is called when the transaction has early hint (i.e. the
     * '103 Early Hint' informational response) headers.
     */
    earlyHint(linkHeader: ACString, referrerPolicy: ACString, cspHeader: ACString): void;
}

/**
 * Utilities for migrating from legacy (non-Chromimum-based) Edge.
 */
declare interface nsIEdgeMigrationUtilsType extends nsISupportsType {
    /**
     * Determine if the Edge database is locked for writing.
     *
     * @param aFile The path to the Edge database.
     *
     * @returns A promise that is resolved to whether or not the given database
     * could be opened for writing.
     */
    isDbLocked(aFile: nsIFileType): Promise;
}

/**
 * A generic editor action listener interface.
 *
 *
 * nsIEditActionListener is the interface used by applications wishing to be notified
 * when the editor modifies the DOM tree.
 *
 * Note:  this is the wrong class to implement if you are interested in generic
 * change notifications.  For generic notifications, you should implement
 * nsIDocumentObserver.
 */
declare interface nsIEditActionListenerType extends nsISupportsType {
    /**
     * Called after the editor deletes a node.
     * @param aChild    The node to delete
     * @param aResult   The result of the delete node operation.
     */
    DidDeleteNode(aChild: Node, aResult: nsresult): void;
    /**
     * Called after the editor inserts text.
     * @param aTextNode   This node getting inserted text.
     * @param aOffset     The offset in aTextNode to insert at.
     * @param aString     The string that gets inserted.
     * @param aResult     The result of the insert text operation.
     */
    DidInsertText(aTextNode: CharacterData, aOffset: long, aString: AString, aResult: nsresult): void;
    /**
     * Called before the editor deletes text.
     * @param aTextNode   This node getting text deleted.
     * @param aOffset     The offset in aTextNode to delete at.
     * @param aLength     The amount of text to delete.
     */
    WillDeleteText(aTextNode: CharacterData, aOffset: long, aLength: long): void;
    /**
     * Called before the editor deletes the ranges.
     * @param aRangesToDelete     The ranges to be deleted.
     */
    WillDeleteRanges(aRangesToDelete: invalid): void;
}

/**
 *
 */
declare interface nsIEditingSessionType extends nsISupportsType {
    /**
     * Status after editor creation and document loading
     * Value is one of the above error codes
     */
    readonly editorStatus: unsigned_long;
    /**
     * Make this window editable
     * @param aWindow nsIDOMWindow, the window the embedder needs to make editable
     * @param aEditorType string, "html" "htmlsimple" "text" "textsimple"
     * @param aMakeWholeDocumentEditable if PR_TRUE make the whole document in
     * aWindow editable, otherwise it's the
     * embedder who should make the document
     * (or part of it) editable.
     * @param aInteractive if PR_FALSE turn off scripting and plugins
     */
    makeWindowEditable(window: mozIDOMWindowProxy, aEditorType: string, doAfterUriLoad: boolean, aMakeWholeDocumentEditable: boolean, aInteractive: boolean): void;
    /**
     * Test whether a specific window has had its editable flag set; it may have an editor
     * now, or will get one after the uri load.
     *
     * Use this, passing the content root window, to test if we've set up editing
     * for this content.
     */
    windowIsEditable(window: mozIDOMWindowProxy): boolean;
    /**
     * Get the editor for this window. May return null
     */
    getEditorForWindow(window: mozIDOMWindowProxy): nsIEditor;
}

/**
 *
 */
declare interface nsIEditorType extends nsISupportsType {
    /**
     *
     */
    readonly selection: Selection;
    /**
     *
     */
    setAttributeOrEquivalent(element: Element, sourceAttrName: AString, sourceAttrValue: AString, aSuppressTransaction: boolean): void;
    /**
     *
     */
    removeAttributeOrEquivalent(element: Element, sourceAttrName: AString, aSuppressTransaction: boolean): void;
    /**
     * edit flags for this editor.  May be set at any time.
     */
    flags: unsigned_long;
    /**
     * the MimeType of the document
     */
    contentsMIMEType: AString;
    /**
     * Returns true if we have a document that is not marked read-only
     */
    readonly isDocumentEditable: boolean;
    /**
     * Returns true if the current selection anchor is editable
     */
    readonly isSelectionEditable: boolean;
    /**
     * the DOM Document this editor is associated with, refcounted.
     */
    readonly document: Document;
    /**
     * the body element, i.e. the root of the editable document.
     */
    readonly rootElement: Element;
    /**
     * the selection controller for the current presentation, refcounted.
     */
    readonly selectionController: nsISelectionController;
    /**
     * ------------ Selected content removal --------------
     *
     * DeleteSelection removes all nodes in the current selection.
     * @param aDir  if eNext, delete to the right (for example, the DEL key)
     * if ePrevious, delete to the left (for example, the BACKSPACE key)
     * @param stripWrappers If eStrip, strip any empty inline elements left
     * behind after the deletion; if eNoStrip, don't.  If in
     * doubt, pass eStrip -- eNoStrip is only for if you're
     * about to insert text or similar right after.
     */
    deleteSelection(action: short, stripWrappers: short): void;
    /**
     * ------------ Document info and file methods --------------
     * Returns true if the document has no *meaningful* content
     */
    readonly documentIsEmpty: boolean;
    /**
     * Returns true if the document is modifed and needs saving
     */
    readonly documentModified: boolean;
    /**
     * Sets document's character set.  This is available only when the editor
     * instance is an HTMLEditor since it's odd to change character set of
     * parent document of `<input>` and `<textarea>`.
     */
    documentCharacterSet: ACString;
    /**
     * to be used ONLY when we need to override the doc's modification
     * state (such as when it's saved).
     */
    resetModificationCount(): void;
    /**
     * Gets the modification count of the document we are editing.
     * @return the modification count of the document being edited.
     * Zero means unchanged.
     */
    getModificationCount(): long;
    /**
     * called each time we modify the document.
     * Increments the modification count of the document.
     * @param  aModCount  the number of modifications by which
     * to increase or decrease the count
     */
    incrementModificationCount(aModCount: long): void;
    /**
     * ------------ Transaction methods --------------
     *
     * turn the undo system on or off
     * @param aEnable  if PR_TRUE, the undo system is turned on if available
     * if PR_FALSE the undo system is turned off if it
     * was previously on
     * @return         if aEnable is PR_TRUE, returns NS_OK if
     * the undo system could be initialized properly
     * if aEnable is PR_FALSE, returns NS_OK.
     */
    enableUndo(enable: boolean): void;
    /**
     * Returns true when undo/redo is enabled (by default).
     */
    readonly undoRedoEnabled: boolean;
    /**
     * Retruns true when undo/redo is enabled and there is one or more transaction
     * in the undo stack.
     */
    readonly canUndo: boolean;
    /**
     * Returns true when undo/redo is enabled and there is one or more transaction
     * in the redo stack.
     */
    readonly canRedo: boolean;
    /**
     * Clears the transactions both for undo and redo.
     * This may fail if you call this while editor is handling something, i.e.,
     * don't call this from a legacy mutation event listeners, then, you won't
     * see any exceptions.
     */
    clearUndoRedo(): void;
    /**
     * Undo the topmost transaction in the undo stack.
     * This may throw exception when this is called while editor is handling
     * transactions.
     */
    undo(): void;
    /**
     * Undo all transactions in the undo stack.
     * This may throw exception when this is called while editor is handling
     * transactions.
     */
    undoAll(): void;
    /**
     * Redo the topmost transaction in the redo stack.
     * This may throw exception when this is called while editor is handling
     * transactions.
     */
    redo(): void;
    /**
     * beginTransaction is a signal from the caller to the editor that
     * the caller will execute multiple updates to the content tree
     * that should be treated as a single logical operation,
     * in the most efficient way possible.<br>
     * All transactions executed between a call to beginTransaction and
     * endTransaction will be undoable as an atomic action.<br>
     * endTransaction must be called after beginTransaction.<br>
     * Calls to beginTransaction can be nested, as long as endTransaction
     * is called once per beginUpdate.
     */
    beginTransaction(): void;
    /**
     * endTransaction is a signal to the editor that the caller is
     * finished updating the content model.<br>
     * beginUpdate must be called before endTransaction is called.<br>
     * Calls to beginTransaction can be nested, as long as endTransaction
     * is called once per beginTransaction.
     */
    endTransaction(): void;
    /**
     * While setting the flag with this method to false,  DeleteRangeTransaction,
     * DeleteTextTransaction, InsertNodeTransaction, InsertTextTransaction and
     * SplitNodeTransaction won't change Selection after modifying the DOM tree.
     * Note that calling this with false does not guarantee that Selection won't
     * be changed because other transaction may ignore this flag, editor itself
     * may change selection, and current selection may become invalid after
     * changing the DOM tree, etc.
     * After calling this method with true, the caller should guarantee that
     * Selection should be positioned where user expects.
     *
     * @param should    false if you don't want above transactions to modify
     * Selection automatically after modifying the DOM tree.
     * Note that calling this with false does not guarantee
     * that Selection is never changed.
     */
    setShouldTxnSetSelection(should: boolean): void;
    /**
     * ------------ Inline Spell Checking methods --------------
     *
     * Returns the inline spell checker associated with this object. The spell
     * checker is lazily created, so this function may create the object for
     * you during this call.
     * @param  autoCreate  If true, this will create a spell checker object
     * if one does not exist yet for this editor. If false
     * and the object has not been created, this function
     * WILL RETURN NULL.
     */
    getInlineSpellChecker(autoCreate: boolean): nsIInlineSpellChecker;
    /**
     * Called when the user manually overrides the spellchecking state for this
     * editor.
     * @param  enable  The new state of spellchecking in this editor, as
     * requested by the user.
     */
    setSpellcheckUserOverride(enable: boolean): void;
    /**
     * ------------ Clipboard methods --------------
     *
     * cut the currently selected text, putting it into the OS clipboard
     * What if no text is selected?
     * What about mixed selections?
     * What are the clipboard formats?
     */
    cut(): void;
    /**
     * canCut() returns true if selected content is allowed to be copied to the
     * clipboard and to be removed.
     * Note that this always returns true if the editor is in a non-chrome
     * HTML/XHTML document.
     * FYI: Current user in script is only BlueGriffon.
     */
    canCut(): boolean;
    /**
     * copy the currently selected text, putting it into the OS clipboard
     * What if no text is selected?
     * What about mixed selections?
     * What are the clipboard formats?
     */
    copy(): void;
    /**
     * canCopy() returns true if selected content is allowed to be copied to
     * the clipboard.
     * Note that this always returns true if the editor is in a non-chrome
     * HTML/XHTML document.
     * FYI: Current user in script is only BlueGriffon.
     */
    canCopy(): boolean;
    /**
     * paste the text in the OS clipboard at the cursor position, replacing
     * the selected text (if any)
     */
    paste(aClipboardType: long): void;
    /**
     * Paste the text in |aTransferable| at the cursor position, replacing the
     * selected text (if any).
     */
    pasteTransferable(aTransferable: nsITransferableType): void;
    /**
     * Can we paste? True if the doc is modifiable, and we have
     * pasteable data in the clipboard.
     */
    canPaste(aClipboardType: long): boolean;
    /**
     * ------------ Selection methods --------------
     *
     * sets the document selection to the entire contents of the document
     */
    selectAll(): void;
    /**
     * Collapses selection at start of the document.  If it's an HTML editor,
     * collapses selection at start of current editing host (<body> element if
     * it's in designMode) instead.  If there is a non-editable node before any
     * editable text nodes or inline elements which can have text nodes as their
     * children, collapses selection at start of the editing host.  If there is
     * an editable text node which is not collapsed, collapses selection at
     * start of the text node.  If there is an editable inline element which
     * cannot have text nodes as its child, collapses selection at before the
     * element node.  Otherwise, collapses selection at start of the editing
     * host.
     */
    beginningOfDocument(): void;
    /**
     * Sets the selection to the end of the last leaf child/descendant or the root
     * element.
     */
    endOfDocument(): void;
    /**
     * ------------ Node manipulation methods --------------
     *
     * setAttribute() sets the attribute of aElement.
     * No checking is done to see if aAttribute is a legal attribute of the node,
     * or if aValue is a legal value of aAttribute.
     *
     * @param aElement    the content element to operate on
     * @param aAttribute  the string representation of the attribute to set
     * @param aValue      the value to set aAttribute to
     */
    setAttribute(aElement: Element, attributestr: AString, attvalue: AString): void;
    /**
     * removeAttribute() deletes aAttribute from the attribute list of aElement.
     * If aAttribute is not an attribute of aElement, nothing is done.
     *
     * @param aElement      the content element to operate on
     * @param aAttribute    the string representation of the attribute to get
     */
    removeAttribute(aElement: Element, aAttribute: AString): void;
    /**
     * cloneAttributes() is similar to Node::cloneNode(),
     * it assures the attribute nodes of the destination are identical
     * with the source node by copying all existing attributes from the
     * source and deleting those not in the source.
     * This is used when the destination element already exists
     *
     * @param aDestNode     the destination element to operate on
     * @param aSourceNode   the source element to copy attributes from
     */
    cloneAttributes(aDestElement: Element, aSourceElement: Element): void;
    /**
     * insertNode inserts aNode into aParent at aPosition.
     * No checking is done to verify the legality of the insertion.
     * That is the responsibility of the caller.
     * @param aNode     The DOM Node to insert.
     * @param aParent   The node to insert the new object into
     * @param aPosition The place in aParent to insert the new node
     * 0=first child, 1=second child, etc.
     * any number > number of current children = last child
     */
    insertNode(node: Node, parent: Node, aPosition: unsigned_long): void;
    /**
     * deleteNode removes aChild from aParent.
     * @param aChild    The node to delete
     */
    deleteNode(child: Node): void;
    /**
     * ------------ Output methods --------------
     *
     * Output methods:
     * aFormatType is a mime type, like text/plain.
     */
    outputToString(formatType: AString, flags: unsigned_long): AString;
    /**
     * ------------ Various listeners methods --------------
     * nsIEditor holds strong references to the editor observers, action listeners
     * and document state listeners.
     *
     * add an EditActionListener to the editors list of listeners.
     */
    addEditActionListener(listener: nsIEditActionListenerType): void;
    /**
     * Remove an EditActionListener from the editor's list of listeners.
     */
    removeEditActionListener(listener: nsIEditActionListenerType): void;
    /**
     * Add a DocumentStateListener to the editors list of doc state listeners.
     */
    addDocumentStateListener(listener: nsIDocumentStateListenerType): void;
    /**
     * Remove a DocumentStateListener to the editors list of doc state listeners.
     */
    removeDocumentStateListener(listener: nsIDocumentStateListenerType): void;
    /**
     * forceCompositionEnd() force the composition end
     */
    forceCompositionEnd(): void;
    /**
     * whether this editor has active IME transaction
     */
    readonly composing: boolean;
    /**
     * unmask() is available only when the editor is a passwrod field.  This
     * unmasks characters in specified by aStart and aEnd.  If there have
     * already unmasked characters, they are masked when this is called.
     * Note that if you calls this without non-zero `aTimeout`, you bear
     * responsibility for masking password with calling `mask()`.  I.e.,
     * user inputting password won't be masked automacitally.  If user types
     * a new character and echo is enabled, unmasked range is expanded to
     * including it.
     *
     * @param aStart      Optional, first index to show the character.  If you
     * specify middle of a surrogate pair, this expands the
     * range to include the prceding high surrogate
     * automatically.
     * If omitted, it means that all characters of the
     * password becomes unmasked.
     * @param aEnd        Optional, next index of last unmasked character.  If
     * you specify middle of a surrogate pair, the expands
     * the range to include the following low surrogate.
     * If omitted or negative value, it means unmasking all
     * characters after aStart.  Specifying same index
     * throws an exception.
     * @param aTimeout    Optional, specify milliseconds to hide the unmasked
     * characters if you want to show them temporarily.
     * If omitted or 0, it means this won't mask the characters
     * automatically.
     */
    unmask(aStart: unsigned_long, aEnd: long_long, aTimeout: unsigned_long): void;
    /**
     * mask() is available only when the editor is a password field.  This masks
     * all unmasked characters immediately.
     */
    mask(): void;
    /**
     * These attributes are available only when the editor is a password field.
     * unmaskedStart is first unmasked character index, or 0 if there is no
     * unmasked characters.
     * unmaskedEnd is next index of the last unmasked character.  0 means there
     * is no unmasked characters.
     */
    readonly unmaskedStart: unsigned_long;
    /**
     *
     */
    readonly unmaskedEnd: unsigned_long;
    /**
     * autoMaskingEnabled is true if unmasked range and newly inputted characters
     * are masked automatically.  That's the default state.  If false, until
     * `mask()` is called, unmasked range and newly inputted characters are
     * unmasked.
     */
    readonly autoMaskingEnabled: boolean;
    /**
     * passwordMask attribute is a mask character which is used to mask password.
     */
    readonly passwordMask: AString;
    /**
     * The length of the contents in characters.
     */
    readonly textLength: unsigned_long;
    /**
     * Get and set newline handling.
     *
     * Values are the constants defined above.
     */
    newlineHandling: long;
    /**
     * Inserts a string at the current location,
     * given by the selection.
     * If the selection is not collapsed, the selection is deleted
     * and the insertion takes place at the resulting collapsed selection.
     *
     * @param aString   the string to be inserted
     */
    insertText(aStringToInsert: AString): void;
    /**
     * Insert a line break into the content model.
     * The interpretation of a break is up to the implementation:
     * it may enter a character, split a node in the tree, etc.
     * This may be more efficient than calling InsertText with a newline.
     */
    insertLineBreak(): void;
}

/**
 *
 */
declare interface nsIEditorMailSupportType extends nsISupportsType {
    /**
     * Insert a string as quoted text
     * (whose representation is dependant on the editor type),
     * replacing the selected text (if any),
     * including, if possible, a "cite" attribute.
     * @param aQuotedText  The actual text to be quoted
     * @param aCitation    The "mid" URL of the source message
     * @param aInsertHTML  Insert as html?  (vs plaintext)
     * @return             The node which was inserted
     */
    insertAsCitedQuotation(aQuotedText: AString, aCitation: AString, aInsertHTML: boolean): Node;
    /**
     * Rewrap the selected part of the document, re-quoting if necessary.
     * @param aRespectNewlines  Try to maintain newlines in the original?
     */
    rewrap(aRespectNewlines: boolean): void;
    /**
     * Inserts a plaintext string at the current location,
     * with special processing for lines beginning with ">",
     * which will be treated as mail quotes and inserted
     * as plaintext quoted blocks.
     * If the selection is not collapsed, the selection is deleted
     * and the insertion takes place at the resulting collapsed selection.
     *
     * @param aString   the string to be inserted
     */
    insertTextWithQuotations(aStringToInsert: AString): void;
    /**
     * Get and set the body wrap width.
     *
     * Special values:
     * 0 = wrap to window width
     * -1 = no wrap at all
     */
    wrapWidth: long;
}

/**
 *
 */
declare interface nsIEditorSpellCheckType extends nsISupportsType {
    /**
     * Returns true if we can enable spellchecking. If there are no available
     * dictionaries, this will return false.
     */
    canSpellCheck(): boolean;
    /**
     * Turns on the spell checker for the given editor. enableSelectionChecking
     * set means that we only want to check the current selection in the editor,
     * (this controls the behavior of GetNextMisspelledWord). For spellchecking
     * clients with no modal UI (such as inline spellcheckers), this flag doesn't
     * matter.  Initialization is asynchronous and is not complete until the given
     * callback is called.
     */
    InitSpellChecker(editor: nsIEditorType, enableSelectionChecking: boolean, callback: nsIEditorSpellCheckCallbackType): void;
    /**
     * When interactively spell checking the document, this will return the
     * value of the next word that is misspelled. This also computes the
     * suggestions which you can get by calling GetSuggestedWord.
     *
     * @see mozSpellChecker::GetNextMisspelledWord
     */
    GetNextMisspelledWord(): AString;
    /**
     * Used to get suggestions for the last word that was checked and found to
     * be misspelled. The first call will give you the first (best) suggestion.
     * Subsequent calls will iterate through all the suggestions, allowing you
     * to build a list. When there are no more suggestions, an empty string
     * (not a null pointer) will be returned.
     *
     * @see mozSpellChecker::GetSuggestedWord
     */
    GetSuggestedWord(): AString;
    /**
     * Check a given word. In spite of the name, this function checks the word
     * you give it, returning true if the word is misspelled. If the word is
     * misspelled, it will compute the suggestions which you can get from
     * GetSuggestedWord().
     *
     * @see mozSpellChecker::CheckCurrentWord
     */
    CheckCurrentWord(suggestedWord: AString): boolean;
    /**
     * Check a given word then returns suggestion words via Promise if a given
     * word is misspelled. If not misspelled, returns empty string array.
     */
    suggest(aCheckingWorkd: AString, aMaxCount: unsigned_long): Promise;
    /**
     * Use when modally checking the document to replace a word.
     *
     * @see mozSpellChecker::CheckCurrentWord
     */
    ReplaceWord(misspelledWord: AString, replaceWord: AString, allOccurrences: boolean): void;
    /**
     * @see mozSpellChecker::IgnoreAll
     */
    IgnoreWordAllOccurrences(word: AString): void;
    /**
     * Fills an internal list of words added to the personal dictionary. These
     * words can be retrieved using GetPersonalDictionaryWord()
     *
     * @see mozSpellChecker::GetPersonalDictionary
     * @see GetPersonalDictionaryWord
     */
    GetPersonalDictionary(): void;
    /**
     * Used after you call GetPersonalDictionary() to iterate through all the
     * words added to the personal dictionary. Will return the empty string when
     * there are no more words.
     */
    GetPersonalDictionaryWord(): AString;
    /**
     * Adds a word to the current personal dictionary.
     *
     * @see mozSpellChecker::AddWordToDictionary
     */
    AddWordToDictionary(word: AString): void;
    /**
     * Removes a word from the current personal dictionary.
     *
     * @see mozSpellChecker::RemoveWordFromPersonalDictionary
     */
    RemoveWordFromDictionary(word: AString): void;
    /**
     * @see mozSpellChecker::SetCurrentDictionaries
     */
    setCurrentDictionaries(dictionaries: invalid): Promise;
    /**
     * Call this to free up the spell checking object. It will also save the
     * current selected language as the default for future use.
     *
     * If you have called CanSpellCheck but not InitSpellChecker, you can still
     * call this function to clear the cached spell check object, and no
     * preference saving will happen.
     */
    UninitSpellChecker(): void;
    /**
     * Used to filter the content (for example, to skip blockquotes in email from
     * spellchecking. Call this before calling InitSpellChecker; calling it
     * after initialization will have no effect.
     */
    setFilterType(filterType: unsigned_long): void;
    /**
     * Update the dictionary in use to be sure it corresponds to what the editor
     * needs.  The update is asynchronous and is not complete until the given
     * callback is called.
     */
    UpdateCurrentDictionary(callback: nsIEditorSpellCheckCallbackType): void;
}

/**
 *
 */
declare interface nsIEditorSpellCheckCallbackType extends nsISupportsType {
    /**
     *
     */
    editorSpellCheckDone(): void;
}

/**
 *
 */
declare interface nsIEffectiveTLDServiceType extends nsISupportsType {
    /**
     * Returns the public suffix of a URI. A public suffix is the highest-level domain
     * under which individual domains may be registered; it may therefore contain one
     * or more dots. For example, the public suffix for "www.bbc.co.uk" is "co.uk",
     * because the .uk TLD does not allow the registration of domains at the
     * second level ("bbc.uk" is forbidden).
     *
     * The public suffix will be returned encoded in ASCII/ACE and will be normalized
     * according to RFC 3454, i.e. the same encoding returned by nsIURI::GetAsciiHost().
     * If consumers wish to compare the result of this method against the host from
     * another nsIURI, the host should be obtained using nsIURI::GetAsciiHost().
     * In the case of nested URIs, the innermost URI will be used.
     *
     * @param   aURI   The URI to be analyzed
     *
     * @returns the public suffix
     *
     * @throws NS_ERROR_UNEXPECTED
     * or other error returned by nsIIDNService::normalize when
     * the hostname contains characters disallowed in URIs
     * @throws NS_ERROR_HOST_IS_IP_ADDRESS
     * if the host is a numeric IPv4 or IPv6 address (as determined by
     * the success of a call to PR_StringToNetAddr()).
     */
    getPublicSuffix(aURI: nsIURIType): ACString;
    /**
     * Similar to getPublicSuffix, but the suffix is validated against
     * the Public Suffix List. If the suffix is unknown this will return
     * an empty string.
     *
     * @param   aURI   The URI to be analyzed
     * @returns the public suffix if known, an empty string otherwise
     * @see     getPublicSuffixFromHost()
     */
    getKnownPublicSuffix(aURI: nsIURIType): ACString;
    /**
     * Returns the base domain of a URI; that is, the public suffix with a given
     * number of additional domain name parts. For example, the result of this method
     * for "www.bbc.co.uk", depending on the value of aAdditionalParts parameter, will
     * be:
     *
     * 0 (default) -> bbc.co.uk
     * 1           -> www.bbc.co.uk
     *
     * Similarly, the public suffix for "www.developer.mozilla.org" is "org", and the base
     * domain will be:
     *
     * 0 (default) -> mozilla.org
     * 1           -> developer.mozilla.org
     * 2           -> www.developer.mozilla.org
     *
     * The base domain will be returned encoded in ASCII/ACE and will be normalized
     * according to RFC 3454, i.e. the same encoding returned by nsIURI::GetAsciiHost().
     * If consumers wish to compare the result of this method against the host from
     * another nsIURI, the host should be obtained using nsIURI::GetAsciiHost().
     * In the case of nested URIs, the innermost URI will be used.
     *
     * @param   aURI               The URI to be analyzed
     * @param   aAdditionalParts   Number of domain name parts to be
     * returned in addition to the public suffix
     *
     * @returns the base domain (public suffix plus the requested number of additional parts)
     *
     * @throws NS_ERROR_UNEXPECTED
     * or other error returned by nsIIDNService::normalize when
     * the hostname contains characters disallowed in URIs
     * @throws NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
     * when there are insufficient subdomain levels in the hostname to satisfy the
     * requested aAdditionalParts value.
     * @throws NS_ERROR_HOST_IS_IP_ADDRESS
     * if aHost is a numeric IPv4 or IPv6 address (as determined by
     * the success of a call to PR_StringToNetAddr()).
     *
     * @see    getPublicSuffix()
     */
    getBaseDomain(aURI: nsIURIType, aAdditionalParts: uint32_t): ACString;
    /**
     * Get the Site without the scheme for the origin of aURI; e.g. for
     * "https://www.bbc.co.uk/index.html", this would be "bbc.co.uk".
     * This uses getBaseDomain() internally. This is appropriately permissive,
     * and will return a schemeless site for aliased hostnames and IP addresses
     * and will therefore not throw NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS or
     * NS_ERROR_HOST_IS_IP_ADDRESS, e.g. "http://localhost/index.html" will
     * return "localhost" successfully, rather than throwing an error.
     *
     * @param aHostURI
     * The URI to analyze.
     *
     * @return the Site.
     *
     * @throws NS_ERROR_UNEXPECTED
     * or other error returned by nsIIDNService::normalize when
     * the hostname contains characters disallowed in URIs
     *
     * @see    getBaseDomain()
     * @see    getSite()
     *
     * @warning This function should not be used without good reason. Please
     * use getSite() or the Origin if you are not absolutely certain.
     */
    getSchemelessSite(aURI: nsIURIType): ACString;
    /**
     * Get the Site for the origin of aURI; e.g. for
     * "https://www.bbc.co.uk/index.html", this would be "https://bbc.co.uk".
     * This uses getBaseDomain() internally. This is appropriately permissive,
     * and will return a scheme for alaised hostnames and IP addresses and will
     * therefore not throw NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS or
     * NS_ERROR_HOST_IS_IP_ADDRESS, e.g. "http://localhost/index.html" will
     * return "http://localhost" successfully, rather than throwing an error.
     *
     * @param aHostURI
     * The URI to analyze.
     *
     * @return the Site.
     *
     * @throws NS_ERROR_UNEXPECTED
     * or other error returned by nsIIDNService::normalize when
     * the hostname contains characters disallowed in URIs
     *
     * @see    getBaseDomain()
     */
    getSite(aURI: nsIURIType): ACString;
    /**
     * NOTE: It is strongly recommended to use getPublicSuffix() above if a suitable
     * nsIURI is available. Only use this method if this is not the case.
     *
     * Returns the public suffix of a host string. Otherwise identical to getPublicSuffix().
     *
     * @param   aHost   The host to be analyzed. Any additional parts (e.g. scheme,
     * port, or path) will cause this method to throw. ASCII/ACE and
     * UTF8 encodings are acceptable as input; normalization will
     * be performed as specified in getBaseDomain().
     *
     * @see     getPublicSuffix()
     */
    getPublicSuffixFromHost(aHost: AUTF8String): ACString;
    /**
     * Similar to getPublicSuffixFromHost, but the suffix is validated against
     * the Public Suffix List. If the suffix is unknown this will return
     * an empty string.
     *
     * @param   aHost   The host to be analyzed.
     * @returns the public suffix if known, an empty string otherwise
     * @see     getPublicSuffixFromHost()
     */
    getKnownPublicSuffixFromHost(aHost: AUTF8String): ACString;
    /**
     * NOTE: It is strongly recommended to use getBaseDomain() above if a suitable
     * nsIURI is available. Only use this method if this is not the case.
     *
     * Returns the base domain of a host string. Otherwise identical to getBaseDomain().
     *
     * @param   aHost   The host to be analyzed. Any additional parts (e.g. scheme,
     * port, or path) will cause this method to throw. ASCII/ACE and
     * UTF8 encodings are acceptable as input; normalization will
     * be performed as specified in getBaseDomain().
     *
     * @see     getBaseDomain()
     */
    getBaseDomainFromHost(aHost: AUTF8String, aAdditionalParts: uint32_t): ACString;
    /**
     * Returns the parent sub-domain of a host string. If the host is a base
     * domain, it will throw NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS.
     *
     * For example: "player.bbc.co.uk" would return "bbc.co.uk" and
     * "bbc.co.uk" would throw NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS.
     *
     * @param   aHost   The host to be analyzed. Any additional parts (e.g. scheme,
     * port, or path) will cause this method to throw. ASCII/ACE and
     * UTF8 encodings are acceptable as input; normalization will
     * be performed as specified in getBaseDomain().
     */
    getNextSubDomain(aHost: AUTF8String): ACString;
    /**
     * Returns true if the |aInput| in is part of the root domain of |aHost|.
     * For example, if |aInput| is "www.mozilla.org", and we pass in
     * "mozilla.org" as |aHost|, this will return true.  It would return false
     * the other way around.
     *
     * @param aInput The host to be analyzed.
     * @param aHost  The host to compare to.
     */
    hasRootDomain(aInput: AUTF8String, aHost: AUTF8String): bool;
}

/**
 * The nsIEmbeddingSiteWindow is implemented by the embedder to provide
 * Gecko with the means to call up to the host to resize the window,
 * hide or show it and set/get its title.
 */
declare interface nsIEmbeddingSiteWindowType extends nsISupportsType {
    /**
     * Sets the dimensions for the window; the position & size. The
     * flags to indicate what the caller wants to set and whether the size
     * refers to the inner or outer area. The inner area refers to just
     * the embedded area, wheras the outer area can also include any
     * surrounding chrome, window frame, title bar, and so on.
     *
     * @param flags  Combination of position, inner and outer size flags.
     * The ignore flags are telling the parent to use the
     * current values for those dimensions and ignore the
     * corresponding parameters the child sends.
     * @param x      Left hand corner of the outer area.
     * @param y      Top corner of the outer area.
     * @param cx     Width of the inner or outer area.
     * @param cy     Height of the inner or outer area.
     *
     * @return `NS_OK` if operation was performed correctly;
     * `NS_ERROR_UNEXPECTED` if window could not be
     * destroyed;
     * `NS_ERROR_INVALID_ARG` for bad flag combination
     * or illegal dimensions.
     *
     * @see getDimensions
     * @see DIM_FLAGS_POSITION
     * @see DIM_FLAGS_SIZE_OUTER
     * @see DIM_FLAGS_SIZE_INNER
     */
    setDimensions(flags: unsigned_long, x: long, y: long, cx: long, cy: long): void;
    /**
     * Gets the dimensions of the window. The caller may pass
     * `nullptr` for any value it is uninterested in receiving.
     *
     * @param flags  Combination of position, inner and outer size flag .
     * @param x      Left hand corner of the outer area; or `nullptr`.
     * @param y      Top corner of the outer area; or `nullptr`.
     * @param cx     Width of the inner or outer area; or `nullptr`.
     * @param cy     Height of the inner or outer area; or `nullptr`.
     *
     * @see setDimensions
     * @see DIM_FLAGS_POSITION
     * @see DIM_FLAGS_SIZE_OUTER
     * @see DIM_FLAGS_SIZE_INNER
     */
    getDimensions(flags: unsigned_long, x: long, y: long, cx: long, cy: long): void;
    /**
     * Visibility of the window.
     */
    visibility: boolean;
    /**
     * Title of the window.
     */
    title: AString;
    /**
     * Native window for the site's window. The implementor should copy the
     * native window object into the address supplied by the caller. The
     * type of the native window that the address refers to is  platform
     * and OS specific as follows:
     *
     *
     * - On Win32 it is an `HWND`.
     * - On MacOS this is a `WindowPtr`.
     * - On GTK this is a `GtkWidget*`.
     */
    readonly siteWindow: voidPtr;
    /**
     * Blur the window. This should unfocus the window and send an onblur event.
     */
    blur(): void;
}

/**
 *
 */
declare interface nsISupportsType {
}

/**
 * A channel interface which allows special handling of encoded content
 */
declare interface nsIEncodedChannelType extends nsISupportsType {
    /**
     * This attribute holds the MIME types corresponding to the content
     * encodings on the channel.  The enumerator returns nsISupportsCString
     * objects.  The first one corresponds to the outermost encoding on the
     * channel and then we work our way inward.  "identity" is skipped and not
     * represented on the list.  Unknown encodings make the enumeration stop.
     * If you want the actual Content-Encoding value, use
     * getResponseHeader("Content-Encoding").
     *
     * When there is no Content-Encoding header, this property is null.
     *
     * Modifying the Content-Encoding header on the channel will cause
     * this enumerator to have undefined behavior.  Don't do it.
     *
     * Also note that contentEncodings only exist during or after OnStartRequest.
     * Calling contentEncodings before OnStartRequest is an error.
     */
    readonly contentEncodings: nsIUTF8StringEnumerator;
    /**
     * This attribute controls whether or not content conversion should be
     * done per the Content-Encoding response header.  applyConversion can only
     * be set before or during OnStartRequest.  Calling this during
     * OnDataAvailable is an error.
     *
     * TRUE by default.
     */
    applyConversion: boolean;
    /**
     * This function will start converters if they are available.
     * aNewNextListener will be nullptr if no converter is available.
     */
    doApplyContentConversions(aNextListener: nsIStreamListenerType, aNewNextListener: nsIStreamListenerType, aCtxt: nsISupportsType): void;
}

/**
 *
 */
declare interface nsIEnterprisePoliciesType extends nsISupportsType {
    /**
     *
     */
    readonly status: short;
    /**
     *
     */
    isAllowed(feature: ACString): bool;
    /**
     * Get the active policies that have been successfully parsed.
     *
     * @returns A JS object that contains the policies names and
     * their corresponding parameters.
     */
    getActivePolicies(): jsval;
    /**
     * Get the contents of the support menu (if applicable)
     *
     * @returns A JS object that contains the url and label or null.
     */
    getSupportMenu(): jsval;
    /**
     * Get the policy for a given extensionID (if available)
     *
     * @returns A JS object that contains the storage or null if unavailable.
     */
    getExtensionPolicy(extensionID: ACString): jsval;
    /**
     * Retrieves the ExtensionSettings policy for the given extensionID.
     *
     * If there is no policy for the extension, it returns the global policy.
     *
     * If there is no global policy, it returns null.
     *
     * @returns A JS object that settings or null if unavailable.
     */
    getExtensionSettings(extensionID: ACString): jsval;
    /**
     * Uses the allowlist, blocklist and settings to determine if an addon
     * may be installed.
     *
     * @returns A boolean - true of the addon may be installed.
     */
    mayInstallAddon(addon: jsval): bool;
    /**
     * Uses install_sources to determine if an addon can be installed
     * from the given URI.
     *
     * @returns A boolean - true of the addon may be installed.
     */
    allowedInstallSource(uri: nsIURIType): bool;
    /**
     * Uses ExemptDomainFileTypePairsFromFileTypeDownloadWarnings to determine
     * if a given file extension is exempted from executable behavior and
     * warnings based on the URL.
     *
     * @returns A boolean - true if the extension should be exempt.
     */
    isExemptExecutableExtension(url: ACString, extension: ACString): bool;
}

/**
 * Scriptable access to the current process environment.
 */
declare interface nsIEnvironmentType extends nsISupportsType {
    /**
     * Set the value of an environment variable.
     *
     * @param aName   the variable name to set.
     * @param aValue  the value to set.
     */
    set(aName: AString, aValue: AString): void;
    /**
     * Get the value of an environment variable.
     *
     * @param aName   the variable name to retrieve.
     * @return        returns the value of the env variable. An empty string
     * will be returned when the env variable does not exist or
     * when the value itself is an empty string - please use
     * |exists()| to probe whether the env variable exists
     * or not.
     */
    get(aName: AString): AString;
    /**
     * Check the existence of an environment variable.
     * This method checks whether an environment variable is present in
     * the environment or not.
     *
     * - For Unix/Linux platforms we follow the Unix definition:
     * An environment variable exists when |getenv()| returns a non-NULL value.
     * An environment variable does not exist when |getenv()| returns NULL.
     * - For non-Unix/Linux platforms we have to fall back to a
     * "portable" definition (which is incorrect for Unix/Linux!!!!)
     * which simply checks whether the string returned by |Get()| is empty
     * or not.
     *
     * @param aName   the variable name to probe.
     * @return        if the variable has been set, the value returned is
     * PR_TRUE. If the variable was not defined in the
     * environment PR_FALSE will be returned.
     */
    exists(aName: AString): boolean;
}

/**
 * Contains an event target along with a count of event listener changes
 * affecting accessibility.
 */
declare interface nsIEventListenerChangeType extends nsISupportsType {
    /**
     *
     */
    readonly target: EventTarget;
    /**
     *
     */
    readonly countOfEventListenerChangesAffectingAccessibility: uint32_t;
}

/**
 *
 */
declare interface nsIListenerChangeListenerType extends nsISupportsType {
    /**
     *
     */
    listenersChanged(aEventListenerChanges: nsIArrayType): void;
}

/**
 * An instance of this interface describes how an event listener
 * was added to an event target.
 */
declare interface nsIEventListenerInfoType extends nsISupportsType {
    /**
     * The type of the event for which the listener was added.
     * Null if the listener is for all the events.
     */
    readonly type: AString;
    /**
     *
     */
    readonly capturing: boolean;
    /**
     *
     */
    readonly allowsUntrusted: boolean;
    /**
     *
     */
    readonly inSystemEventGroup: boolean;
    /**
     * Changing the enabled state works only with listeners implemented in
     * JS. An error is thrown for native listeners.
     */
    enabled: boolean;
    /**
     * The underlying JS object of the event listener, if this listener
     * has one.  Null otherwise.
     */
    readonly listenerObject: jsval;
    /**
     * Tries to serialize event listener to a string.
     * Returns null if serialization isn't possible
     * (for example with C++ listeners).
     */
    toSource(): AString;
}

/**
 *
 */
declare interface nsIEventListenerServiceType extends nsISupportsType {
    /**
     * Returns true if a event target has any listener for the given type.
     */
    hasListenersFor(aEventTarget: EventTarget, aType: AString): boolean;
    /**
     * Add a system-group eventlistener to a event target.
     */
    addSystemEventListener(target: EventTarget, type: AString, listener: jsval, useCapture: boolean): void;
    /**
     * Remove a system-group eventlistener from a event target.
     */
    removeSystemEventListener(target: EventTarget, type: AString, listener: jsval, useCapture: boolean): void;
    /**
     *
     */
    addListenerForAllEvents(target: EventTarget, listener: jsval, aUseCapture: boolean, aWantsUntrusted: boolean, aSystemEventGroup: boolean): void;
    /**
     *
     */
    removeListenerForAllEvents(target: EventTarget, listener: jsval, aUseCapture: boolean, aSystemEventGroup: boolean): void;
    /**
     *
     */
    addListenerChangeListener(aListener: nsIListenerChangeListenerType): void;
    /**
     *
     */
    removeListenerChangeListener(aListener: nsIListenerChangeListenerType): void;
}

/**
 *
 */
declare interface nsIEventSourceEventListenerType extends nsISupportsType {
    /**
     *
     */
    eventSourceConnectionOpened(aHttpChannelId: uint64_t): void;
    /**
     *
     */
    eventSourceConnectionClosed(aHttpChannelId: uint64_t): void;
    /**
     *
     */
    eventReceived(aHttpChannelId: uint64_t, aEventName: AString, aLastEventID: AString, aData: AString, aRetry: uint32_t, aTimeStamp: DOMHighResTimeStamp): void;
}

/**
 *
 */
declare interface nsIEventSourceEventServiceType extends nsISupportsType {
    /**
     *
     */
    addListener(aInnerWindowID: unsigned_long_long, aListener: nsIEventSourceEventListenerType): void;
    /**
     *
     */
    removeListener(aInnerWindowID: unsigned_long_long, aListener: nsIEventSourceEventListenerType): void;
    /**
     *
     */
    hasListenerFor(aInnerWindowID: unsigned_long_long): bool;
}

/**
 *
 */
declare interface nsIEventTargetType extends nsISupportsType {
    /**
     *
     */
    isOnCurrentThread(): boolean;
    /**
     * Version of Dispatch to expose to JS, which doesn't require an alreadyAddRefed<>
     * (it will be converted to that internally)
     *
     * @param event
     * The (raw) event to dispatch.
     * @param flags
     * The flags modifying event dispatch.  The flags are described in detail
     * below.
     *
     * @throws NS_ERROR_INVALID_ARG
     * Indicates that event is null.
     * @throws NS_ERROR_UNEXPECTED
     * Indicates that the thread is shutting down and has finished processing
     * events, so this event would never run and has not been dispatched.
     */
    dispatch(event: nsIRunnableType, flags: unsigned_long): void;
}

/**
 *
 */
declare interface nsIStackFrameType extends nsISupportsType {
    /**
     *
     */
    readonly filename: AString;
    /**
     *
     */
    readonly name: AString;
    /**
     *
     */
    readonly sourceId: int32_t;
    /**
     *
     */
    readonly lineNumber: int32_t;
    /**
     *
     */
    readonly columnNumber: int32_t;
    /**
     *
     */
    readonly sourceLine: AUTF8String;
    /**
     *
     */
    readonly asyncCause: AString;
    /**
     *
     */
    readonly asyncCaller: nsIStackFrame;
    /**
     *
     */
    readonly caller: nsIStackFrame;
    /**
     *
     */
    readonly formattedStack: AString;
    /**
     *
     */
    readonly nativeSavedFrame: jsval;
    /**
     *
     */
    toString(): AUTF8String;
    /**
     *
     */
    getFilename(aCx: JSContext, aFilename: AString): void;
    /**
     *
     */
    getName(aCx: JSContext, aName: AString): void;
    /**
     *
     */
    getSourceId(aCx: JSContext): int32_t;
    /**
     *
     */
    getLineNumber(aCx: JSContext): int32_t;
    /**
     *
     */
    getColumnNumber(aCx: JSContext): int32_t;
    /**
     *
     */
    getAsyncCause(aCx: JSContext, aAsyncCause: AString): void;
    /**
     *
     */
    getAsyncCaller(aCx: JSContext): StackFrameRef;
    /**
     *
     */
    getCaller(aCx: JSContext): StackFrameRef;
    /**
     *
     */
    getFormattedStack(aCx: JSContext, aFormattedStack: AString): void;
    /**
     *
     */
    toStringInfallible(aCx: JSContext, aString: AUTF8String): void;
}

/**
 *
 */
declare interface nsIExceptionType extends nsISupportsType {
}

/**
 * This interface should be implemented by any content sink that wants
 * to get output from expat and do something with it; in other words,
 * by any sink that handles some sort of XML dialect.
 */
declare interface nsIExpatSinkType extends nsISupportsType {
    /**
     * Called to handle the opening tag of an element.
     * @param aName the fully qualified tagname of the element
     * @param aAtts the array of attribute names and values.  There are
     * aAttsCount/2 names and aAttsCount/2 values, so the total number of
     * elements in the array is aAttsCount.  The names and values
     * alternate.  Thus, if we number attributes starting with 0,
     * aAtts[2*k] is the name of the k-th attribute and aAtts[2*k+1] is
     * the value of that attribute  Both explicitly specified attributes
     * and attributes that are defined to have default values in a DTD are
     * present in aAtts.
     * @param aAttsCount the number of elements in aAtts.
     * @param aLineNumber the line number of the start tag in the data stream.
     * @param aColumnNumber the column number of the start tag in the data stream.
     */
    HandleStartElement(aName: wstring, aAtts: wstring[], aAttsCount: unsigned_long, aLineNumber: unsigned_long, aColumnNumber: unsigned_long): void;
    /**
     * Called to handle the closing tag of an element.
     * @param aName the fully qualified tagname of the element
     */
    HandleEndElement(aName: wstring): void;
    /**
     * Called to handle a comment
     * @param aCommentText the text of the comment (not including the
     * "<!--" and "-->")
     */
    HandleComment(aCommentText: wstring): void;
    /**
     * Called to handle a CDATA section
     * @param aData the text in the CDATA section.  This is null-terminated.
     * @param aLength the length of the aData string
     */
    HandleCDataSection(aData: wstring, aLength: unsigned_long): void;
    /**
     * Called to handle the doctype declaration
     */
    HandleDoctypeDecl(aSubset: AString, aName: AString, aSystemId: AString, aPublicId: AString, aCatalogData: nsISupportsType): void;
    /**
     * Called to handle character data.  Note that this does NOT get
     * called for the contents of CDATA sections.
     * @param aData the data to handle.  aData is NOT NULL-TERMINATED.
     * @param aLength the length of the aData string
     */
    HandleCharacterData(aData: wstring, aLength: unsigned_long): void;
    /**
     * Called to handle a processing instruction
     * @param aTarget the PI target (e.g. xml-stylesheet)
     * @param aData all the rest of the data in the PI
     */
    HandleProcessingInstruction(aTarget: wstring, aData: wstring): void;
    /**
     * Handle the XML Declaration.
     *
     * @param aVersion    The version string, can be null if not specified.
     * @param aEncoding   The encoding string, can be null if not specified.
     * @param aStandalone -1, 0, or 1 indicating respectively that there was no
     * standalone parameter in the declaration, that it was
     * given as no, or that it was given as yes.
     */
    HandleXMLDeclaration(aVersion: wstring, aEncoding: wstring, aStandalone: long): void;
    /**
     * Ask the content sink if the expat driver should log an error to the console.
     *
     * @param aErrorText  Error message to pass to content sink.
     * @param aSourceText Source text of the document we're parsing.
     * @param aError      Script error object with line number & column number
     *
     * @retval True if the expat driver should report the error.
     */
    ReportError(aErrorText: wstring, aSourceText: wstring, aError: nsIScriptErrorType): boolean;
}

/**
 * The external helper app service is used for finding and launching
 * platform specific external applications for a given mime content type.
 */
declare interface nsIExternalHelperAppServiceType extends nsISupportsType {
    /**
     * Binds an external helper application to a stream listener. The caller
     * should pump data into the returned stream listener. When the OnStopRequest
     * is issued, the stream listener implementation will launch the helper app
     * with this data.
     * @param aMimeContentType The content type of the incoming data
     * @param aChannel The channel corresponding to the incoming data
     * @param aContentContext Used in processing content document refresh
     * headers after target content is downloaded.
     * @param aForceSave True to always save this content to disk, regardless of
     * nsIMIMEInfo and other such influences.
     * @param aWindowContext Used in parenting helper app dialogs, usually
     * points to the parent browser window. This parameter may be null,
     * in which case dialogs will be parented to aContentContext.
     * @return A nsIStreamListener which the caller should pump the data into.
     */
    doContent(aMimeContentType: ACString, aChannel: nsIChannelType, aContentContext: nsIInterfaceRequestorType, aForceSave: boolean, aWindowContext: nsIInterfaceRequestorType): nsIStreamListener;
    /**
     * Binds an external helper application to a stream listener. The caller
     * should pump data into the returned stream listener. When the OnStopRequest
     * is issued, the stream listener implementation will launch the helper app
     * with this data.
     * Replaces doContent for native code, and uses BrowsingContext.
     *
     * @param aMimeContentType The content type of the incoming data
     * @param aChannel The channel corresponding to the incoming data
     * @param aContentContext The BrowsingContext that the channel was initiated
     * by. Used for closing the window if we opened one specifically for this download.
     * @param aForceSave True to always save this content to disk, regardless of
     * nsIMIMEInfo and other such influences.
     * @param aWindowContext Used in parenting helper app dialogs, usually
     * points to the parent browser window. This parameter may be null,
     * in which case dialogs will be parented to aContentContext.
     * @return A nsIStreamListener which the caller should pump the data into.
     */
    createListener(aMimeContentType: ACString, aChannel: nsIChannelType, aContentContext: BrowsingContext, aForceSave: boolean, aWindowContext: nsIInterfaceRequestorType): nsIStreamListener;
    /**
     * Returns true if data from a URL with this extension combination
     * is to be decoded from aEncodingType prior to saving or passing
     * off to helper apps, false otherwise.
     */
    applyDecodingForExtension(aExtension: AUTF8String, aEncodingType: ACString): boolean;
}

/**
 * This is a private interface shared between external app handlers and the platform specific
 * external helper app service
 */
declare interface nsPIExternalAppLauncherType extends nsISupportsType {
    /**
     * mscott --> eventually I should move this into a new service so other
     * consumers can add temporary files they want deleted on exit.
     * @param aTemporaryFile A temporary file we should delete on exit.
     */
    deleteTemporaryFileOnExit(aTemporaryFile: nsIFileType): void;
    /**
     * Delete a temporary file created inside private browsing mode when
     * the private browsing mode has ended.
     */
    deleteTemporaryPrivateFileWhenPossible(aTemporaryFile: nsIFileType): void;
}

/**
 * A helper app launcher is a small object created to handle the launching
 * of an external application.
 *
 * Note that cancelling the load via the nsICancelable interface will release
 * the reference to the launcher dialog.
 */
declare interface nsIHelperAppLauncherType extends nsICancelableType {
    /**
     * The mime info object associated with the content type this helper app
     * launcher is currently attempting to load
     */
    readonly MIMEInfo: nsIMIMEInfo;
    /**
     * The source uri
     */
    readonly source: nsIURI;
    /**
     * The suggested name for this file
     */
    readonly suggestedFileName: AString;
    /**
     * Saves the final destination of the file.
     * NOTE: This will release the reference to the nsIHelperAppLauncherDialog.
     */
    promptForSaveDestination(): void;
    /**
     * Tell the launcher that we will want to open the file.
     * NOTE: This will release the reference to the nsIHelperAppLauncherDialog.
     * @param aHandleInternally TRUE if we should handle opening this internally.
     * @param aNewFileLocation a preferred location choosen through the File Picker.
     * Null if going through the fast save without File Picker.
     */
    setDownloadToLaunch(aHandleInternally: boolean, aFile: nsIFileType): void;
    /**
     * Use the MIMEInfo associated with us to open a file that is already local.
     * Will no-op if `source` is not a local file.
     */
    launchLocalFile(): void;
    /**
     * Callback invoked by nsIHelperAppLauncherDialog::promptForSaveToFileAsync
     * after the user has chosen a file through the File Picker (or dismissed it).
     * @param aFile The file that was chosen by the user (or null if dialog was dismissed).
     * @param aDialogWasShown Optional boolean - false by default. Pass true if a
     * dialog was opened in the process of reaching this file result. If true, we
     * suppress the opening of the downloads panel to avoid redundancy.
     */
    saveDestinationAvailable(aFile: nsIFileType, aDialogWasShown: boolean): void;
    /**
     * The following methods are used by the progress dialog to get or set
     * information on the current helper app launcher download.
     * This reference will be released when the download is finished (after the
     * listener receives the STATE_STOP notification).
     */
    setWebProgressListener(aWebProgressListener: nsIWebProgressListener2Type): void;
    /**
     * The file we are saving to
     */
    readonly targetFile: nsIFile;
    /**
     * The executable-ness of the target file
     */
    readonly targetFileIsExecutable: boolean;
    /**
     * Time when the download started
     */
    readonly timeDownloadStarted: PRTime;
    /**
     * The download content length, or -1 if the length is not available.
     */
    readonly contentLength: int64_t;
    /**
     * The browsingContext ID of the launcher's source
     */
    readonly browsingContextId: uint64_t;
}

/**
 *
 */
declare interface nsIExternalProtocolHandlerType extends nsIProtocolHandlerType {
    /**
     * This method checks if the external handler exists for a given scheme.
     *
     * @param scheme external scheme.
     * @return TRUE if the external handler exists for the input scheme, FALSE otherwise.
     */
    externalAppExistsForScheme(scheme: ACString): boolean;
}

/**
 * The external protocol service is used for finding and launching
 * web handlers (a la registerProtocolHandler in the HTML5 draft) or
 * platform-specific applications for handling particular protocols.
 *
 * You can ask the external protocol service if it has an external
 * handler for a given protocol scheme. And you can ask it to load
 * the url using the default handler.
 */
declare interface nsIExternalProtocolServiceType extends nsISupportsType {
    /**
     * Check whether a handler for a specific protocol exists.  Specifically,
     * this looks to see whether there are any known possible application handlers
     * in either the nsIHandlerService datastore or registered with the OS.
     *
     * @param aProtocolScheme The scheme from a url: http, ftp, mailto, etc.
     *
     * @return true if we have a handler and false otherwise.
     *
     * XXX shouldn't aProtocolScheme be an ACString like nsIURI::scheme?
     */
    externalProtocolHandlerExists(aProtocolScheme: string): boolean;
    /**
     * Check whether a handler for a specific protocol is "exposed" as a visible
     * feature of the current application.
     *
     * An exposed protocol handler is one that can be used in all contexts.  A
     * non-exposed protocol handler is one that can only be used internally by the
     * application.  For example, a non-exposed protocol would not be loaded by the
     * application in response to a link click or a X-remote openURL command.
     * Instead, it would be deferred to the system's external protocol handler.
     * XXX shouldn't aProtocolScheme be an ACString like nsIURI::scheme?
     */
    isExposedProtocol(aProtocolScheme: string): boolean;
    /**
     * Retrieve the handler for the given protocol.  If neither the application
     * nor the OS knows about a handler for the protocol, the object this method
     * returns will represent a default handler for unknown content.
     *
     * @param aProtocolScheme the scheme from a URL: http, ftp, mailto, etc.
     *
     * Note: aProtocolScheme should not include a trailing colon, which is part
     * of the URI syntax, not part of the scheme itself (i.e. pass "mailto" not
     * "mailto:").
     *
     * @return the handler, if any; otherwise a default handler
     */
    getProtocolHandlerInfo(aProtocolScheme: ACString): nsIHandlerInfo;
    /**
     * Given a scheme, looks up the protocol info from the OS.  This should be
     * overridden by each OS's implementation.
     *
     * @param aScheme The protocol scheme we are looking for.
     * @param aFound  Was an OS default handler for this scheme found?
     * @return An nsIHanderInfo for the protocol.
     */
    getProtocolHandlerInfoFromOS(aProtocolScheme: ACString, aFound: boolean): nsIHandlerInfo;
    /**
     * Set some sane defaults for a protocol handler object.
     *
     * @param aHandlerInfo      nsIHandlerInfo object, as returned by
     * getProtocolHandlerInfoFromOS
     * @param aOSHandlerExists  was the object above created for an extant
     * OS default handler?  This is generally the
     * value of the aFound out param from
     * getProtocolHandlerInfoFromOS.
     */
    setProtocolHandlerDefaults(aHandlerInfo: nsIHandlerInfoType, aOSHandlerExists: boolean): void;
    /**
     * Used to load a URI via an external application. Might prompt the user for
     * permission to load the external application.
     *
     * @param aURI
     * The URI to load
     *
     * @param aTriggeringPrincipal
     * The principal triggering this load.
     *
     * @param aRedirectPrincipal
     * The last post-redirect principal triggering this load.
     * Used for display and permission purposes. If null, we'll
     * use the triggering principal.
     *
     * @param aBrowsingContext
     * The context to parent the dialog against, and, if a web handler
     * is chosen, it is loaded in this window as well.  This parameter
     * may be ultimately passed nsIURILoader.openURI in the case of a
     * web handler, and aWindowContext is null or not present, web
     * handlers will fail.  We need to do better than that; bug 394483
     * filed in order to track.
     *
     * @param aWasTriggeredExternally
     * If true, indicates the load was initiated by an external app.
     *
     * @param aHasValidUserGestureActivation
     * Whether the document that triggered the load had user activation.
     * Used for sandbox checks.
     *
     * @note  Embedders that do not expose the http protocol should not currently
     * use web-based protocol handlers, as handoff won't work correctly
     * (bug 394479).
     */
    loadURI(aURI: nsIURIType, aTriggeringPrincipal: nsIPrincipalType, aRedirectPrincipal: nsIPrincipalType, aBrowsingContext: BrowsingContext, aWasTriggeredExternally: bool, aHasValidUserGestureActivation: bool): void;
    /**
     * Gets a human-readable description for the application responsible for
     * handling a specific protocol.
     *
     * @param aScheme The scheme to look up. For example, "mms".
     *
     * @throw NS_ERROR_NOT_IMPLEMENTED
     * If getting descriptions for protocol helpers is not supported
     * @throw NS_ERROR_NOT_AVAILABLE
     * If no protocol helper exists for this scheme, or if it is not
     * possible to get a description for it.
     */
    getApplicationDescription(aScheme: AUTF8String): AString;
    /**
     * Check if this app is registered as the OS default for a given scheme.
     *
     * @param aScheme The scheme to look up. For example, "mms".
     */
    isCurrentAppOSDefaultForProtocol(aScheme: AUTF8String): bool;
}

/**
 *
 */
declare interface nsIFOGType extends nsISupportsType {
    /**
     * Initialize FOG.
     *
     * Call it eventually. Metric data recorded beforehand will be buffered.
     *
     * @param aDataPathOverride - The path of a custom Glean data path to use
     * instead of the profile dir.
     * @param aAppIdOverride - The application_id to use instead of
     * "firefox.desktop".
     */
    initializeFOG(aDataPathOverride: AUTF8String, aAppIdOverride: AUTF8String): void;
    /**
     * Register custom pings.
     *
     * Ensure all custom pings are registered with Glean.
     */
    registerCustomPings(): void;
    /**
     * Enable or Disable the logging of pings in the Glean SDK.
     * See https://firefox-source-docs.mozilla.org/toolkit/components/glean/testing.html
     * for details.
     *
     * @param aEnableLogPings - true to enable logging, false to disable.
     */
    setLogPings(aEnableLogPings: boolean): void;
    /**
     * Set the tag to be applied to pings assembled from now on.
     * See https://firefox-source-docs.mozilla.org/toolkit/components/glean/testing.html
     * for details.
     *
     * @param aDebugTag - The string tag to apply.
     * If it cannot be applied (e.g it contains characters that are
     * forbidden in HTTP headers) the old value will remain.
     */
    setTagPings(aDebugTag: ACString): void;
    /**
     * Send the named ping.
     * See https://firefox-source-docs.mozilla.org/toolkit/components/glean/testing.html
     * for details.
     *
     * @param aPingName - The name of the ping to send. If no ping of that name
     * exists, or the ping is known but cannot be assembled
     * (e.g if it is empty), no ping will be sent.
     */
    sendPing(aPingName: ACString): void;
    /**
     * Indicate that an experiment is running.
     * Glean will add an experiment annotation which is sent with pings.
     * This information is not persisted between runs.
     *
     * See `glean_core::Glean::set_experiment_active`.
     *
     * Logs on error, but does not throw.
     *
     * @param aExperimentId - The id/slug of the experiment.
     * @param aBranch - The name of the active branch of the experiment.
     * @param aExtra - Optional string -> string dictionary of extra information.
     */
    setExperimentActive(aExperimentId: ACString, aBranch: ACString, aExtra: jsval): void;
    /**
     * Indicate that an experiment is no longer running.
     *
     * See `glean_core::Glean::set_experiment_inactive`.
     *
     * Logs on error, but does not throw.
     *
     * @param aExperimentId - The id/slug of the experiment from setExperimentActive.
     */
    setExperimentInactive(aExperimentId: ACString): void;
    /**
     * **Test-only API**
     *
     * If the identified experiment was set active and hasn't been set inactive,
     * this will give you the active branch and extra information.
     *
     * @param aExperimentId - The id/slug of the experiment from setExperimentActive.
     *
     * @return an object of the form
     * {branch: "branch-name", extra: {extra_key1: extra_value1, ...}}
     * if there is an active experiment. Undefined, otherwise.
     */
    testGetExperimentData(aExperimentId: ACString): jsval;
    /**
     * Set remote-configuration for metrics' disabled property.
     *
     * See [`glean_core::Glean::set_metrics_enabled_config`]
     *
     * Logs on error, but does not throw.
     *
     * @param aJsonConfig - The stringified JSON object in the form
     * {metric_base_identifier: boolean,}
     * which may contain multiple metric object entries.
     */
    setMetricsFeatureConfig(aJsonConfig: ACString): void;
    /**
     * ** Test-only Method **
     *
     * Flush all data from all child processes.
     *
     * @returns A promise that resolves when the data's been stored.
     */
    testFlushAllChildren(): Promise;
    /**
     * ** Test-only Method **
     *
     * Reset FOG and the Glean SDK, clearing storage.
     */
    testResetFOG(aDataPathOverride: AUTF8String, aAppIdOverride: AUTF8String): void;
    /**
     * ** Test-only Method **
     *
     * Trigger test metric instrumentation on the GPU, RDD or Socket process.
     *
     * @param aProcessType - A PROCESS_TYPE_* value from the constants defined
     * in the nsIXULRuntime interface.
     *
     * @returns A promise that resolves when the test data has been added.
     * The promise will be rejected if the process type is not supported
     * or if sending the IPC to the child process fails.
     */
    testTriggerMetrics(aProcessType: unsigned_long): Promise;
    /**
     * ** Test-only Method **
     *
     * Register a metric.
     *
     * This function is deliberately not too friendly to use. You probably aren't
     * supposed to use it unless you're testing metric registration itself.
     *
     * @param aType - The metric's type.
     * @param aCategory - The metric's category.
     * @param aName - The metric's name.
     * @param aPings - The pings to send it in.
     * @param aLifetime - The metric's lifetime.
     * @param aDisabled - Whether the metric, though existing, isn't enabled.
     * @param aExtraArgs - Optional JSON string of extra args.
     */
    testRegisterRuntimeMetric(aType: ACString, aCategory: ACString, aName: ACString, aPings: invalid, aLifetime: ACString, aDisabled: boolean, aExtraArgs: ACString): uint32_t;
    /**
     * ** Test-only Method **
     *
     * Register a ping.
     *
     * This function is deliberately not too friendly to use. You probably aren't
     * supposed to use it unless you're testing ping registration itself.
     *
     * @param aName - The ping's name.
     * @param aIncludeClientId - Whether the ping should include the client_id.
     * @param aSendIfEmpty - Whether the ping should send even if empty.
     * @param aReasonCodes - The list of valid reasons for ping submission.
     */
    testRegisterRuntimePing(aName: ACString, aIncludeClientId: boolean, aSendIfEmpty: boolean, aReasonCodes: invalid): uint32_t;
}

/**
 * A class factory allows the creation of nsISupports derived
 * components without specifying a concrete base class.
 */
declare interface nsIFactoryType extends nsISupportsType {
    /**
     * Creates an instance of a component.
     *
     * @param iid    The IID of the interface being requested in
     * the component which is being currently created.
     * @param result [out] Pointer to the newly created instance, if successful.
     * @throws NS_NOINTERFACE - Interface not accessible.
     * NS_ERROR* - Method failure.
     */
    createInstance(iid: nsIIDRefType, result: nsQIResult): void;
}

/**
 *
 */
declare interface nsIFaviconServiceType extends nsISupportsType {
    /**
     * For a given icon URI, this will return a URI that will result in the image.
     * In most cases, this is an annotation URI.  For chrome URIs, this will do
     * nothing but returning the input URI.
     *
     * No validity checking is done. If you pass an icon URI that we've never
     * seen, you'll get back a URI that references an invalid icon. The moz-anno
     * protocol handler's special case for "favicon" annotations will resolve
     * invalid icons to the default icon, although without caching.
     * For invalid chrome URIs, you'll get a broken image.
     *
     * @param aFaviconURI
     * The URI of an icon in the favicon service.
     * @return A URI that will give you the icon image.  This is NOT the URI of
     * the icon as set on the page, but a URI that will give you the
     * data out of the favicon service.  For a normal page with a
     * favicon we've stored, this will be an annotation URI which will
     * then cause the corresponding favicon data to be loaded async from
     * this service.  For pages where we don't have a favicon, this will
     * be a chrome URI of the default icon. For chrome URIs, the
     * output will be the same as the input.
     */
    getFaviconLinkForIcon(aFaviconURI: nsIURIType): nsIURI;
    /**
     * Expire all known favicons from the database.
     *
     * @note This is an async method.
     * On successful completion a "places-favicons-expired" notification is
     * dispatched through observer's service.
     */
    expireAllFavicons(): void;
    /**
     * Sets the default size returned by preferredSizeFromURI when the uri doesn't
     * specify a size ref. If this is not invoked first, or 0 is passed to it,
     * preferredSizeFromURI() will return UINT16_MAX, that matches the biggest
     * icon available.
     */
    setDefaultIconURIPreferredSize(aDefaultSize: unsigned_short): void;
    /**
     * Tries to extract the preferred size from an icon uri ref fragment.
     *
     * @param aURI
     * The URI to parse.
     * @return The preferred size, or a default size set through
     * setDefaultIconURIPreferredSize, or UINT16_MAX if neither are set.
     */
    preferredSizeFromURI(aURI: nsIURIType): unsigned_short;
    /**
     * The default favicon URI
     */
    readonly defaultFavicon: nsIURI;
    /**
     * The default favicon mimeType
     */
    readonly defaultFaviconMimeType: AUTF8String;
    /**
     * Declares that a given page uses a favicon with the given URI and
     * attempts to fetch and save the icon data by loading the favicon URI
     * through an async network request.
     *
     * If the icon data already exists, we won't try to reload the icon unless
     * aForceReload is true.  Similarly, if the icon is in the failed favicon
     * cache we won't do anything unless aForceReload is true, in which case
     * we'll try to reload the favicon.
     *
     * This function will only save favicons for pages that are already stored in
     * the database, like visited pages or bookmarks.  For any other URIs, it
     * will succeed but do nothing.  This function will also ignore the error
     * page favicon URI (see FAVICON_ERRORPAGE_URL below).
     *
     * Icons that fail to load will automatically be added to the failed favicon
     * cache, and this function will not save favicons for non-bookmarked URIs
     * when history is disabled.
     *
     * @note This function is identical to
     * nsIFaviconService::setAndLoadFaviconForPage.
     *
     * @param aPageURI
     * URI of the page whose favicon is being set.
     * @param aFaviconURI
     * URI of the favicon to associate with the page.
     * @param aForceReload
     * If aForceReload is false, we try to reload the favicon only if we
     * don't have it or it has expired from the cache.  Setting
     * aForceReload to true causes us to reload the favicon even if we
     * have a usable copy.
     * @param aFaviconLoadType
     * Set to FAVICON_LOAD_PRIVATE if the favicon is loaded from a private
     * browsing window.  Set to FAVICON_LOAD_NON_PRIVATE otherwise.
     * @param [optional] aCallback
     * Once we're done setting and/or fetching the favicon, we invoke this
     * callback.
     * @param [optional] aLoadingPrincipal
     * Principal of the page whose favicon is being set. If this argument
     * is omitted, the loadingPrincipal defaults to the nullPrincipal.
     * @param [optional] aRequestContextID
     * used to inform Necko of how to link the
     * favicon request with other requests in the same tab.
     *
     * @see nsIFaviconDataCallback in nsIFaviconService.idl.
     */
    setAndFetchFaviconForPage(aPageURI: nsIURIType, aFaviconURI: nsIURIType, aForceReload: boolean, aFaviconLoadType: unsigned_long, aCallback: nsIFaviconDataCallbackType, aLoadingPrincipal: nsIPrincipalType, aRequestContextID: unsigned_long_long): mozIPlacesPendingOperation;
    /**
     * Sets the data for a given favicon URI either by replacing existing data in
     * the database or taking the place of otherwise fetched icon data when
     * calling setAndFetchFaviconForPage later.
     *
     * Favicon data for favicon URIs that are not associated with a page URI via
     * setAndFetchFaviconForPage will be stored in memory, but may be expired at
     * any time, so you should make an effort to associate favicon URIs with page
     * URIs as soon as possible.
     *
     * It's better to not use this function for chrome: icon URIs since you can
     * reference the chrome image yourself. getFaviconLinkForIcon/Page will ignore
     * any associated data if the favicon URI is "chrome:" and just return the
     * same chrome URI.
     *
     * This function does NOT send out notifications that the data has changed.
     * Pages using this favicons that are visible in history or bookmarks views
     * will keep the old icon until they have been refreshed by other means.
     *
     * This function tries to optimize the favicon size, if it is bigger
     * than a defined limit we will try to convert it to a 16x16 png image.
     * If the conversion fails and favicon is still bigger than our max accepted
     * size it won't be saved.
     *
     * @param aFaviconURI
     * URI of the favicon whose data is being set.
     * @param aData
     * Binary contents of the favicon to save
     * @param aMimeType
     * MIME type of the data to store.  This is important so that we know
     * what to report when the favicon is used.  You should always set this
     * param unless you are clearing an icon.
     * @param [optional] aExpiration
     * Time in microseconds since the epoch when this favicon expires.
     * Until this time, we won't try to load it again.
     * @throws NS_ERROR_FAILURE
     * Thrown if the favicon is overbloated and won't be saved to the db.
     */
    replaceFaviconData(aFaviconURI: nsIURIType, aData: invalid, aMimeType: AUTF8String, aExpiration: PRTime): void;
    /**
     * Same as replaceFaviconData but the data is provided by a string
     * containing a data URL.
     *
     * @see replaceFaviconData
     *
     * @param aFaviconURI
     * URI of the favicon whose data is being set.
     * @param aDataURL
     * string containing a data URL that represents the contents of
     * the favicon to save
     * @param [optional] aExpiration
     * Time in microseconds since the epoch when this favicon expires.
     * Until this time, we won't try to load it again.
     * @param [optional] aLoadingPrincipal
     * Principal of the page whose favicon is being set. If this argument
     * is omitted, the loadingPrincipal defaults to the nullPrincipal.
     * @throws NS_ERROR_FAILURE
     * Thrown if the favicon is overbloated and won't be saved to the db.
     */
    replaceFaviconDataFromDataURL(aFaviconURI: nsIURIType, aDataURL: AString, aExpiration: PRTime, aLoadingPrincipal: nsIPrincipalType): void;
    /**
     * Retrieves the favicon URI associated to the given page, if any.
     *
     * @param aPageURI
     * URI of the page whose favicon URI we're looking up.
     * @param aCallback
     * This callback is always invoked to notify the result of the lookup.
     * The aURI parameter will be the favicon URI, or null when no favicon
     * is associated with the page or an error occurred while fetching it.
     * aDataLen will be always 0, aData will be an empty array, and
     * aMimeType will be an empty string, regardless of whether a favicon
     * was found.
     * @param [optional] aPreferredWidth
     * The preferred icon width, skip or pass 0 for the default value,
     * set through setDefaultIconURIPreferredSize.
     *
     * @note If a favicon specific to this page cannot be found, this will try to
     * fallback to the /favicon.ico for the root domain.
     *
     * @see nsIFaviconDataCallback in nsIFaviconService.idl.
     */
    getFaviconURLForPage(aPageURI: nsIURIType, aCallback: nsIFaviconDataCallbackType, aPreferredWidth: unsigned_short): void;
    /**
     * Retrieves the favicon URI and data associated to the given page, if any.
     * If the page icon is not available, it will try to return the root domain
     * icon data, when it's known.
     *
     * @param aPageURI
     * URI of the page whose favicon URI and data we're looking up.
     * @param aCallback
     * This callback is always invoked to notify the result of the lookup.  The aURI
     * parameter will be the favicon URI, or null when no favicon is
     * associated with the page or an error occurred while fetching it.  If
     * aURI is not null, the other parameters may contain the favicon data.
     * However, if no favicon data is currently associated with the favicon
     * URI, aDataLen will be 0, aData will be an empty array, and aMimeType
     * will be an empty string.
     * @param [optional] aPreferredWidth
     * The preferred icon width, skip or pass 0 for the default value,
     * set through setDefaultIconURIPreferredSize.
     * @note If a favicon specific to this page cannot be found, this will try to
     * fallback to the /favicon.ico for the root domain.
     *
     * @see nsIFaviconDataCallback in nsIFaviconService.idl.
     */
    getFaviconDataForPage(aPageURI: nsIURIType, aCallback: nsIFaviconDataCallbackType, aPreferredWidth: unsigned_short): void;
    /**
     * Copies cached favicons from a page to another one.
     *
     * @param aFromPageURI
     * URI of the originating page.
     * @param aToPageURI
     * URI of the destination page.
     * @param aFaviconLoadType
     * Set to FAVICON_LOAD_PRIVATE if the copy is started from a private
     * browsing window.  Set to FAVICON_LOAD_NON_PRIVATE otherwise.
     * @param [optional] aCallback
     * Once we're done copying the favicon, we invoke this callback.
     * If a copy has been done, the callback will report one of the
     * favicons uri as aFaviconURI, otherwise all the params will be null.
     */
    copyFavicons(aFromPageURI: nsIURIType, aToPageURI: nsIURIType, aFaviconLoadType: unsigned_long, aCallback: nsIFaviconDataCallbackType): void;
}

/**
 *
 */
declare interface nsIFaviconDataCallbackType extends nsISupportsType {
    /**
     * Called when the required favicon's information is available.
     *
     * It's up to the invoking method to state if the callback is always invoked,
     * or called on success only.  Check the method documentation to ensure that.
     *
     * The caller will receive the most information we can gather on the icon,
     * but it's not guaranteed that all of them will be set.  For some method
     * we could not know the favicon's data (it could just be too expensive to
     * get it, or the method does not require we actually have any data).
     * It's up to the caller to check aDataLen > 0 before using any data-related
     * information like mime-type or data itself.
     *
     * @param aFaviconURI
     * Receives the "favicon URI" (not the "favicon link URI") associated
     * to the requested page.  This can be null if there is no associated
     * favicon URI, or the callback is notifying a failure.
     * @param aDataLen
     * Size of the icon data in bytes.  Notice that a value of 0 does not
     * necessarily mean that we don't have an icon.
     * @param aData
     * Icon data, or an empty array if aDataLen is 0.
     * @param aMimeType
     * Mime type of the icon, or an empty string if aDataLen is 0.
     * @param aWidth
     * Width of the icon. 0 if the width is unknown or if the icon is
     * vectorial.
     *
     * @note If you want to open a network channel to access the favicon, it's
     * recommended that you call the getFaviconLinkForIcon method to convert
     * the "favicon URI" into a "favicon link URI".
     */
    onComplete(aFaviconURI: nsIURIType, aDataLen: unsigned_long, aData: octet[], aMimeType: AUTF8String, aWidth: unsigned_short): void;
}

/**
 * An nsIFile is an abstract representation of a filename. It manages
 * filename encoding issues, pathname component separators ('/' vs. '\\'
 * vs. ':') and weird stuff like differing volumes with identical names, as
 * on pre-Darwin Macintoshes.
 *
 * This file has long introduced itself to new hackers with this opening
 * paragraph:
 *
 * This is the only correct cross-platform way to specify a file.
 * Strings are not such a way. If you grew up on windows or unix, you
 * may think they are.  Welcome to reality.
 *
 * While taking the pose struck here to heart would be uncalled for, one
 * may safely conclude that writing cross-platform code is an embittering
 * experience.
 *
 * All methods with string parameters have two forms.  The preferred
 * form operates on UCS-2 encoded characters strings.  An alternate
 * form operates on characters strings encoded in the "native" charset.
 *
 * A string containing characters encoded in the native charset cannot
 * be safely passed to javascript via xpconnect.  Therefore, the "native
 * methods" are not scriptable.
 */
declare interface nsIFileType extends nsISupportsType {
    /**
     * append[Native]
     *
     * This function is used for constructing a descendent of the
     * current nsIFile.
     *
     * @param node
     * A string which is intended to be a child node of the nsIFile.
     * For security reasons, this cannot contain .. and cannot start with
     * a directory separator. For the |appendNative| method, the node must
     * be in the native filesystem charset.
     */
    append(node: AString): void;
    /**
     * Normalize the pathName (e.g. removing .. and . components on Unix).
     */
    normalize(): void;
    /**
     * create
     *
     * This function will create a new file or directory in the
     * file system. Any nodes that have not been created or
     * resolved, will be.  If the file or directory already
     * exists create() will return NS_ERROR_FILE_ALREADY_EXISTS.
     *
     * @param type
     * This specifies the type of file system object
     * to be made.  The only two types at this time
     * are file and directory which are defined above.
     * If the type is unrecongnized, we will return an
     * error (NS_ERROR_FILE_UNKNOWN_TYPE).
     *
     * @param permissions
     * The unix style octal permissions.  This may
     * be ignored on systems that do not need to do
     * permissions.
     *
     * @param skipAncestors
     * Optional; if set to true, we'll skip creating
     * ancestor directories (and return an error instead).
     */
    create(type: unsigned_long, permissions: unsigned_long, skipAncestors: bool): void;
    /**
     * Accessor to the leaf name of the file itself.
     * For the |nativeLeafName| method, the nativeLeafName must
     * be in the native filesystem charset.
     */
    leafName: AString;
    /**
     *
     */
    nativeLeafName: ACString;
    /**
     * The leaf name as displayed in OS-provided file pickers and similar UI.
     * On Windows and macOS, 'real' leaf names of some directories can be
     * in English, but the OS will show a different, translated name to users
     * using a different locale. So folders like "Downloads", "Desktop" and
     * "Documents" might not normally appear to users with that (English) name,
     * but with an OS-localized translation. This API will return such a
     * translation if it exists, or the leafName if it doesn't.
     * On Linux, this will always be the same as `leafName`.
     */
    readonly displayName: AString;
    /**
     * copyTo[Native]
     *
     * This will copy this file to the specified newParentDir.
     * If a newName is specified, the file will be renamed.
     * If 'this' is not created we will return an error
     * (NS_ERROR_FILE_NOT_FOUND).
     *
     * copyTo may fail if the file already exists in the destination
     * directory.
     *
     * copyTo will NOT resolve aliases/shortcuts during the copy.
     *
     * @param newParentDir
     * This param is the destination directory. If the
     * newParentDir is null, copyTo() will use the parent
     * directory of this file. If the newParentDir is not
     * empty and is not a directory, an error will be
     * returned (NS_ERROR_FILE_DESTINATION_NOT_DIR). For the
     * |CopyToNative| method, the newName must be in the
     * native filesystem charset.
     *
     * @param newName
     * This param allows you to specify a new name for
     * the file to be copied. This param may be empty, in
     * which case the current leaf name will be used.
     */
    copyTo(newParentDir: nsIFileType, newName: AString): void;
    /**
     * copyToFollowingLinks[Native]
     *
     * This function is identical to copyTo with the exception that,
     * as the name implies, it follows symbolic links.  The XP_UNIX
     * implementation always follow symbolic links when copying.  For
     * the |CopyToFollowingLinks| method, the newName must be in the
     * native filesystem charset.
     */
    copyToFollowingLinks(newParentDir: nsIFileType, newName: AString): void;
    /**
     * moveTo[Native]
     *
     * A method to move this file or directory to newParentDir.
     * If a newName is specified, the file or directory will be renamed.
     * If 'this' is not created we will return an error
     * (NS_ERROR_FILE_NOT_FOUND).
     * If 'this' is a file, and the destination file already exists, moveTo
     * will replace the old file.
     * This object is updated to refer to the new file.
     *
     * moveTo will NOT resolve aliases/shortcuts during the copy.
     * moveTo will do the right thing and allow copies across volumes.
     * moveTo will return an error (NS_ERROR_FILE_DIR_NOT_EMPTY) if 'this' is
     * a directory and the destination directory is not empty.
     * moveTo will return an error (NS_ERROR_FILE_ACCESS_DENIED) if 'this' is
     * a directory and the destination directory is not writable.
     *
     * @param newParentDir
     * This param is the destination directory. If the
     * newParentDir is empty, moveTo() will rename the file
     * within its current directory. If the newParentDir is
     * not empty and does not name a directory, an error will
     * be returned (NS_ERROR_FILE_DESTINATION_NOT_DIR).  For
     * the |moveToNative| method, the newName must be in the
     * native filesystem charset.
     *
     * @param newName
     * This param allows you to specify a new name for
     * the file to be moved. This param may be empty, in
     * which case the current leaf name will be used.
     */
    moveTo(newParentDir: nsIFileType, newName: AString): void;
    /**
     * moveToFollowingLinks[Native]
     *
     * This function is identical to moveTo with the exception that,
     * as the name implies, it follows symbolic links.  The XP_UNIX
     * implementation always follows symbolic links when moving.  For
     * the |MoveToFollowingLinks| method, the newName ust be in the native
     * filesystem charset.
     */
    moveToFollowingLinks(newParentDir: nsIFileType, newName: AString): void;
    /**
     * renameTo
     *
     * This method is identical to moveTo except that if this file or directory
     * is moved to a a different volume, it fails and returns an error
     * (NS_ERROR_FILE_ACCESS_DENIED).
     * This object will still point to the old location after renaming.
     */
    renameTo(newParentDir: nsIFileType, newName: AString): void;
    /**
     * This will try to delete this file.  The 'recursive' flag
     * must be PR_TRUE to delete directories which are not empty.
     *
     * If passed, 'removeCount' will be incremented by the total number of files
     * and/or directories removed. Will be 1 unless the 'recursive' flag is
     * set. The parameter must be initialized beforehand.
     *
     * This will not resolve any symlinks.
     */
    remove(recursive: boolean, removeCount: uint32_t): void;
    /**
     * Attributes of nsIFile.
     */
    permissions: unsigned_long;
    /**
     *
     */
    permissionsOfLink: unsigned_long;
    /**
     * The last accesss time of the file in milliseconds from midnight, January
     * 1, 1970 GMT, if available.
     */
    lastAccessedTime: PRTime;
    /**
     *
     */
    lastAccessedTimeOfLink: PRTime;
    /**
     * File Times are to be in milliseconds from
     * midnight (00:00:00), January 1, 1970 Greenwich Mean
     * Time (GMT).
     */
    lastModifiedTime: PRTime;
    /**
     *
     */
    lastModifiedTimeOfLink: PRTime;
    /**
     * The creation time of file in milliseconds from midnight, January 1, 1970
     * GMT, if available.
     *
     * This attribute is only implemented on Windows and macOS. Accessing this
     * on another platform will this will throw NS_ERROR_NOT_IMPLEMENTED.
     */
    readonly creationTime: PRTime;
    /**
     *
     */
    readonly creationTimeOfLink: PRTime;
    /**
     * WARNING!  On the Mac, getting/setting the file size with nsIFile
     * only deals with the size of the data fork.  If you need to
     * know the size of the combined data and resource forks use the
     * GetFileSizeWithResFork() method defined on nsILocalFileMac.
     */
    fileSize: int64_t;
    /**
     *
     */
    readonly fileSizeOfLink: int64_t;
    /**
     * target & path
     *
     * Accessor to the string path.  The native version of these
     * strings are not guaranteed to be a usable path to pass to
     * NSPR or the C stdlib.  There are problems that affect
     * platforms on which a path does not fully specify a file
     * because two volumes can have the same name (e.g., mac).
     * This is solved by holding "private", native data in the
     * nsIFile implementation.  This native data is lost when
     * you convert to a string.
     *
     * DO NOT PASS TO USE WITH NSPR OR STDLIB!
     *
     * target
     * Find out what the symlink points at.  Will give error
     * (NS_ERROR_FILE_INVALID_PATH) if not a symlink.
     *
     * path
     * Find out what the nsIFile points at.
     *
     * Note that the ACString attributes are returned in the
     * native filesystem charset.
     */
    readonly target: AString;
    /**
     *
     */
    readonly nativeTarget: ACString;
    /**
     *
     */
    readonly path: AString;
    /**
     *
     */
    nativePath(): PathString;
    /**
     *
     */
    exists(): boolean;
    /**
     *
     */
    isWritable(): boolean;
    /**
     *
     */
    isReadable(): boolean;
    /**
     *
     */
    isExecutable(): boolean;
    /**
     *
     */
    isHidden(): boolean;
    /**
     *
     */
    isDirectory(): boolean;
    /**
     *
     */
    isFile(): boolean;
    /**
     *
     */
    isSymlink(): boolean;
    /**
     * Not a regular file, not a directory, not a symlink.
     */
    isSpecial(): boolean;
    /**
     * createUnique
     *
     * This function will create a new file or directory in the
     * file system. Any nodes that have not been created or
     * resolved, will be.  If this file already exists, we try
     * variations on the leaf name "suggestedName" until we find
     * one that did not already exist.
     *
     * If the search for nonexistent files takes too long
     * (thousands of the variants already exist), we give up and
     * return NS_ERROR_FILE_TOO_BIG.
     *
     * @param type
     * This specifies the type of file system object
     * to be made.  The only two types at this time
     * are file and directory which are defined above.
     * If the type is unrecongnized, we will return an
     * error (NS_ERROR_FILE_UNKNOWN_TYPE).
     *
     * @param permissions
     * The unix style octal permissions.  This may
     * be ignored on systems that do not need to do
     * permissions.
     */
    createUnique(type: unsigned_long, permissions: unsigned_long): void;
    /**
     * clone()
     *
     * This function will allocate and initialize a nsIFile object to the
     * exact location of the |this| nsIFile.
     *
     * @param file
     * A nsIFile which this object will be initialize
     * with.
     */
    clone(): nsIFile;
    /**
     * Will determine if the inFile equals this.
     */
    equals(inFile: nsIFileType): boolean;
    /**
     * Will determine if inFile is a descendant of this file.
     * This routine looks in subdirectories too.
     */
    contains(inFile: nsIFileType): boolean;
    /**
     * Parent will be null when this is at the top of the volume.
     */
    readonly parent: nsIFile;
    /**
     * Returns an enumeration of the elements in a directory. Each
     * element in the enumeration is an nsIFile.
     *
     * @throws NS_ERROR_FILE_NOT_DIRECTORY if the current nsIFile does
     * not specify a directory.
     */
    readonly directoryEntries: nsIDirectoryEnumerator;
    /**
     * initWith[Native]Path
     *
     * This function will initialize the nsIFile object.  Any
     * internal state information will be reset.
     *
     * @param filePath
     * A string which specifies a full file path to a
     * location.  Relative paths will be treated as an
     * error (NS_ERROR_FILE_UNRECOGNIZED_PATH).  For
     * initWithNativePath, the filePath must be in the native
     * filesystem charset.
     */
    initWithPath(filePath: AString): void;
    /**
     * initWithFile
     *
     * Initialize this object with another file
     *
     * @param aFile
     * the file this becomes equivalent to
     */
    initWithFile(aFile: nsIFileType): void;
    /**
     *
     */
    readonly diskSpaceAvailable: int64_t;
    /**
     *
     */
    readonly diskCapacity: int64_t;
    /**
     * appendRelative[Native]Path
     *
     * Append a relative path to the current path of the nsIFile object.
     *
     * @param relativeFilePath
     * relativeFilePath is a native relative path. For security reasons,
     * this cannot contain .. and cannot start with a directory separator.
     * For the |appendRelativeNativePath| method, the relativeFilePath
     * must be in the native filesystem charset.
     */
    appendRelativePath(relativeFilePath: AString): void;
    /**
     * Accessor to a null terminated string which will specify
     * the file in a persistent manner for disk storage.
     *
     * The character set of this attribute is undefined.  DO NOT TRY TO
     * INTERPRET IT AS HUMAN READABLE TEXT!
     */
    persistentDescriptor: ACString;
    /**
     * reveal
     *
     * Ask the operating system to open the folder which contains
     * this file or folder. This routine only works on platforms which
     * support the ability to open a folder and is run async on Windows.
     * This routine must be called on the main.
     */
    reveal(): void;
    /**
     * launch
     *
     * Ask the operating system to attempt to open the file.
     * this really just simulates "double clicking" the file on your platform.
     * This routine only works on platforms which support this functionality
     * and is run async on Windows.  This routine must be called on the
     * main thread.
     */
    launch(): void;
    /**
     * getRelativeDescriptor
     *
     * Returns a relative file path in an opaque, XP format. It is therefore
     * not a native path.
     *
     * The character set of the string returned from this function is
     * undefined.  DO NOT TRY TO INTERPRET IT AS HUMAN READABLE TEXT!
     *
     * @param fromFile
     * the file from which the descriptor is relative.
     * Throws if fromFile is null.
     */
    getRelativeDescriptor(fromFile: nsIFileType): ACString;
    /**
     * setRelativeDescriptor
     *
     * Initializes the file to the location relative to fromFile using
     * a string returned by getRelativeDescriptor.
     *
     * @param fromFile
     * the file to which the descriptor is relative
     * @param relative
     * the relative descriptor obtained from getRelativeDescriptor
     */
    setRelativeDescriptor(fromFile: nsIFileType, relativeDesc: ACString): void;
    /**
     * getRelativePath
     *
     * Returns a relative file from 'fromFile' to this file as a UTF-8 string.
     * Going up the directory tree is represented via "../".  '/' is used as
     * the path segment separator.  This is not a native path, since it's UTF-8
     * encoded.
     *
     * @param fromFile
     * the file from which the path is relative.
     * Throws if fromFile is null.
     */
    getRelativePath(fromFile: nsIFileType): AUTF8String;
    /**
     * setRelativePath
     *
     * Initializes the file to the location relative to fromFile using
     * a string returned by getRelativePath.
     *
     * @param fromFile
     * the file from which the path is relative
     * @param relative
     * the relative path obtained from getRelativePath
     */
    setRelativePath(fromFile: nsIFileType, relativeDesc: AUTF8String): void;
}

/**
 * nsIFileChannel
 */
declare interface nsIFileChannelType extends nsISupportsType {
    /**
     *
     */
    readonly file: nsIFile;
}

/**
 *
 */
declare interface nsIFilePickerType extends nsISupportsType {
    /**
     * Initialize the file picker widget.  The file picker is not valid until this
     * method is called.
     *
     * @param      parent   mozIDOMWindow parent.  This dialog will be dependent
     * on this parent. parent must be non-null.
     * @param      title    The title for the file widget
     * @param      mode     load, save, or get folder
     */
    init(parent: mozIDOMWindowProxy, title: AString, mode: nsIFilePicker_ModeType): void;
    /**
     * Returns a Promise that resolves to true if the passed nsIFilePicker mode
     * is supported on the current platform, and false otherwise. The Promise may
     * reject if something unexpected occurs while trying to determine if the mode
     * is supported.
     *
     * @param mode
     * @return Promise<boolean>
     */
    isModeSupported(mode: nsIFilePicker_ModeType): Promise;
    /**
     * Append to the  filter list with things from the predefined list
     *
     * @param      filters  mask of filters i.e. (filterAll | filterHTML)
     */
    appendFilters(filterMask: long): void;
    /**
     * Add a filter
     *
     * @param      title    name of the filter
     * @param      filter   extensions to filter -- semicolon and space separated
     */
    appendFilter(title: AString, filter: AString): void;
    /**
     * Add a raw filter (eg, add a MIME type without transforming it to a list of
     * extensions).
     *
     * @param     filter   a filter taken directly from the accept attribute
     * without processing
     */
    appendRawFilter(filter: AString): void;
    /**
     * The filename that should be suggested to the user as a default. This should
     * include the extension.
     *
     * @throws NS_ERROR_FAILURE on attempts to get
     */
    defaultString: AString;
    /**
     * The extension that should be associated with files of the type we
     * want to work with.  On some platforms, this extension will be
     * automatically appended to filenames the user enters, if needed.
     */
    defaultExtension: AString;
    /**
     * The filter which is currently selected in the File Picker dialog
     *
     * @return Returns the index (0 based) of the selected filter in the filter list.
     */
    filterIndex: long;
    /**
     * Set the directory that the file open/save dialog initially displays
     * Note that, if displaySpecialDirectory has been already set, this value will
     * be ignored.
     *
     * @param      displayDirectory  the name of the directory
     */
    displayDirectory: nsIFile;
    /**
     * Set the directory that the file open/save dialog initially displays using
     * one of the special name as such as 'Desk', 'TmpD', and so on.
     * Note that, if displayDirectory has been already set, this value will be
     * ignored.
     *
     * @param      displaySpecialDirectory  the name of the special directory
     */
    displaySpecialDirectory: AString;
    /**
     * Get the nsIFile for the file or directory. A different file object
     * may be returned by each invocation.
     *
     * @return Returns the file currently selected
     */
    readonly file: nsIFile;
    /**
     * Get the nsIURI for the file or directory.
     *
     * @return Returns the file currently selected
     */
    readonly fileURL: nsIURI;
    /**
     * Get the enumerator for the selected files
     * only works in the modeOpenMultiple mode
     *
     * @return Returns the files currently selected
     */
    readonly files: nsISimpleEnumerator;
    /**
     * Get the DOM File or the DOM Directory
     *
     * @return Returns the file or directory currently selected DOM object.
     */
    readonly domFileOrDirectory: nsISupports;
    /**
     * Get the enumerator for the selected files or directories
     * only works in the modeOpenMultiple mode
     *
     * @return Returns the files/directories currently selected as DOM object.
     */
    readonly domFileOrDirectoryEnumerator: nsISimpleEnumerator;
    /**
     * Controls whether the chosen file(s) should be added to the system's recent
     * documents list. This attribute will be ignored if the system has no "Recent
     * Docs" concept, or if the application is in private browsing mode (in which
     * case the file will not be added). Defaults to true.
     */
    addToRecentDocs: boolean;
    /**
     * Opens the file dialog asynchrounously.
     * The passed in object's done method will be called upon completion.
     */
    open(aFilePickerShownCallback: nsIFilePickerShownCallbackType): void;
    /**
     * The picker's mode, as set by the 'mode' argument passed to init()
     * (one of the modeOpen et. al. constants specified above).
     */
    readonly mode: nsIFilePicker_Mode;
    /**
     * If set to non-empty string, the nsIFilePicker implementation
     * may use okButtonLabel as the label for the button the user uses to accept
     * file selection.
     */
    okButtonLabel: AString;
    /**
     * Implementation of HTMLInputElement's `capture` property.
     *
     * Not used by Firefox Desktop.
     */
    capture: nsIFilePicker_CaptureTarget;
}

/**
 *
 */
declare interface nsIFilePickerShownCallbackType extends nsISupportsType {
    /**
     * Callback which is called when a filepicker is shown and a result
     * is returned.
     *
     * @param aResult One of returnOK, returnCancel, or returnReplace
     */
    done(aResult: nsIFilePicker_ResultCodeType): void;
}

/**
 *
 */
declare interface nsIFileProtocolHandlerType extends nsIProtocolHandlerType {
    /**
     * This method constructs a new file URI
     *
     * @param aFile nsIFile
     * @return reference to a new nsIURI object
     */
    newFileURI(aFile: nsIFileType): nsIURI;
    /**
     * This method constructs a new file URI, and returns a URI mutator
     * that has not yet been finalized, allowing the URI to be changed without
     * being cloned.
     *
     * @param aFile nsIFile
     * @return reference to a new nsIURIMutator object
     */
    newFileURIMutator(file: nsIFileType): nsIURIMutator;
    /**
     * Converts a non-directory nsIFile to the corresponding URL string.
     * NOTE: under some platforms this is a lossy conversion (e.g., Mac
     * Carbon build). If the nsIFile is a local file, then the result
     * will be a file:// URL string.
     *
     * The resulting string may contain URL-escaped characters.
     *
     * Should only be called on files which are not directories. If
     * called on directories, the resulting URL may lack a trailing slash
     * and cause relative URLs in such a document to misbehave.
     */
    getURLSpecFromActualFile(file: nsIFileType): AUTF8String;
    /**
     * Converts a directory nsIFile to the corresponding URL string.
     * NOTE: under some platforms this is a lossy conversion (e.g., Mac
     * Carbon build). If the nsIFile is a local file, then the result
     * will be a file:// URL string.
     *
     * The resulting string may contain URL-escaped characters.
     *
     * Should only be called on files which are directories (will enforce
     * the URL ends with a slash).
     */
    getURLSpecFromDir(file: nsIFileType): AUTF8String;
    /**
     * Converts the URL string into the corresponding nsIFile if possible.
     * A local file will be created if the URL string begins with file://.
     */
    getFileFromURLSpec(url: AUTF8String): nsIFile;
    /**
     * Takes a local file and tries to interpret it as an internet shortcut
     * (e.g. .url files on windows).
     * @param file The local file to read
     * @return The URI the file refers to
     *
     * @throw NS_ERROR_NOT_AVAILABLE if the OS does not support such files.
     * @throw NS_ERROR_NOT_AVAILABLE if this file is not an internet shortcut.
     */
    readURLFile(file: nsIFileType): nsIURI;
    /**
     * Takes a local file and tries to interpret it as a shell link file
     * (.lnk files on Windows)
     * @param file The local file to read
     * @return The URI the file refers to
     *
     * @throw NS_ERROR_NOT_AVAILABLE if the OS does not support such files.
     * @throw NS_ERROR_NOT_AVAILABLE if this file is not a shell link.
     */
    readShellLink(file: nsIFileType): nsIURI;
}

/**
 * An input stream that allows you to read from a file.
 */
declare interface nsIFileInputStreamType extends nsIInputStreamType {
    /**
     * @param file          file to read from
     * @param ioFlags       file open flags listed in prio.h (see
     * PR_Open documentation) or -1 to open the
     * file in default mode (PR_RDONLY).
     * @param perm          file mode bits listed in prio.h or -1 to
     * use the default value (0)
     * @param behaviorFlags flags specifying various behaviors of the class
     * (see enumerations in the class)
     */
    init(file: nsIFileType, ioFlags: long, perm: long, behaviorFlags: long): void;
}

/**
 * An output stream that lets you stream to a file.
 */
declare interface nsIFileOutputStreamType extends nsIOutputStreamType {
    /**
     * @param file          file to write to
     * @param ioFlags       file open flags listed in prio.h (see
     * PR_Open documentation) or -1 to open the
     * file in default mode (PR_WRONLY |
     * PR_CREATE_FILE | PR_TRUNCATE)
     * @param perm          file mode bits listed in prio.h or -1 to
     * use the default permissions (0664)
     * @param behaviorFlags flags specifying various behaviors of the class
     * (currently none supported)
     */
    init(file: nsIFileType, ioFlags: long, perm: long, behaviorFlags: long): void;
}

/**
 * A stream that allows you to read from a file or stream to a file.
 */
declare interface nsIFileRandomAccessStreamType extends nsIRandomAccessStreamType {
    /**
     * @param file          file to read from or stream to
     * @param ioFlags       file open flags listed in prio.h (see
     * PR_Open documentation) or -1 to open the
     * file in default mode (PR_RDWR).
     * @param perm          file mode bits listed in prio.h or -1 to
     * use the default value (0)
     * @param behaviorFlags flags specifying various behaviors of the class
     * (see enumerations in the class)
     */
    init(file: nsIFileType, ioFlags: long, perm: long, behaviorFlags: long): void;
}

/**
 * An interface that allows you to get some metadata like file size and
 * file last modified time. These methods and attributes can throw
 * NS_BASE_STREAM_WOULD_BLOCK in case the informations are not available yet.
 * If this happens, consider the use of nsIAsyncFileMetadata.
 *
 * If using nsIAsyncFileMetadata, you should retrieve any data via this
 * interface before taking any action that might consume the underlying stream.
 * For example, once Available(), Read(), or nsIAsyncInputStream::AsyncWait()
 * are invoked, these methods may return NS_BASE_STREAM_CLOSED.  This will
 * happen when using RemoteLazyInputStream with an underlying file stream, for
 * example.
 */
declare interface nsIFileMetadataType extends nsISupportsType {
    /**
     * File size in bytes.
     */
    readonly size: long_long;
    /**
     * File last modified time in milliseconds from midnight (00:00:00),
     * January 1, 1970 Greenwich Mean Time (GMT).
     */
    readonly lastModified: long_long;
}

/**
 *
 */
declare interface nsIAsyncFileMetadataType extends nsIFileMetadataType {
    /**
     * Asynchronously wait for the object to be ready.
     *
     * @param aCallback The callback will be used when the stream is ready to
     * return File metadata. Use a nullptr to cancel a
     * previous operation.
     *
     * @param aEventTarget The event target where aCallback will be executed.
     * If aCallback is passed, aEventTarget cannot be null.
     */
    asyncFileMetadataWait(aCallback: nsIFileMetadataCallbackType, aEventTarget: nsIEventTargetType): void;
}

/**
 * This is a companion interface for
 * nsIAsyncFileMetadata::asyncFileMetadataWait.
 */
declare interface nsIFileMetadataCallbackType extends nsISupportsType {
    /**
     * Called to indicate that the nsIFileMetadata object is ready.
     */
    onFileMetadataReady(aObject: nsIAsyncFileMetadataType): void;
}

/**
 * nsIFileURL provides access to the underlying nsIFile object corresponding to
 * an URL.  The URL scheme need not be file:, since other local protocols may
 * map URLs to files (e.g., resource:).
 */
declare interface nsIFileURLType extends nsIURLType {
    /**
     * Get the nsIFile corresponding to this URL.
     *
     * - Returns a reference to an immutable object.  Callers must clone
     * before attempting to modify the returned nsIFile object.  NOTE: this
     * constraint might not be enforced at runtime, so beware!!
     */
    readonly file: nsIFile;
}

/**
 *
 */
declare interface nsIFileURLMutatorType extends nsISupportsType {
}

/**
 *
 */
declare interface nsIFinalizationWitnessServiceType extends nsISupportsType {
    /**
     * Create a new Finalization Witness.
     *
     * A finalization witness is an object whose sole role is to
     * broadcast when it is garbage-collected. Once the witness is
     * created, call method its method |forget()| to prevent the
     * broadcast.
     *
     * @param aTopic The topic that the witness will broadcast using
     * Services.obs.
     * @param aString The string that the witness will broadcast.
     * @return An object with a single method |forget()|.
     */
    make(aTopic: string, aString: wstring): jsval;
}

/**
 *
 */
declare interface nsIFindType extends nsISupportsType {
    /**
     *
     */
    findBackwards: boolean;
    /**
     *
     */
    caseSensitive: boolean;
    /**
     *
     */
    entireWord: boolean;
    /**
     *
     */
    matchDiacritics: boolean;
    /**
     * Find some text in the current context. The implementation is
     * responsible for performing the find and highlighting the text.
     *
     * @param aPatText     The text to search for.
     * @param aSearchRange A Range specifying domain of search.
     * @param aStartPoint  A Range specifying search start point.
     * If not collapsed, we'll start from
     * end (forward) or start (backward).
     * @param aEndPoint    A Range specifying search end point.
     * If not collapsed, we'll end at
     * end (forward) or start (backward).
     * @retval             A range spanning the match that was found (or null).
     */
    Find(aPatText: AString, aSearchRange: Range, aStartPoint: Range, aEndPoint: Range): Range;
}

/**
 *
 */
declare interface nsIFindServiceType extends nsISupportsType {
    /**
     * The sole purpose of the Find service is to store globally the
     * last used Find settings
     */
    searchString: AString;
    /**
     *
     */
    replaceString: AString;
    /**
     *
     */
    findBackwards: boolean;
    /**
     *
     */
    wrapFind: boolean;
    /**
     *
     */
    entireWord: boolean;
    /**
     *
     */
    matchCase: boolean;
    /**
     *
     */
    matchDiacritics: boolean;
}

/**
 * The focus manager deals with all focus related behaviour. Only one element
 * in the entire application may have the focus at a time; this element
 * receives any keyboard events. While there is only one application-wide
 * focused element, each nsIDOMWindow maintains a reference to the element
 * that would be focused if the window was active.
 *
 * If the window's reference is to a frame element (iframe, browser,
 * editor), then the child window contains the element that is currently
 * focused. If the window's reference is to a root element, then the root is
 * focused. If a window's reference is null, then no element is focused, yet
 * the window is still focused.
 *
 * The blur event is fired on an element when it loses the application focus.
 * After this blur event, if the focus is moving away from a document, two
 * additional blur events are fired on the old document and window containing
 * the focus respectively.
 *
 * When a new document is focused, two focus events are fired on the new
 * document and window respectively. Then the focus event is fired on an
 * element when it gains the application focus.
 *
 * A special case is that the root element may be focused, yet does not
 * receive the element focus and blur events. Instead a focus outline may be
 * drawn around the document.
 *
 * Blur and focus events do not bubble as per the W3C DOM Events spec.
 */
declare interface nsIFocusManagerType extends nsISupportsType {
    /**
     * The most active (frontmost) window, or null if no window that is part of
     * the application is active. Do not use outside the parent process.
     */
    readonly activeWindow: mozIDOMWindowProxy;
    /**
     * In the parent process: The BrowsingContext corresponding to activeWindow.
     * In content processes: The top-level Web content browsing context that
     * focus is in if the application is active and focus is in Web content.
     */
    readonly activeBrowsingContext: BrowsingContext;
    /**
     * The child window within the activeWindow that is focused. This will
     * always be activeWindow, a child window of activeWindow or null if no
     * child window is focused. Setting the focusedWindow changes the focused
     * window and raises the toplevel window it is in. If the current focus
     * within the new focusedWindow is a frame element, then the focusedWindow
     * will actually be set to the child window and the current element within
     * that set as the focused element. This process repeats downwards until a
     * non-frame element is found.
     * The setter for this attribute defaults to CallerType::System.
     * If focus is in another process, this is null in content processes and
     * the closest ancestor in the parent process.
     */
    focusedWindow: mozIDOMWindowProxy;
    /**
     * Parent-process only: The content BrowsingContext that currently has focus,
     * if any. Note this can be different from activeBrowsingContext in the case
     * of subframes.
     */
    readonly focusedContentBrowsingContext: BrowsingContext;
    /**
     * The element that is currently focused. This will always be an element
     * within the document loaded in focusedWindow or null if no element in that
     * document is focused.
     */
    readonly focusedElement: Element;
    /**
     * Returns the method that was used to focus the element in window. This
     * will either be 0, FLAG_BYMOUSE or FLAG_BYKEY. If window is null, then
     * the current focusedWindow will be used by default. This has the result
     * of retrieving the method that was used to focus the currently focused
     * element.
     */
    getLastFocusMethod(window: mozIDOMWindowProxy): uint32_t;
    /**
     * Changes the focused element reference within the window containing
     * aElement to aElement or potentially redirects it to an anonymous
     * descendant of it (e.g., for `<input type="number">` the focus is redirected
     * to its descendant `<input type="text">`).
     */
    setFocus(aElement: Element, aFlags: unsigned_long): void;
    /**
     * Move the focus to another element. If aStartElement is specified, then
     * movement is done relative to aStartElement. If aStartElement is null,
     * then movement is done relative to the currently focused element. If no
     * element is focused, focus the first focusable element within the
     * document (or the last focusable element if aType is MOVEFOCUS_END). This
     * method is equivalent to setting the focusedElement to the new element.
     *
     * Specifying aStartElement and using MOVEFOCUS_LAST is not currently
     * implemented.
     *
     * If no element is found, and aType is either MOVEFOCUS_ROOT or
     * MOVEFOCUS_CARET, then the focus is cleared. If aType is any other value,
     * the focus is not changed.
     *
     * Returns the element that was focused (see setFocus). The return value
     * may be null if focus was moved into a child process.
     */
    moveFocus(aWindow: mozIDOMWindowProxy, aStartElement: Element, aType: unsigned_long, aFlags: unsigned_long): Element;
    /**
     * Clears the focused element within aWindow. If the current focusedWindow
     * is a descendant of aWindow, sets the current focusedWindow to aWindow.
     *
     * @throws NS_ERROR_INVALID_ARG if aWindow is null
     */
    clearFocus(aWindow: mozIDOMWindowProxy): void;
    /**
     * Returns the currently focused element within aWindow. If aWindow is equal
     * to the current value of focusedWindow, then the returned element will be
     * the application-wide focused element (the value of focusedElement). The
     * return value will be null if no element is focused.
     *
     * If aDeep is true, then child frames are traversed and the return value
     * may be the element within a child descendant window that is focused. If
     * aDeep if false, then the return value will be the frame element if the
     * focus is in a child frame.
     *
     * aFocusedWindow will be set to the currently focused descendant window of
     * aWindow, or to aWindow if aDeep is false. This will be set even if no
     * element is focused.
     *
     * @throws NS_ERROR_INVALID_ARG if aWindow is null
     */
    getFocusedElementForWindow(aWindow: mozIDOMWindowProxy, aDeep: boolean, aFocusedWindow: mozIDOMWindowProxy): Element;
    /**
     * Moves the selection caret within aWindow to the current focus.
     */
    moveCaretToFocus(aWindow: mozIDOMWindowProxy): void;
    /**
     * *
     * Check if given element (or potentially a descendant, see setFocus) is
     * focusable.
     */
    elementIsFocusable(aElement: Element, aFlags: unsigned_long): boolean;
}

/**
 *
 */
declare interface nsIFontEnumeratorType extends nsISupportsType {
    /**
     * Return a promise that resolves to a sorted array of the names of all
     * installed fonts.
     *
     * @return Promise that resolves to Array
     */
    EnumerateAllFontsAsync(): jsval;
    /**
     * Return a promise that resolves to a sorted array of names of fonts
     * that support the given language group and are suitable for use as the given
     * CSS generic font.
     *
     * @param  aLangGroup language group
     * @param  aGeneric   CSS generic font
     * @return Promise that resolves to Array
     */
    EnumerateFontsAsync(aLangGroup: string, aGeneric: string): jsval;
    /**
     * @param  aLangGroup language group
     * @return bool do we have a font for this language group
     */
    HaveFontFor(aLangGroup: string, aResult: boolean): void;
    /**
     * @param  aLangGroup language group
     * @param  aGeneric CSS generic font
     * @return suggested default font for this language group and generic family
     */
    getDefaultFont(aLangGroup: string, aGeneric: string): wstring;
    /**
     * get the standard family name on the system from given family
     * @param  aName family name which may be alias
     * @return the standard family name on the system, if given name does not
     * exist, returns empty string
     */
    getStandardFamilyName(aName: wstring): wstring;
}

/**
 *
 */
declare interface nsIFontLoadCompleteCallbackType extends nsISupportsType {
    /**
     *
     */
    fontLoadComplete(): void;
}

/**
 * nsIForcePending interface exposes a function that enables overwriting of the normal
 * behavior for the channel's IsPending(), forcing 'true' to be returned.
 */
declare interface nsIForcePendingChannelType extends nsISupportsType {
    /**
     * forcePending(true) overrides the normal behavior for the
     * channel's IsPending(), forcing 'true' to be returned. A call to
     * forcePending(false) reverts IsPending() back to normal behavior.
     */
    forcePending(aForcePending: boolean): void;
}

/**
 *
 */
declare interface nsIFormAutoCompleteType extends nsISupportsType {
    /**
     * Generate results for a form input autocomplete menu asynchronously.
     */
    autoCompleteSearchAsync(aInputName: AString, aSearchString: AString, aField: HTMLInputElement, aPreviousResult: nsIAutoCompleteResultType, aAddDatalist: bool, aListener: nsIFormAutoCompleteObserverType): void;
    /**
     * If a search is in progress, stop it. Otherwise, do nothing. This is used
     * to cancel an existing search, for example, in preparation for a new search.
     */
    stopAutoCompleteSearch(): void;
}

/**
 *
 */
declare interface nsIFormAutoCompleteObserverType extends nsISupportsType {
    /**
     * Called when a search is complete and the results are ready even if the
     * result set is empty. If the search is cancelled or a new search is
     * started, this is not called.
     *
     * @param result - The search result object
     */
    onSearchCompletion(result: nsIAutoCompleteResultType): void;
}

/**
 * nsIFormFillController is an interface for controlling form fill behavior
 * on HTML documents.  Any number of docShells can be controller concurrently.
 * While a docShell is attached, all HTML documents that are loaded within it
 * will have a focus listener attached that will listen for when a text input
 * is focused.  When this happens, the input will be bound to the
 * global nsIAutoCompleteController service.
 */
declare interface nsIFormFillControllerType extends nsISupportsType {
    /**
     * The input element the form fill controller is currently bound to.
     */
    readonly focusedInput: HTMLInputElement;
    /**
     * Whether the autocomplete popup on a password field was automatically opened
     * by the form fill controller (upon focus).
     */
    readonly passwordPopupAutomaticallyOpened: boolean;
    /**
     *
     */
    attachPopupElementToDocument(document: Document, popup: Element): void;
    /**
     *
     */
    detachFromDocument(document: Document): void;
    /**
     * Returns true if aInput is managed by the login manager.
     *
     * @param aInput - The HTML <input> element to tag
     */
    isLoginManagerField(aInput: HTMLInputElement): boolean;
    /**
     * Mark the specified <input> element as being managed by password manager.
     * Autocomplete requests will be handed off to the password manager, and will
     * not be stored in form history.
     *
     * @param aInput - The HTML <input> element to tag
     */
    markAsLoginManagerField(aInput: HTMLInputElement): void;
    /**
     * Mark the specified <input> element as being managed by a form autofill component.
     * Autocomplete requests will be handed off to the autofill component.
     *
     * @param aInput - The HTML <input> element to mark
     */
    markAsAutofillField(aInput: HTMLInputElement): void;
    /**
     * Open the autocomplete popup, if possible.
     */
    showPopup(): void;
}

/**
 * nsIFormPOSTActionChannel
 *
 * Channel classes that want to be allowed for HTML form POST action must
 * implement this interface.
 */
declare interface nsIFormPOSTActionChannelType extends nsIUploadChannelType {
}

/**
 *
 */
declare interface nsIFormatConverterType extends nsISupportsType {
    /**
     * Determines whether a conversion from one flavor to another is supported
     *
     * @param  aFromFormatConverter flavor to convert from
     * @param  aFromFormatConverter flavor to convert to
     */
    canConvert(aFromDataFlavor: string, aToDataFlavor: string): boolean;
    /**
     * Converts from one flavor to another.
     *
     * @param  aFromFormatConverter flavor to convert from
     * @param  aFromFormatConverter flavor to convert to (destination own the memory)
     * @returns returns NS_OK if it was converted
     */
    convert(aFromDataFlavor: string, aFromData: nsISupportsType, aToDataFlavor: string, aToData: nsISupportsType): void;
}

/**
 *
 */
declare interface nsIGIOMimeAppType extends nsIHandlerAppType {
    /**
     *
     */
    readonly id: AUTF8String;
    /**
     *
     */
    readonly command: AUTF8String;
    /**
     *
     */
    readonly expectsURIs: long;
    /**
     *
     */
    readonly supportedURISchemes: nsIUTF8StringEnumerator;
    /**
     *
     */
    setAsDefaultForMimeType(mimeType: AUTF8String): void;
    /**
     *
     */
    setAsDefaultForFileExtensions(extensions: AUTF8String): void;
    /**
     *
     */
    setAsDefaultForURIScheme(uriScheme: AUTF8String): void;
}

/**
 *
 */
declare interface nsIGIOServiceType extends nsISupportsType {
    /**
     * * MIME registry methods **
     *
     * Obtain the MIME type registered for an extension.  The extension
     * should not include a leading dot.
     */
    getMimeTypeFromExtension(extension: AUTF8String): AUTF8String;
    /**
     * Obtain the preferred application for opening a given URI scheme
     */
    getAppForURIScheme(aURIScheme: AUTF8String): nsIHandlerApp;
    /**
     * Obtain list of application capable of opening given URI scheme
     */
    getAppsForURIScheme(aURIScheme: AUTF8String): nsIMutableArray;
    /**
     * Obtain the preferred application for opening a given MIME type
     */
    getAppForMimeType(mimeType: AUTF8String): nsIHandlerApp;
    /**
     * Create application info for given command and name
     */
    createAppFromCommand(cmd: AUTF8String, appName: AUTF8String): nsIGIOMimeApp;
    /**
     * Find the application info by given command
     */
    findAppFromCommand(cmd: AUTF8String): nsIGIOMimeApp;
    /**
     * Obtain a description for the given MIME type
     */
    getDescriptionForMimeType(mimeType: AUTF8String): AUTF8String;
    /**
     * * Misc. methods **
     */
    readonly isRunningUnderFlatpak: boolean;
}

/**
 *
 */
declare interface nsIGNOMEShellServiceType extends nsIShellServiceType {
    /**
     * Used to determine whether or not to offer "Set as desktop background"
     * functionality. Even if shell service is available it is not
     * guaranteed that it is able to set the background for every desktop
     * which is especially true for Linux with its many different desktop
     * environments.
     */
    readonly canSetDesktopBackground: boolean;
    /**
     * Returns true if Firefox is set as the default handler for the scheme.
     */
    isDefaultForScheme(aScheme: AUTF8String): boolean;
}

/**
 *
 */
declare interface nsIGSettingsCollectionType extends nsISupportsType {
    /**
     *
     */
    setString(key: AUTF8String, value: AUTF8String): void;
    /**
     *
     */
    setBoolean(key: AUTF8String, value: boolean): void;
    /**
     *
     */
    setInt(key: AUTF8String, value: long): void;
    /**
     *
     */
    getString(key: AUTF8String): AUTF8String;
    /**
     *
     */
    getBoolean(key: AUTF8String): boolean;
    /**
     *
     */
    getInt(key: AUTF8String): long;
    /**
     *
     */
    getStringList(key: AUTF8String): nsIArray;
}

/**
 *
 */
declare interface nsIGSettingsServiceType extends nsISupportsType {
    /**
     *
     */
    getCollectionForSchema(schema: AUTF8String): nsIGSettingsCollection;
}

/**
 * Interface provides a way for a geolocation provider to
 * notify the system that a new location is available.
 */
declare interface nsIGeolocationUpdateType extends nsISupportsType {
    /**
     * Notify the geolocation service that a new geolocation
     * has been discovered.
     * This must be called on the main thread
     */
    update(position: nsIDOMGeoPositionType): void;
    /**
     * Notify the geolocation service of an error.
     * This must be called on the main thread.
     * The parameter refers to one of the constants in the
     * nsIDOMGeoPositionError interface.
     * Use this to report spurious errors coming from the
     * provider; for errors occurring inside the methods in
     * the nsIGeolocationProvider interface, just use the return
     * value.
     */
    notifyError(error: unsigned_short): void;
}

/**
 * Interface provides location information to the nsGeolocator
 * via the nsIDOMGeolocationCallback interface.  After
 * startup is called, any geo location change should call
 * callback.update().
 */
declare interface nsIGeolocationProviderType extends nsISupportsType {
    /**
     * Start up the provider.  This is called before any other
     * method.  may be called multiple times.
     */
    startup(): void;
    /**
     * watch
     * When a location change is observed, notify the callback.
     */
    watch(callback: nsIGeolocationUpdateType): void;
    /**
     * shutdown
     * Shuts down the location device.
     */
    shutdown(): void;
    /**
     * hint to provide to use any amount of power to provide a better result
     */
    setHighAccuracy(enable: boolean): void;
}

/**
 * NOTE: this interface is completely undesigned, not stable and likely to change
 */
declare interface nsIGfxInfoType extends nsISupportsType {
    /**
     * These are win32-specific
     */
    readonly D2DEnabled: boolean;
    /**
     *
     */
    readonly DWriteEnabled: boolean;
    /**
     *
     */
    readonly EmbeddedInFirefoxReality: boolean;
    /**
     *
     */
    readonly AzureCanvasBackend: AString;
    /**
     *
     */
    readonly AzureContentBackend: AString;
    /**
     *
     */
    readonly usingGPUProcess: boolean;
    /**
     *
     */
    readonly hasBattery: boolean;
    /**
     *
     */
    readonly DWriteVersion: AString;
    /**
     *
     */
    readonly cleartypeParameters: AString;
    /**
     * These are non-Android linux-specific
     */
    readonly windowProtocol: AString;
    /**
     *
     */
    readonly testType: AString;
    /**
     * These are valid across all platforms.
     */
    readonly ContentBackend: AString;
    /**
     *
     */
    readonly isHeadless: boolean;
    /**
     *
     */
    readonly TargetFrameRate: unsigned_long;
    /**
     *
     */
    readonly CodecSupportInfo: ACString;
    /**
     * The name of the display adapter.
     */
    readonly adapterDescription: AString;
    /**
     *
     */
    readonly adapterDescription2: AString;
    /**
     *
     */
    readonly adapterDriver: AString;
    /**
     *
     */
    readonly adapterDriver2: AString;
    /**
     * These types are inspired by DXGI_ADAPTER_DESC
     */
    readonly adapterVendorID: AString;
    /**
     *
     */
    readonly adapterVendorID2: AString;
    /**
     *
     */
    readonly adapterDeviceID: AString;
    /**
     *
     */
    readonly adapterDeviceID2: AString;
    /**
     *
     */
    readonly adapterSubsysID: AString;
    /**
     *
     */
    readonly adapterSubsysID2: AString;
    /**
     * The amount of RAM in MB in the display adapter.
     */
    readonly adapterRAM: unsigned_long;
    /**
     *
     */
    readonly adapterRAM2: unsigned_long;
    /**
     *
     */
    readonly adapterDriverVendor: AString;
    /**
     *
     */
    readonly adapterDriverVendor2: AString;
    /**
     *
     */
    readonly adapterDriverVersion: AString;
    /**
     *
     */
    readonly adapterDriverVersion2: AString;
    /**
     *
     */
    readonly adapterDriverDate: AString;
    /**
     *
     */
    readonly adapterDriverDate2: AString;
    /**
     *
     */
    readonly isGPU2Active: boolean;
    /**
     *
     */
    readonly drmRenderDevice: ACString;
    /**
     * Returns an array of objects describing each monitor. Guaranteed properties
     * are "screenWidth" and "screenHeight". This is only implemented on Desktop.
     *
     * Windows additionally supplies "refreshRate" and "pseudoDisplay".
     *
     * OS X additionally supplies "scale".
     */
    getMonitors(): jsval;
    /**
     * Ask about a feature, and return the status of that feature.
     * If the feature is not ok then aFailureId will give a unique failure Id
     * otherwise it will be empty.
     */
    getFeatureStatus(aFeature: long, aFailureId: ACString): long;
    /**
     * Ask about a feature, return the minimum driver version required for it if its status is
     * FEATURE_BLOCKED_DRIVER_VERSION, otherwise return an empty string.
     */
    getFeatureSuggestedDriverVersion(aFeature: long): AString;
    /**
     *
     */
    getInfo(): jsval;
    /**
     *
     */
    getFeatureLog(): jsval;
    /**
     *
     */
    getFeatures(): jsval;
    /**
     *
     */
    getActiveCrashGuards(): jsval;
    /**
     *
     */
    controlGPUProcessForXPCShell(aEnable: boolean): boolean;
    /**
     *
     */
    killGPUProcessForTests(): void;
    /**
     *
     */
    crashGPUProcessForTests(): void;
}

/**
 * NOTE: this interface is only implemented in debug builds
 */
declare interface nsIGfxInfoDebugType extends nsISupportsType {
    /**
     *
     */
    spoofVendorID(aVendorID: AString): void;
    /**
     *
     */
    spoofDeviceID(aDeviceID: AString): void;
    /**
     *
     */
    spoofDriverVersion(aDriverVersion: AString): void;
    /**
     *
     */
    spoofOSVersion(aVersion: unsigned_long): void;
}

/**
 *
 */
declare interface nsIGleanBooleanType extends nsISupportsType {
    /**
     * Set to the specified boolean value.
     *
     * @param value the value to set.
     */
    set(value: bool): void;
    /**
     * **Test-only API**
     *
     * Gets the currently stored value as a boolean.
     *
     * This function will attempt to await the last parent-process task (if any)
     * writing to the the metric's storage engine before returning a value.
     * This function will not wait for data from child processes.
     *
     * This doesn't clear the stored value.
     * Parent process only. Panics in child processes.
     *
     * @param aPingName The (optional) name of the ping to retrieve the metric
     * for. Defaults to the first value in `send_in_pings`.
     *
     * @return value of the stored metric, or undefined if there is no value.
     */
    testGetValue(aPingName: AUTF8String): jsval;
}

/**
 *
 */
declare interface nsIGleanDatetimeType extends nsISupportsType {
    /**
     * Set the datetime to the provided value, or the local now.
     * The internal value will store the local timezone.
     *
     * Note: The metric's time_unit affects the resolution of the value, not the
     * unit of this function's parameter (which is always PRTime/nanos).
     *
     * @param aValue The (optional) time value as PRTime (nanoseconds since epoch).
     * Defaults to local now.
     */
    set(aValue: PRTime): void;
    /**
     * **Test-only API**
     *
     * Gets the currently stored value as an integer.
     *
     * This function will attempt to await the last parent-process task (if any)
     * writing to the the metric's storage engine before returning a value.
     * This function will not wait for data from child processes.
     *
     * This doesn't clear the stored value.
     * Parent process only. Panics in child processes.
     *
     * @param aPingName The (optional) name of the ping to retrieve the metric
     * for. Defaults to the first value in `send_in_pings`.
     *
     * @return value of the stored metric as a JS Date with timezone,
     * or undefined if there is no value.
     */
    testGetValue(aPingName: AUTF8String): jsval;
}

/**
 *
 */
declare interface nsIGleanCounterType extends nsISupportsType {
    /**
     * Increases the counter by `amount`.
     *
     * @param amount The amount to increase by. Should be positive.
     */
    add(amount: int32_t): void;
    /**
     * **Test-only API**
     *
     * Gets the currently stored value as an integer.
     *
     * This function will attempt to await the last parent-process task (if any)
     * writing to the the metric's storage engine before returning a value.
     * This function will not wait for data from child processes.
     *
     * This doesn't clear the stored value.
     * Parent process only. Panics in child processes.
     *
     * @param aPingName The (optional) name of the ping to retrieve the metric
     * for. Defaults to the first value in `send_in_pings`.
     *
     * @return value of the stored metric, or undefined if there is no value.
     */
    testGetValue(aPingName: AUTF8String): jsval;
}

/**
 *
 */
declare interface nsIGleanTimingDistributionType extends nsISupportsType {
    /**
     * Starts tracking time for the provided metric.
     *
     * @returns A unique timer id for the new timer
     */
    start(): jsval;
    /**
     * Stops tracking time for the provided metric and timer id.
     *
     * Adds a count to the corresponding bucket in the timing distribution.
     * This will record an error if no `start` was called for this TimerId or
     * if this TimerId was used to call `cancel`.
     *
     * @param aId The TimerId associated with this timing. This allows for
     * concurrent timing of events associated with different ids.
     */
    stopAndAccumulate(aId: uint64_t): void;
    /**
     * Aborts a previous `start` call. No error is recorded if no `start` was
     * called. (But then where did you get that id from?)
     *
     * @param aId The TimerID whose `start` you wish to abort.
     */
    cancel(aId: uint64_t): void;
    /**
     * **Test-only API**
     *
     * Gets the currently stored value as a DistributionData.
     *
     * This function will attempt to await the last parent-process task (if any)
     * writing to the the metric's storage engine before returning a value.
     * This function will not wait for data from child processes.
     *
     * This doesn't clear the stored value.
     * Parent process only. Panics in child processes.
     *
     * @param aPingName The (optional) name of the ping to retrieve the metric
     * for. Defaults to the first value in `send_in_pings`.
     *
     * @return value of the stored metric, or undefined if there is no value.
     */
    testGetValue(aPingName: ACString): jsval;
    /**
     * **Test-only API**
     *
     * Accumulates a raw numeric sample of milliseconds.
     *
     * Test-only until we find a use-case and decent JS Time Duration type.
     *
     * @param aSample The sample, in milliseconds, to add.
     */
    testAccumulateRawMillis(aSample: uint64_t): void;
}

/**
 *
 */
declare interface nsIGleanMemoryDistributionType extends nsISupportsType {
    /**
     * Accumulates the provided sample in the metric.
     *
     * @param aSample The sample to be recorded by the metric. The sample is
     * assumed to be in the confgured memory unit of the metric.
     *
     * Notes: Values bigger than 1 Terabyte (2^40 bytes) are truncated and an
     * InvalidValue error is recorded.
     */
    accumulate(aSample: uint64_t): void;
    /**
     * **Test-only API**
     *
     * Gets the currently stored value as a DistributionData.
     *
     * This function will attempt to await the last parent-process task (if any)
     * writing to the the metric's storage engine before returning a value.
     * This function will not wait for data from child processes.
     *
     * This doesn't clear the stored value.
     * Parent process only. Panics in child processes.
     *
     * @param aPingName The (optional) name of the ping to retrieve the metric
     * for. Defaults to the first value in `send_in_pings`.
     *
     * @return value of the stored metric, or undefined if there is no value.
     */
    testGetValue(aPingName: ACString): jsval;
}

/**
 *
 */
declare interface nsIGleanCustomDistributionType extends nsISupportsType {
    /**
     * Accumulates the provided signed samples in the metric.
     *
     * @param aSamples - The vector holding the samples to be recorded by the metric.
     *
     * Notes: Discards any negative value in `samples`
     * and report an `ErrorType::InvalidValue` for each of them.
     */
    accumulateSamples(aSamples: invalid): void;
    /**
     * **Test-only API**
     *
     * Gets the currently stored value as a DistributionData.
     *
     * This function will attempt to await the last parent-process task (if any)
     * writing to the the metric's storage engine before returning a value.
     * This function will not wait for data from child processes.
     *
     * This doesn't clear the stored value.
     * Parent process only. Panics in child processes.
     *
     * @param aPingName The (optional) name of the ping to retrieve the metric
     * for. Defaults to the first value in `send_in_pings`.
     *
     * @return value of the stored metric, or undefined if there is no value.
     */
    testGetValue(aPingName: ACString): jsval;
}

/**
 *
 */
declare interface nsIGleanPingTestCallbackType extends nsISupportsType {
    /**
     *
     */
    call(aReason: ACString): void;
}

/**
 *
 */
declare interface nsIGleanPingType extends nsISupportsType {
    /**
     * Collect and submit the ping for eventual upload.
     *
     * This will collect all stored data to be included in the ping.
     * Data with lifetime `ping` will then be reset.
     *
     * If the ping is configured with `send_if_empty = false`
     * and the ping currently contains no content,
     * it will not be queued for upload.
     * If the ping is configured with `send_if_empty = true`
     * it will be queued for upload even if empty.
     *
     * Pings always contain the `ping_info` and `client_info` sections.
     * See [ping sections](https://mozilla.github.io/glean/book/user/pings/index.html#ping-sections)
     * for details.
     *
     * @param aReason - Optional. The reason the ping is being submitted.
     * Must match one of the configured `reason_codes`.
     */
    submit(aReason: ACString): void;
    /**
     * **Test-only API**
     *
     * Register a callback to be called right before this ping is next submitted.
     * The provided function is called exactly once before submitting.
     *
     * Note: The callback will be called on any call to submit.
     * A ping might not be sent afterwards, e.g. if the ping is empty and
     * `send_if_empty` is `false`.
     *
     * @param aCallback - The callback to call on the next submit.
     */
    testBeforeNextSubmit(aCallback: nsIGleanPingTestCallbackType): void;
}

/**
 *
 */
declare interface nsIGleanStringType extends nsISupportsType {
    /**
     * Set to the specified value.
     *
     * @param value The string to set the metric to.
     */
    set(value: AUTF8String): void;
    /**
     * **Test-only API**
     *
     * Gets the currently stored value as a string.
     *
     * This function will attempt to await the last parent-process task (if any)
     * writing to the the metric's storage engine before returning a value.
     * This function will not wait for data from child processes.
     *
     * This doesn't clear the stored value.
     * Parent process only. Panics in child processes.
     *
     * @param aPingName The (optional) name of the ping to retrieve the metric
     * for. Defaults to the first value in `send_in_pings`.
     *
     * @return value of the stored metric, or undefined if there is no value.
     */
    testGetValue(aPingName: AUTF8String): jsval;
}

/**
 *
 */
declare interface nsIGleanStringListType extends nsISupportsType {
    /**
     * Adds a new string to the list.
     *
     * Truncates the value and logs an error if it is longer than 50 bytes.
     *
     * @param value The string to add.
     */
    add(value: AUTF8String): void;
    /**
     * Sets to a specific list of strings.
     *
     * Truncates the list and logs an error if longer than 20 items.
     * Truncates any item longer than 50 bytes and logs an error.
     *
     * @param value The list of strings to set.
     */
    set(value: invalid): void;
    /**
     * **Test-only API**
     *
     * Gets the currently stored value.
     *
     * This function will attempt to await the last parent-process task (if any)
     * writing to the the metric's storage engine before returning a value.
     * This function will not wait for data from child processes.
     *
     * This doesn't clear the stored value.
     * Parent process only. Panics in child processes.
     *
     * @param aPingName The (optional) name of the ping to retrieve the metric
     * for. Defaults to the first value in `send_in_pings`.
     *
     * @return value of the stored metric, or undefined if there is no value.
     */
    testGetValue(aPingName: AUTF8String): jsval;
}

/**
 *
 */
declare interface nsIGleanTimespanType extends nsISupportsType {
    /**
     * Start tracking time for the provided metric.
     *
     * This records an error if its already tracking time (i.e. start was already
     * called with no corresponding [stop]): in that case the original
     * start time will be preserved.
     */
    start(): void;
    /**
     * Stop tracking time for the provided metric.
     *
     * Sets the metric to the elapsed time, but does not overwrite an already
     * existing value.
     * This will record an error if no [start] was called or there is an already
     * existing value.
     */
    stop(): void;
    /**
     * Aborts a previous start.
     *
     * Does not record an error if there was no previous call to start.
     */
    cancel(): void;
    /**
     * Explicitly sets the timespan value.
     *
     * This API should only be used if you cannot make use of
     * `start`/`stop`/`cancel`.
     *
     * @param aDuration The duration of this timespan, in units matching the
     * `time_unit` of this metric's definition.
     */
    setRaw(aDuration: uint32_t): void;
    /**
     * **Test-only API**
     *
     * Gets the currently stored value as an integer.
     *
     * This function will attempt to await the last parent-process task (if any)
     * writing to the the metric's storage engine before returning a value.
     * This function will not wait for data from child processes.
     *
     * This doesn't clear the stored value.
     * Parent process only. Panics in child processes.
     *
     * @param aPingName The (optional) name of the ping to retrieve the metric
     * for. Defaults to the first value in `send_in_pings`.
     *
     * @return value of the stored metric, or undefined if there is no value.
     */
    testGetValue(aPingName: AUTF8String): jsval;
}

/**
 *
 */
declare interface nsIGleanUuidType extends nsISupportsType {
    /**
     * Set to the specified value.
     *
     * @param aValue The UUID to set the metric to.
     */
    set(aValue: AUTF8String): void;
    /**
     * Generate a new random UUID and set the metric to it.
     */
    generateAndSet(): void;
    /**
     * **Test-only API**
     *
     * Gets the currently stored value as an integer.
     *
     * This function will attempt to await the last parent-process task (if any)
     * writing to the the metric's storage engine before returning a value.
     * This function will not wait for data from child processes.
     *
     * This doesn't clear the stored value.
     * Parent process only. Panics in child processes.
     *
     * @param aPingName The (optional) name of the ping to retrieve the metric
     * for. Defaults to the first value in `send_in_pings`.
     *
     * @return value of the stored metric, or undefined if there is no value.
     */
    testGetValue(aPingName: AUTF8String): jsval;
}

/**
 *
 */
declare interface nsIGleanEventType extends nsISupportsType {
    /**
     * Record an event.
     *
     * @param aExtra An (optional) map of extra values.
     */
    record(aExtra: jsval): void;
    /**
     * **Test-only API**
     *
     * Get a list of currently stored events for this event metric.
     *
     * This function will attempt to await the last parent-process task (if any)
     * writing to the the metric's storage engine before returning a value.
     * This function will not wait for data from child processes.
     *
     * This doesn't clear the stored value.
     * Parent process only. Panics in child processes.
     *
     * @param aPingName The (optional) name of the ping to retrieve the metric
     * for. Defaults to the first value in `send_in_pings`.
     *
     * @return value of the stored metric, or undefined if there is no value.
     *
     * The data is an array of objects:
     *
     * ```
     * [
     * {
     * timestamp: Integer,
     * category: String,
     * name: String,
     * extra: {
     * String: String
     * ...
     * }
     * },
     * ...
     * ]
     * ```
     *
     * The difference between event timestamps is in milliseconds
     * See https://mozilla.github.io/glean/book/user/metrics/event.html for further details.
     * Due to limitations of numbers in JavaScript, the timestamp will only be accurate up until 2^53.
     * (This is probably not an issue with the current clock implementation. Probably.)
     */
    testGetValue(aPingName: AUTF8String): jsval;
}

/**
 *
 */
declare interface nsIGleanQuantityType extends nsISupportsType {
    /**
     * Set to the specified value.
     *
     * @param value the value to set.
     */
    set(value: int64_t): void;
    /**
     * **Test-only API**
     *
     * Gets the currently stored value.
     *
     * This function will attempt to await the last parent-process task (if any)
     * writing to the the metric's storage engine before returning a value.
     * This function will not wait for data from child processes.
     *
     * This doesn't clear the stored value.
     * Parent process only. Panics in child processes.
     *
     * @param aPingName The (optional) name of the ping to retrieve the metric
     * for. Defaults to the first value in `send_in_pings`.
     *
     * @return value of the stored metric, or undefined if there is no value.
     */
    testGetValue(aPingName: AUTF8String): jsval;
}

/**
 *
 */
declare interface nsIGleanDenominatorType extends nsISupportsType {
    /**
     * Increases the counter by `amount`.
     *
     * @param amount The amount to increase by. Should be positive.
     */
    add(amount: int32_t): void;
    /**
     * **Test-only API**
     *
     * Gets the currently stored value as an integer.
     *
     * This function will attempt to await the last parent-process task (if any)
     * writing to the the metric's storage engine before returning a value.
     * This function will not wait for data from child processes.
     *
     * This doesn't clear the stored value.
     * Parent process only. Panics in child processes.
     *
     * @param aPingName The (optional) name of the ping to retrieve the metric
     * for. Defaults to the first value in `send_in_pings`.
     *
     * @return value of the stored metric, or undefined if there is no value.
     */
    testGetValue(aPingName: AUTF8String): jsval;
}

/**
 *
 */
declare interface nsIGleanNumeratorType extends nsISupportsType {
    /**
     * Increases the numerator by `amount`.
     *
     * @param amount The amount to increase by. Should be positive.
     */
    addToNumerator(amount: int32_t): void;
    /**
     * **Test-only API**
     *
     * Gets the currently stored value in the form {numerator: n, denominator: d}
     *
     * This function will attempt to await the last parent-process task (if any)
     * writing to the the metric's storage engine before returning a value.
     * This function will not wait for data from child processes.
     *
     * This doesn't clear the stored value.
     * Parent process only. Panics in child processes.
     *
     * @param aPingName The (optional) name of the ping to retrieve the metric
     * for. Defaults to the first value in `send_in_pings`.
     *
     * @return value of the stored metric, or undefined if there is no value.
     */
    testGetValue(aPingName: AUTF8String): jsval;
}

/**
 *
 */
declare interface nsIGleanRateType extends nsISupportsType {
    /**
     * Increases the numerator by `amount`.
     *
     * @param amount The amount to increase by. Should be positive.
     */
    addToNumerator(amount: int32_t): void;
    /**
     * Increases the denominator by `amount`.
     *
     * @param amount The amount to increase by. Should be positive.
     */
    addToDenominator(amount: int32_t): void;
    /**
     * **Test-only API**
     *
     * Gets the currently stored value in the form {numerator: n, denominator: d}
     *
     * This function will attempt to await the last parent-process task (if any)
     * writing to the the metric's storage engine before returning a value.
     * This function will not wait for data from child processes.
     *
     * This doesn't clear the stored value.
     * Parent process only. Panics in child processes.
     *
     * @param aPingName The (optional) name of the ping to retrieve the metric
     * for. Defaults to the first value in `send_in_pings`.
     *
     * @return value of the stored metric, or undefined if there is no value.
     */
    testGetValue(aPingName: AUTF8String): jsval;
}

/**
 *
 */
declare interface nsIGleanUrlType extends nsISupportsType {
    /**
     * Sets to the specified stringified URL.
     *
     * @param value The stringified URL to set the metric to.
     */
    set(value: AUTF8String): void;
    /**
     * **Test-only API**
     *
     * Gets the currently stored value as a string.
     *
     * This function will attempt to await the last parent-process task (if any)
     * writing to the the metric's storage engine before returning a value.
     * This function will not wait for data from child processes.
     *
     * This doesn't clear the stored value.
     * Parent process only. Panics in child processes.
     *
     * @param aPingName The (optional) name of the ping to retrieve the metric
     * for. Defaults to the first value in `send_in_pings`.
     *
     * @return value of the stored metric, or undefined if there is no value.
     */
    testGetValue(aPingName: AUTF8String): jsval;
}

/**
 *
 */
declare interface nsIGleanTextType extends nsISupportsType {
    /**
     * Set to the specified value.
     *
     * @param value The text to set the metric to.
     */
    set(value: AUTF8String): void;
    /**
     * **Test-only API**
     *
     * Gets the currently stored value as a string.
     *
     * This function will attempt to await the last parent-process task (if any)
     * writing to the the metric's storage engine before returning a value.
     * This function will not wait for data from child processes.
     *
     * This doesn't clear the stored value.
     * Parent process only. Panics in child processes.
     *
     * @param aPingName The (optional) name of the ping to retrieve the metric
     * for. Defaults to the first value in `send_in_pings`.
     *
     * @return value of the stored metric, or undefined if there is no value.
     */
    testGetValue(aPingName: AUTF8String): jsval;
}

/**
 *
 */
declare interface nsIGleanPingTestCallbackType extends nsISupportsType {
    /**
     *
     */
    call(aReason: ACString): void;
}

/**
 *
 */
declare interface nsIGleanPingType extends nsISupportsType {
    /**
     * Collect and submit the ping for eventual upload.
     *
     * This will collect all stored data to be included in the ping.
     * Data with lifetime `ping` will then be reset.
     *
     * If the ping is configured with `send_if_empty = false`
     * and the ping currently contains no content,
     * it will not be queued for upload.
     * If the ping is configured with `send_if_empty = true`
     * it will be queued for upload even if empty.
     *
     * Pings always contain the `ping_info` and `client_info` sections.
     * See [ping sections](https://mozilla.github.io/glean/book/user/pings/index.html#ping-sections)
     * for details.
     *
     * @param aReason - Optional. The reason the ping is being submitted.
     * Must match one of the configured `reason_codes`.
     */
    submit(aReason: ACString): void;
    /**
     * **Test-only API**
     *
     * Register a callback to be called right before this ping is next submitted.
     * The provided function is called exactly once before submitting.
     *
     * Note: The callback will be called on any call to submit.
     * A ping might not be sent afterwards, e.g. if the ping is empty and
     * `send_if_empty` is `false`.
     *
     * @param aCallback - The callback to call on the next submit.
     */
    testBeforeNextSubmit(aCallback: nsIGleanPingTestCallbackType): void;
}

/**
 * Allow the TaskbarProgress instance to set a new target window.
 */
declare interface nsIGtkTaskbarProgressType extends nsITaskbarProgressType {
    /**
     * Sets the window that is considered primary for purposes of
     * setting the XApp progress property.
     */
    setPrimaryWindow(aWindow: mozIDOMWindowProxy): void;
}

/**
 *
 */
declare interface nsIHTMLAbsPosEditorType extends nsISupportsType {
    /**
     * true if Absolute Positioning handling is enabled in the editor
     */
    absolutePositioningEnabled: boolean;
    /**
     * Utility methods
     * true if Snap To Grid is enabled in the editor.
     */
    snapToGridEnabled: boolean;
    /**
     * sets the grid size in pixels.
     * @param aSizeInPixels [IN] the size of the grid in pixels
     */
    gridSize: unsigned_long;
}

/**
 *
 */
declare interface nsIHTMLEditorType extends nsISupportsType {
    /**
     * ------------ Inline property methods --------------
     *
     * SetInlineProperty() sets the aggregate properties on the current selection
     *
     * @param aProperty   the property to set on the selection
     * @param aAttribute  the attribute of the property, if applicable.
     * May be null.
     * Example: aProperty="font", aAttribute="color"
     * @param aValue      if aAttribute is not null, the value of the attribute.
     * May be null.
     * Example: aProperty="font", aAttribute="color",
     * aValue="0x00FFFF"
     */
    setInlineProperty(aProperty: AString, aAttribute: AString, aValue: AString): void;
    /**
     * getInlinePropertyWithAttrValue() gets aggregate properties of the current
     * selection.  All object in the current selection are scanned and their
     * attributes are represented in a list of Property object.
     *
     * @param aProperty   the property to get on the selection
     * @param aAttribute  the attribute of the property, if applicable.
     * May be null.
     * Example: aProperty="font", aAttribute="color"
     * @param aValue      if aAttribute is not null, the value of the attribute.
     * May be null.
     * Example: aProperty="font", aAttribute="color",
     * aValue="0x00FFFF"
     * @param aFirst      [OUT] PR_TRUE if the first text node in the
     * selection has the property
     * @param aAny        [OUT] PR_TRUE if any of the text nodes in the
     * selection have the property
     * @param aAll        [OUT] PR_TRUE if all of the text nodes in the
     * selection have the property
     */
    getInlinePropertyWithAttrValue(aProperty: AString, aAttribute: AString, aValue: AString, aFirst: boolean, aAny: boolean, aAll: boolean): AString;
    /**
     * removeInlineProperty() removes a property which changes inline style of
     * text.  E.g., bold, italic, super and sub.
     *
     * @param aProperty   Tag name whcih represents the inline style you want to
     * remove.  E.g., "strong", "b", etc.
     * If "href", <a> element which has href attribute will be
     * removed.
     * If "name", <a> element which has non-empty name
     * attribute will be removed.
     * @param aAttribute  If aProperty is "font", aAttribute should be "face",
     * "size", "color" or "bgcolor".
     */
    removeInlineProperty(aProperty: AString, aAttribute: AString): void;
    /**
     * ------------ HTML content methods --------------
     *
     * Tests if a node is a BLOCK element according the the HTML 4.0 DTD.
     * This does NOT consider CSS effect on display type
     *
     * @param aNode      the node to test
     */
    nodeIsBlock(node: Node): boolean;
    /**
     * Insert some HTML source at the current location
     *
     * @param aInputString   the string to be inserted
     */
    insertHTML(aInputString: AString): void;
    /**
     * Rebuild the entire document from source HTML
     * Needed to be able to edit HEAD and other outside-of-BODY content
     *
     * @param aSourceString   HTML source string of the entire new document
     */
    rebuildDocumentFromSource(aSourceString: AString): void;
    /**
     * Insert an element, which may have child nodes, at the selection
     * Used primarily to insert a new element for various insert element dialogs,
     * but it enforces the HTML 4.0 DTD "CanContain" rules, so it should
     * be useful for other elements.
     *
     * @param aElement           The element to insert
     * @param aDeleteSelection   Delete the selection before inserting
     * If aDeleteSelection is PR_FALSE, then the element is inserted
     * after the end of the selection for all element except
     * Named Anchors, which insert before the selection
     */
    insertElementAtSelection(aElement: Element, aDeleteSelection: boolean): void;
    /**
     * Set the BaseURL for the document to the current URL
     * but only if the page doesn't have a <base> tag
     * This should be done after the document URL has changed,
     * such as after saving a file
     * This is used as base for relativizing link and image urls
     */
    updateBaseURL(): void;
    /**
     * ------------ Selection manipulation --------------
     *
     * Should these be moved to Selection?
     *
     * Set the selection at the suppled element
     *
     * @param aElement   An element in the document
     */
    selectElement(aElement: Element): void;
    /**
     * getParagraphState returns what block tag paragraph format is in
     * the selection.
     * @param aMixed     True if there is more than one format
     * @return           Name of block tag. "" is returned for none.
     */
    getParagraphState(aMixed: boolean): AString;
    /**
     * getFontFaceState returns what font face is in the selection.
     * @param aMixed    True if there is more than one font face
     * @return          Name of face.  Note: "tt" is returned for
     * tt tag.  "" is returned for none.
     */
    getFontFaceState(aMixed: boolean): AString;
    /**
     * getHighlightColorState returns what the highlight color of the selection.
     * @param aMixed     True if there is more than one font color
     * @return           Color string. "" is returned for none.
     */
    getHighlightColorState(aMixed: boolean): AString;
    /**
     * getListState returns what list type is in the selection.
     * @param aMixed    True if there is more than one type of list, or
     * if there is some list and non-list
     * @param aOL       The company that employs me.  No, really, it's
     * true if an "ol" list is selected.
     * @param aUL       true if an "ul" list is selected.
     * @param aDL       true if a "dl" list is selected.
     */
    getListState(aMixed: boolean, aOL: boolean, aUL: boolean, aDL: boolean): void;
    /**
     * getListItemState returns what list item type is in the selection.
     * @param aMixed    True if there is more than one type of list item, or
     * if there is some list and non-list
     * XXX This ignores `- ` element selected state.
     * For example, even if `- ` and `<dt>` are selected,
     * this is set to false.
     * @param aLI       true if "li" list items are selected.
     * @param aDT       true if "dt" list items are selected.
     * @param aDD       true if "dd" list items are selected.
     */
    getListItemState(aMixed: boolean, aLI: boolean, aDT: boolean, aDD: boolean): void;
    /**
     * getAlignment     returns what alignment is in the selection.
     * @param aMixed    Always returns false.
     * @param aAlign    enum value for first encountered alignment
     * (left/center/right)
     */
    getAlignment(aMixed: boolean, aAlign: short): void;
    /**
     * Document me!
     */
    makeOrChangeList(aListType: AString, entireList: boolean, aBulletType: AString): void;
    /**
     * removeList removes list items (- , <dd>, and <dt>) and list structures
     * (, , and <dl>).
     *
     * @param aListType  Unused.
     */
    removeList(aListType: AString): void;
    /**
     * GetElementOrParentByTagName() returns an inclusive ancestor element whose
     * name matches aTagName from aNode or anchor node of Selection to <body>
     * element or null if there is no element matching with aTagName.
     *
     * @param aTagName        The tag name which you want to look for.
     * Must not be empty string.
     * If "list", the result may be ,  or <dl>
     * element.
     * If "td", the result may be <td> or <th>.
     * If "href", the result may be <a> element
     * which has "href" attribute with non-empty value.
     * If "anchor", the result may be <a> which has
     * "name" attribute with non-empty value.
     * @param aNode           If non-null, this starts to look for the result
     * from it.  Otherwise, i.e., null, starts from
     * anchor node of Selection.
     * @return                If an element which matches aTagName, returns
     * an Element.  Otherwise, nullptr.
     */
    getElementOrParentByTagName(aTagName: AString, aNode: Node): Element;
    /**
     * getSelectedElement() returns a "selected" element node.  "selected" means:
     * - there is only one selection range
     * - the range starts from an element node or in an element
     * - the range ends at immediately after same element
     * - and the range does not include any other element nodes.
     * Additionally, only when aTagName is "href", this thinks that an <a>
     * element which has non-empty "href" attribute includes the range, the
     * <a> element is selected.
     *
     * @param aTagName    Case-insensitive element name.
     * If empty string, this returns any element node or null.
     * If "href", this returns an <a> element which has
     * non-empty "href" attribute or null.
     * If "anchor", this returns an <a> element which has
     * non-empty "name" attribute or null.
     * Otherwise, returns an element node whose name is
     * same as aTagName or null.
     * @return            A "selected" element.
     */
    getSelectedElement(aTagName: AString): nsISupports;
    /**
     * Return a new element with default attribute values
     *
     * This does not rely on the selection, and is not sensitive to context.
     *
     * Used primarily to supply new element for various insert element dialogs
     * (Image, Link, NamedAnchor, Table, and HorizontalRule
     * are the only returned elements as of 7/25/99)
     *
     * @param aTagName  The HTML tagname
     * Special input values for Links and Named anchors:
     * Use "href" to get a link node
     * (an "A" tag with the "href" attribute set)
     * Use "anchor" or "namedanchor" to get a named anchor node
     * (an "A" tag with the "name" attribute set)
     * @return          The new element created.
     */
    createElementWithDefaults(aTagName: AString): Element;
    /**
     * Insert an link element as the parent of the current selection
     *
     * @param aElement   An "A" element with a non-empty "href" attribute
     */
    insertLinkAroundSelection(aAnchorElement: Element): void;
    /**
     * Set the value of the "bgcolor" attribute on the document's <body> element
     *
     * @param aColor  The HTML color string, such as "#ffccff" or "yellow"
     */
    setBackgroundColor(aColor: AString): void;
    /**
     * A boolean which is true is the HTMLEditor has been instantiated
     * with CSS knowledge and if the CSS pref is currently checked
     *
     * @return    true if CSS handled and enabled
     */
    isCSSEnabled: boolean;
    /**
     * checkSelectionStateForAnonymousButtons() may refresh editing UI such as
     * resizers, inline-table-editing UI, absolute positioning UI for current
     * Selection and focus state.  When this method shows or hides UI, the
     * editor (and/or its document/window) could be broken by mutation observers.
     * FYI: Current user in script is only BlueGriffon.
     */
    checkSelectionStateForAnonymousButtons(): void;
    /**
     *
     */
    isAnonymousElement(aElement: Element): boolean;
    /**
     * A boolean indicating if a return key pressed in a paragraph creates
     * another paragraph or just inserts a <br> at the caret
     *
     * @return    true if CR in a paragraph creates a new paragraph
     */
    returnInParagraphCreatesNewParagraph: boolean;
}

/**
 *
 */
declare interface nsIHTMLInlineTableEditorType extends nsISupportsType {
    /**
     * boolean indicating if inline table editing is enabled in the editor.
     * When inline table editing is enabled, and when the selection is
     * contained in a table cell, special buttons allowing to add/remove
     * a line/column are available on the cell's border.
     */
    inlineTableEditingEnabled: boolean;
}

/**
 *
 */
declare interface nsIHTMLObjectResizerType extends nsISupportsType {
    /**
     * a boolean indicating if object resizing is enabled in the editor
     */
    objectResizingEnabled: boolean;
    /**
     * Hide resizers if they are visible.  If this is called while there is no
     * visible resizers, this does not throw exception, just does nothing.
     */
    hideResizers(): void;
}

/**
 *
 */
declare interface nsIHandlerServiceType extends nsISupportsType {
    /**
     * Asynchronously performs any IO that the nsIHandlerService needs to do
     * before it can be of use.
     */
    asyncInit(): void;
    /**
     * Retrieve a list of all handlers in the datastore.  This list is not
     * guaranteed to be in any particular order, and callers should not assume
     * it will remain in the same order in the future.
     *
     * @returns a list of all handlers in the datastore
     */
    enumerate(): nsISimpleEnumerator;
    /**
     * Fill a handler info object with information from the datastore.
     *
     * Note: because of the way the external helper app service currently mixes
     * OS and user handler info in the same handler info object, this method
     * takes an existing handler info object (probably retrieved from the OS)
     * and "fills it in" with information from the datastore, overriding any
     * existing properties on the object with properties from the datastore.
     *
     * Ultimately, however, we're going to separate OS and user handler info
     * into separate objects, at which point this method should be renamed to
     * something like "get" or "retrieve", take a class and type (or perhaps
     * a type whose class can be determined by querying the type, for example
     * an nsIContentType which is also an nsIMIMEType or an nsIProtocolScheme),
     * and return a handler info object representing only the user info.
     *
     * Note: if you specify an override type, then the service will fill in
     * the handler info object with information about that type instead of
     * the type specified by the object's nsIHandlerInfo::type attribute.
     *
     * This is useful when you are trying to retrieve information about a MIME
     * type that doesn't exist in the datastore, but you have a file extension
     * for that type, and nsIHandlerService::getTypeFromExtension returns another
     * MIME type that does exist in the datastore and can handle that extension.
     *
     * For example, the user clicks on a link, and the content has a MIME type
     * that isn't in the datastore, but the link has a file extension, and that
     * extension is associated with another MIME type in the datastore (perhaps
     * an unofficial MIME type preceded an official one, like with image/x-png
     * and image/png).
     *
     * In that situation, you can call this method to fill in the handler info
     * object with information about that other type by passing the other type
     * as the aOverrideType parameter.
     *
     * @param aHandlerInfo   the handler info object
     * @param aOverrideType  a type to use instead of aHandlerInfo::type
     *
     * Note: if there is no information in the datastore about this type,
     * this method throws NS_ERROR_NOT_AVAILABLE. Callers are encouraged to
     * check exists() before calling fillHandlerInfo(), to prevent spamming the
     * console with XPCOM exception errors.
     */
    fillHandlerInfo(aHandlerInfo: nsIHandlerInfoType, aOverrideType: ACString): void;
    /**
     * Save the preferred action, preferred handler, possible handlers, and
     * always ask properties of the given handler info object to the datastore.
     * Updates an existing record or creates a new one if necessary.
     *
     * Note: if preferred action is undefined or invalid, then we assume
     * the default value nsIHandlerInfo::useHelperApp.
     *
     * @param aHandlerInfo  the handler info object
     */
    store(aHandlerInfo: nsIHandlerInfoType): void;
    /**
     * Whether or not a record for the given handler info object exists
     * in the datastore. If the datastore is corrupt (or some other error
     * is caught in the implementation), false will be returned.
     *
     * @param aHandlerInfo  a handler info object
     *
     * @returns whether or not a record exists
     */
    exists(aHandlerInfo: nsIHandlerInfoType): boolean;
    /**
     * Remove the given handler info object from the datastore.  Deletes all
     * records associated with the object, including the preferred handler, info,
     * and type records plus the entry in the list of types, if they exist.
     * Otherwise, it does nothing and does not return an error.
     *
     * @param aHandlerInfo  the handler info object
     */
    remove(aHandlerInfo: nsIHandlerInfoType): void;
    /**
     * Get the MIME type mapped to the given file extension in the datastore.
     *
     * XXX If we ever support extension -> protocol scheme mappings, then this
     * method should work for those as well.
     *
     * Note: in general, you should use nsIMIMEService::getTypeFromExtension
     * to get a MIME type from a file extension, as that method checks a variety
     * of other sources besides just the datastore.  Use this only when you want
     * to specifically get only the mapping available in the datastore.
     *
     * @param aFileExtension  the file extension
     *
     * @returns the MIME type, if any; otherwise returns an empty string ("").
     */
    getTypeFromExtension(aFileExtension: ACString): ACString;
    /**
     * Whether or not there is a handler known to the OS for the
     * specified protocol type.
     *
     * @param aProtocolScheme scheme to check for support
     *
     * @returns whether or not a handler exists
     */
    existsForProtocolOS(aProtocolScheme: ACString): boolean;
    /**
     * Whether or not there is a handler in the datastore or OS for
     * the specified protocol type. If there is no handler in the datastore,
     * falls back to a check for an OS handler.
     *
     * @param aProtocolScheme scheme to check for support
     *
     * @returns whether or not a handler exists
     */
    existsForProtocol(aProtocolScheme: ACString): boolean;
    /**
     * Get a description for the application responsible for handling
     * the provided protocol.
     */
    getApplicationDescription(aProtocolScheme: ACString): AString;
}

/**
 * A scriptable interface for getting information about a BHR detected hang.
 * This is the type of the subject of the "bhr-thread-hang" observer topic.
 */
declare interface nsIHangDetailsType extends nsISupportsType {
    /**
     * The hang was persisted to disk as a permahang, so we can clear the
     * permahang file once we submit this.
     */
    readonly wasPersisted: bool;
    /**
     * The detected duration of the hang in milliseconds.
     */
    readonly duration: double;
    /**
     * The name of the thread which hung.
     */
    readonly thread: ACString;
    /**
     * The name of the runnable which hung if it hung on the main thread.
     */
    readonly runnableName: ACString;
    /**
     * The type of process which produced the hang. This should be either:
     * "default", "content", or "gpu".
     */
    readonly process: ACString;
    /**
     * The remote type of the content process which produced the hang.
     */
    readonly remoteType: AUTF8String;
    /**
     * Returns the stack which was captured by BHR. The offset is encoded as a hex
     * string, as it can contain numbers larger than JS can hold losslessly.
     *
     * This value takes the following form:
     * [ [moduleIndex, offset], ... ]
     */
    readonly stack: jsval;
    /**
     * Returns the modules which were captured by BHR.
     *
     * This value takes the following form:
     * [ ["fileName", "BreakpadId"], ... ]
     */
    readonly modules: jsval;
    /**
     * The hang annotations which were captured when the hang occured. This
     * attribute is a JS object of key-value pairs.
     */
    readonly annotations: jsval;
}

/**
 * When a content process hangs, Gecko notifies "process-hang-report" observers
 * and passes an nsIHangReport for the subject parameter. There is at most one
 * nsIHangReport associated with a given content process. As long as the content
 * process stays stuck, the "process-hang-report" observer will continue to be
 * notified at regular intervals (approximately once per second). The content
 * process will continue to run uninhibitedly during this time.
 */
declare interface nsIHangReportType extends nsISupportsType {
    /**
     *
     */
    readonly scriptBrowser: Element;
    /**
     *
     */
    readonly scriptFileName: ACString;
    /**
     *
     */
    readonly hangDuration: double;
    /**
     *
     */
    readonly addonId: AString;
    /**
     *
     */
    readonly childID: unsigned_long_long;
    /**
     *
     */
    userCanceled(): void;
    /**
     *
     */
    terminateScript(): void;
    /**
     *
     */
    beginStartingDebugger(): void;
    /**
     *
     */
    endStartingDebugger(): void;
    /**
     *
     */
    isReportForBrowserOrChildren(aFrameLoader: FrameLoader): bool;
}

/**
 *
 */
declare interface nsIHapticFeedbackType extends nsISupportsType {
    /**
     * Perform haptic feedback
     *
     * @param isLongPress
     * indicate whether feedback is for a long press (vs. short press)
     */
    performSimpleAction(isLongPress: long): void;
}

/**
 * This interface is used to display a confirmation dialog before
 * launching a "helper app" to handle content not handled by
 * Mozilla.
 *
 * Usage:  Clients (of which there is one: the nsIExternalHelperAppService
 * implementation in mozilla/uriloader/exthandler) create an instance of
 * this interface (using the contract ID) and then call the show() method.
 *
 * The dialog is shown non-modally.  The implementation of the dialog
 * will access methods of the nsIHelperAppLauncher passed in to show()
 * in order to cause a "save to disk" or "open using" action.
 */
declare interface nsIHelperAppLauncherDialogType extends nsISupportsType {
    /**
     * Show confirmation dialog for launching application (or "save to
     * disk") for content specified by aLauncher.
     *
     * @param aLauncher
     * A nsIHelperAppLauncher to be invoked when a file is selected.
     * @param aWindowContext
     * Window associated with action.
     * @param aReason
     * One of the constants from above. It indicates why the dialog is
     * shown. Implementors should treat unknown reasons like
     * REASON_CANTHANDLE.
     */
    show(aLauncher: nsIHelperAppLauncherType, aWindowContext: nsIInterfaceRequestorType, aReason: unsigned_long): void;
    /**
     * Async invoke a save-to-file dialog instead of the full fledged helper app
     * dialog. When the file is chosen (or the dialog is closed), the callback
     * in aLauncher (aLauncher.saveDestinationAvailable) is called with the
     * selected file.
     *
     * @param aLauncher
     * A nsIHelperAppLauncher to be invoked when a file is selected.
     * @param aWindowContext
     * Window associated with action.
     * @param aDefaultFileName
     * Default file name to provide (can be null)
     * @param aSuggestedFileExtension
     * Sugested file extension
     * @param aForcePrompt
     * Set to true to force prompting the user for thet file
     * name/location, otherwise perferences may control if the user is
     * prompted.
     */
    promptForSaveToFileAsync(aLauncher: nsIHelperAppLauncherType, aWindowContext: nsIInterfaceRequestorType, aDefaultFileName: wstring, aSuggestedFileExtension: wstring, aForcePrompt: boolean): void;
}

/**
 * nsIHttpActivityObserver
 *
 * This interface provides a way for http activities to be reported
 * to observers.
 */
declare interface nsIHttpActivityObserverType extends nsISupportsType {
    /**
     * observe activity from the http transport
     *
     * @param aHttpChannel
     * nsISupports interface for the the http channel that
     * generated this activity
     * @param aActivityType
     * The value of this aActivityType will be one of
     * ACTIVITY_TYPE_SOCKET_TRANSPORT or
     * ACTIVITY_TYPE_HTTP_TRANSACTION
     * @param aActivitySubtype
     * The value of this aActivitySubtype, will be depend
     * on the value of aActivityType. When aActivityType
     * is ACTIVITY_TYPE_SOCKET_TRANSPORT
     * aActivitySubtype will be one of the
     * nsISocketTransport::STATUS_???? values defined in
     * nsISocketTransport.idl
     * OR when aActivityType
     * is ACTIVITY_TYPE_HTTP_TRANSACTION
     * aActivitySubtype will be one of the
     * nsIHttpActivityObserver::ACTIVITY_SUBTYPE_???? values
     * defined below
     * @param aTimestamp
     * microseconds past the epoch of Jan 1, 1970
     * @param aExtraSizeData
     * Any extra size data optionally available with
     * this activity
     * @param aExtraStringData
     * Any extra string data optionally available with
     * this activity
     */
    observeActivity(aHttpChannel: nsISupportsType, aActivityType: uint32_t, aActivitySubtype: uint32_t, aTimestamp: PRTime, aExtraSizeData: uint64_t, aExtraStringData: ACString): void;
    /**
     * This attribute is true when this interface is active and should
     * observe http activities. When false, observeActivity() should not
     * be called. It is present for compatibility reasons and should be
     * implemented only by nsHttpActivityDistributor.
     */
    readonly isActive: boolean;
    /**
     * This function is for testing only. We use this function to observe the
     * activities of HTTP connections. To receive this notification,
     * observeConnection should be set to true.
     */
    observeConnectionActivity(aHost: ACString, aPort: int32_t, aSSL: boolean, aHasECH: boolean, aIsHttp3: boolean, aActivityType: uint32_t, aActivitySubtype: uint32_t, aTimestamp: PRTime, aExtraStringData: ACString): void;
}

/**
 * nsIHttpActivityDistributor
 *
 * This interface provides a way to register and unregister observers to the
 * http activities.
 */
declare interface nsIHttpActivityDistributorType extends nsIHttpActivityObserverType {
    /**
     *
     */
    addObserver(aObserver: nsIHttpActivityObserverType): void;
    /**
     *
     */
    removeObserver(aObserver: nsIHttpActivityObserverType): void;
    /**
     * When true, the ACTIVITY_SUBTYPE_PROXY_RESPONSE_HEADER will be sent to
     * the observers.
     */
    observeProxyResponse: boolean;
    /**
     * When true, the ACTIVITY_TYPE_HTTP_CONNECTION will be sent to
     * the observers.
     */
    observeConnection: boolean;
}

/**
 * nsIHttpAuthManager
 *
 * This service provides access to cached HTTP authentication
 * user credentials (domain, username, password) for sites
 * visited during the current browser session.
 *
 * This interface exists to provide other HTTP stacks with the
 * ability to share HTTP authentication credentials with Necko.
 * This is currently used by the Java plugin (version 1.5 and
 * higher) to avoid duplicate authentication prompts when the
 * Java client fetches content from a HTTP site that the user
 * has already logged into.
 */
declare interface nsIHttpAuthManagerType extends nsISupportsType {
    /**
     * Lookup auth identity.
     *
     * @param aScheme
     * the URL scheme (e.g., "http").  NOTE: for proxy authentication,
     * this should be "http" (this includes authentication for CONNECT
     * tunneling).
     * @param aHost
     * the host of the server issuing a challenge (ASCII only).
     * @param aPort
     * the port of the server issuing a challenge.
     * @param aAuthType
     * optional string identifying auth type used (e.g., "basic")
     * @param aRealm
     * optional string identifying auth realm.
     * @param aPath
     * optional string identifying auth path. empty for proxy auth.
     * @param aUserDomain
     * return value containing user domain.
     * @param aUserName
     * return value containing user name.
     * @param aUserPassword
     * return value containing user password.
     * @param aIsPrivate
     * whether to look up a private or public identity (they are
     * stored separately, for use by private browsing)
     * @param aPrincipal
     * the principal from which to derive information about which
     * app/mozbrowser is in use for this request
     */
    getAuthIdentity(aScheme: ACString, aHost: ACString, aPort: int32_t, aAuthType: ACString, aRealm: ACString, aPath: ACString, aUserDomain: AString, aUserName: AString, aUserPassword: AString, aIsPrivate: bool, aPrincipal: nsIPrincipalType): void;
    /**
     * Store auth identity.
     *
     * @param aScheme
     * the URL scheme (e.g., "http").  NOTE: for proxy authentication,
     * this should be "http" (this includes authentication for CONNECT
     * tunneling).
     * @param aHost
     * the host of the server issuing a challenge (ASCII only).
     * @param aPort
     * the port of the server issuing a challenge.
     * @param aAuthType
     * optional string identifying auth type used (e.g., "basic")
     * @param aRealm
     * optional string identifying auth realm.
     * @param aPath
     * optional string identifying auth path. empty for proxy auth.
     * @param aUserDomain
     * optional string containing user domain.
     * @param aUserName
     * optional string containing user name.
     * @param aUserPassword
     * optional string containing user password.
     * @param aIsPrivate
     * whether to store a private or public identity (they are
     * stored separately, for use by private browsing)
     * @param aPrincipal
     * the principal from which to derive information about which
     * app/mozbrowser is in use for this request
     */
    setAuthIdentity(aScheme: ACString, aHost: ACString, aPort: int32_t, aAuthType: ACString, aRealm: ACString, aPath: ACString, aUserDomain: AString, aUserName: AString, aUserPassword: AString, aIsPrivate: boolean, aPrincipal: nsIPrincipalType): void;
    /**
     * Clear all auth cache.
     */
    clearAll(): void;
}

/**
 *
 */
declare interface nsIHttpAuthenticableChannelType extends nsIProxiedChannelType {
    /**
     * If the channel being authenticated is using SSL.
     */
    readonly isSSL: boolean;
    /**
     * Returns if the proxy HTTP method used is CONNECT. If no proxy is being
     * used it must return PR_FALSE.
     */
    readonly proxyMethodIsConnect: boolean;
    /**
     * Cancels the current request. See nsIRequest.
     */
    cancel(aStatus: nsresult): void;
    /**
     * The load flags of this request. See nsIRequest.
     */
    readonly loadFlags: nsLoadFlags;
    /**
     * The URI corresponding to the channel. See nsIChannel.
     */
    readonly URI: nsIURI;
    /**
     * The load group of this request. It is here for querying its
     * notificationCallbacks. See nsIRequest.
     */
    readonly loadGroup: nsILoadGroup;
    /**
     * The notification callbacks for the channel. See nsIChannel.
     */
    readonly notificationCallbacks: nsIInterfaceRequestor;
    /**
     * The HTTP request method. See nsIHttpChannel.
     */
    readonly requestMethod: ACString;
    /**
     * The "Server" response header.
     * Return NS_ERROR_NOT_AVAILABLE if not available.
     */
    readonly serverResponseHeader: ACString;
    /**
     * The Proxy-Authenticate response header.
     */
    readonly proxyChallenges: ACString;
    /**
     * The WWW-Authenticate response header.
     */
    readonly WWWChallenges: ACString;
    /**
     * Sets the Proxy-Authorization request header. An empty string
     * will clear it.
     */
    setProxyCredentials(credentials: ACString): void;
    /**
     * Sets the Authorization request header. An empty string
     * will clear it.
     */
    setWWWCredentials(credentials: ACString): void;
    /**
     * Called when authentication information is ready and has been set on this
     * object using setWWWCredentials/setProxyCredentials. Implementations can
     * continue with the request and send the given information to the server.
     *
     * It is called asynchronously from
     * nsIHttpChannelAuthProvider::processAuthentication if that method returns
     * NS_ERROR_IN_PROGRESS.
     *
     * @note  Any exceptions thrown from this method should be ignored.
     */
    onAuthAvailable(): void;
    /**
     * Notifies that the prompt was cancelled. It is called asynchronously
     * from nsIHttpChannelAuthProvider::processAuthentication if that method
     * returns NS_ERROR_IN_PROGRESS.
     *
     * @param userCancel
     * If the user was cancelled has cancelled the authentication prompt.
     */
    onAuthCancelled(userCancel: boolean): void;
    /**
     * Tells the channel to drop and close any sticky connection, since this
     * connection oriented schema cannot be negotiated second time on
     * the same connection.
     */
    closeStickyConnection(): void;
    /**
     * Tells the channel to mark the connection as allowed to restart on
     * authentication retry.  This is allowed when the request is a start
     * of a new authentication round.
     */
    connectionRestartable(restartable: boolean): void;
}

/**
 * nsIHttpAuthenticator
 *
 * Interface designed to allow for pluggable HTTP authentication modules.
 * Implementations are registered under the ContractID:
 *
 * "@mozilla.org/network/http-authenticator;1?scheme=<auth-scheme>"
 *
 * where <auth-scheme> is the lower-cased value of the authentication scheme
 * found in the server challenge per the rules of RFC 2617.
 */
declare interface nsIHttpAuthenticatorType extends nsISupportsType {
    /**
     * Upon receipt of a server challenge, this function is called to determine
     * whether or not the current user identity has been rejected.  If true,
     * then the user will be prompted by the channel to enter (or revise) their
     * identity.  Following this, generateCredentials will be called.
     *
     * If the IDENTITY_IGNORED auth flag is set, then the aInvalidateIdentity
     * return value will be ignored, and user prompting will be suppressed.
     *
     * @param aChannel
     * the http channel that received the challenge.
     * @param aChallenge
     * the challenge from the WWW-Authenticate/Proxy-Authenticate
     * server response header.  (possibly from the auth cache.)
     * @param aProxyAuth
     * flag indicating whether or not aChallenge is from a proxy.
     * @param aSessionState
     * see description below for generateCredentials.
     * @param aContinuationState
     * see description below for generateCredentials.
     * @param aInvalidateIdentity
     * return value indicating whether or not to prompt the user for a
     * revised identity.
     */
    challengeReceived(aChannel: nsIHttpAuthenticableChannelType, aChallenge: ACString, aProxyAuth: boolean, aSessionState: nsISupportsType, aContinuationState: nsISupportsType, aInvalidatesIdentity: boolean): void;
    /**
     * Called to generate the authentication credentials for a particular
     * server/proxy challenge asynchronously. Credentials will be sent back
     * to the server via an Authorization/Proxy-Authorization header.
     *
     * @param aChannel
     * the http channel requesting credentials
     * @param aCallback
     * callback function to be called when credentials are available
     * @param aChallenge
     * the challenge from the WWW-Authenticate/Proxy-Authenticate
     * server response header.  (possibly from the auth cache.)
     * @param aProxyAuth
     * flag indicating whether or not aChallenge is from a proxy.
     * @param aDomain
     * string containing the domain name (if appropriate)
     * @param aUser
     * string containing the user name
     * @param aPassword
     * string containing the password
     * @param aSessionState
     * state stored along side the user's identity in the auth cache
     * for the lifetime of the browser session.  if a new auth cache
     * entry is created for this challenge, then this parameter will
     * be null.  on return, the result will be stored in the new auth
     * cache entry.  this parameter is non-null when an auth cache entry
     * is being reused. currently modification of session state is not
     * communicated to caller, thus caching credentials obtained by
     * asynchronous way is not supported.
     * @param aContinuationState
     * state held by the channel between consecutive calls to
     * generateCredentials, assuming multiple calls are required
     * to authenticate.  this state is held for at most the lifetime of
     * the channel.
     * @pram aCancel
     * returns cancellable runnable object which caller can use to cancel
     * calling aCallback when finished.
     */
    generateCredentialsAsync(aChannel: nsIHttpAuthenticableChannelType, aCallback: nsIHttpAuthenticatorCallbackType, aChallenge: ACString, aProxyAuth: boolean, aDomain: AString, aUser: AString, aPassword: AString, aSessionState: nsISupportsType, aContinuationState: nsISupportsType, aCancel: nsICancelableType): void;
    /**
     * Called to generate the authentication credentials for a particular
     * server/proxy challenge.  This is the value that will be sent back
     * to the server via an Authorization/Proxy-Authorization header.
     *
     * This function may be called using a cached challenge provided the
     * authenticator sets the REUSABLE_CHALLENGE flag.
     *
     * @param aChannel
     * the http channel requesting credentials
     * @param aChallenge
     * the challenge from the WWW-Authenticate/Proxy-Authenticate
     * server response header.  (possibly from the auth cache.)
     * @param aProxyAuth
     * flag indicating whether or not aChallenge is from a proxy.
     * @param aDomain
     * string containing the domain name (if appropriate)
     * @param aUser
     * string containing the user name
     * @param aPassword
     * string containing the password
     * @param aSessionState
     * state stored along side the user's identity in the auth cache
     * for the lifetime of the browser session.  if a new auth cache
     * entry is created for this challenge, then this parameter will
     * be null.  on return, the result will be stored in the new auth
     * cache entry.  this parameter is non-null when an auth cache entry
     * is being reused.
     * @param aContinuationState
     * state held by the channel between consecutive calls to
     * generateCredentials, assuming multiple calls are required
     * to authenticate.  this state is held for at most the lifetime of
     * the channel.
     * @param aFlags
     * authenticator may return one of the generate flags bellow.
     */
    generateCredentials(aChannel: nsIHttpAuthenticableChannelType, aChallenge: ACString, aProxyAuth: boolean, aDomain: AString, aUser: AString, aPassword: AString, aSessionState: nsISupportsType, aContinuationState: nsISupportsType, aFlags: unsigned_long): ACString;
    /**
     * Flags defining various properties of the authenticator.
     */
    readonly authFlags: unsigned_long;
}

/**
 *
 */
declare interface nsIHttpAuthenticatorCallbackType extends nsISupportsType {
    /**
     * Authentication data for a header is available.
     *
     * @param aCreds
     * Credentials which were obtained asynchonously.
     * @param aFlags
     * Flags set by asynchronous call.
     * @param aResult
     * Result status of credentials generation
     * @param aSessionState
     * Modified session state to be passed to caller
     * @param aContinuationState
     * Modified continuation state to be passed to caller
     */
    onCredsGenerated(aCreds: ACString, aFlags: unsigned_long, aResult: nsresult, aSessionsState: nsISupportsType, aContinuationState: nsISupportsType): void;
}

/**
 * nsIHttpChannel
 *
 * This interface allows for the modification of HTTP request parameters and
 * the inspection of the resulting HTTP response status and headers when they
 * become available.
 */
declare interface nsIHttpChannelType extends nsIIdentChannelType {
    /**
     * ************************************************************************
     * REQUEST CONFIGURATION
     *
     * Modifying request parameters after asyncOpen has been called is an error.
     * Set/get the HTTP request method (default is "GET").  Both setter and
     * getter are case sensitive.
     *
     * This attribute may only be set before the channel is opened.
     *
     * NOTE: The data for a "POST" or "PUT" request can be configured via
     * nsIUploadChannel; however, after setting the upload data, it may be
     * necessary to set the request method explicitly.  The documentation
     * for nsIUploadChannel has further details.
     *
     * @throws NS_ERROR_IN_PROGRESS if set after the channel has been opened.
     */
    requestMethod: ACString;
    /**
     * Get/set the referrer information.  This contains the referrer (URI) of the
     * resource from which this channel's URI was obtained (see RFC2616 section
     * 14.36) and the referrer policy applied to the referrer.
     *
     * This attribute may only be set before the channel is opened.
     *
     * Setting this attribute will clone new referrerInfo object by default.
     *
     * NOTE: The channel may silently refuse to set the Referer header if the
     * URI does not pass certain security checks (e.g., a "https://" URL will
     * never be sent as the referrer for a plaintext HTTP request).  The
     * implementation is not required to throw an exception when the referrer
     * URI is rejected.
     *
     * @throws NS_ERROR_IN_PROGRESS if set after the channel has been opened.
     * @throws NS_ERROR_FAILURE if used for setting referrer during
     * visitRequestHeaders. Getting the value will not throw.
     */
    referrerInfo: nsIReferrerInfo;
    /**
     * Returns the network protocol used to fetch the resource as identified
     * by the ALPN Protocol ID.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called before the response
     * has been received (before onStartRequest).
     */
    readonly protocolVersion: ACString;
    /**
     * size consumed by the response header fields and the response payload body
     */
    readonly transferSize: uint64_t;
    /**
     * size consumed by the request header fields and the request payload body
     */
    readonly requestSize: uint64_t;
    /**
     * The size of the message body received by the client,
     * after removing any applied content-codings
     */
    readonly decodedBodySize: uint64_t;
    /**
     * The size in octets of the payload body, prior to removing content-codings
     */
    readonly encodedBodySize: uint64_t;
    /**
     * Get the value of a particular request header.
     *
     * @param aHeader
     * The case-insensitive name of the request header to query (e.g.,
     * "Cache-Control").
     *
     * @return the value of the request header.
     * @throws NS_ERROR_NOT_AVAILABLE if the header is not set.
     */
    getRequestHeader(aHeader: ACString): ACString;
    /**
     * Set the value of a particular request header.
     *
     * This method allows, for example, the cookies module to add "Cookie"
     * headers to the outgoing HTTP request.
     *
     * This method may only be called before the channel is opened.
     *
     * @param aHeader
     * The case-insensitive name of the request header to set (e.g.,
     * "Cookie").
     * @param aValue
     * The request header value to set (e.g., "X=1").
     * @param aMerge
     * If true, the new header value will be merged with any existing
     * values for the specified header.  This flag is ignored if the
     * specified header does not support merging (e.g., the "Content-
     * Type" header can only have one value).  The list of headers for
     * which this flag is ignored is an implementation detail.  If this
     * flag is false, then the header value will be replaced with the
     * contents of |aValue|.
     *
     * If aValue is empty and aMerge is false, the header will be cleared.
     *
     * @throws NS_ERROR_IN_PROGRESS if called after the channel has been
     * opened.
     * @throws NS_ERROR_FAILURE if called during visitRequestHeaders.
     */
    setRequestHeader(aHeader: ACString, aValue: ACString, aMerge: boolean): void;
    /**
     * Creates and sets new ReferrerInfo object
     * @param aUrl          referrer url
     * @param aPolicy       referrer policy of the created object
     * @param aSendReferrer indicates if the referrer should not be sent or not
     * even when it's available.
     */
    setNewReferrerInfo(aUrl: ACString, aPolicy: nsIReferrerInfo_ReferrerPolicyIDLType, aSendReferrer: boolean): void;
    /**
     * Set a request header with empty value.
     *
     * This should be used with caution in the cases where the behavior of
     * setRequestHeader ignoring empty header values is undesirable.
     *
     * This method may only be called before the channel is opened.
     *
     * @param aHeader
     * The case-insensitive name of the request header to set (e.g.,
     * "Cookie").
     *
     * @throws NS_ERROR_IN_PROGRESS if called after the channel has been
     * opened.
     * @throws NS_ERROR_FAILURE if called during visitRequestHeaders.
     */
    setEmptyRequestHeader(aHeader: ACString): void;
    /**
     * Call this method to visit all request headers.  Calling setRequestHeader
     * while visiting request headers has undefined behavior.  Don't do it!
     *
     * @param aVisitor
     * the header visitor instance.
     */
    visitRequestHeaders(aVisitor: nsIHttpHeaderVisitorType): void;
    /**
     * Call this method to visit all non-default (UA-provided) request headers.
     * Calling setRequestHeader while visiting request headers has undefined
     * behavior. Don't do it!
     *
     * @param aVisitor
     * the header visitor instance.
     */
    visitNonDefaultRequestHeaders(aVisitor: nsIHttpHeaderVisitorType): void;
    /**
     * Call this method to see if we need to strip the request body headers
     * for the new http channel. This should be called during redirection.
     */
    ShouldStripRequestBodyHeader(aMethod: ACString): bool;
    /**
     * This attribute of the channel indicates whether or not
     * the underlying HTTP transaction should be honor stored Strict Transport
     * Security directives for its principal. It defaults to true. Using
     * OCSP to bootstrap the HTTPs is the likely use case for setting it to
     * false.
     *
     * This attribute may only be set before the channel is opened.
     *
     * @throws NS_ERROR_IN_PROGRESS or NS_ERROR_ALREADY_OPENED
     * if called after the channel has been opened.
     */
    allowSTS: boolean;
    /**
     * This attribute specifies the number of redirects this channel is allowed
     * to make.  If zero, the channel will fail to redirect and will generate
     * a NS_ERROR_REDIRECT_LOOP failure status.
     *
     * NOTE: An HTTP redirect results in a new channel being created.  If the
     * new channel supports nsIHttpChannel, then it will be assigned a value
     * to its |redirectionLimit| attribute one less than the value of the
     * redirected channel's |redirectionLimit| attribute.  The initial value
     * for this attribute may be a configurable preference (depending on the
     * implementation).
     */
    redirectionLimit: unsigned_long;
    /**
     * ************************************************************************
     * RESPONSE INFO
     *
     * Accessing response info before the onStartRequest event is an error.
     * Get the HTTP response code (e.g., 200).
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called before the response
     * has been received (before onStartRequest).
     */
    readonly responseStatus: unsigned_long;
    /**
     * Get the HTTP response status text (e.g., "OK").
     *
     * NOTE: This returns the raw (possibly 8-bit) text from the server.  There
     * are no assumptions made about the charset of the returned text.  You
     * have been warned!
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called before the response
     * has been received (before onStartRequest).
     */
    readonly responseStatusText: ACString;
    /**
     * Returns true if the HTTP response code indicates success.  The value of
     * nsIRequest::status will be NS_OK even when processing a 404 response
     * because a 404 response may include a message body that (in some cases)
     * should be shown to the user.
     *
     * Use this attribute to distinguish server error pages from normal pages,
     * instead of comparing the response status manually against the set of
     * valid response codes, if that is required by your application.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called before the response
     * has been received (before onStartRequest).
     */
    readonly requestSucceeded: boolean;
    /**
     * Indicates whether channel should be treated as the main one for the
     * current document.  If manually set to true, will always remain true.  Otherwise,
     * will be true if LOAD_DOCUMENT_URI is set in the channel's loadflags.
     */
    isMainDocumentChannel: boolean;
    /**
     * Get the value of a particular response header.
     *
     * @param aHeader
     * The case-insensitive name of the response header to query (e.g.,
     * "Set-Cookie").
     *
     * @return the value of the response header.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called before the response
     * has been received (before onStartRequest) or if the header is
     * not set in the response.
     */
    getResponseHeader(header: ACString): ACString;
    /**
     * Set the value of a particular response header.
     *
     * This method allows, for example, the HTML content sink to inform the HTTP
     * channel about HTTP-EQUIV headers found in HTML <META> tags.
     *
     * @param aHeader
     * The case-insensitive name of the response header to set (e.g.,
     * "Cache-control").
     * @param aValue
     * The response header value to set (e.g., "no-cache").
     * @param aMerge
     * If true, the new header value will be merged with any existing
     * values for the specified header.  This flag is ignored if the
     * specified header does not support merging (e.g., the "Content-
     * Type" header can only have one value).  The list of headers for
     * which this flag is ignored is an implementation detail.  If this
     * flag is false, then the header value will be replaced with the
     * contents of |aValue|.
     *
     * If aValue is empty and aMerge is false, the header will be cleared.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called before the response
     * has been received (before onStartRequest).
     * @throws NS_ERROR_ILLEGAL_VALUE if changing the value of this response
     * header is not allowed.
     * @throws NS_ERROR_FAILURE if called during visitResponseHeaders,
     * VisitOriginalResponseHeaders or getOriginalResponseHeader.
     */
    setResponseHeader(header: ACString, value: ACString, merge: boolean): void;
    /**
     * Call this method to visit all response headers.  Calling
     * setResponseHeader while visiting response headers has undefined
     * behavior.  Don't do it!
     *
     * @param aVisitor
     * the header visitor instance.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called before the response
     * has been received (before onStartRequest).
     */
    visitResponseHeaders(aVisitor: nsIHttpHeaderVisitorType): void;
    /**
     * Get the value(s) of a particular response header in the form and order
     * it has been received from the remote peer. There can be multiple headers
     * with the same name.
     *
     * @param aHeader
     * The case-insensitive name of the response header to query (e.g.,
     * "Set-Cookie").
     *
     * @param aVisitor
     * the header visitor instance.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called before the response
     * has been received (before onStartRequest) or if the header is
     * not set in the response.
     */
    getOriginalResponseHeader(aHeader: ACString, aVisitor: nsIHttpHeaderVisitorType): void;
    /**
     * Call this method to visit all response headers in the form and order as
     * they have been received from the remote peer.
     * Calling setResponseHeader while visiting response headers has undefined
     * behavior.  Don't do it!
     *
     * @param aVisitor
     * the header visitor instance.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called before the response
     * has been received (before onStartRequest).
     */
    visitOriginalResponseHeaders(aVisitor: nsIHttpHeaderVisitorType): void;
    /**
     * Returns true if the server sent a "Cache-Control: no-store" response
     * header.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called before the response
     * has been received (before onStartRequest).
     */
    isNoStoreResponse(): boolean;
    /**
     * Returns true if the server sent the equivalent of a "Cache-control:
     * no-cache" response header.  Equivalent response headers include:
     * "Pragma: no-cache", "Expires: 0", and "Expires" with a date value
     * in the past relative to the value of the "Date" header.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called before the response
     * has been received (before onStartRequest).
     */
    isNoCacheResponse(): boolean;
    /**
     * Returns true if the server sent a "Cache-Control: private" response
     * header.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called before the response
     * has been received (before onStartRequest).
     */
    isPrivateResponse(): boolean;
    /**
     * Instructs the channel to immediately redirect to a new destination.
     * Can only be called on channels that have not yet called their
     * listener's OnStartRequest(). Generally that means the latest time
     * this can be used is one of:
     * "http-on-examine-response"
     * "http-on-examine-merged-response"
     * "http-on-examine-cached-response"
     *
     * When non-null URL is set before AsyncOpen:
     * we attempt to redirect to the targetURI before we even start building
     * and sending the request to the cache or the origin server.
     * If the redirect is vetoed, we fail the channel.
     *
     * When set between AsyncOpen and first call to OnStartRequest being called:
     * we attempt to redirect before we start delivery of network or cached
     * response to the listener.  If vetoed, we continue with delivery of
     * the original content to the channel listener.
     *
     * When passed aTargetURI is null the channel behaves normally (can be
     * rewritten).
     *
     * This method provides no explicit conflict resolution. The last
     * caller to call it wins.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called after the channel has already
     * started to deliver the content to its listener.
     */
    redirectTo(aTargetURI: nsIURIType): void;
    /**
     * Flags a channel to be upgraded to HTTPS.
     *
     * Upgrading to a secure channel must happen before or during
     * "http-on-modify-request". If redirectTo is called early as well, it
     * will win and upgradeToSecure will be a no-op.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called after the channel has already
     * started to deliver the content to its listener.
     */
    upgradeToSecure(): void;
    /**
     * Identifies the request context for this load.
     */
    requestContextID: uint64_t;
    /**
     * ID of the top-level document's inner window.  Identifies the content
     * this channels is being load in.
     */
    topLevelContentWindowId: uint64_t;
    /**
     * ID of the browser for this channel.
     *
     * NOTE: The setter of this attribute is currently for xpcshell test only.
     * Don't alter it otherwise.
     */
    browserId: uint64_t;
    /**
     * In e10s, the information that the CORS response blocks the load is in the
     * parent, which doesn't know the true window id of the request, so we may
     * need to proxy the request to the child.
     *
     * @param aMessage
     * The message to print in the console.
     *
     * @param aCategory
     * The category under which the message should be displayed.
     *
     * @param aIsWarning
     * When true, this is a warning message.
     */
    logBlockedCORSRequest(aMessage: AString, aCategory: ACString, aIsWarning: boolean): void;
    /**
     *
     */
    logMimeTypeMismatch(aMessageName: ACString, aWarning: boolean, aURL: AString, aContentType: AString): void;
    /**
     *
     */
    setSource(aSource: UniqueProfileChunkedBuffer): void;
    /**
     *
     */
    classicScriptHintCharset: AString;
    /**
     *
     */
    documentCharacterSet: AString;
}

/**
 * nsIHttpChannelAuthProvider
 *
 * This interface is intended for providing authentication for http-style
 * channels, like nsIHttpChannel and nsIWebSocket, which implement the
 * nsIHttpAuthenticableChannel interface.
 *
 * When requesting pages AddAuthorizationHeaders MUST be called
 * in order to get the http cached headers credentials. When the request is
 * unsuccessful because of receiving either a 401 or 407 http response code
 * ProcessAuthentication MUST be called and the page MUST be requested again
 * with the new credentials that the user has provided. After a successful
 * request, checkForSuperfluousAuth MAY be called, and disconnect MUST be
 * called.
 */
declare interface nsIHttpChannelAuthProviderType extends nsICancelableType {
    /**
     * Initializes the http authentication support for the channel.
     * Implementations must hold a weak reference of the channel.
     */
    init(channel: nsIHttpAuthenticableChannelType): void;
    /**
     * Upon receipt of a server challenge, this function is called to determine
     * the credentials to send.
     *
     * @param httpStatus
     * the http status received.
     * @param sslConnectFailed
     * if the last ssl tunnel connection attempt was or not successful.
     * @param callback
     * the callback to be called when it returns NS_ERROR_IN_PROGRESS.
     * The implementation must hold a weak reference.
     *
     * @returns NS_OK if the credentials were got and set successfully.
     * NS_ERROR_IN_PROGRESS if the credentials are going to be asked to
     * the user. The channel reference must be
     * alive until the feedback from
     * nsIHttpAuthenticableChannel's methods or
     * until disconnect be called.
     */
    processAuthentication(httpStatus: unsigned_long, sslConnectFailed: boolean): void;
    /**
     * Add credentials from the http auth cache.
     *
     * @param dontUseCachedWWWCreds
     * When true, the method will not add any Authorization headers from
     * the auth cache.
     */
    addAuthorizationHeaders(dontUseCachedWWWCreds: boolean): void;
    /**
     * Check if an unnecessary(and maybe malicious) url authentication has been
     * provided.
     */
    checkForSuperfluousAuth(): void;
    /**
     * Cancel pending user auth prompts and release the callback and channel
     * weak references.
     */
    disconnect(status: nsresult): void;
    /**
     * Clear the proxy ident to not consider it invalid on re-athentication.
     * Called when the channel finds out its transaction has been internally
     * restarted.
     */
    clearProxyIdent(): void;
}

/**
 *
 */
declare interface nsIHttpChannelChildType extends nsISupportsType {
    /**
     *
     */
    addCookiesToRequest(): void;
    /**
     *
     */
    readonly clientSetRequestHeaders: RequestHeaderTuples;
    /**
     *
     */
    GetClientSetCorsPreflightParameters(args: MaybeCorsPreflightArgsRef): void;
    /**
     *
     */
    removeCorsPreflightCacheEntry(aURI: nsIURIType, aRequestingPrincipal: nsIPrincipalType, aOriginAttributes: const_OriginAttributes): void;
}

/**
 * The callback interface for nsIHttpChannelInternal::HTTPUpgrade()
 */
declare interface nsIHttpUpgradeListenerType extends nsISupportsType {
    /**
     *
     */
    onTransportAvailable(aTransport: nsISocketTransportType, aSocketIn: nsIAsyncInputStreamType, aSocketOut: nsIAsyncOutputStreamType): void;
    /**
     *
     */
    onUpgradeFailed(aErrorCode: nsresult): void;
    /**
     *
     */
    onWebSocketConnectionAvailable(aConnection: WebSocketConnectionBase): void;
}

/**
 * Dumping ground for http.  This interface will never be frozen.  If you are
 * using any feature exposed by this interface, be aware that this interface
 * will change and you will be broken.  You have been warned.
 */
declare interface nsIHttpChannelInternalType extends nsISupportsType {
    /**
     * An http channel can own a reference to the document URI
     */
    documentURI: nsIURI;
    /**
     * Get the major/minor version numbers for the request
     */
    getRequestVersion(major: unsigned_long, minor: unsigned_long): void;
    /**
     * Get the major/minor version numbers for the response
     */
    getResponseVersion(major: unsigned_long, minor: unsigned_long): void;
    /**
     * Helper method to set a cookie with a consumer-provided
     * cookie header, _but_ using the channel's other information
     * (URI's, prompters, date headers etc).
     *
     * @param aCookieHeader
     * The cookie header to be parsed.
     */
    setCookie(aCookieHeader: ACString): void;
    /**
     * Returns true in case this channel is used for auth;
     * (the response header includes 'www-authenticate').
     */
    readonly isAuthChannel: bool;
    /**
     * When set, these flags modify the algorithm used to decide whether to
     * send 3rd party cookies for a given channel.
     */
    thirdPartyFlags: unsigned_long;
    /**
     * This attribute was added before the "flags" above and is retained here
     * for compatibility. When set to true, has the same effect as
     * THIRD_PARTY_FORCE_ALLOW, described above.
     */
    forceAllowThirdPartyCookie: boolean;
    /**
     * External handlers may set this to true to notify the channel
     * that it is open on behalf of a download.
     */
    channelIsForDownload: boolean;
    /**
     * The local IP address to which this channel is bound, in the
     * format produced by PR_NetAddrToString. May be IPv4 or IPv6.
     * Note: in the presence of NAT, this may not be the same as the
     * address that the remote host thinks it's talking to.
     *
     * May throw NS_ERROR_NOT_AVAILABLE if accessed when the channel's
     * endpoints are not yet determined, or in any case when
     * nsIHttpActivityObserver.isActive is false. See bugs 534698 and 526207.
     */
    readonly localAddress: AUTF8String;
    /**
     * The local port number to which this channel is bound.
     *
     * May throw NS_ERROR_NOT_AVAILABLE if accessed when the channel's
     * endpoints are not yet determined, or in any case when
     * nsIHttpActivityObserver.isActive is false. See bugs 534698 and 526207.
     */
    readonly localPort: int32_t;
    /**
     * The IP address of the remote host that this channel is
     * connected to, in the format produced by PR_NetAddrToString.
     *
     * May throw NS_ERROR_NOT_AVAILABLE if accessed when the channel's
     * endpoints are not yet determined, or in any case when
     * nsIHttpActivityObserver.isActive is false. See bugs 534698 and 526207.
     */
    readonly remoteAddress: AUTF8String;
    /**
     * The remote port number that this channel is connected to.
     *
     * May throw NS_ERROR_NOT_AVAILABLE if accessed when the channel's
     * endpoints are not yet determined, or in any case when
     * nsIHttpActivityObserver.isActive is false. See bugs 534698 and 526207.
     */
    readonly remotePort: int32_t;
    /**
     * HTTPUpgrade allows for the use of HTTP to bootstrap another protocol
     * via the RFC 2616 Upgrade request header in conjunction with a 101 level
     * response. The nsIHttpUpgradeListener will have its
     * onTransportAvailable() method invoked if a matching 101 is processed.
     * The arguments to onTransportAvailable provide the new protocol the low
     * level tranport streams that are no longer used by HTTP. If any errors
     * occur during the upgrade but the original request has (potentially)
     * already received onStopRequest, the nsIHttpUpgradeListener will have its
     * onUpgradeFailed() method invoked instead of onTransportAvailable().
     *
     * The onStartRequest and onStopRequest events are still delivered and the
     * listener gets full control over the socket if and when onTransportAvailable
     * is delivered. Note that if onStopRequest is called with an error, no
     * methods on the nsIHttpUpgradeListener might be invoked at all.
     *
     * @param aProtocolName
     * The value of the HTTP Upgrade request header
     * @param aListener
     * The callback object used to handle a successful upgrade
     */
    HTTPUpgrade(aProtocolName: ACString, aListener: nsIHttpUpgradeListenerType): void;
    /**
     * Enable only CONNECT to a proxy. Fails if no HTTPUpgrade listener
     * has been defined. An ALPN header is set using the upgrade protocol.
     *
     * Load flags are set with INHIBIT_CACHING, LOAD_ANONYMOUS,
     * LOAD_BYPASS_CACHE, and LOAD_BYPASS_SERVICE_WORKER.
     *
     * Proxy resolve flags are set with RESOLVE_PREFER_HTTPS_PROXY and
     * RESOLVE_ALWAYS_TUNNEL.
     */
    setConnectOnly(): void;
    /**
     * True iff the channel is CONNECT only.
     */
    readonly onlyConnect: boolean;
    /**
     * Enable/Disable Spdy negotiation on per channel basis.
     * The network.http.http2.enabled preference is still a pre-requisite
     * for starting spdy.
     */
    allowSpdy: boolean;
    /**
     * Enable/Disable HTTP3 negotiation on per channel basis.
     * The network.http.http3.enable preference is still a pre-requisite
     * for starting HTTP3.
     */
    allowHttp3: boolean;
    /**
     * This attribute en/disables the timeout for the first byte of an HTTP
     * response. Enabled by default.
     */
    responseTimeoutEnabled: boolean;
    /**
     * If the underlying transport supports RWIN manipulation, this is the
     * intiial window value for the channel. HTTP/2 implements this.
     * 0 means no override from system default. Set before opening channel.
     */
    initialRwin: unsigned_long;
    /**
     * Get value of the URI passed to nsIHttpChannel.redirectTo() if any.
     * May return null when redirectTo() has not been called.
     */
    readonly apiRedirectToURI: nsIURI;
    /**
     * Enable/Disable use of Alternate Services with this channel.
     * The network.http.altsvc.enabled preference is still a pre-requisite.
     */
    allowAltSvc: boolean;
    /**
     * If true, do not use newer protocol features that might have interop problems
     * on the Internet. Intended only for use with critical infra like the updater.
     * default is false.
     */
    beConservative: boolean;
    /**
     * If true, do not resolve any proxy for this request. Intended only for use with
     * critical infra like the updater.
     * default is false.
     */
    bypassProxy: boolean;
    /**
     * True if channel is used by the internal trusted recursive resolver
     * This flag places data for the request in a cache segment specific to TRR
     */
    isTRRServiceChannel: boolean;
    /**
     * If the channel's remote IP was resolved using TRR.
     * Is false for resources loaded from the cache or resources that have an
     * IP literal host.
     */
    readonly isResolvedByTRR: boolean;
    /**
     * The effective TRR mode used to resolve this channel.
     * This is computed by taking the value returned by nsIRequest.getTRRMode()
     * and the state of the TRRService. If the domain is excluded from TRR
     * or the TRRService is disabled, the effective mode would be TRR_DISABLED_MODE
     * even if the initial mode set on the request was TRR_ONLY_MODE.
     */
    readonly effectiveTRRMode: nsIRequest_TRRMode;
    /**
     * If the DNS request triggered by this channel didn't use TRR, this value
     * contains the reason why that was skipped.
     */
    readonly trrSkipReason: nsITRRSkipReason_value;
    /**
     * True if channel is loaded by socket process.
     */
    readonly isLoadedBySocketProcess: boolean;
    /**
     * Set to true if the channel is an OCSP check.
     * Channels with this flag set will skip TRR in mode3 (because the circular
     * dependency with checking OCSP for the TRR server will cause a failure)
     */
    isOCSP: boolean;
    /**
     * An opaque flags for non-standard behavior of the TLS system.
     * It is unlikely this will need to be set outside of telemetry studies
     * relating to the TLS implementation.
     */
    tlsFlags: unsigned_long;
    /**
     *
     */
    readonly lastModifiedTime: PRTime;
    /**
     * Set by nsCORSListenerProxy if credentials should be included in
     * cross-origin requests. false indicates "same-origin", users should still
     * check flag LOAD_ANONYMOUS!
     */
    corsIncludeCredentials: boolean;
    /**
     * Set by nsCORSListenerProxy to indicate CORS load type. Defaults to CORS_MODE_NO_CORS.
     */
    requestMode: RequestMode;
    /**
     * Set to indicate Request.redirect mode exposed during ServiceWorker
     * interception. No policy enforcement is performed by the channel for this
     * value.
     */
    redirectMode: unsigned_long;
    /**
     * Set to indicate Request.cache mode, which simulates the fetch API
     * semantics, and is also used for exposing this value to the Web page
     * during service worker interception.
     */
    fetchCacheMode: unsigned_long;
    /**
     * The URI of the top-level window that's associated with this channel.
     */
    readonly topWindowURI: nsIURI;
    /**
     * Set top-level window URI to this channel only when the topWindowURI
     * is null and there is no window associated to this channel.
     * Note that the current usage of this method is only for xpcshell test.
     */
    setTopWindowURIIfUnknown(topWindowURI: nsIURIType): void;
    /**
     * Read the proxy URI, which, if non-null, will be used to resolve
     * proxies for this channel.
     */
    readonly proxyURI: nsIURI;
    /**
     * When set to true, the channel will not pop any authentication prompts up
     * to the user.  When provided or cached credentials lead to an
     * authentication failure, that failure will be propagated to the channel
     * listener.  Must be called before opening the channel, otherwise throws.
     */
    blockAuthPrompt: boolean;
    /**
     * Set to indicate Request.integrity.
     */
    integrityMetadata: AString;
    /**
     * The connection info's hash key. We use it to test connection separation.
     */
    readonly connectionInfoHashKey: ACString;
    /**
     * If this channel was created as the result of a redirect, then this
     * value will reflect the redirect flags passed to the
     * SetupReplacementChannel() method.
     */
    lastRedirectFlags: unsigned_long;
    /**
     *
     */
    navigationStartTimeStamp: TimeStamp;
    /**
     * The channel will be loaded over IPv6, disabling IPv4.
     */
    setIPv4Disabled(): void;
    /**
     * The channel will be loaded over IPv4, disabling IPv6.
     */
    setIPv6Disabled(): void;
    /**
     * Returns a cached CrossOriginOpenerPolicy that is computed just before we
     * determine if there is a policy mismatch.
     * @throws NS_ERROR_NOT_AVAILABLE if it has not been computed yet
     */
    readonly crossOriginOpenerPolicy: nsILoadInfo_CrossOriginOpenerPolicy;
    /**
     * If this is called, this channel's transaction will not be dispatched
     * until the HTTPSSVC record is available.
     */
    setWaitForHTTPSSVCRecord(): void;
    /**
     * This attribute indicates if the channel has support for HTTP3
     */
    readonly supportsHTTP3: boolean;
    /**
     * This attribute indicates if the HTTPS RR is used for this channel.
     */
    readonly hasHTTPSRR: boolean;
    /**
     * Set Early Hint Observer.
     */
    setEarlyHintObserver(aObserver: nsIEarlyHintObserverType): void;
    /**
     * id of the EarlyHintPreloader to connect back from PreloadService to
     * EarlyHintPreloader.
     */
    earlyHintPreloaderId: unsigned_long_long;
    /**
     *
     */
    setConnectionInfo(aInfo: nsHttpConnectionInfo): void;
    /**
     * This attribute indicates if the channel was loaded via Proxy.
     */
    readonly isProxyUsed: boolean;
    /**
     * Set mWebTransportSessionEventListener.
     */
    setWebTransportSessionEventListener(aListener: WebTransportSessionEventListener): void;
    /**
     * This attribute indicates the type of Link header in the received
     * 103 response.
     */
    earlyHintLinkType: unsigned_long;
}

/**
 * Implement this interface to visit http headers.
 */
declare interface nsIHttpHeaderVisitorType extends nsISupportsType {
    /**
     * Called by the nsIHttpChannel implementation when visiting request and
     * response headers.
     *
     * @param aHeader
     * the header being visited.
     * @param aValue
     * the header value (possibly a comma delimited list).
     *
     * @throw any exception to terminate enumeration
     */
    visitHeader(aHeader: ACString, aValue: ACString): void;
}

/**
 *
 */
declare interface nsIHttpProtocolHandlerType extends nsIProxiedProtocolHandlerType {
    /**
     * Get the HTTP advertised user agent string.
     */
    readonly userAgent: ACString;
    /**
     * Get the HTTP advertised user agent string.
     */
    readonly rfpUserAgent: ACString;
    /**
     * Get the application name.
     *
     * @return The name of this application (eg. "Mozilla").
     */
    readonly appName: ACString;
    /**
     * Get the application version string.
     *
     * @return The complete version (major and minor) string. (eg. "5.0")
     */
    readonly appVersion: ACString;
    /**
     * Get the current platform.
     *
     * @return The platform this application is running on
     * (eg. "Windows", "Macintosh", "X11")
     */
    readonly platform: ACString;
    /**
     * Get the current oscpu.
     *
     * @return The oscpu this application is running on
     */
    readonly oscpu: ACString;
    /**
     * Get the application comment misc portion.
     */
    readonly misc: ACString;
    /**
     * This function is used to ensure HSTS data storage is ready to read after
     * the returned promise is resolved.
     * Note that this function should only used for testing.
     * See bug 1521729 for more details.
     */
    EnsureHSTSDataReady(): Promise;
    /**
     * Clears the CORS preflight cache.
     */
    clearCORSPreflightCache(): void;
}

/**
 * nsIHttpPushListener
 *
 * Used for triggering when a HTTP/2 push is received.
 */
declare interface nsIHttpPushListenerType extends nsISupportsType {
    /**
     * When provided as a notificationCallback to an httpChannel, this.onPush()
     * will be invoked when there is a >= Http2 push to that
     * channel. The push may be in progress.
     *
     * The consumer must start the new channel in the usual way by calling
     * pushChannel.AsyncOpen with a nsIStreamListener object that
     * will receive the normal sequence of OnStartRequest(),
     * 0 to N OnDataAvailable(), and onStopRequest().
     *
     * The new channel can be canceled after the AsyncOpen if it is not wanted.
     *
     * @param associatedChannel
     * the monitor channel that was recieved on
     * @param pushChannel
     * a channel to the resource which is being pushed
     */
    onPush(associatedChannel: nsIHttpChannelType, pushChannel: nsIHttpChannelType): void;
}

/**
 * An interface which represents an HTTP server.
 */
declare interface nsIHttpServerType extends nsISupportsType {
    /**
     * Starts up this server, listening upon the given port.
     *
     * @param port
     * the port upon which listening should happen, or -1 if no specific port is
     * desired
     * @throws NS_ERROR_ALREADY_INITIALIZED
     * if this server is already started
     * @throws NS_ERROR_NOT_AVAILABLE
     * if the server is not started and cannot be started on the desired port
     * (perhaps because the port is already in use or because the process does
     * not have privileges to do so)
     * @note
     * Behavior is undefined if this method is called after stop() has been
     * called on this but before the provided callback function has been
     * called.
     */
    start(port: long): void;
    /**
     * Starts up this server, listening upon the given port on a ipv6 adddress.
     *
     * @param port
     * the port upon which listening should happen, or -1 if no specific port is
     * desired
     * @throws NS_ERROR_ALREADY_INITIALIZED
     * if this server is already started
     * @throws NS_ERROR_NOT_AVAILABLE
     * if the server is not started and cannot be started on the desired port
     * (perhaps because the port is already in use or because the process does
     * not have privileges to do so)
     * @note
     * Behavior is undefined if this method is called after stop() has been
     * called on this but before the provided callback function has been
     * called.
     */
    start_ipv6(port: long): void;
    /**
     * Like the two functions above, but this server supports both IPv6 and
     * IPv4 addresses.
     */
    start_dualStack(port: long): void;
    /**
     * Shuts down this server if it is running (including the period of time after
     * stop() has been called but before the provided callback has been called).
     *
     * @param callback
     * an asynchronous callback used to notify the user when this server is
     * stopped and all pending requests have been fully served
     * @throws NS_ERROR_NULL_POINTER
     * if callback is null
     * @throws NS_ERROR_UNEXPECTED
     * if this server is not running
     */
    stop(callback: nsIHttpServerStoppedCallbackType): void;
    /**
     * Associates the local file represented by the string file with all requests
     * which match request.
     *
     * @param path
     * the path which is to be mapped to the given file; must begin with "/" and
     * be a valid URI path (i.e., no query string, hash reference, etc.)
     * @param file
     * the file to serve for the given path, or null to remove any mapping that
     * might exist; this file must exist for the lifetime of the server
     * @param handler
     * an optional object which can be used to handle any further changes.
     */
    registerFile(path: string, file: nsIFileType, handler: nsIHttpRequestHandlerType): void;
    /**
     * Registers a custom path handler.
     *
     * @param path
     * the path on the server (beginning with a "/") which is to be handled by
     * handler; this path must not include a query string or hash component; it
     * also should usually be canonicalized, since most browsers will do so
     * before sending otherwise-matching requests
     * @param handler
     * an object which will handle any requests for the given path, or null to
     * remove any existing handler; if while the server is running the handler
     * throws an exception while responding to a request, an HTTP 500 response
     * will be returned
     * @throws NS_ERROR_INVALID_ARG
     * if path does not begin with a "/"
     */
    registerPathHandler(path: string, handler: nsIHttpRequestHandlerType): void;
    /**
     * Registers a custom prefix handler.
     *
     * @param prefix
     * the path on the server (beginning and ending with "/") which is to be
     * handled by handler; this path must not include a query string or hash
     * component. All requests that start with this prefix will be directed to
     * the given handler.
     * @param handler
     * an object which will handle any requests for the given path, or null to
     * remove any existing handler; if while the server is running the handler
     * throws an exception while responding to a request, an HTTP 500 response
     * will be returned
     * @throws NS_ERROR_INVALID_ARG
     * if path does not begin with a "/" or does not end with a "/"
     */
    registerPrefixHandler(prefix: string, handler: nsIHttpRequestHandlerType): void;
    /**
     * Registers a custom error page handler.
     *
     * @param code
     * the error code which is to be handled by handler
     * @param handler
     * an object which will handle any requests which generate the given status
     * code, or null to remove any existing handler.  If the handler throws an
     * exception during server operation, fallback is to the genericized error
     * handler (the x00 version), then to 500, using a user-defined error
     * handler if one exists or the server default handler otherwise.  Fallback
     * will never occur from a user-provided handler that throws to the same
     * handler as provided by the server, e.g. a throwing user 404 falls back to
     * 400, not a server-provided 404 that might not throw.
     * @note
     * If the error handler handles HTTP 500 and throws, behavior is undefined.
     */
    registerErrorHandler(code: unsigned_long, handler: nsIHttpRequestHandlerType): void;
    /**
     * Maps all requests to paths beneath path to the corresponding file beneath
     * dir.
     *
     * @param path
     * the absolute path on the server against which requests will be served
     * from dir (e.g., "/", "/foo/", etc.); must begin and end with a forward
     * slash
     * @param dir
     * the directory to be used to serve all requests for paths underneath path
     * (except those further overridden by another, deeper path registered with
     * another directory); if null, any current mapping for the given path is
     * removed
     * @throws NS_ERROR_INVALID_ARG
     * if dir is non-null and does not exist or is not a directory, or if path
     * does not begin with and end with a forward slash
     */
    registerDirectory(path: string, dir: nsIFileType): void;
    /**
     * Associates files with the given extension with the given Content-Type when
     * served by this server, in the absence of any file-specific information
     * about the desired Content-Type.  If type is empty, removes any extant
     * mapping, if one is present.
     *
     * @throws NS_ERROR_INVALID_ARG
     * if the given type is not a valid header field value, i.e. if it doesn't
     * match the field-value production in RFC 2616
     * @note
     * No syntax checking is done of the given type, beyond ensuring that it is
     * a valid header field value.  Behavior when not given a string matching
     * the media-type production in RFC 2616 section 3.7 is undefined.
     * Implementations may choose to define specific behavior for types which do
     * not match the production, such as for CGI functionality.
     * @note
     * Implementations MAY treat type as a trusted argument; users who fail to
     * generate this string from trusted data risk security vulnerabilities.
     */
    registerContentType(extension: string, type: string): void;
    /**
     * Sets the handler used to display the contents of a directory if
     * the directory contains no index page.
     *
     * @param handler
     * an object which will handle any requests for directories which
     * do not contain index pages, or null to reset to the default
     * index handler; if while the server is running the handler
     * throws an exception while responding to a request, an HTTP 500
     * response will be returned.  An nsIFile corresponding to the
     * directory is available from the metadata object passed to the
     * handler, under the key "directory".
     */
    setIndexHandler(handler: nsIHttpRequestHandlerType): void;
    /**
     * Represents the locations at which this server is reachable.
     */
    readonly identity: nsIHttpServerIdentity;
    /**
     * Retrieves the string associated with the given key in this, for the given
     * path's saved state.  All keys are initially associated with the empty
     * string.
     */
    getState(path: AString, key: AString): AString;
    /**
     * Sets the string associated with the given key in this, for the given path's
     * saved state.
     */
    setState(path: AString, key: AString, value: AString): void;
    /**
     * Retrieves the string associated with the given key in this, in
     * entire-server saved state.  All keys are initially associated with the
     * empty string.
     */
    getSharedState(key: AString): AString;
    /**
     * Sets the string associated with the given key in this, in entire-server
     * saved state.
     */
    setSharedState(key: AString, value: AString): void;
    /**
     * Retrieves the object associated with the given key in this in
     * object-valued saved state.  All keys are initially associated with null.
     */
    getObjectState(key: AString): nsISupports;
    /**
     * Sets the object associated with the given key in this in object-valued
     * saved state.  The value may be null.
     */
    setObjectState(key: AString, value: nsISupportsType): void;
}

/**
 * An interface through which a notification of the complete stopping (socket
 * closure, in-flight requests all fully served and responded to) of an HTTP
 * server may be received.
 */
declare interface nsIHttpServerStoppedCallbackType extends nsISupportsType {
    /**
     * Called when the corresponding server has been fully stopped.
     */
    onStopped(): void;
}

/**
 * Represents a set of names for a server, one of which is the primary name for
 * the server and the rest of which are secondary.  By default every server will
 * contain ("http", "localhost", port) and ("http", "127.0.0.1", port) as names,
 * where port is what was provided to the corresponding server when started;
 * however, except for their being removed when the corresponding server stops
 * they have no special importance.
 */
declare interface nsIHttpServerIdentityType extends nsISupportsType {
    /**
     * The primary scheme at which the corresponding server is located, defaulting
     * to 'http'.  This name will be the value of nsIHttpRequest.scheme for
     * HTTP/1.0 requests.
     *
     * This value is always set when the corresponding server is running.  If the
     * server is not running, this value is set only if it has been set to a
     * non-default name using setPrimary.  In this case reading this value will
     * throw NS_ERROR_NOT_INITIALIZED.
     */
    readonly primaryScheme: string;
    /**
     * The primary name by which the corresponding server is known, defaulting to
     * 'localhost'.  This name will be the value of nsIHttpRequest.host for
     * HTTP/1.0 requests.
     *
     * This value is always set when the corresponding server is running.  If the
     * server is not running, this value is set only if it has been set to a
     * non-default name using setPrimary.  In this case reading this value will
     * throw NS_ERROR_NOT_INITIALIZED.
     */
    readonly primaryHost: string;
    /**
     * The primary port on which the corresponding server runs, defaulting to the
     * associated server's port.  This name will be the value of
     * nsIHttpRequest.port for HTTP/1.0 requests.
     *
     * This value is always set when the corresponding server is running.  If the
     * server is not running, this value is set only if it has been set to a
     * non-default name using setPrimary.  In this case reading this value will
     * throw NS_ERROR_NOT_INITIALIZED.
     */
    readonly primaryPort: long;
    /**
     * Adds a location at which this server may be accessed.
     *
     * @throws NS_ERROR_ILLEGAL_VALUE
     * if scheme or host do not match the scheme or host productions imported
     * into RFC 2616 from RFC 2396, or if port is not a valid port number
     */
    add(scheme: string, host: string, port: long): void;
    /**
     * Removes this name from the list of names by which the corresponding server
     * is known.  If name is also the primary name for the server, the primary
     * name reverts to 'http://127.0.0.1' with the associated server's port.
     *
     * @throws NS_ERROR_ILLEGAL_VALUE
     * if scheme or host do not match the scheme or host productions imported
     * into RFC 2616 from RFC 2396, or if port is not a valid port number
     * @returns
     * true if the given name was a name for this server, false otherwise
     */
    remove(scheme: string, host: string, port: long): boolean;
    /**
     * Returns true if the given name is in this, false otherwise.
     *
     * @throws NS_ERROR_ILLEGAL_VALUE
     * if scheme or host do not match the scheme or host productions imported
     * into RFC 2616 from RFC 2396, or if port is not a valid port number
     */
    has(scheme: string, host: string, port: long): boolean;
    /**
     * Returns the scheme for the name with the given host and port, if one is
     * present; otherwise returns the empty string.
     *
     * @throws NS_ERROR_ILLEGAL_VALUE
     * if host does not match the host production imported into RFC 2616 from
     * RFC 2396, or if port is not a valid port number
     */
    getScheme(host: string, port: long): string;
    /**
     * Designates the given name as the primary name in this and adds it to this
     * if it is not already present.
     *
     * @throws NS_ERROR_ILLEGAL_VALUE
     * if scheme or host do not match the scheme or host productions imported
     * into RFC 2616 from RFC 2396, or if port is not a valid port number
     */
    setPrimary(scheme: string, host: string, port: long): void;
}

/**
 * A representation of a handler for HTTP requests.  The handler is used by
 * calling its .handle method with data for an incoming request; it is the
 * handler's job to use that data as it sees fit to make the desired response.
 *
 * @note
 * This interface uses the [function] attribute, so you can pass a
 * script-defined function with the functionality of handle() to any
 * method which has a nsIHttpRequestHandler parameter, instead of wrapping
 * it in an otherwise empty object.
 */
declare interface nsIHttpRequestHandlerType extends nsISupportsType {
    /**
     * Processes an HTTP request and initializes the passed-in response to reflect
     * the correct HTTP response.
     *
     * If this method throws an exception, externally observable behavior depends
     * upon whether is being processed asynchronously.  If such is the case, the
     * output is some prefix (perhaps all, perhaps none, perhaps only some) of the
     * data which would have been sent if, instead, the response had been finished
     * at that point.  If no data has been written, the response has not had
     * seizePower() called on it, and it is not being asynchronously created, an
     * error handler will be invoked (usually 500 unless otherwise specified).
     *
     * Some uses of nsIHttpRequestHandler may require this method to never throw
     * an exception; in the general case, however, this method may throw an
     * exception (causing an HTTP 500 response to occur, if the above conditions
     * are met).
     *
     * @param request
     * data representing an HTTP request
     * @param response
     * an initially-empty response which must be modified to reflect the data
     * which should be sent as the response to the request described by metadata
     */
    handle(request: nsIHttpRequestType, response: nsIHttpResponseType): void;
}

/**
 * A representation of the data included in an HTTP request.
 */
declare interface nsIHttpRequestType extends nsISupportsType {
    /**
     * The request type for this request (see RFC 2616, section 5.1.1).
     */
    readonly method: string;
    /**
     * The scheme of the requested path, usually 'http' but might possibly be
     * 'https' if some form of SSL tunneling is in use.  Note that this value
     * cannot be accurately determined unless the incoming request used the
     * absolute-path form of the request line; it defaults to 'http', so only
     * if it is something else can you be entirely certain it's correct.
     */
    readonly scheme: string;
    /**
     * The host of the data being requested (e.g. "localhost" for the
     * http://localhost:8080/file resource).  Note that the relevant port on the
     * host is specified in this.port.  This value is in the ASCII character
     * encoding.
     */
    readonly host: string;
    /**
     * The port on the server on which the request was received.
     */
    readonly port: unsigned_long;
    /**
     * The requested path, without any query string (e.g. "/dir/file.txt").  It is
     * guaranteed to begin with a "/".  The individual components in this string
     * are URL-encoded.
     */
    readonly path: string;
    /**
     * The URL-encoded query string associated with this request, not including
     * the initial "?", or "" if no query string was present.
     */
    readonly queryString: string;
    /**
     * A string containing the HTTP version of the request (i.e., "1.1").  Leading
     * zeros for either component of the version will be omitted.  (In other
     * words, if the request contains the version "1.01", this attribute will be
     * "1.1"; see RFC 2616, section 3.1.)
     */
    readonly httpVersion: string;
    /**
     * Returns the value for the header in this request specified by fieldName.
     *
     * @param fieldName
     * the name of the field whose value is to be gotten; note that since HTTP
     * header field names are case-insensitive, this method produces equivalent
     * results for "HeAdER" and "hEADer" as fieldName
     * @returns
     * The result is a string containing the individual values of the header,
     * usually separated with a comma.  The headers WWW-Authenticate,
     * Proxy-Authenticate, and Set-Cookie violate the HTTP specification,
     * however, and for these headers only the separator string is '\n'.
     *
     * @throws NS_ERROR_INVALID_ARG
     * if fieldName does not constitute a valid header field name
     * @throws NS_ERROR_NOT_AVAILABLE
     * if the given header does not exist in this
     */
    getHeader(fieldName: string): string;
    /**
     * Returns true if a header with the given field name exists in this, false
     * otherwise.
     *
     * @param fieldName
     * the field name whose existence is to be determined in this; note that
     * since HTTP header field names are case-insensitive, this method produces
     * equivalent results for "HeAdER" and "hEADer" as fieldName
     * @throws NS_ERROR_INVALID_ARG
     * if fieldName does not constitute a valid header field name
     */
    hasHeader(fieldName: string): boolean;
    /**
     * An nsISimpleEnumerator of nsISupportsStrings over the names of the headers
     * in this request.  The header field names in the enumerator may not
     * necessarily have the same case as they do in the request itself.
     */
    readonly headers: nsISimpleEnumerator;
    /**
     * A stream from which data appearing in the body of this request can be read.
     */
    readonly bodyInputStream: nsIInputStream;
}

/**
 * Represents an HTTP response, as described in RFC 2616, section 6.
 */
declare interface nsIHttpResponseType extends nsISupportsType {
    /**
     * Sets the status line for this.  If this method is never called on this, the
     * status line defaults to "HTTP/", followed by the server's default HTTP
     * version (e.g. "1.1"), followed by " 200 OK".
     *
     * @param httpVersion
     * the HTTP version of this, as a string (e.g. "1.1"); if null, the server
     * default is used
     * @param code
     * the numeric HTTP status code for this
     * @param description
     * a human-readable description of code; may be null if no description is
     * desired
     * @throws NS_ERROR_INVALID_ARG
     * if httpVersion is not a valid HTTP version string, statusCode is greater
     * than 999, or description contains invalid characters
     * @throws NS_ERROR_NOT_AVAILABLE
     * if this response is being processed asynchronously and data has been
     * written to this response's body, or if seizePower() has been called on
     * this
     */
    setStatusLine(httpVersion: string, statusCode: unsigned_short, description: string): void;
    /**
     * Sets the specified header in this.
     *
     * @param name
     * the name of the header; must match the field-name production per RFC 2616
     * @param value
     * the value of the header; must match the field-value production per RFC
     * 2616
     * @param merge
     * when true, if the given header already exists in this, the values passed
     * to this function will be merged into the existing header, per RFC 2616
     * header semantics (except for the Set-Cookie, WWW-Authenticate, and
     * Proxy-Authenticate headers, which will treat each such merged header as
     * an additional instance of the header, for real-world compatibility
     * reasons); when false, replaces any existing header of the given name (if
     * any exists) with a new header with the specified value
     * @throws NS_ERROR_INVALID_ARG
     * if name or value is not a valid header component
     * @throws NS_ERROR_NOT_AVAILABLE
     * if this response is being processed asynchronously and data has been
     * written to this response's body, or if seizePower() has been called on
     * this
     */
    setHeader(name: string, value: string, merge: boolean): void;
    /**
     * This is used for testing our header handling, so header will be sent out
     * without transformation. There can be multiple headers.
     */
    setHeaderNoCheck(name: string, value: string): void;
    /**
     * A stream to which data appearing in the body of this response (or in the
     * totality of the response if seizePower() is called) should be written.
     * After this response has been designated as being processed asynchronously,
     * or after seizePower() has been called on this, subsequent writes will no
     * longer be buffered and will be written to the underlying transport without
     * delaying until the entire response is constructed.  Write-through may or
     * may not be synchronous in the implementation, and in any case particular
     * behavior may not be observable to the HTTP client as intermediate buffers
     * both in the server socket and in the client may delay written data; be
     * prepared for delays at any time.
     *
     * @throws NS_ERROR_NOT_AVAILABLE
     * if accessed after this response is fully constructed
     */
    readonly bodyOutputStream: nsIOutputStream;
    /**
     * Writes a string to the response's output stream.  This method is merely a
     * convenient shorthand for writing the same data to bodyOutputStream
     * directly.
     *
     * @note
     * This method is only guaranteed to work with ASCII data.
     * @throws NS_ERROR_NOT_AVAILABLE
     * if called after this response has been fully constructed
     */
    write(data: string): void;
    /**
     * Signals that this response is being constructed asynchronously.  Requests
     * are typically completely constructed during nsIHttpRequestHandler.handle;
     * however, responses which require significant resources (time, memory,
     * processing) to construct can be created and sent incrementally by calling
     * this method during the call to nsIHttpRequestHandler.handle.  This method
     * only has this effect when called during nsIHttpRequestHandler.handle;
     * behavior is undefined if it is called at a later time.  It may be called
     * multiple times with no ill effect, so long as each call occurs before
     * finish() is called.
     *
     * @throws NS_ERROR_UNEXPECTED
     * if not initially called within a nsIHttpRequestHandler.handle call or if
     * called after this response has been finished
     * @throws NS_ERROR_NOT_AVAILABLE
     * if seizePower() has been called on this
     */
    processAsync(): void;
    /**
     * Seizes complete control of this response (and its connection) from the
     * server, allowing raw and unfettered access to data being sent in the HTTP
     * response.  Once this method has been called the only property which may be
     * accessed without an exception being thrown is bodyOutputStream, and the
     * only methods which may be accessed without an exception being thrown are
     * write(), finish(), and seizePower() (which may be called multiple times
     * without ill effect so long as all calls are otherwise allowed).
     *
     * After a successful call, all data subsequently written to the body of this
     * response is written directly to the corresponding connection.  (Previously-
     * written data is silently discarded.)  No status line or headers are sent
     * before doing so; if the response handler wishes to write such data, it must
     * do so manually.  Data generation completes only when finish() is called; it
     * is not enough to simply call close() on bodyOutputStream.
     *
     * @throws NS_ERROR_NOT_AVAILABLE
     * if processAsync() has been called on this
     * @throws NS_ERROR_UNEXPECTED
     * if finish() has been called on this
     */
    seizePower(): void;
    /**
     * Signals that construction of this response is complete and that it may be
     * sent over the network to the client, or if seizePower() has been called
     * signals that all data has been written and that the underlying connection
     * may be closed.  This method may only be called after processAsync() or
     * seizePower() has been called.  This method is idempotent.
     *
     * @throws NS_ERROR_UNEXPECTED
     * if processAsync() or seizePower() has not already been properly called
     */
    finish(): void;
}

/**
 * An interface to test for cookie permissions
 */
declare interface nsIHttpsOnlyModePermissionType extends nsISupportsType {
}

/**
 *
 */
declare interface nsIIDBPermissionsRequestType extends nsISupportsType {
    /**
     *
     */
    readonly browserElement: Element;
    /**
     *
     */
    readonly responseObserver: nsIObserver;
}

/**
 * nsIIDNService interface.
 *
 * IDN (Internationalized Domain Name) support. Provides facilities
 * for manipulating IDN hostnames according to the specification set
 * forth by the IETF.
 *
 * IDN effort:
 * http://www.ietf.org/html.characters/idn-charter.html
 * http://www.i-dns.net
 *
 * IDNA specification:
 * http://search.ietf.org/internet-drafts/draft-ietf-idn-idna-06.txt
 */
declare interface nsIIDNServiceType extends nsISupportsType {
    /**
     * Prepares the input hostname according to IDNA ToASCII operation,
     * the input hostname is assumed to be UTF8-encoded.
     */
    convertUTF8toACE(input: AUTF8String): ACString;
    /**
     * This is the ToUnicode operation as specified in the IDNA proposal,
     * with an additional step to encode the result in UTF-8.
     * It takes an ACE-encoded hostname and performs ToUnicode to it, then
     * encodes the resulting string into UTF8.
     */
    convertACEtoUTF8(input: ACString): AUTF8String;
    /**
     * Checks if the input string is ACE encoded or not.
     */
    isACE(input: ACString): boolean;
    /**
     * Performs the unicode normalization needed for hostnames in IDN,
     * for callers that want early normalization.
     */
    normalize(input: AUTF8String): AUTF8String;
    /**
     * Normalizes and converts a host to UTF-8 if the host is in the IDN
     * whitelist, otherwise converts it to ACE. This is useful for display
     * purposes and to ensure an encoding consistent with nsIURI::GetHost().
     * If the result is ASCII or ACE encoded, |isASCII| will be true.
     */
    convertToDisplayIDN(input: AUTF8String, isASCII: boolean): AUTF8String;
}

/**
 *
 */
declare interface nsIINIParserType extends nsISupportsType {
    /**
     * Initializes an INI file from string data
     */
    initFromString(aData: AUTF8String): void;
    /**
     * Enumerates the [section]s available in the INI file.
     */
    getSections(): nsIUTF8StringEnumerator;
    /**
     * Enumerates the keys available within a section.
     */
    getKeys(aSection: AUTF8String): nsIUTF8StringEnumerator;
    /**
     * Get the value of a string for a particular section and key.
     */
    getString(aSection: AUTF8String, aKey: AUTF8String): AUTF8String;
}

/**
 *
 */
declare interface nsIINIParserWriterType extends nsISupportsType {
    /**
     * Set the value of a string for a particular section and key.
     */
    setString(aSection: AUTF8String, aKey: AUTF8String, aValue: AUTF8String): void;
    /**
     * Write to the INI file.
     */
    writeFile(aINIFile: nsIFileType): void;
    /**
     * Return the formatted INI file contents
     */
    writeToString(): AUTF8String;
}

/**
 *
 */
declare interface nsIINIParserFactoryType extends nsISupportsType {
    /**
     * Create an iniparser instance from a local file.
     */
    createINIParser(aINIFile: nsIFileType): nsIINIParser;
}

/**
 * nsIIOService provides a set of network utility functions.  This interface
 * duplicates many of the nsIProtocolHandler methods in a protocol handler
 * independent way (e.g., NewURI inspects the scheme in order to delegate
 * creation of the new URI to the appropriate protocol handler).  nsIIOService
 * also provides a set of URL parsing utility functions.  These are provided
 * as a convenience to the programmer and in some cases to improve performance
 * by eliminating intermediate data structures and interfaces.
 */
declare interface nsIIOServiceType extends nsISupportsType {
    /**
     * Returns a protocol handler for a given URI scheme.
     *
     * @param aScheme the URI scheme
     * @return reference to corresponding nsIProtocolHandler
     */
    getProtocolHandler(aScheme: string): nsIProtocolHandler;
    /**
     * Returns the protocol flags for a given scheme.
     *
     * @param aScheme the URI scheme
     * @return protocol flags for the corresponding protocol
     */
    getProtocolFlags(aScheme: string): unsigned_long;
    /**
     * Returns the dynamic protocol flags for a given URI.
     *
     * @param aURI the URI to get all dynamic flags for
     * @return protocol flags for that URI
     */
    getDynamicProtocolFlags(aURI: nsIURIType): unsigned_long;
    /**
     * Returns the default port for a given scheme.
     *
     * @param aScheme the URI scheme
     * @return default port for the corresponding protocol
     */
    getDefaultPort(aScheme: string): long;
    /**
     * This method constructs a new URI based on the scheme of the URI spec.
     * QueryInterface can be used on the resulting URI object to obtain a more
     * specific type of URI.
     */
    newURI(aSpec: AUTF8String, aOriginCharset: string, aBaseURI: nsIURIType): nsIURI;
    /**
     * This method constructs a new URI from a nsIFile.
     *
     * @param aFile specifies the file path
     * @return reference to a new nsIURI object
     *
     * Note: in the future, for perf reasons we should allow
     * callers to specify whether this is a file or directory by
     * splitting this  into newDirURI() and newActualFileURI().
     */
    newFileURI(aFile: nsIFileType): nsIURI;
    /**
     * Converts an internal URI (e.g. one that has a username and password in
     * it) into one which we can expose to the user, for example on the URL bar.
     *
     * @param  aURI The URI to be converted.
     * @return nsIURI The converted, exposable URI.
     */
    createExposableURI(aURI: nsIURIType): nsIURI;
    /**
     * Creates a channel for a given URI.
     *
     * @param aURI
     * nsIURI from which to make a channel
     * @param aLoadingNode
     * @param aLoadingPrincipal
     * @param aTriggeringPrincipal
     * @param aSecurityFlags
     * @param aContentPolicyType
     * These will be used as values for the nsILoadInfo object on the
     * created channel. For details, see nsILoadInfo in nsILoadInfo.idl
     * @return reference to the new nsIChannel object
     *
     * Please note, if you provide both a loadingNode and a loadingPrincipal,
     * then loadingPrincipal must be equal to loadingNode->NodePrincipal().
     * But less error prone is to just supply a loadingNode.
     *
     * Keep in mind that URIs coming from a webpage should *never* use the
     * systemPrincipal as the loadingPrincipal.
     */
    newChannelFromURI(aURI: nsIURIType, aLoadingNode: Node, aLoadingPrincipal: nsIPrincipalType, aTriggeringPrincipal: nsIPrincipalType, aSecurityFlags: unsigned_long, aContentPolicyType: nsContentPolicyType): nsIChannel;
    /**
     * Equivalent to newChannelFromURI(aURI, aLoadingNode, ...)
     */
    newChannelFromURIWithLoadInfo(aURI: nsIURIType, aLoadInfo: nsILoadInfoType): nsIChannel;
    /**
     * Equivalent to newChannelFromURI(newURI(...))
     */
    newChannel(aSpec: AUTF8String, aOriginCharset: string, aBaseURI: nsIURIType, aLoadingNode: Node, aLoadingPrincipal: nsIPrincipalType, aTriggeringPrincipal: nsIPrincipalType, aSecurityFlags: unsigned_long, aContentPolicyType: nsContentPolicyType): nsIChannel;
    /**
     * Creates a WebTransport.
     */
    newWebTransport(): nsIWebTransport;
    /**
     * Returns true if networking is in "offline" mode. When in offline mode,
     * attempts to access the network will fail (although this does not
     * necessarily correlate with whether there is actually a network
     * available -- that's hard to detect without causing the dialer to
     * come up).
     *
     * Changing this fires observer notifications ... see below.
     */
    offline: boolean;
    /**
     * Returns false if there are no interfaces for a network request
     */
    readonly connectivity: boolean;
    /**
     * Checks if a port number is banned. This involves consulting a list of
     * unsafe ports, corresponding to network services that may be easily
     * exploitable. If the given port is considered unsafe, then the protocol
     * handler (corresponding to aScheme) will be asked whether it wishes to
     * override the IO service's decision to block the port. This gives the
     * protocol handler ultimate control over its own security policy while
     * ensuring reasonable, default protection.
     *
     * @see nsIProtocolHandler::allowPort
     */
    allowPort(aPort: long, aScheme: string): boolean;
    /**
     * Utility to extract the scheme from a URL string, consistently and
     * according to spec (see RFC 2396).
     *
     * NOTE: Most URL parsing is done via nsIURI, and in fact the scheme
     * can also be extracted from a URL string via nsIURI.  This method
     * is provided purely as an optimization.
     *
     * @param aSpec the URL string to parse
     * @return URL scheme, lowercase
     *
     * @throws NS_ERROR_MALFORMED_URI if URL string is not of the right form.
     */
    extractScheme(urlString: AUTF8String): ACString;
    /**
     * Checks if a URI host is a local IPv4 or IPv6 address literal.
     *
     * @param nsIURI the URI that contains the hostname to check
     * @return true if the URI hostname is a local IP address
     */
    hostnameIsLocalIPAddress(aURI: nsIURIType): boolean;
    /**
     * Checks if a URI host is a shared IPv4 address literal.
     *
     * @param nsIURI the URI that contains the hostname to check
     * @return true if the URI hostname is a shared IP address
     */
    hostnameIsSharedIPAddress(aURI: nsIURIType): boolean;
    /**
     * While this is set, IOService will monitor an nsINetworkLinkService
     * (if available) and set its offline status to "true" whenever
     * isLinkUp is false.
     *
     * Applications that want to control changes to the IOService's offline
     * status should set this to false, watch for network:link-status-changed
     * broadcasts, and change nsIIOService::offline as they see fit. Note
     * that this means during application startup, IOService may be offline
     * if there is no link, until application code runs and can turn off
     * this management.
     */
    manageOfflineStatus: boolean;
    /**
     * Creates a channel for a given URI.
     *
     * @param aURI
     * nsIURI from which to make a channel
     * @param aProxyURI
     * nsIURI to use for proxy resolution. Can be null in which
     * case aURI is used
     * @param aProxyFlags flags from nsIProtocolProxyService to use
     * when resolving proxies for this new channel
     * @param aLoadingNode
     * @param aLoadingPrincipal
     * @param aTriggeringPrincipal
     * @param aSecurityFlags
     * @param aContentPolicyType
     * These will be used as values for the nsILoadInfo object on the
     * created channel. For details, see nsILoadInfo in nsILoadInfo.idl
     * @return reference to the new nsIChannel object
     *
     * Please note, if you provide both a loadingNode and a loadingPrincipal,
     * then loadingPrincipal must be equal to loadingNode->NodePrincipal().
     * But less error prone is to just supply a loadingNode.
     */
    newChannelFromURIWithProxyFlags(aURI: nsIURIType, aProxyURI: nsIURIType, aProxyFlags: unsigned_long, aLoadingNode: Node, aLoadingPrincipal: nsIPrincipalType, aTriggeringPrincipal: nsIPrincipalType, aSecurityFlags: unsigned_long, aContentPolicyType: nsContentPolicyType): nsIChannel;
    /**
     * Return true if socket process is launched.
     */
    readonly socketProcessLaunched: boolean;
    /**
     * The pid for socket process.
     */
    readonly socketProcessId: unsigned_long_long;
    /**
     * Register a protocol handler at runtime, given protocol flags and a
     * default port.
     *
     * Statically registered protocol handlers cannot be overridden, and an
     * error will be returned if that is attempted.
     *
     * Runtime registered protocol handlers are never QueryInterface-ed into
     * `nsIProtocolHandlerWithDynamicFlags`, so that interface will be ignored.
     *
     * @param aScheme the scheme handled by the protocol handler.
     * @param aHandler the protocol handler instance.
     * @param aProtocolFlags protocol flags for this protocol, see
     * nsIProtocolHandler for values.
     * @param aDefaultPort default port for this scheme, or -1.
     */
    registerProtocolHandler(aScheme: ACString, aHandler: nsIProtocolHandlerType, aProtocolFlags: unsigned_long, aDefaultPort: long): void;
    /**
     * Unregister a protocol handler which was previously registered using
     * registerProtocolHandler.
     *
     * @param aScheme the scheme to unregister a handler for.
     */
    unregisterProtocolHandler(aScheme: ACString): void;
}

/**
 *
 */
declare interface nsIIOServiceInternalType extends nsISupportsType {
    /**
     * This is an internal method that should only be called from ContentChild
     * in order to pass the connectivity state from the chrome process to the
     * content process. It throws if called outside the content process.
     */
    SetConnectivity(connectivity: boolean): void;
    /**
     * An internal method to asynchronously run our notifications that happen
     * when we wake from sleep
     */
    NotifyWakeup(): void;
}

/**
 * nsIIOUtil provdes various xpcom/io-related utility methods.
 */
declare interface nsIIOUtilType extends nsISupportsType {
    /**
     * Test whether an input stream is buffered.  See nsStreamUtils.h
     * documentation for NS_InputStreamIsBuffered for the definition of
     * "buffered" used here and for edge-case behavior.
     *
     * @throws NS_ERROR_INVALID_POINTER if null is passed in.
     */
    inputStreamIsBuffered(aStream: nsIInputStreamType): boolean;
    /**
     * Test whether an output stream is buffered.  See nsStreamUtils.h
     * documentation for NS_OutputStreamIsBuffered for the definition of
     * "buffered" used here and for edge-case behavior.
     *
     * @throws NS_ERROR_INVALID_POINTER if null is passed in.
     */
    outputStreamIsBuffered(aStream: nsIOutputStreamType): boolean;
}

/**
 * nsIIconURI
 *
 * This interface derives from nsIURI, to provide additional information
 * about moz-icon URIs.
 *
 * What *is* a moz-icon URI you ask?  Well, it has the following syntax:
 *
 * moz-icon:[<valid-url> | //<file-with-extension> | //stock/<stock-icon>]?
 * ['?'[<parameter-value-pairs>]]
 *
 * <valid-url> is a valid URL spec.
 *
 * <file-with-extension> is any filename with an extension, e.g. "dummy.html".
 * If the file you want an icon for isn't known to exist, you can use this
 * instead of a URL and just place a dummy file name with the extension or
 * content type you want.
 *
 * <stock-icon> is the name of a platform-dependant stock icon.
 *
 * Legal parameter value pairs are listed below:
 *
 * Parameter:   size
 * Values:      [<integer> | button | toolbar | toolbarsmall | menu |
 * dialog]
 * Description: If integer, this is the desired size in square pixels of
 * the icon
 * Else, use the OS default for the specified keyword context.
 *
 * Parameter:   state
 * Values:      [normal | disabled]
 * Description: The state of the icon.
 *
 * Parameter:   contentType
 * Values:      <mime-type>
 * Description: The mime type we want an icon for. This is ignored by
 * stock images.
 */
declare interface nsIMozIconURIType extends nsIURIType {
    /**
     *
     */
    readonly iconURL: nsIURL;
    /**
     *
     */
    readonly imageSize: unsigned_long;
    /**
     *
     */
    readonly stockIcon: ACString;
    /**
     *
     */
    readonly iconSize: ACString;
    /**
     *
     */
    readonly iconState: ACString;
    /**
     *
     */
    readonly contentType: ACString;
    /**
     *
     */
    readonly fileExtension: ACString;
}

/**
 *
 */
declare interface nsIIdentityCredentialPromptServiceType extends nsISupportsType {
    /**
     *
     */
    showProviderPrompt(browsingContext: BrowsingContext, identityProviders: jsval, identityManifests: jsval): Promise;
    /**
     *
     */
    showPolicyPrompt(browsingContext: BrowsingContext, identityProvider: jsval, identityManifest: jsval, identityClientMetadata: jsval): Promise;
    /**
     *
     */
    showAccountListPrompt(browsingContext: BrowsingContext, accountList: jsval, identityProvider: jsval, identityManifest: jsval): Promise;
    /**
     *
     */
    close(browsingContext: BrowsingContext): void;
}

/**
 *
 */
declare interface nsIIdentityCredentialStorageServiceType extends nsISupportsType {
    /**
     *
     */
    setState(rpPrincipal: nsIPrincipalType, idpPrincipal: nsIPrincipalType, credentialID: ACString, registered: boolean, allowLogout: boolean): void;
    /**
     *
     */
    getState(rpPrincipal: nsIPrincipalType, idpPrincipal: nsIPrincipalType, credentialID: ACString, registered: boolean, allowLogout: boolean): void;
    /**
     *
     */
    delete(rpPrincipal: nsIPrincipalType, idpPrincipal: nsIPrincipalType, credentialID: ACString): void;
    /**
     *
     */
    clear(): void;
    /**
     *
     */
    deleteFromBaseDomain(baseDomain: ACString): void;
    /**
     *
     */
    deleteFromPrincipal(rpPrincipal: nsIPrincipalType): void;
    /**
     *
     */
    deleteFromTimeRange(aFrom: PRTime, aTo: PRTime): void;
    /**
     *
     */
    deleteFromOriginAttributesPattern(aPattern: AString): void;
}

/**
 * An instance implementing nsIIdlePeriod is used by an associated
 * nsIThread to estimate when it is likely that it will receive an
 * event.
 */
declare interface nsIIdlePeriodType extends nsISupportsType {
    /**
     * Return an estimate of a point in time in the future when we
     * think that the associated thread will become busy. Should
     * return TimeStamp() (i.e. the null time) or a time less than
     * TimeStamp::Now() if the thread is currently busy or will become
     * busy very soon.
     */
    getIdlePeriodHint(): TimeStamp;
}

/**
 *
 */
declare interface nsIImageLoadingContentType extends imgINotificationObserverType {
    /**
     * setLoadingEnabled is used to enable and disable loading in
     * situations where loading images is unwanted.  Note that enabling
     * loading will *not* automatically trigger an image load.
     */
    setLoadingEnabled(aEnabled: boolean): void;
    /**
     * Used to register an image decoder observer.  Typically, this will
     * be a proxy for a frame that wants to paint the image.
     * Notifications from ongoing image loads will be passed to all
     * registered observers.  Notifications for all request types,
     * current and pending, will be passed through.
     *
     * @param aObserver the observer to register
     */
    addNativeObserver(aObserver: imgINotificationObserver): void;
    /**
     * Used to unregister an image decoder observer.
     *
     * @param aObserver the observer to unregister
     */
    removeNativeObserver(aObserver: imgINotificationObserver): void;
    /**
     * Used to notify the image loading content node that a frame has been
     * created.
     */
    frameCreated(aFrame: nsIFrameType): void;
    /**
     * Used to notify the image loading content node that a frame has been
     * destroyed.
     */
    frameDestroyed(aFrame: nsIFrameType): void;
    /**
     * Gets the URI of the current request, if available.
     * Otherwise, returns the last URI that this content tried to load, or
     * null if there haven't been any such attempts.
     */
    readonly currentURI: nsIURI;
    /**
     * Gets the sync-decoding hint set by the decoding attribute.
     */
    readonly syncDecodingHint: boolean;
}

/**
 * An incremental download object attempts to fetch a file piecemeal over time
 * in an effort to minimize network bandwidth usage.
 *
 * Canceling a background download does not cause the file on disk to be
 * deleted.
 */
declare interface nsIIncrementalDownloadType extends nsIRequestType {
    /**
     * Initialize the incremental download object.  If the destination file
     * already exists, then only the remaining portion of the file will be
     * fetched.
     *
     * NOTE: The downloader will create the destination file if it does not
     * already exist.  It will create the file with the permissions 0600 if
     * needed.  To affect the permissions of the file, consumers of this
     * interface may create an empty file at the specified destination prior to
     * starting the incremental download.
     *
     * NOTE: Since this class may create a temporary file at the specified
     * destination, it is advisable for the consumer of this interface to specify
     * a file name for the destination that would not tempt the user into
     * double-clicking it.  For example, it might be wise to append a file
     * extension like ".part" to the end of the destination to protect users from
     * accidentally running "blah.exe" before it is a complete file.
     *
     * @param uri
     * The URI to fetch.
     * @param destination
     * The location where the file is to be stored.
     * @param chunkSize
     * The size of the chunks to fetch.  A non-positive value results in
     * the default chunk size being used.
     * @param intervalInSeconds
     * The amount of time to wait between fetching chunks.  Pass a
     * negative to use the default interval, or 0 to fetch the remaining
     * part of the file in one chunk.
     */
    init(uri: nsIURIType, destination: nsIFileType, chunkSize: long, intervalInSeconds: long): void;
    /**
     * The URI being fetched.
     */
    readonly URI: nsIURI;
    /**
     * The URI being fetched after any redirects have been followed.  This
     * attribute is set just prior to calling OnStartRequest on the observer
     * passed to the start method.
     */
    readonly finalURI: nsIURI;
    /**
     * The file where the download is being written.
     */
    readonly destination: nsIFile;
    /**
     * The total number of bytes for the requested file.  This attribute is set
     * just prior to calling OnStartRequest on the observer passed to the start
     * method.
     *
     * This attribute has a value of -1 if the total size is unknown.
     */
    readonly totalSize: long_long;
    /**
     * The current number of bytes downloaded so far.  This attribute is set just
     * prior to calling OnStartRequest on the observer passed to the start
     * method.
     *
     * This attribute has a value of -1 if the current size is unknown.
     */
    readonly currentSize: long_long;
    /**
     * Start the incremental download.
     *
     * @param observer
     * An observer to be notified of various events.  OnStartRequest is
     * called when finalURI and totalSize have been determined or when an
     * error occurs.  OnStopRequest is called when the file is completely
     * downloaded or when an error occurs.  If this object implements
     * nsIProgressEventSink, then its OnProgress method will be called as
     * data is written to the destination file.  If this object implements
     * nsIInterfaceRequestor, then it will be assigned as the underlying
     * channel's notification callbacks, which allows it to provide a
     * nsIAuthPrompt implementation if needed by the channel, for example.
     * @param ctxt
     * User defined object forwarded to the observer's methods.
     */
    start(observer: nsIRequestObserverType, ctxt: nsISupportsType): void;
}

/**
 *
 */
declare interface nsIIncrementalStreamLoaderObserverType extends nsISupportsType {
    /**
     * Called when new data has arrived on the stream.
     *
     * @param loader the stream loader that loaded the stream.
     * @param ctxt the context parameter of the underlying channel
     * @param dataLength the length of the new data received
     * @param data the contents of the new data received.
     *
     * This method will always be called asynchronously by the
     * nsIIncrementalStreamLoader involved, on the thread that called the
     * loader's init() method.
     *
     * If the observer wants to not accumulate all or portional of the data in
     * the internal buffer, the consumedLength shall be set to the value of
     * the dataLength or less. By default the consumedLength value is assumed 0.
     * The data and dataLength reflect the non-consumed data and will be
     * accumulated if consumedLength is not set.
     *
     * In comparison with onStreamComplete(), the data buffer cannot be
     * adopted if this method returns NS_SUCCESS_ADOPTED_DATA.
     */
    onIncrementalData(loader: nsIIncrementalStreamLoaderType, ctxt: nsISupportsType, dataLength: unsigned_long, data: octet[], consumedLength: unsigned_long): void;
    /**
     * Called when the entire stream has been loaded.
     *
     * @param loader the stream loader that loaded the stream.
     * @param ctxt the context parameter of the underlying channel
     * @param status the status of the underlying channel
     * @param resultLength the length of the data loaded
     * @param result the data
     *
     * This method will always be called asynchronously by the
     * nsIIncrementalStreamLoader involved, on the thread that called the
     * loader's init() method.
     *
     * If the observer wants to take over responsibility for the
     * data buffer (result), it returns NS_SUCCESS_ADOPTED_DATA
     * in place of NS_OK as its success code. The loader will then
     * "forget" about the data and not free() it after
     * onStreamComplete() returns; observer must call free()
     * when the data is no longer required.
     */
    onStreamComplete(loader: nsIIncrementalStreamLoaderType, ctxt: nsISupportsType, status: nsresult, resultLength: unsigned_long, result: octet[]): void;
}

/**
 * Asynchronously loads a channel into a memory buffer.
 *
 * To use this interface, first call init() with a nsIIncrementalStreamLoaderObserver
 * that will be notified when the data has been loaded. Then call asyncOpen()
 * on the channel with the nsIIncrementalStreamLoader as the listener. The context
 * argument in the asyncOpen() call will be passed to the onStreamComplete()
 * callback.
 *
 * XXX define behaviour for sizes >4 GB
 */
declare interface nsIIncrementalStreamLoaderType extends nsIStreamListenerType {
    /**
     * Initialize this stream loader, and start loading the data.
     *
     * @param aObserver
     * An observer that will be notified when the data is complete.
     */
    init(aObserver: nsIIncrementalStreamLoaderObserverType): void;
    /**
     * Gets the number of bytes read so far.
     */
    readonly numBytesRead: unsigned_long;
    /**
     * Gets the request that loaded this file.
     * null after the request has finished loading.
     */
    readonly request: nsIRequest;
}

/**
 *
 */
declare interface nsIInlineSpellCheckerType extends nsISupportsType {
    /**
     *
     */
    readonly spellChecker: nsIEditorSpellCheck;
    /**
     *
     */
    init(aEditor: nsIEditorType): void;
    /**
     *
     */
    cleanup(aDestroyingFrames: boolean): void;
    /**
     *
     */
    enableRealTimeSpell: boolean;
    /**
     *
     */
    spellCheckRange(aSelection: Range): void;
    /**
     *
     */
    getMisspelledWord(aNode: Node, aOffset: unsigned_long): Range;
    /**
     *
     */
    replaceWord(aNode: Node, aOffset: unsigned_long, aNewword: AString): void;
    /**
     *
     */
    addWordToDictionary(aWord: AString): void;
    /**
     *
     */
    removeWordFromDictionary(aWord: AString): void;
    /**
     *
     */
    ignoreWord(aWord: AString): void;
    /**
     *
     */
    ignoreWords(aWordsToIgnore: invalid): void;
    /**
     *
     */
    updateCurrentDictionary(): void;
    /**
     *
     */
    readonly spellCheckPending: boolean;
}

/**
 *
 */
declare interface nsIInputListAutoCompleteType extends nsISupportsType {
    /**
     * Generate results for a form input autocomplete menu.
     */
    autoCompleteSearch(aSearchString: AString, aField: HTMLInputElement): nsIAutoCompleteResult;
}

/**
 * nsIInputStream
 *
 * An interface describing a readable stream of data.  An input stream may be
 * "blocking" or "non-blocking" (see the IsNonBlocking method).  A blocking
 * input stream may suspend the calling thread in order to satisfy a call to
 * Close, Available, Read, or ReadSegments.  A non-blocking input stream, on
 * the other hand, must not block the calling thread of execution.
 *
 * NOTE: blocking input streams are often read on a background thread to avoid
 * locking up the main application thread.  For this reason, it is generally
 * the case that a blocking input stream should be implemented using thread-
 * safe AddRef and Release.
 */
declare interface nsIInputStreamType extends nsISupportsType {
    /**
     * Close the stream.  This method causes subsequent calls to Read and
     * ReadSegments to return 0 bytes read to indicate end-of-file.  Any
     * subsequent calls to Available or StreamStatus should throw
     * NS_BASE_STREAM_CLOSED.
     *
     * Succeeds (without side effects) if already closed.
     */
    close(): void;
    /**
     * Determine number of bytes available in the stream.  A non-blocking
     * stream that does not yet have any data to read should return 0 bytes
     * from this method (i.e., it must not throw the NS_BASE_STREAM_WOULD_BLOCK
     * exception).
     *
     * In addition to the number of bytes available in the stream, this method
     * also informs the caller of the current status of the stream.  A stream
     * that is closed will throw an exception when this method is called.  That
     * enables the caller to know the condition of the stream before attempting
     * to read from it.  If a stream is at end-of-file, but not closed, then
     * this method returns 0 bytes available.  (Note: some nsIInputStream
     * implementations automatically close when eof is reached; some do not).
     *
     * NOTE: Streams implementing nsIAsyncInputStream must automatically close
     * when eof is reached, as otherwise it is impossible to distinguish between
     * a stream waiting for more data and a stream at EOF using Available().
     *
     * @return number of bytes currently available in the stream.
     *
     * @throws NS_BASE_STREAM_CLOSED if the stream is closed normally.
     * @throws <other-error> if the stream is closed due to some error
     * condition
     */
    available(): unsigned_long_long;
    /**
     * Check the current status of the stream.  A stream that is closed will
     * throw an exception when this method is called.  That enables the caller
     * to know the condition of the stream before attempting to read from it.
     *
     * This method will not throw NS_BASE_STREAM_WOULD_BLOCK, even if the stream
     * is an non-blocking stream with no data. A non-blocking stream that does
     * not yet have any data to read should return NS_OK.
     *
     * NOTE: Unlike available, his method should not block the calling thread
     * (e.g. to query the state of a file descriptor), even when called on a
     * blocking stream.
     *
     * @throws NS_BASE_STREAM_CLOSED if the stream closed normally
     * @throws <other-error> if the stream closed with a different status
     */
    streamStatus(): void;
    /**
     * @return true if stream is non-blocking
     *
     * NOTE: reading from a blocking input stream will block the calling thread
     * until at least one byte of data can be extracted from the stream.
     *
     * NOTE: a non-blocking input stream may implement nsIAsyncInputStream to
     * provide consumers with a way to wait for the stream to have more data
     * once its read method is unable to return any data without blocking.
     */
    isNonBlocking(): boolean;
}

/**
 * nsIInputStreamChannel
 *
 * This interface provides methods to initialize an input stream channel.
 * The input stream channel serves as a data pump for an input stream.
 */
declare interface nsIInputStreamChannelType extends nsISupportsType {
    /**
     * Sets the URI for this channel.  This must be called before the
     * channel is opened, and it may only be called once.
     */
    setURI(aURI: nsIURIType): void;
    /**
     * Get/set the content stream
     *
     * This stream contains the data that will be pushed to the channel's
     * stream listener.  If the stream is non-blocking and supports the
     * nsIAsyncInputStream interface, then the stream will be read directly.
     * Otherwise, the stream will be read on a background thread.
     *
     * This attribute must be set before the channel is opened, and it may
     * only be set once.
     *
     * @throws NS_ERROR_IN_PROGRESS if the setter is called after the channel
     * has been opened.
     */
    contentStream: nsIInputStream;
    /**
     * Get/set the srcdoc data string.  When the input stream channel is
     * created to load a srcdoc iframe, this is set to hold the value of the
     * srcdoc attribute.
     *
     * This should be the same value used to create contentStream, but this is
     * not checked.
     *
     * Changing the value of this attribute will not otherwise affect the
     * functionality of the channel or input stream.
     */
    srcdocData: AString;
    /**
     * Returns true if srcdocData has been set within the channel.
     */
    readonly isSrcdocChannel: boolean;
    /**
     * The base URI to be used for the channel.  Used when the base URI cannot
     * be inferred by other means, for example when this is a srcdoc channel.
     */
    baseURI: nsIURI;
}

/**
 * Note: Instead of using these interfaces directly, consider to use
 * InputStreamLengthHelper class.
 */
declare interface nsIInputStreamLengthType extends nsISupportsType {
    /**
     * Returns the total length of the stream if known. Otherwise it returns -1.
     * This is different than calling available() which returns the number of
     * bytes ready to be read from the stream.
     * -1 is a valid value for a stream that doesn't know its length. For
     * instance, a pipe stream could return such value.
     *
     * It could throw NS_BASE_STREAM_WOULD_BLOCK if the inputStream is
     * non-blocking. If this happens, you should use
     * nsIAsyncInputStreamLength::asyncLengthWait().
     *
     * If the stream has already been read (read()/readSegments()/close()/seek()
     * methods has been called), length() returns NS_ERROR_NOT_AVAILABLE.
     *
     * This is not an attribute because a stream can change its length. For
     * instance, if the stream is a file inputStream and the underlying OS file
     * changes, its length will change as well.
     */
    length(): long_long;
}

/**
 *
 */
declare interface nsIAsyncInputStreamLengthType extends nsISupportsType {
    /**
     * If the stream is non-blocking, nsIInputStreamLength::length() can return
     * NS_BASE_STREAM_WOULD_BLOCK. The caller must then wait for the stream to
     * know its length.
     *
     * If the stream implements nsIAsyncInputStreamLength, then the caller can
     * use this interface to request an asynchronous notification when the
     * stream's length becomes known (via the AsyncLengthWait method).
     * If the length is already known, the aCallback will be still called
     * asynchronously.
     *
     * If the stream has already been read (read()/readSegments()/close()/seek()
     * methods has been called), length() returns NS_ERROR_NOT_AVAILABLE.
     *
     * @param aCallback
     * This object is notified when the length becomes known. This
     * parameter may be null to clear an existing callback.
     * @param aEventTarget
     * Specify that the notification must be delivered to a specific event
     * target.
     */
    asyncLengthWait(aCallback: nsIInputStreamLengthCallbackType, aEventTarget: nsIEventTargetType): void;
}

/**
 * This is a companion interface for
 * nsIAsyncInputStreamLength::asyncLengthWait.
 */
declare interface nsIInputStreamLengthCallbackType extends nsISupportsType {
    /**
     * Called to inform what the total length of the stream is.
     *
     * @param aStream
     * The stream whose asyncLengthWait method was called.
     * @param aLength
     * The stream's length. It can be -1 if the stream doesn't know its
     * length. For instance, this can happen for a pipe inputStream.
     */
    onInputStreamLengthReady(aStream: nsIAsyncInputStreamLengthType, aLength: long_long): void;
}

/**
 *
 */
declare interface nsIInputStreamPriorityType extends nsISupportsType {
    /**
     * An input stream implementing this interface will dispatch runnable
     * events with this priority. See nsIRunnablePriority.
     */
    priority: unsigned_long;
}

/**
 * nsIInputStreamPump
 *
 * This interface provides a means to configure and use a input stream pump
 * instance.  The input stream pump will asynchronously read from an input
 * stream, and push data to an nsIStreamListener instance.  It utilizes the
 * current thread's nsIEventTarget in order to make reading from the stream
 * asynchronous. A different thread can be used if the pump also implements
 * nsIThreadRetargetableRequest.
 *
 * If the given stream supports nsIAsyncInputStream, then the stream pump will
 * call the stream's AsyncWait method to drive the stream listener.  Otherwise,
 * the stream will be read on a background thread utilizing the stream
 * transport service.  More details are provided below.
 */
declare interface nsIInputStreamPumpType extends nsIRequestType {
    /**
     * Initialize the input stream pump.
     *
     * @param aStream
     * contains the data to be read.  if the input stream is non-blocking,
     * then it will be QI'd to nsIAsyncInputStream.  if the QI succeeds
     * then the stream will be read directly.  otherwise, it will be read
     * on a background thread using the stream transport service.
     * @param aSegmentSize
     * if the stream transport service is used, then this parameter
     * specifies the segment size for the stream transport's buffer.
     * pass 0 to specify the default value.
     * @param aSegmentCount
     * if the stream transport service is used, then this parameter
     * specifies the segment count for the stream transport's buffer.
     * pass 0 to specify the default value.
     * @param aCloseWhenDone
     * if true, the input stream will be closed after it has been read.
     * @param aMainThreadTarget
     * a labeled main therad event target.
     */
    init(aStream: nsIInputStreamType, aSegmentSize: unsigned_long, aSegmentCount: unsigned_long, aCloseWhenDone: boolean, aMainThreadTarget: nsISerialEventTargetType): void;
    /**
     * asyncRead causes the input stream to be read in chunks and delivered
     * asynchronously to the listener via OnDataAvailable.
     *
     * @param aListener
     * receives notifications.
     * @param aListenerContext
     * passed to listener methods.
     */
    asyncRead(aListener: nsIStreamListenerType): void;
}

/**
 * A nsIInputStreamTee is a wrapper for an input stream, that when read
 * reads the specified amount of data from its |source| and copies that
 * data to its |sink|.  |sink| must be a blocking output stream.
 */
declare interface nsIInputStreamTeeType extends nsIInputStreamType {
    /**
     *
     */
    source: nsIInputStream;
    /**
     *
     */
    sink: nsIOutputStream;
    /**
     * If |eventTarget| is set, copying to sink is done asynchronously using
     * the event-target (e.g. a thread). If |eventTarget| is not set, copying
     * to sink happens synchronously while reading from the source.
     */
    eventTarget: nsIEventTarget;
}

/**
 * nsIInterceptionInfo is used to record the needed information of the
 * InterceptedHttpChannel.
 * This infomration need to be propagated to the new channel which created by
 * FetchEvent.request or ServiceWorker NavigationPreload.
 */
declare interface nsIInterceptionInfoType extends nsISupportsType {
}

/**
 * The nsIInterfaceRequestor interface defines a generic interface for
 * requesting interfaces that a given object might provide access to.
 * This is very similar to QueryInterface found in nsISupports.
 * The main difference is that interfaces returned from GetInterface()
 * are not required to provide a way back to the object implementing this
 * interface.  The semantics of QI() dictate that given an interface A that
 * you QI() on to get to interface B, you must be able to QI on B to get back
 * to A.  This interface however allows you to obtain an interface C from A
 * that may or most likely will not have the ability to get back to A.
 */
declare interface nsIInterfaceRequestorType extends nsISupportsType {
    /**
     * Retrieves the specified interface pointer.
     *
     * @param uuid The IID of the interface being requested.
     * @param result [out] The interface pointer to be filled in if
     * the interface is accessible.
     * @throws NS_NOINTERFACE - interface not accessible.
     * @throws NS_ERROR* - method failure.
     */
    getInterface(uuid: nsIIDRefType, result: nsQIResult): void;
}

/**
 *
 */
declare interface nsIJARChannelType extends nsIChannelType {
    /**
     * Returns the JAR file.  May be null if the jar is remote.
     * Setting the JAR file is optional and overrides the JAR
     * file used for local file JARs. Setting the JAR file after
     * the channel has been opened is not permitted.
     */
    jarFile: nsIFile;
    /**
     * Returns the zip entry if the file is synchronously accessible.
     * This will work even without opening the channel.
     */
    readonly zipEntry: nsIZipEntry;
    /**
     * If the JAR file is cached in the JAR cache, returns true and
     * holds a reference to the cached zip reader to be used when
     * the channel is read from, ensuring the cached reader will be used.
     * For a successful read from the cached reader, close() should not
     * be called on the reader--per nsIZipReader::getZip() documentation.
     * Returns false if the JAR file is not cached. Calling this method
     * after the channel has been opened is not permitted.
     */
    ensureCached(): boolean;
}

/**
 * JAR URLs have the following syntax
 *
 * jar:<jar-file-uri>!/<jar-entry>
 *
 * EXAMPLE: jar:http://www.big.com/blue.jar!/ocean.html
 *
 * The nsIURL methods operate on the <jar-entry> part of the spec.
 */
declare interface nsIJARURIType extends nsIURLType {
    /**
     * Returns the root URI (the one for the actual JAR file) for this JAR
     * (e.g., http://www.big.com/blue.jar).
     */
    readonly JARFile: nsIURI;
    /**
     * Returns the entry specified for this JAR URI (e.g., "ocean.html").  This
     * value may contain %-escaped byte sequences.
     */
    readonly JAREntry: AUTF8String;
}

/**
 *
 */
declare interface nsIJARURIMutatorType extends nsISupportsType {
    /**
     * Will initialize a URI using the passed spec, baseURI and charset.
     */
    setSpecBaseCharset(aSpec: AUTF8String, aBase: nsIURIType, aCharset: string): void;
}

/**
 * Utilities for running nested event loops, asking them to return, and
 * keeping track of which ones are still running.
 */
declare interface nsIJSInspectorType extends nsISupportsType {
    /**
     * Process the current thread's event queue, calling event handlers until
     * a call to exitNestedEventLoop, below, asks us to return.
     *
     * The name 'enterNestedEventLoop' may be misleading if read too literally.
     * This method loops calling event handlers until one asks it to stop, and
     * then returns. So by that point, the nested event loop has been not only
     * entered, but also run and exited.
     *
     * When enterNestedEventLoop calls an event handler, that handler may itself
     * call enterNestedEventLoop, and so on, so that there may be arbitrarily
     * many such calls on the stack at the same time.
     *
     * We say an enterNestedEventLoop call is "running" if it has not yet been
     * asked to return, or "stopped" if it has been asked to return once it has
     * finished processing the current event.
     *
     * @param requestor   A token of the caller's choice to identify this event
     * loop.
     *
     * @return depth      The number of running enterNestedEventLoop calls
     * remaining, now that this one has returned.
     *
     * (Note that not all calls still on the stack are
     * necessary running; exitNestedEventLoop can ask any
     * number of enterNestedEventLoop calls to return.)
     */
    enterNestedEventLoop(requestor: jsval): unsigned_long;
    /**
     * Stop the youngest running enterNestedEventLoop call, asking it to return
     * once it has finished processing the current event.
     *
     * The name 'exitNestedEventLoop' may be misleading if read too literally.
     * The affected event loop does not return immediately when this method is
     * called. Rather, this method simply returns to its caller; the affected
     * loop's current event handler is allowed to run to completion; and then
     * that loop returns without processing any more events.
     *
     * This method ignores loops that have already been stopped, and operates on
     * the youngest loop that is still running. Each call to this method stops
     * another running loop.
     *
     * @return depth      The number of running enterNestedEventLoop calls
     * remaining, now that one has been stopped.
     *
     * @throws NS_ERROR_FAILURE if there are no running enterNestedEventLoop calls.
     */
    exitNestedEventLoop(): unsigned_long;
    /**
     * The number of running enterNestedEventLoop calls on the stack.
     * This count does not include stopped enterNestedEventLoop calls.
     */
    readonly eventLoopNestLevel: unsigned_long;
    /**
     * The |requestor| value that was passed to the youngest running
     * enterNestedEventLoop call.
     */
    readonly lastNestRequestor: jsval;
}

/**
 *
 */
declare interface nsIJumpListCommittedCallbackType extends nsISupportsType {
    /**
     *
     */
    done(result: boolean): void;
}

/**
 *
 */
declare interface nsIJumpListBuilderType extends nsISupportsType {
    /**
     * Indicates whether jump list taskbar features are supported by the current
     * host.
     */
    readonly available: short;
    /**
     * JumpList management
     *
     * @throw NS_ERROR_NOT_AVAILABLE on all calls if taskbar functionality
     * is not supported by the operating system.
     * Indicates if a commit has already occurred in this session.
     */
    readonly isListCommitted: boolean;
    /**
     * The maximum number of jump list items the current desktop can support.
     */
    readonly maxListItems: short;
    /**
     * Initializes a jump list build and returns a promise with the list of
     * items the user removed since the last time a jump list was committed.
     * Removed items can become state after initListBuild is called, lists
     * should be built in single-shot fasion.
     *
     * @returns a promise with the list of items that were removed by the user
     * since the last commit.
     */
    initListBuild(): Promise;
    /**
     * Adds a list and if required, a set of items for the list.
     *
     * @param aCatType
     * The type of list to add.
     * @param items
     * An array of nsIJumpListItem items to add to the list.
     * @param catName
     * For custom lists, the title of the list.
     *
     * @returns true if the operation completed successfully.
     *
     * @throw NS_ERROR_INVALID_ARG if incorrect parameters are passed for
     * a particular category or item type.
     * @throw NS_ERROR_ILLEGAL_VALUE if an item is added that was removed
     * since the last commit.
     * @throw NS_ERROR_UNEXPECTED on internal errors.
     */
    addListToBuild(aCatType: short, items: nsIArrayType, catName: AString): boolean;
    /**
     * Aborts and clears the current jump list build.
     */
    abortListBuild(): void;
    /**
     * Commits the current jump list build to the Taskbar.
     *
     * @param callback
     * Receives one argument, which is true if the operation completed
     * successfully, otherwise it is false.
     */
    commitListBuild(callback: nsIJumpListCommittedCallbackType): void;
    /**
     * Deletes any currently applied taskbar jump list for this application.
     * Common uses would be the enabling of a privacy mode and uninstallation.
     *
     * @returns true if the operation completed successfully.
     *
     * @throw NS_ERROR_UNEXPECTED on internal errors.
     */
    deleteActiveList(): boolean;
    /**
     *
     */
    setAppUserModelID(aAppUserModelId: AString): void;
}

/**
 * Implements Win7 Taskbar jump list item interfaces.
 *
 * Note to consumers: it's reasonable to expect we'll need support for other types
 * of jump list items (an audio file, an email message, etc.). To add types,
 * create the specific interface here, add an implementation class to WinJumpListItem,
 * and add support to addListBuild & removed items processing.
 */
declare interface nsIJumpListItemType extends nsISupportsType {
    /**
     * Retrieves the jump list item type.
     */
    readonly type: short;
    /**
     * Compare this item to another.
     *
     * Compares the type and other properties specific to this item's
     * type.
     *
     * separator: type
     * link: type, uri, title
     * shortcut: type, handler app
     */
    equals(item: nsIJumpListItemType): boolean;
}

/**
 * A menu separator.
 */
declare interface nsIJumpListSeparatorType extends nsIJumpListItemType {
}

/**
 * A URI link jump list item.
 *
 * Note the application must be the registered protocol
 * handler for the protocol of the link.
 */
declare interface nsIJumpListLinkType extends nsIJumpListItemType {
    /**
     * Set or get the uri for this link item.
     */
    uri: nsIURI;
    /**
     * Set or get the title for a link item.
     */
    uriTitle: AString;
    /**
     * Get a 'privacy safe' unique string hash of the uri's
     * spec. Useful in tracking removed items using visible
     * data stores such as prefs. Generates an MD5 hash of
     * the URI spec using nsICryptoHash.
     */
    readonly uriHash: ACString;
    /**
     * Compare this item's hash to another uri.
     *
     * Generates a spec hash of the incoming uri and compares
     * it to this item's uri spec hash.
     */
    compareHash(uri: nsIURIType): boolean;
}

/**
 * A generic application shortcut with command line support.
 */
declare interface nsIJumpListShortcutType extends nsIJumpListItemType {
    /**
     * Set or get the handler app for this shortcut item.
     *
     * The handler app may also be used along with iconIndex to generate an icon
     * for the jump list item.
     *
     * @throw NS_ERROR_FILE_NOT_FOUND if the handler app can
     * not be found on  the system.
     *
     * @see faviconPageUri
     */
    app: nsILocalHandlerApp;
    /**
     * Set or get the icon displayed with the jump list item.
     *
     * Indicates the resource index of the icon contained within the handler
     * executable which may be used as the jump list icon.
     *
     * @see faviconPageUri
     */
    iconIndex: long;
    /**
     * Set or get the URI of a page whose favicon may be used as the icon.
     *
     * When a jump list build occurs, the favicon to be used for the item is
     * obtained using the following steps:
     * - First, attempt to use the asynchronously retrieved and scaled favicon
     * associated with the faviconPageUri.
     * - If faviconPageUri is null, or if retrieving the favicon fails, fall
     * back to using the handler executable and iconIndex.
     */
    faviconPageUri: nsIURI;
}

/**
 * The key/value service.  Enables retrieval of handles to key/value databases.
 */
declare interface nsIKeyValueServiceType extends nsISupportsType {
    /**
     * Get a handle to an existing database or a newly-created one
     * at the specified path and with the given name.
     *
     * The service supports multiple named databases at the same path
     * (i.e. within the same storage file), so you can call this method
     * multiple times with the same path and different names to retrieve
     * multiple databases stored in the same location on disk.
     */
    getOrCreate(callback: nsIKeyValueDatabaseCallbackType, path: AUTF8String, name: AUTF8String): void;
}

/**
 * A key/value database.
 *
 * All methods are asynchronous and take a callback as their first argument.
 * The types of the callbacks vary, but they can all be implemented in JS
 * via an object literal with the relevant methods.
 */
declare interface nsIKeyValueDatabaseType extends nsISupportsType {
    /**
     * Write the specified key/value pair to the database.
     */
    put(callback: nsIKeyValueVoidCallbackType, key: AUTF8String, value: nsIVariantType): void;
    /**
     * Write multiple key/value pairs to the database.
     *
     * It supports two types of write:
     * * Put a key/value pair into the database. It takes a nsIKeyValuePair
     * where its key and value follow the same types as the put() method.
     * * Delete a key/value pair from database. It takes a nsIkeyValuePair
     * where its value property must be null or undefined.
     *
     * This features the "all-or-nothing" semantics, i.e. if any error occurs
     * during the call, it will rollback the previous writes and terminate the
     * call. In addition, writeMany should be more efficient than calling "put"
     * or "delete" for every single key/value pair since it does all the writes
     * in a single transaction.
     *
     * Note:
     * * If there are multiple values with the same key in the specified
     * pairs, only the last value will be stored in the database.
     * * Deleting a key that is not in the database will be silently ignored.
     * * If the same key gets put and deleted for multiple times, the final
     * state of that key is subject to the ordering of the put(s) and delete(s).
     */
    writeMany(callback: nsIKeyValueVoidCallbackType, pairs: invalid): void;
    /**
     * Retrieve the value of the specified key from the database.
     *
     * If the key/value pair doesn't exist in the database, and you specify
     * a default value, then the default value will be returned.  Otherwise,
     * the callback's resolve() method will be called with a variant
     * of type VTYPE_EMPTY, which translates to the JS `null` value.
     */
    get(callback: nsIKeyValueVariantCallbackType, key: AUTF8String, defaultValue: nsIVariantType): void;
    /**
     * Determine whether or not the key exists in the database.
     */
    has(callback: nsIKeyValueVariantCallbackType, key: AUTF8String): void;
    /**
     * Remove the key/value pair with the given key from the database.
     *
     * If the given key doesn't exist in the database, this operation doesn't
     * fail; or rather, it fails silently, calling the resolve() method
     * of its callback rather than reject().  If you want to know whether
     * or not a key exists when deleting it, call the has() method first.
     */
    delete(callback: nsIKeyValueVoidCallbackType, key: AUTF8String): void;
    /**
     * Clear all the key/value pairs from the database.
     */
    clear(callback: nsIKeyValueVoidCallbackType): void;
    /**
     * Enumerate key/value pairs, starting with the first key equal to
     * or greater than the "from" key (inclusive) and ending with the last key
     * less than the "to" key (exclusive) sorted lexicographically.
     *
     * If either key is omitted, the range extends to the first and/or last key
     * in the database.
     */
    enumerate(callback: nsIKeyValueEnumeratorCallbackType, fromKey: AUTF8String, toKey: AUTF8String): void;
}

/**
 * A key/value pair.  Returned by nsIKeyValueEnumerator.getNext().
 */
declare interface nsIKeyValuePairType extends nsISupportsType {
    /**
     *
     */
    readonly key: AUTF8String;
    /**
     *
     */
    readonly value: nsIVariant;
}

/**
 * An enumerator of key/value pairs.  Although its methods are similar
 * to those of nsISimpleEnumerator, this interface's getNext() method returns
 * an nsIKeyValuePair rather than an nsISupports, so consumers don't need
 * to QI it to that interface; but this interface doesn't implement the JS
 * iteration protocol (because the Rust-XPCOM bindings don't yet support it),
 * which is another reason why you should use the kvstore.jsm module from JS
 * instead of accessing this API directly.
 */
declare interface nsIKeyValueEnumeratorType extends nsISupportsType {
    /**
     *
     */
    hasMoreElements(): bool;
    /**
     *
     */
    getNext(): nsIKeyValuePair;
}

/**
 * A callback for the nsIKeyValueService.getOrCreate() method.
 *
 * The result is an nsIKeyValueDatabase.
 */
declare interface nsIKeyValueDatabaseCallbackType extends nsISupportsType {
    /**
     *
     */
    resolve(database: nsIKeyValueDatabaseType): void;
    /**
     *
     */
    reject(message: AUTF8String): void;
}

/**
 * A callback for the nsIKeyValueDatabase.enumerate() method.
 *
 * The result is an nsIKeyValueEnumerator.
 */
declare interface nsIKeyValueEnumeratorCallbackType extends nsISupportsType {
    /**
     *
     */
    resolve(enumerator: nsIKeyValueEnumeratorType): void;
    /**
     *
     */
    reject(message: AUTF8String): void;
}

/**
 * A callback for the nsIKeyValueEnumerator.getNext() method.
 *
 * The result is the next key/value pair, expressed as separate key and value
 * parameters.
 */
declare interface nsIKeyValuePairCallbackType extends nsISupportsType {
    /**
     *
     */
    resolve(pair: nsIKeyValuePairType): void;
    /**
     *
     */
    reject(message: AUTF8String): void;
}

/**
 * A callback for the nsIKeyValueDatabase.has() and .get() methods.
 *
 * The result is an nsIVariant, which is always a boolean for the has() method
 * and can be any supported data type for the get() method.
 */
declare interface nsIKeyValueVariantCallbackType extends nsISupportsType {
    /**
     *
     */
    resolve(result: nsIVariantType): void;
    /**
     *
     */
    reject(message: AUTF8String): void;
}

/**
 * A callback for the nsIKeyValueDatabase.put() and .delete() methods.
 *
 * There is no result, but the resolve() method is still called when those
 * async operations complete, to notify consumers of completion.
 */
declare interface nsIKeyValueVoidCallbackType extends nsISupportsType {
    /**
     *
     */
    resolve(): void;
    /**
     *
     */
    reject(message: AUTF8String): void;
}

/**
 *
 */
declare interface nsIKeychainMigrationUtilsType extends nsISupportsType {
    /**
     *
     */
    getGenericPassword(aServiceName: ACString, aAccountName: ACString): ACString;
}

/**
 * A series of hooks into non-IDL-ized layout code to allow all the
 * layout debugging functions to be used from chrome.
 */
declare interface nsILayoutDebuggingToolsType extends nsISupportsType {
    /**
     * Initialize debugger object to act on a docshell.
     */
    init(win: mozIDOMWindow): void;
    /**
     *
     */
    forceRefresh(): void;
    /**
     * Toggle various debugging states
     */
    setReflowCounts(enabled: boolean): void;
    /**
     *
     */
    setPagedMode(enabled: boolean): void;
    /**
     * Run various tests.
     */
    dumpContent(): void;
    /**
     *
     */
    dumpFrames(): void;
    /**
     *
     */
    dumpFramesInCSSPixels(): void;
    /**
     *
     */
    dumpTextRuns(): void;
    /**
     *
     */
    dumpViews(): void;
    /**
     *
     */
    dumpCounterManager(): void;
    /**
     *
     */
    dumpStyleSheets(): void;
    /**
     *
     */
    dumpMatchedRules(): void;
    /**
     *
     */
    dumpComputedStyles(): void;
    /**
     *
     */
    dumpReflowStats(): void;
}

/**
 *
 */
declare interface nsILayoutHistoryStateType extends nsISupportsType {
    /**
     * Whether this LayoutHistoryState contains any PresStates.
     */
    readonly hasStates: boolean;
    /**
     * Attempts to get the data of the PresState corresponding to
     * the passed key. Throws if no data could be found.
     */
    getPresState(aKey: ACString, aScrollX: float, aScrollY: float, aAllowScrollOriginDowngrade: boolean, aRes: float): void;
    /**
     * Constructs a new PresState object based on the supplied data
     * and adds it to the LayoutHistoryState.
     */
    addNewPresState(aKey: ACString, aScrollX: float, aScrollY: float, aAllowScrollOriginDowngrade: boolean, aRes: float): void;
}

/**
 *
 */
declare interface nsILineInputStreamType extends nsISupportsType {
    /**
     * Read a single line from the stream, where a line is a
     * possibly zero length sequence of 8bit chars terminated by a
     * CR, LF, CRLF, LFCR, or eof.
     * The line terminator is not returned.
     * @retval false
     * End of file. This line is the last line of the file
     * (aLine is valid).
     * @retval true
     * The file contains further lines.
     * @note Do not mix readLine with other read functions.
     * Doing so can cause various problems and is not supported.
     */
    readLine(aLine: ACString): boolean;
}

/**
 * An nsILoadContext represents the context of a load.  This interface
 * can be queried for various information about where the load is
 * happening.
 */
declare interface nsILoadContextType extends nsISupportsType {
    /**
     * associatedWindow is the window with which the load is associated, if any.
     * Note that the load may be triggered by a document which is different from
     * the document in associatedWindow, and in fact the source of the load need
     * not be same-origin with the document in associatedWindow.  This attribute
     * may be null if there is no associated window.
     */
    readonly associatedWindow: mozIDOMWindowProxy;
    /**
     * topWindow is the top window which is of same type as associatedWindow.
     * This is equivalent to associatedWindow.top, but is provided here as a
     * convenience.  All the same caveats as associatedWindow of apply, of
     * course.  This attribute may be null if there is no associated window.
     */
    readonly topWindow: mozIDOMWindowProxy;
    /**
     * topFrameElement is the <iframe>, <frame>, or <browser> element which
     * contains the topWindow with which the load is associated.
     *
     * Note that we may have a topFrameElement even when we don't have an
     * associatedWindow, if the topFrameElement's content lives out of process.
     * topFrameElement is available in single-process and multiprocess contexts.
     * Note that topFrameElement may be in chrome even when the nsILoadContext is
     * associated with content.
     */
    readonly topFrameElement: Element;
    /**
     * True if the load context is content (as opposed to chrome).  This is
     * determined based on the type of window the load is performed in, NOT based
     * on any URIs that might be around.
     */
    readonly isContent: boolean;
    /**
     * Attribute that determines if private browsing should be used. May not be
     * changed after a document has been loaded in this context.
     */
    usePrivateBrowsing: boolean;
    /**
     * Attribute that determines if remote (out-of-process) tabs should be used.
     */
    readonly useRemoteTabs: boolean;
    /**
     * Determines if out-of-process iframes should be used.
     */
    readonly useRemoteSubframes: boolean;
    /**
     * Attribute that determines if tracking protection should be used. May not be
     * changed after a document has been loaded in this context.
     */
    useTrackingProtection: boolean;
    /**
     * A dictionary of the non-default origin attributes associated with this
     * nsILoadContext.
     */
    readonly originAttributes: jsval;
}

/**
 * Helper interface to carry informatin about the load context
 * encapsulating origin attributes and IsAnonymous, IsPrivite properties.
 * It shall be used where nsILoadContext cannot be used or is not
 * available.
 */
declare interface nsILoadContextInfoType extends nsISupportsType {
    /**
     * Whether the context is in a Private Browsing mode
     */
    readonly isPrivate: boolean;
    /**
     * Whether the load is initiated as anonymous
     */
    readonly isAnonymous: boolean;
    /**
     * OriginAttributes hiding all the security context attributes
     */
    readonly originAttributes: jsval;
}

/**
 * Since OriginAttributes struct limits the implementation of
 * nsILoadContextInfo (that needs to be thread safe) to C++,
 * we need a scriptable factory to create instances of that
 * interface from JS.
 */
declare interface nsILoadContextInfoFactoryType extends nsISupportsType {
    /**
     *
     */
    readonly default: nsILoadContextInfo;
    /**
     *
     */
    readonly private: nsILoadContextInfo;
    /**
     *
     */
    readonly anonymous: nsILoadContextInfo;
    /**
     *
     */
    custom(aAnonymous: boolean, aOriginAttributes: jsval): nsILoadContextInfo;
    /**
     *
     */
    fromLoadContext(aLoadContext: nsILoadContextType, aAnonymous: boolean): nsILoadContextInfo;
    /**
     *
     */
    fromWindow(aWindow: nsIDOMWindowType, aAnonymous: boolean): nsILoadContextInfo;
}

/**
 * A load group maintains a collection of nsIRequest objects.
 * This is used in lots of places where groups of requests need to be tracked.
 * For example, Document::mDocumentLoadGroup is used to track all requests
 * made for subdocuments in order to track page load progress and allow all
 * requests made on behalf of the document to be stopped, etc.
 */
declare interface nsILoadGroupType extends nsIRequestType {
    /**
     * The group observer is notified when requests are added to and removed
     * from this load group.  The groupObserver is weak referenced.
     */
    groupObserver: nsIRequestObserver;
    /**
     * Accesses the default load request for the group.  Each time a number
     * of requests are added to a group, the defaultLoadRequest may be set
     * to indicate that all of the requests are related to a base request.
     *
     * The load group inherits its load flags from the default load request.
     * If the default load request is NULL, then the group's load flags are
     * not changed.
     */
    defaultLoadRequest: nsIRequest;
    /**
     * Adds a new request to the group.  This will cause the default load
     * flags to be applied to the request.  If this is a foreground
     * request then the groupObserver's onStartRequest will be called.
     *
     * If the request is the default load request or if the default load
     * request is null, then the load group will inherit its load flags from
     * the request.
     */
    addRequest(aRequest: nsIRequestType, aContext: nsISupportsType): void;
    /**
     * Removes a request from the group.  If this is a foreground request
     * then the groupObserver's onStopRequest will be called.
     *
     * By the time this call ends, aRequest will have been removed from the
     * loadgroup, even if this function throws an exception.
     */
    removeRequest(aRequest: nsIRequestType, aContext: nsISupportsType, aStatus: nsresult): void;
    /**
     * Returns the requests contained directly in this group.
     * Enumerator element type: nsIRequest.
     */
    readonly requests: nsISimpleEnumerator;
    /**
     * Returns the count of "active" requests (ie. requests without the
     * LOAD_BACKGROUND bit set).
     */
    readonly activeCount: unsigned_long;
    /**
     * Notification callbacks for the load group.
     */
    notificationCallbacks: nsIInterfaceRequestor;
    /**
     * Context for managing things like js/css connection blocking,
     * and per-tab connection grouping.
     */
    readonly requestContextID: unsigned_long_long;
    /**
     * The set of load flags that will be added to all new requests added to
     * this group. Any existing requests in the load group are not modified,
     * so it is expected these flags will be added before requests are added
     * to the group - typically via nsIDocShell::defaultLoadFlags on a new
     * docShell.
     * Note that these flags are *not* added to the default request for the
     * load group; it is expected the default request will already have these
     * flags (again, courtesy of setting nsIDocShell::defaultLoadFlags before
     * the docShell has created the default request.)
     */
    defaultLoadFlags: nsLoadFlags;
    /**
     * Returns true if the loadGroup belongs to a discarded context, such as, a
     * terminated private browsing session.
     */
    readonly isBrowsingContextDiscarded: boolean;
}

/**
 * nsILoadGroupChild provides a hierarchy of load groups so that the
 * root load group can be used to conceptually tie a series of loading
 * operations into a logical whole while still leaving them separate
 * for the purposes of cancellation and status events.
 */
declare interface nsILoadGroupChildType extends nsISupportsType {
    /**
     * The parent of this load group. It is stored with
     * a nsIWeakReference/nsWeakPtr so there is no requirement for the
     * parentLoadGroup to out live the child, nor will the child keep a
     * reference count on the parent.
     */
    parentLoadGroup: nsILoadGroup;
    /**
     * The nsILoadGroup associated with this nsILoadGroupChild
     */
    readonly childLoadGroup: nsILoadGroup;
    /**
     * The rootLoadGroup is the recursive parent of this
     * load group where parent is defined as parentlLoadGroup if set
     * or childLoadGroup.loadGroup as a backup. (i.e. parentLoadGroup takes
     * precedence.) The nsILoadGroup child is the root if neither parent
     * nor loadgroup attribute is specified.
     */
    readonly rootLoadGroup: nsILoadGroup;
}

/**
 * The LoadInfo object contains information about a network load, why it
 * was started, and how we plan on using the resulting response.
 * If a network request is redirected, the new channel will receive a new
 * LoadInfo object. The new object will contain mostly the same
 * information as the pre-redirect one, but updated as appropriate.
 * For detailed information about what parts of LoadInfo are updated on
 * redirect, see documentation on individual properties.
 */
declare interface nsILoadInfoType extends nsISupportsType {
    /**
     * This is the principal of the network request's caller/requester where
     * the resulting resource will be used. I.e. it is the principal which
     * will get access to the result of the request. (Where "get access to"
     * might simply mean "embed" depending on the type of resource that is
     * loaded).
     *
     * For example for an image, it is the principal of the document where
     * the image is rendered. For a stylesheet it is the principal of the
     * document where the stylesheet will be applied.
     *
     * So if document at http://a.com/page.html loads an image from
     * http://b.com/pic.jpg, then loadingPrincipal will be
     * http://a.com/page.html.
     *
     * For <iframe> and <frame> loads, the LoadingPrincipal is the
     * principal of the parent document. For top-level loads, the
     * LoadingPrincipal is null. For all loads except top-level loads
     * the LoadingPrincipal is never null.
     *
     * If the loadingPrincipal is the system principal, no security checks
     * will be done at all. There will be no security checks on the initial
     * load or any subsequent redirects. This means there will be no
     * nsIContentPolicy checks or any CheckLoadURI checks. Because of
     * this, never set the loadingPrincipal to the system principal when
     * the URI to be loaded is controlled by a webpage.
     * If the loadingPrincipal and triggeringPrincipal are both
     * content principals, then we will always call into
     * nsIContentPolicies and CheckLoadURI. The call to nsIContentPolicies
     * and CheckLoadURI happen even if the URI to be loaded is same-origin
     * with the loadingPrincipal or triggeringPrincipal.
     */
    readonly loadingPrincipal: nsIPrincipal;
    /**
     * This is the principal which caused the network load to start. I.e.
     * this is the principal which provided the URL to be loaded. This is
     * often the same as the LoadingPrincipal, but there are a few cases
     * where that's not true.
     *
     * For example for loads into an <iframe>, the LoadingPrincipal is always
     * the principal of the parent document. However the triggeringPrincipal
     * is the principal of the document which provided the URL that the
     * <iframe> is navigating to. This could be the previous document inside
     * the <iframe> which set document.location. Or a document elsewhere in
     * the frame tree which contained a <a target="..."> which targetted the
     * <iframe>.
     *
     * If a stylesheet links to a sub-resource, like an @imported stylesheet,
     * or a background image, then the triggeringPrincipal is the principal
     * of the stylesheet, while the LoadingPrincipal is the principal of the
     * document being styled.
     *
     * The triggeringPrincipal is never null.
     *
     * If the triggeringPrincipal is the system principal, no security checks
     * will be done at all. There will be no security checks on the initial
     * load or any subsequent redirects. This means there will be no
     * nsIContentPolicy checks or any CheckLoadURI checks. Because of
     * this, never set the triggeringPrincipal to the system principal when
     * the URI to be loaded is controlled by a webpage.
     * If the loadingPrincipal and triggeringPrincipal are both
     * content principals, then we will always call into
     * nsIContentPolicies and CheckLoadURI. The call to nsIContentPolicies
     * and CheckLoadURI happen even if the URI to be loaded is same-origin
     * with the loadingPrincipal or triggeringPrincipal.
     */
    readonly triggeringPrincipal: nsIPrincipal;
    /**
     * The remote type of the process which caused the network load to start. I.e.
     * this is the remote type of the process which provided the URL to be loaded.
     *
     * For subresource loads, this should be the same as the process which will
     * handle the response, however for document loads this may both be different
     * than the final process, as well as different from the process which starts
     * the navigation.
     *
     * This field is intentionally not perfectly preserved over IPC, and will be
     * reset to the remote type of the sending process when sent from a content
     * process to the parent process.
     */
    triggeringRemoteType: AUTF8String;
    /**
     * For non-document loads the principalToInherit is always null. For
     * loads of type TYPE_DOCUMENT or TYPE_SUBDOCUMENT the principalToInherit
     * might be null. If it's non null, then this is the principal that is
     * inherited if a principal needs to be inherited. If the principalToInherit
     * is null but the inherit flag is set, then the triggeringPrincipal is
     * the principal that is inherited.
     */
    principalToInherit: nsIPrincipal;
    /**
     * This is the ownerDocument of the LoadingNode. Unless the LoadingNode
     * is a Document, in which case the LoadingDocument is the same as the
     * LoadingNode.
     *
     * For top-level loads, and for loads originating from workers, the
     * LoadingDocument is null. When the LoadingDocument is not null, the
     * LoadingPrincipal is set to the principal of the LoadingDocument.
     */
    readonly loadingDocument: Document;
    /**
     * For all loads except loads of TYPE_DOCUMENT, the loadingContext
     * simply returns the loadingNode. For loads of TYPE_DOCUMENT this
     * will return the context available for top-level loads which
     * do not have a loadingNode.
     */
    readonly loadingContext: nsISupports;
    /**
     * The securityFlags of that channel.
     */
    readonly securityFlags: nsSecurityFlags;
    /**
     * The sandboxFlags of that channel.
     */
    readonly sandboxFlags: unsigned_long;
    /**
     * The TriggingSandboxFlags are the SandboxFlags of the entity
     * responsible for causing the load to occur.
     */
    triggeringSandboxFlags: unsigned_long;
    /**
     * The window id and storage access status of the window of the
     * context that triggered the load. This is used to allow self-initiated
     * same-origin navigations to propogate their "has storage access" bit
     * to the next Document.
     */
    triggeringWindowId: unsigned_long_long;
    /**
     *
     */
    triggeringStorageAccess: boolean;
    /**
     * Allows to query only the security mode bits from above.
     */
    readonly securityMode: unsigned_long;
    /**
     * This flag is used for any browsing context where we should not sniff
     * the content type. E.g if an iframe has the XCTO nosniff header, then
     * that flag is set to true so we skip content sniffing for that browsing
     * context.
     */
    skipContentSniffing: boolean;
    /**
     * Upgrade state of HTTPS-Only Mode. The flag HTTPS_ONLY_EXEMPT can get
     * set on requests that should be excempt from an upgrade.
     */
    httpsOnlyStatus: unsigned_long;
    /**
     * Reflects whetehr this is an HTTP Strict Transport Security host
     */
    hstsStatus: boolean;
    /**
     * Returns true if at the time of the loadinfo construction the document
     * that triggered this load has the bit hasValidTransientUserGestureActivation
     * set or the load was triggered from External. (Mostly this bool is used
     * in the context of Sec-Fetch-User.)
     */
    hasValidUserGestureActivation: boolean;
    /**
     * We disallow the SystemPrincipal to initiate requests to
     * the public web. This flag is to allow exceptions.
     */
    allowDeprecatedSystemRequests: boolean;
    /**
     * Only ever returns true if the loadinfo is of TYPE_SCRIPT and
     * the script was created by the HTML parser.
     */
    parserCreatedScript: boolean;
    /**
     * True if this request is known to have been triggered by a user
     * manually requesting the URI to be saved.
     */
    isUserTriggeredSave: boolean;
    /**
     * True if this request is from DevTools.
     */
    isInDevToolsContext: boolean;
    /**
     * True if this request is embedded in a context that can't be third-party
     * (i.e. an iframe embedded in a cross-origin parent window). If this is
     * false, then this request may be third-party if it's a third-party to
     * loadingPrincipal.
     */
    isInThirdPartyContext: boolean;
    /**
     * True if this request is a third party in respect to the top-level window.
     *
     * Note that this doesn't consider the parent window. I.e. It will still
     * return false even in the case that the parent is cross-origin but the
     * top-level is same-origin.
     *
     * This value would be set during opening the channel in parent and propagate
     * to the channel in the content.
     */
    isThirdPartyContextToTopWindow: boolean;
    /**
     * See the SEC_COOKIES_* flags above. This attribute will never return
     * SEC_COOKIES_DEFAULT, but will instead return what the policy resolves to.
     * I.e. SEC_COOKIES_SAME_ORIGIN for CORS mode, and SEC_COOKIES_INCLUDE
     * otherwise.
     */
    readonly cookiePolicy: unsigned_long;
    /**
     * The cookie jar settings inherited from the top-level document's loadInfo.
     * It cannot be null.
     */
    cookieJarSettings: nsICookieJarSettings;
    /**
     * The result of the storage permission check of the loading document. This
     * value would be set during opening the channel.
     */
    storagePermission: nsILoadInfo_StoragePermissionState;
    /**
     * True if the load was triggered by a meta refresh.
     */
    isMetaRefresh: boolean;
    /**
     * If forceInheritPrincipal is true, the data coming from the channel should
     * inherit its principal, even when the data is loaded over http:// or another
     * protocol that would normally use a URI-based principal.
     *
     * See the documentation for principalToInherit, which describes exactly what
     * principal is inherited.
     *
     * This attribute will never be true when loadingSandboxed is true.
     */
    readonly forceInheritPrincipal: boolean;
    /**
     * If forceInheritPrincipalOverruleOwner is true, the data coming from the
     * channel should inherit the principal, even when the data is loaded over
     * http:// or another protocol that would normally use a URI-based principal
     * and even if the channel's .owner is not null.  This last is the difference
     * between forceInheritPrincipalOverruleOwner and forceInheritPrincipal: the
     * latter does _not_ overrule the .owner setting.
     *
     * See the documentation for principalToInherit, which describes exactly what
     * principal is inherited.
     */
    readonly forceInheritPrincipalOverruleOwner: boolean;
    /**
     * If loadingSandboxed is true, the data coming from the channel is
     * being loaded sandboxed, so it should have a nonce origin and
     * hence should use a NullPrincipal.
     */
    readonly loadingSandboxed: boolean;
    /**
     * If aboutBlankInherits is true, then about:blank should inherit
     * the principal.
     */
    readonly aboutBlankInherits: boolean;
    /**
     * If allowChrome is true, then use nsIScriptSecurityManager::ALLOW_CHROME
     * when calling CheckLoadURIWithPrincipal().
     */
    readonly allowChrome: boolean;
    /**
     * If disallowScript is true, then use nsIScriptSecurityManager::DISALLOW_SCRIPT
     * when calling CheckLoadURIWithPrincipal().
     */
    readonly disallowScript: boolean;
    /**
     * Returns true if SEC_DONT_FOLLOW_REDIRECTS is set.
     */
    readonly dontFollowRedirects: boolean;
    /**
     * Returns true if SEC_LOAD_ERROR_PAGE is set.
     */
    readonly loadErrorPage: boolean;
    /**
     * True if the load was initiated by a form request.
     * This is important to know to handle the CSP directive navigate-to.
     */
    isFormSubmission: boolean;
    /**
     * The external contentPolicyType of the channel, used for security checks
     * like Mixed Content Blocking and Content Security Policy.
     *
     * Specifically, content policy types with _INTERNAL_ in their name will
     * never get returned from this attribute.
     */
    readonly externalContentPolicyType: nsContentPolicyType;
    /**
     * CSP uses this parameter to send or not CSP violation events.
     * Default value: true.
     */
    sendCSPViolationEvents: boolean;
    /**
     *
     */
    readonly internalContentPolicyType: nsContentPolicyType;
    /**
     * Returns true if document or any of the documents ancestors
     * up to the toplevel document make use of the CSP directive
     * 'block-all-mixed-content'.
     *
     * Warning: If the loadingDocument is null, then the
     * blockAllMixedContent is false.
     */
    readonly blockAllMixedContent: boolean;
    /**
     * Returns true if document or any of the documents ancestors
     * up to the toplevel document make use of the CSP directive
     * 'upgrade-insecure-requests'.
     *
     * Warning: If the loadingDocument is null, then the
     * upgradeInsecureRequests is false.
     */
    readonly upgradeInsecureRequests: boolean;
    /**
     * Returns true if the the page is https and the content is upgradable from http
     * requires 'security.mixed_content.upgrade_display_content' pref to be true.
     * Currently this only upgrades display content but might be expanded to other loads.
     * This is very similar in implementation to upgradeInsecureRequests but browser set.
     */
    readonly browserUpgradeInsecureRequests: boolean;
    /**
     * Returns true if the display content was or will get upgraded from http to https.
     * Requires 'security.mixed_content.upgrade_display_content' pref to be true.
     * Flag is set purely to collect telemetry.
     */
    browserDidUpgradeInsecureRequests: boolean;
    /**
     * Returns true if the the page is https and the content is upgradable from http
     * requires 'security.mixed_content.upgrade_display_content' pref to be false.
     * See browserUpgradeInsecureRequests for more details, this only happens
     * when *not* upgrading purely for telemetry.
     */
    readonly browserWouldUpgradeInsecureRequests: boolean;
    /**
     * If true, toplevel data: URI navigation is allowed
     */
    forceAllowDataURI: boolean;
    /**
     * If true, insecure redirects to a data: URI are allowed.
     */
    allowInsecureRedirectToDataURI: boolean;
    /**
     * If true, the content policy security check is excluded from web requests.
     */
    skipContentPolicyCheckForWebRequest: boolean;
    /**
     * If true, this is the load of a frame's original src attribute
     */
    originalFrameSrcLoad: boolean;
    /**
     * The SEC_FORCE_INHERIT_PRINCIPAL flag may be dropped when a load info
     * object is created.  Specifically, it will be dropped if the SANDBOXED_ORIGIN
     * sandbox flag is also present.  This flag is set if SEC_FORCE_INHERIT_PRINCIPAL
     * was dropped.
     */
    readonly forceInheritPrincipalDropped: boolean;
    /**
     * This is the inner window ID of the window in which the element being
     * loaded lives.
     *
     * Note that this window ID can be 0 if the window is not
     * available.
     */
    readonly innerWindowID: unsigned_long_long;
    /**
     * The BrowsingContext performing the load for this nsILoadInfo object.
     */
    readonly browsingContextID: unsigned_long_long;
    /**
     *
     */
    readonly browsingContext: BrowsingContext;
    /**
     * The BrowsingContext which the worker is associated.
     *
     * Note that this could be 0 if the load is not triggered in a WorkerScope.
     * This value is only set and used in the parent process for some sitautions
     * the channel is created in the parent process for Workers. Such as fetch().
     * In content process, it is always 0.
     * This value would not be propagated through IPC.
     */
    workerAssociatedBrowsingContextID: unsigned_long_long;
    /**
     *
     */
    readonly workerAssociatedBrowsingContext: BrowsingContext;
    /**
     * Only when the element being loaded is <frame src="foo.html">
     * (or, more generally, if the element QIs to nsFrameLoaderOwner),
     * the frameBrowsingContext is the browsing context containing the
     * foo.html document.
     *
     * Note: For other cases, frameBrowsingContextID is 0.
     */
    readonly frameBrowsingContextID: unsigned_long_long;
    /**
     *
     */
    readonly frameBrowsingContext: BrowsingContext;
    /**
     * If the element being loaded is a nsFrameLoaderOwner,
     * `targetBrowsingContext` is the Browsing Context which will contain the
     * loading document (see `frameBrowsingContext`). Otherwise, it is the
     * Browsing Context performing the load (see `browsingContext`).
     */
    readonly targetBrowsingContextID: unsigned_long_long;
    /**
     *
     */
    readonly targetBrowsingContext: BrowsingContext;
    /**
     * Resets the PrincipalToInherit to a freshly created NullPrincipal
     * which inherits the origin attributes from the loadInfo.
     *
     * WARNING: Please only use that function if you know exactly what
     * you are doing!!!
     */
    resetPrincipalToInheritToNullPrincipal(): void;
    /**
     * Customized OriginAttributes within LoadInfo to allow overwriting of the
     * default originAttributes from the loadingPrincipal.
     *
     * In chrome side, originAttributes.privateBrowsingId will always be 0 even if
     * the usePrivateBrowsing is true, because chrome docshell won't set
     * privateBrowsingId on origin attributes (See bug 1278664). This is to make
     * sure nsILoadInfo and nsILoadContext have the same origin attributes.
     */
    originAttributes: jsval;
    /**
     * Whenever a channel is evaluated by the ContentSecurityManager
     * the first time, we set this flag to true to indicate that
     * subsequent calls of AsyncOpen() do not have to enforce all
     * security checks again. E.g., after a redirect there is no
     * need to set up CORS again. We need this separate flag
     * because the redirectChain might also contain internal
     * redirects which might pollute the redirectChain so we can't
     * rely on the size of the redirectChain-array to query whether
     * a channel got redirected or not.
     *
     * Please note, once the flag is set to true it must remain true
     * throughout the lifetime of the channel. Trying to set it
     * to anything else than true will be discarded.
     */
    initialSecurityCheckDone: boolean;
    /**
     * Returns true if the load was triggered from an external application
     * (e.g. Thunderbird). Please note that this flag will only ever be true
     * if the load is of TYPE_DOCUMENT.
     */
    loadTriggeredFromExternal: boolean;
    /**
     * True if the tainting has been set by the service worker.
     */
    readonly serviceWorkerTaintingSynthesized: boolean;
    /**
     * Whenever a channel gets redirected, append the redirect history entry of
     * the channel which contains principal referrer and remote address [before
     * the channels got redirected] to the loadinfo, so that at every point this
     * array provides us information about all the redirects this channel went
     * through.
     * @param channelToDeriveFrom the channel being redirected
     * @param aIsInternalRedirect should be true if the channel is going
     * through an internal redirect, otherwise false.
     */
    appendRedirectHistoryEntry(channelToDeriveFrom: nsIChannelType, isInternalRedirect: boolean): void;
    /**
     * An array of nsIRedirectHistoryEntry which stores redirects associated
     * with this channel. This array is filled whether or not the channel has
     * ever been opened. The last element of the array is associated with the
     * most recent redirect. Please note, that this array *includes* internal
     * redirects.
     */
    readonly redirectChainIncludingInternalRedirects: jsval;
    /**
     * Same as RedirectChain but does *not* include internal redirects.
     */
    readonly redirectChain: jsval;
    /**
     * Returns value set through setCorsPreflightInfo.
     */
    readonly forcePreflight: boolean;
    /**
     * A C++ friendly getter for the forcePreflight flag.
     */
    readonly isPreflight: boolean;
    /**
     * Determine the associated channel's current tainting.  Note, this can
     * change due to a service worker intercept, so it should be checked after
     * OnStartRequest() fires.
     */
    readonly tainting: unsigned_long;
    /**
     * Note a new tainting level and possibly increase the current tainting
     * to match.  If the tainting level is already greater than the given
     * value, then there is no effect.  It is not possible to reduce the tainting
     * level on an existing channel/loadinfo.
     */
    maybeIncreaseTainting(aTainting: unsigned_long): void;
    /**
     * Returns true if this load is for top level document.
     * Note that the load for a sub-frame's document will return false here.
     */
    readonly isTopLevelLoad: boolean;
    /**
     * If this is non-null, this property represents two things: (1) the
     * URI to be used for the principal if the channel with this loadinfo
     * gets a principal based on URI and (2) the URI to use for a document
     * created from the channel with this loadinfo.
     */
    resultPrincipalURI: nsIURI;
    /**
     * This is the URI used to create the most recent channel in the load's
     * redirect chain, if it's different from channel's `originalURI`.
     * This is always null for loads not handled by DocumentLoadListener. If
     * non-null, channelCreationOriginalURI will be used instead of channel's
     * originalURI to re-create the channel in the final content process selected
     * to perform the load.
     */
    channelCreationOriginalURI: nsIURI;
    /**
     * Return the top-level principal, which is the principal of the top-level
     * window.
     */
    readonly topLevelPrincipal: nsIPrincipal;
    /**
     * Returns the CSP (or Preload CSP for preloads) which should be enforced
     * when fetching the resource this loadinfo belongs to.
     *
     * a) Non-navigations:
     * For non-navigation loads, GetCsp() returns what the spec refers to as the
     * "request's client's global object's CSP list". In practice, if this is the
     * loadinfo of a subresource load (e.g an image load), then GetCsp() or
     * GetPreloadCSP() returns the CSP of the document which embeds the image.
     * The returned CSP includes any policy delivered through the HTTP header or
     * also through the meta tag (modulo the difference for preloads, e.g. image
     * preloads have to query GetPreloadCsp() because at the time of preloading
     * we are not entirely sure if the Meta CSP will be applied to the document
     * in the end or not). Please note that GetCSPToInherit() called on a
     * loadinfo for any non-navigation always returns null.
     *
     * b) Navigations:
     * * Top-level loads:
     * For top-level loads (navigations) GetCsp() will return null, unless
     * the navigation is started by a WebExtension, in which case it will
     * return the CSP of the webextension, if any.
     * If you need to query the CSP that potentially should apply to the
     * new top-level load, you have to query GetCspToInherit(), which is
     * the CSP of the request's client's global object, just like GetCsp()
     * is for non-navigation requests.
     *
     * * Iframe-loads:
     * For iframe-loads (navigations) GetCsp() will return the CSP of the
     * parent document, unless the navigation is started by a WebExtension,
     * in which case it will return the CSP of the webextension, if any.
     *
     * If you need to query the CSP that should potentially be inherited
     * into the new document, you have to query GetCSPToInherit().
     *
     * TODO Bug 1557114:
     * After evaluating what CSP to use for frame navigations we should
     * update the above documentation to match the outcome of Bug 1557114.
     */
    GetCsp(): CSPRef;
    /**
     *
     */
    GetPreloadCsp(): CSPRef;
    /**
     *
     */
    GetCspToInherit(): CSPRef;
    /**
     * The top-level document has been user-interacted.
     */
    documentHasUserInteracted: boolean;
    /**
     * During a top-level document channel redirect from tracking to
     * non-tracking resources, our anti-tracking heuristic, grants the storage
     * access permission for a short amount of seconds (See
     * privacy.restrict3rdpartystorage.expiration_redirect pref).
     * We use this flag to remember this decision even if this channel is part
     * of a chain of redirects.
     */
    allowListFutureDocumentsCreatedFromThisRedirectChain: boolean;
    /**
     * Indicates that we need to check if we should apply the anti-tracking
     * heuristic after the channel has been classified.
     */
    needForCheckingAntiTrackingHeuristic: boolean;
    /**
     * A snapshot of the nonce at load start time which is used for CSP
     * checks and only set for:
     * * TYPE_SCRIPT and
     * * TYPE_STYLESHEET
     */
    cspNonce: AString;
    /**
     *
     */
    integrityMetadata: AString;
    /**
     * If the request associated with this load info was blocked by some of
     * our content or load blockers, the reason can be found here.
     * Note that setting this attribute has NO EFFECT on blocking the request.
     * This attribute is only informative!
     *
     * By default the value is '0' - NONE.
     * Each write rewrites the last value.
     * Can be accessed only on a single thread.
     */
    requestBlockingReason: unsigned_long;
    /**
     * The object in charged to receive CSP violation events. It can be null.
     * This attribute will be merged into the CSP object eventually.
     * See bug 1500908.
     */
    cspEventListener: nsICSPEventListener;
    /**
     * This attribute will be true if this is a load triggered by
     * https://html.spec.whatwg.org/multipage/iframe-embed-object.html#process-the-iframe-attributes
     * or https://html.spec.whatwg.org/multipage/obsolete.html#process-the-frame-attributes
     */
    readonly isFromProcessingFrameAttributes: boolean;
    /**
     * This attribute is the loading context's cross origin embedder policy.
     * The value is initialized with corresponding WindowContext which get by
     * innerWindowIID in the nsILoadInfo.
     * It also could be set by workers when fetch is called under
     * the workers' scope.
     */
    loadingEmbedderPolicy: nsILoadInfo_CrossOriginEmbedderPolicy;
    /**
     * This attribute will be true if the top level document has COEP:
     * credentialless enabled in Origin Trial.
     */
    isOriginTrialCoepCredentiallessEnabledForTopLevel: boolean;
    /**
     * This attribute will be true if this is a load triggered by a media
     * element.
     */
    isMediaRequest: boolean;
    /**
     * This attribute will be true if this is a load triggered by a media
     * element and it's an initial request.
     */
    isMediaInitialRequest: boolean;
    /**
     * This attribute will be true if the fetch request is from object or embed
     * elements
     */
    isFromObjectOrEmbed: boolean;
    /**
     * This attribute will be true if the URL is known to be possibly broken and
     * CheckForBrokenChromeURL and RecordZeroLengthEvent should be skipped.
     */
    readonly shouldSkipCheckForBrokenURLOrZeroSized: boolean;
    /**
     * If this is non-null, this property holds the URI as it was before query
     * stripping was performed.
     */
    unstrippedURI: nsIURI;
    /**
     * Whether nsICookieInjector has injected a cookie for this request to
     * handle a cookie banner. This is only done for top-level requests.
     */
    hasInjectedCookieForCookieBannerHandling: boolean;
}

/**
 * The nsILoadURIDelegate interface.
 * Used for delegating URI loads to GeckoView's application, e.g., Custom Tabs
 * or Progressive Web Apps.
 */
declare interface nsILoadURIDelegateType extends nsISupportsType {
    /**
     * Delegates page load error handling. This may be called for either top-level
     * loads or subframes.
     *
     * @param aURI The URI that failed to load.
     * @param aError The error code.
     * @param aErrorModule The error module code.
     * Returns an error page URL to load, or null to show the default error page.
     * No error page is shown at all if an error is thrown.
     */
    handleLoadError(aURI: nsIURIType, aError: nsresult, aErrorModule: short): nsIURI;
}

/**
 *
 */
declare interface nsILocalFileMacType extends nsIFileType {
    /**
     * fileSizeWithResFork
     *
     * Returns the combined size of both the data fork and the resource
     * fork (if present) rather than just the size of the data fork
     * as returned by GetFileSize()
     */
    readonly fileSizeWithResFork: int64_t;
    /**
     * fileType, creator
     *
     * File type and creator attributes
     */
    fileType: OSType;
    /**
     *
     */
    fileCreator: OSType;
    /**
     * launchWithDoc
     *
     * Launch the application that this file points to with a document.
     *
     * @param   aDocToLoad          Must not be NULL. If no document, use nsIFile::launch
     * @param   aLaunchInBackground TRUE if the application should not come to the front.
     */
    launchWithDoc(aDocToLoad: nsIFileType, aLaunchInBackground: boolean): void;
    /**
     * openDocWithApp
     *
     * Open the document that this file points to with the given application.
     *
     * @param   aAppToOpenWith      The application with  which to open the document.
     * If NULL, the creator code of the document is used
     * to determine the application.
     * @param   aLaunchInBackground TRUE if the application should not come to the front.
     */
    openDocWithApp(aAppToOpenWith: nsIFileType, aLaunchInBackground: boolean): void;
    /**
     * isPackage
     *
     * returns true if a directory is determined to be a package under Mac OS 9/X
     */
    isPackage(): boolean;
    /**
     * bundleDisplayName
     *
     * returns the display name of the application bundle (usually the human
     * readable name of the application)
     */
    readonly bundleDisplayName: AString;
    /**
     * bundleIdentifier
     *
     * returns the identifier of the bundle
     */
    readonly bundleIdentifier: AUTF8String;
    /**
     * Last modified time of a bundle's contents (as opposed to its package
     * directory).  Our convention is to make the bundle's Info.plist file
     * stand in for the rest of its contents -- since this file contains the
     * bundle's version information and other identifiers.  For non-bundles
     * this is the same as lastModifiedTime.
     */
    readonly bundleContentsLastModifiedTime: int64_t;
    /**
     * Return whether or not the file has an extended attribute.
     *
     * @param aAttrName The attribute name to check for.
     *
     * @return Whether or not the extended attribute is present.
     */
    hasXAttr(aAttrName: ACString): bool;
    /**
     * Set an extended attribute.
     *
     * @param aAttrName The attribute name to set a value for.
     * @param aAttrValue The value to set for the attribute.
     */
    setXAttr(aAttrName: ACString, aAttrValue: invalid): void;
    /**
     * Delete an extended attribute.
     *
     * @param aAttrName The extended attribute to delete.
     */
    delXAttr(aAttrName: ACString): void;
}

/**
 *
 */
declare interface nsILocalFileWinType extends nsIFileType {
    /**
     * initWithCommandLine
     *
     * Initialize this object based on the main app path of a commandline
     * handler.
     *
     * @param aCommandLine
     * the commandline to parse an app path out of.
     */
    initWithCommandLine(aCommandLine: AString): void;
    /**
     * getVersionInfoValue
     *
     * Retrieve a metadata field from the file's VERSIONINFO block.
     * Throws NS_ERROR_FAILURE if no value is found, or the value is empty.
     *
     * @param   aField         The field to look up.
     */
    getVersionInfoField(aField: string): AString;
    /**
     * The canonical path of the file, which avoids short/long
     * pathname inconsistencies. The nsIFile persistent
     * descriptor is not guaranteed to be canonicalized (it may
     * persist either the long or the short path name). The format of
     * the canonical path will vary with the underlying file system:
     * it will typically be the short pathname on filesystems that
     * support both short and long path forms.
     */
    readonly canonicalPath: AString;
    /**
     * Get or set whether this file is marked read-only.
     *
     * Throws NS_ERROR_FILE_INVALID_PATH for an invalid file.
     * Throws NS_ERROR_FAILURE if the set or get fails.
     */
    readOnly: bool;
    /**
     * Setting this to true will prepend the prefix "\\?\" to all parsed file
     * paths which match ^[A-Za-z]:\\.* (regex) syntax.
     *
     * There are two known issues (and potentially more) which can be resolved
     * by the prefix:
     * - In the Windows API, the maximum length for a path is MAX_PATH in
     * general. However, Windows API has many functions that also have Unicode
     * versions to permit an extended-length path for a maximum total path
     * length of 32,767 characters.
     *
     * - A path component which ends with a dot is not allowed for Windows
     * API.
     *
     * If either of these issues are expected to be common in your code, you
     * should set this flag to true. (You should probably not have to set this
     * flag to true.)
     */
    useDOSDevicePathSyntax: boolean;
}

/**
 * Methods specific to LocalStorage, see nsIDOMStorageManager for methods shared
 * with SessionStorage.  Methods may migrate there as SessionStorage is
 * overhauled.
 */
declare interface nsILocalStorageManagerType extends nsISupportsType {
    /**
     *
     */
    readonly nextGenLocalStorageEnabled: boolean;
    /**
     * Trigger preload of LocalStorage for the given principal.  For use by
     * ContentParent::AboutToLoadHttpFtpDocumentForChild to maximize the
     * amount of time we have to load the data off disk before the page might
     * attempt to touch LocalStorage.
     *
     * This method will not create a QuotaManager-managed directory on disk if
     * one does not already exist for the principal.
     */
    preload(aPrincipal: nsIPrincipalType): Promise;
    /**
     *
     */
    isPreloaded(aPrincipal: nsIPrincipalType): Promise;
    /**
     *
     */
    getState(aPrincipal: nsIPrincipalType): Promise;
}

/**
 *
 */
declare interface nsILoginAutoCompleteSearchType extends nsISupportsType {
    /**
     * Generate results for a login field autocomplete menu.
     *
     * NOTE: This interface is provided for use only by the FormFillController,
     * which calls it directly. This isn't really ideal, it should
     * probably be callback registered through the FFC.
     * NOTE: This API is different than nsIAutoCompleteSearch.
     */
    startSearch(aSearchString: AString, aPreviousResult: nsIAutoCompleteResultType, aElement: HTMLInputElement, aListener: nsIFormAutoCompleteObserverType): void;
    /**
     * Stop a previously-started search.
     */
    stopSearch(): void;
}

/**
 *
 */
declare interface nsILoginDetectionServiceType extends nsISupportsType {
    /**
     * called to initialize the login detection service.
     */
    init(): void;
    /**
     * Returns true if we have loaded logins from the password manager.
     * This is now used by testcase only.
     */
    isLoginsLoaded(): bool;
}

/**
 * An object containing information for a login stored by the
 * password manager.
 */
declare interface nsILoginInfoType extends nsISupportsType {
    /**
     * A string to display to the user for the origin which includes the httpRealm,
     * where applicable.
     * e.g. "site.com", "site.com:1234", or "site.com (My Secure Realm)"
     */
    readonly displayOrigin: AString;
    /**
     * The origin the login applies to.
     *
     * For example,
     * "https://site.com", "http://site.com:1234", "ftp://ftp.site.com",
     * "moz-proxy://127.0.0.1:8888, "chrome://FirefoxAccounts", "file://".
     */
    origin: AString;
    /**
     * The origin the login applies to, incorrectly called a hostname.
     * @deprecated in favor of `origin`
     */
    hostname: AString;
    /**
     * The origin a form-based login was submitted to.
     *
     * For logins obtained from HTML forms, this field is the origin of the |action|
     * attribute from the |form| element. For
     * example "http://www.site.com". [Forms with no |action| attribute
     * default to submitting to their origin URL, so we store that.]
     *
     * For logins obtained from a HTTP or FTP protocol authentication,
     * this field is NULL.
     */
    formActionOrigin: AString;
    /**
     * The origin a form-based login was submitted to, incorrectly referred to as a URL.
     * @deprecated in favor of `formActionOrigin`
     */
    formSubmitURL: AString;
    /**
     * The HTTP Realm a login was requested for.
     *
     * When an HTTP server sends a 401 result, the WWW-Authenticate
     * header includes a realm to identify the "protection space." See
     * RFC2617. If the response sent has a missing or blank realm, the
     * hostname is used instead.
     *
     * For logins obtained from HTML forms, this field is NULL.
     */
    httpRealm: AString;
    /**
     * The username for the login.
     */
    username: AString;
    /**
     * The |name| attribute for the username input field.
     *
     * For logins obtained from a HTTP or FTP protocol authentication,
     * this field is an empty string.
     *
     * @note This attribute is currently saved but not used.
     */
    usernameField: AString;
    /**
     * The password for the login.
     */
    password: AString;
    /**
     * The |name| attribute for the password input field.
     *
     * For logins obtained from a HTTP or FTP protocol authentication,
     * this field is an empty string.
     *
     * @note This attribute is currently saved but not used.
     */
    passwordField: AString;
    /**
     * Unknown fields this client doesn't know about but will be roundtripped
     * for other clients to prevent data loss
     */
    unknownFields: AString;
    /**
     * True if the login has ever been synced at some point.
     */
    everSynced: boolean;
    /**
     * A counter used to indicate that syncing is occuring. It will get restored to 0
     * once syncing is complete.
     */
    syncCounter: long;
    /**
     * Initialize a newly created nsLoginInfo object.
     *
     * The arguments are the fields for the new object.
     */
    init(aOrigin: AString, aFormActionOrigin: AString, aHttpRealm: AString, aUsername: AString, aPassword: AString, aUsernameField: AString, aPasswordField: AString): void;
    /**
     * Test for strict equality with another nsILoginInfo object.
     *
     * @param aLoginInfo
     * The other object to test.
     */
    equals(aLoginInfo: nsILoginInfoType): boolean;
    /**
     * Test for loose equivalency with another nsILoginInfo object. The
     * passwordField and usernameField values are ignored, and the password
     * values may be optionally ignored. If one login's formSubmitURL is an
     * empty string (but not null), it will be treated as a wildcard. [The
     * blank value indicates the login was stored before bug 360493 was fixed.]
     *
     * @param aLoginInfo
     * The other object to test.
     * @param ignorePassword
     * If true, ignore the password when checking for match.
     */
    matches(aLoginInfo: nsILoginInfoType, ignorePassword: boolean): boolean;
    /**
     * Create an identical copy of the login, duplicating all of the login's
     * nsILoginInfo and nsILoginMetaInfo properties.
     *
     * This allows code to be forwards-compatible, when additional properties
     * are added to nsILoginMetaInfo (or nsILoginInfo) in the future.
     */
    clone(): nsILoginInfo;
}

/**
 *
 */
declare interface nsILoginSearchCallbackType extends nsISupportsType {
    /**
     * Called when a search is complete and the results are ready.
     *
     * @param aLogins
     * Logins found in the search.
     */
    onSearchComplete(aLogins: invalid): void;
}

/**
 *
 */
declare interface nsILoginManagerType extends nsISupportsType {
    /**
     * This promise is resolved when initialization is complete, and is rejected
     * in case initialization failed.  This includes the initial loading of the
     * login data as well as any migration from previous versions.
     *
     * Calling any method of nsILoginManager before this promise is resolved
     * might trigger the synchronous initialization fallback.
     */
    readonly initializationPromise: Promise;
    /**
     * Store a new login in the login manager.
     *
     * @param aLogin
     * The login to be added.
     * @return a clone of the login info with the guid set (even if it was not provided)
     *
     * Default values for the login's nsILoginMetaInfo properties will be
     * created. However, if the caller specifies non-default values, they will
     * be used instead.
     */
    addLogin(aLogin: nsILoginInfoType): nsILoginInfo;
    /**
     * Like addLogin, but asynchronous.
     *
     * @param aLogin
     * The login to be added.
     * @return A promise which resolves with a cloned login with the guid set.
     *
     * Default values for each login's nsILoginMetaInfo properties will be
     * created. However, if the caller specifies non-default values, they will
     * be used instead.
     */
    addLoginAsync(aLogin: nsILoginInfoType): Promise;
    /**
     * Like addLogin, but asynchronous and for many logins.
     *
     * @param aLogins
     * A JS Array of nsILoginInfos to add.
     * @return A promise which resolves with a JS Array of cloned logins with
     * the guids set.
     *
     * Default values for each login's nsILoginMetaInfo properties will be
     * created. However, if the caller specifies non-default values, they will
     * be used instead.
     */
    addLogins(aLogins: jsval): Promise;
    /**
     * Remove a login from the login manager.
     *
     * @param aLogin
     * The login to be removed.
     *
     * The specified login must exactly match a stored login. However, the
     * values of any nsILoginMetaInfo properties are ignored.
     */
    removeLogin(aLogin: nsILoginInfoType): void;
    /**
     * Modify an existing login in the login manager.
     *
     * @param oldLogin
     * The login to be modified.
     * @param newLoginData
     * The new login values (either a nsILoginInfo or nsIProperyBag)
     *
     * If newLoginData is a nsILoginInfo, all of the old login's nsILoginInfo
     * properties are changed to the values from newLoginData (but the old
     * login's nsILoginMetaInfo properties are unmodified).
     *
     * If newLoginData is a nsIPropertyBag, only the specified properties
     * will be changed. The nsILoginMetaInfo properties of oldLogin can be
     * changed in this manner.
     *
     * If the propertybag contains an item named "timesUsedIncrement", the
     * login's timesUsed property will be incremented by the item's value.
     */
    modifyLogin(oldLogin: nsILoginInfoType, newLoginData: nsISupportsType): void;
    /**
     * Record that the password of a saved login was used (e.g. submitted or copied).
     *
     * @param {nsILoginInfo} aLogin
     * The login record of the password that was used.
     * @param {boolean} aPrivateContextWithoutExplicitConsent
     * If the use was in private browsing AND without the user explicitly choosing to save/update.
     * Login use metadata will not be updated in this case but it will stil be counted for telemetry.
     * @param {AString} aLoginType
     * One of "form_login", "form_password", "auth_login", or "prompt_login".
     * See saved_login_used in Events.yaml.
     * Don't assume that an auth. login is never used in a form and vice-versa. This argument
     * indicates the context of how it was used.
     * @param {boolean} aFilled
     * Whether the login was filled, rather than being typed manually.
     *
     * If only the username was used, this method shouldn't be called as we don't
     * want to double-count the use if both the username and password are copied.
     * Copying of the username normally precedes the copying of the password anyways.
     */
    recordPasswordUse(aLogin: nsILoginInfoType, aPrivateContextWithoutExplicitConsent: boolean, aLoginType: AString, aFilled: boolean): void;
    /**
     * Remove all stored user facing logins.
     *
     * This will remove all the logins that a user can access through about:logins.
     * This will not remove the FxA Sync key which is stored with the rest of a user's logins
     * but is not accessible through about:logins
     *
     * The browser sanitization feature allows the user to clear any stored
     * passwords. This interface allows that to be done without getting each
     * login first.
     */
    removeAllUserFacingLogins(): void;
    /**
     * Completely remove all logins, including the user's FxA Sync key.
     */
    removeAllLogins(): void;
    /**
     * Fetch all logins in the login manager. An array is always returned;
     * if there are no logins the array is empty. Decryption is handled in
     * one batch.
     *
     * @return A promise which resolves with a JS Array of nsILoginInfo objects.
     */
    getAllLogins(): Promise;
    /**
     * Like getAllLogins, but with a callback returning the search results.
     *
     * @param {nsILoginSearchCallback} aCallback
     * The interface to notify when the search is complete.
     */
    getAllLoginsWithCallback(aCallback: nsILoginSearchCallbackType): void;
    /**
     * Check to see if saving logins has been disabled for an origin.
     *
     * @param aHost
     * The origin to check. For example: "http://foo.com".
     */
    getLoginSavingEnabled(aHost: AString): boolean;
    /**
     * Disable (or enable) storing logins for the specified origin. When
     * disabled, the login manager will not prompt to store logins for
     * that origin. Existing logins are not affected.
     *
     * @param aHost
     * The origin to set. For example: "http://foo.com".
     * @param isEnabled
     * Specify if saving logins should be enabled (true) or
     * disabled (false)
     */
    setLoginSavingEnabled(aHost: AString, isEnabled: boolean): void;
    /**
     * Search for logins matching the specified criteria, as with
     * findLogins(). This interface only returns the number of matching
     * logins (and not the logins themselves), which allows a caller to
     * check for logins without causing the user to be prompted for a primary
     * password to decrypt the logins.
     *
     * @param aOrigin
     * The origin to restrict searches to. Specify an empty string
     * to match all origins. A null value will not match any logins, and
     * will thus always return a count of 0.
     * @param aActionOrigin
     * The origin to which a form login will be submitted. To match any
     * form login, specify an empty string. To not match any form
     * login, specify null.
     * @param aHttpRealm
     * The HTTP Realm for which the login applies. To match logins for
     * any realm, specify an empty string. To not match logins for any
     * realm, specify null.
     */
    countLogins(aOrigin: AString, aActionOrigin: AString, aHttpRealm: AString): unsigned_long;
    /**
     * Asynchonously search for logins in the login manager. The Promise always
     * resolves to an array; if there are no logins the array is empty.
     *
     * @param {object} matchData
     * The data used to search as a JS object. This does not follow the same
     * requirements as findLogins for those fields. Wildcard matches are
     * simply not specified. If a `guid` is specified then no other properties
     * are used (outside of GeckoView).
     * @return A promise resolving to an array of nsILoginInfo objects.
     */
    searchLoginsAsync(matchData: jsval): Promise;
    /**
     * Returns the "sync id" used by Sync to know whether the store is current with
     * respect to the sync servers.
     *
     * Returns null if the data doesn't exist or if the data can't be
     * decrypted (including if the primary-password prompt is cancelled). This is
     * OK for Sync as it can't even begin syncing if the primary-password is
     * locked as the sync encrytion keys are stored in this login manager.
     */
    getSyncID(): Promise;
    /**
     * Sets the "sync id" used by Sync to know whether the store is current with
     * respect to the sync servers. May be set to null.
     *
     * Throws if the data can't be encrypted (including if the primary-password
     * prompt is cancelled)
     */
    setSyncID(syncID: AString): Promise;
    /**
     * Returns the timestamp of the last sync as a double (in seconds since Epoch
     * rounded to two decimal places), or 0.0 if the data doesn't exist.
     */
    getLastSync(): Promise;
    /**
     * Sets the timestamp of the last sync.
     */
    setLastSync(timestamp: double): Promise;
    /**
     * Ensures that the local sync ID for the engine matches the sync ID for
     * the collection on the server. If they don't match, then we set
     * the local sync ID to newSyncID and reset the last sync timestamp.
     */
    ensureCurrentSyncID(newSyncID: AString): Promise;
    /**
     * True when a primary password prompt is being displayed.
     */
    readonly uiBusy: boolean;
    /**
     * True when the primary password has already been entered, and so a caller
     * can ask for decrypted logins without triggering a prompt.
     */
    readonly isLoggedIn: boolean;
}

/**
 *
 */
declare interface nsILoginManagerAuthPrompterType extends nsISupportsType {
    /**
     * Initialize the prompter. Must be called before using other interfaces.
     *
     * @param aWindow
     * The window in which the user is doing some login-related action that's
     * resulting in a need to prompt them for something. The prompt
     * will be associated with this window (or, if a notification bar
     * is being used, topmost opener in some cases).
     *
     * aWindow can be null if there is no associated window, e.g. in a JSM
     * or Sandbox. In this case there will be no checkbox to save the login
     * since the window is needed to know if this is a private context.
     *
     * If this window is a content window, the corresponding window and browser
     * elements will be calculated. If this window is a chrome window, the
     * corresponding browser element needs to be set using setBrowser.
     */
    init(aWindow: nsIDOMWindowType): void;
    /**
     * The browser this prompter is being created for.
     * This is required if the init function received a chrome window as argument.
     */
    browser: Element;
}

/**
 *
 */
declare interface nsILoginManagerCryptoType extends nsISupportsType {
    /**
     * encrypt
     *
     * @param plainText
     * The string to be encrypted.
     *
     * Encrypts the specified string, returning the ciphertext value.
     *
     * NOTE: The current implemention of this inferface simply uses NSS/PSM's
     * "Secret Decoder Ring" service. It is not recommended for general
     * purpose encryption/decryption.
     *
     * Can throw if the user cancels entry of their primary password.
     */
    encrypt(plainText: AString): AString;
    /**
     * encryptMany
     *
     * @param plainTexts
     * The strings to be encrypted.
     *
     * Encrypts the specified strings, similar to encrypt, but returning a promise
     * which resolves with the the encrypted strings.
     */
    encryptMany(plainTexts: jsval): Promise;
    /**
     * decrypt
     *
     * @param cipherText
     * The string to be decrypted.
     *
     * Decrypts the specified string, returning the plaintext value.
     *
     * Can throw if the user cancels entry of their primary password, or if the
     * cipherText value can not be successfully decrypted (eg, if it was
     * encrypted with some other key).
     */
    decrypt(cipherText: AString): AString;
    /**
     * @param cipherTexts
     * The strings to be decrypted.
     *
     * Decrypts the specified strings, returning the plaintext values.
     *
     * Can throw if the user cancels entry of their primary password, or if the
     * cipherText value can not be successfully decrypted (eg, if it was
     * encrypted with some other key).
     */
    decryptMany(cipherTexts: jsval): Promise;
    /**
     * uiBusy
     *
     * True when a primary password prompt is being displayed.
     */
    readonly uiBusy: boolean;
    /**
     * isLoggedIn
     *
     * Current login state of the token used for encryption. If the user is
     * not logged in, performing a crypto operation will result in a primary
     * password prompt.
     */
    readonly isLoggedIn: boolean;
    /**
     * defaultEncType
     *
     * Default encryption type used by an implementation of this interface.
     */
    readonly defaultEncType: unsigned_long;
}

/**
 *
 */
declare interface nsILoginManagerPrompterType extends nsISupportsType {
    /**
     * Ask the user if they want to save a login (Yes, Never, Not Now)
     *
     * @param aBrowser
     * The browser of the webpage request that triggered the prompt.
     * @param aLogin
     * The login to be saved.
     * @param dismissed
     * A boolean value indicating whether the save logins doorhanger should
     * be dismissed automatically when shown.
     * @param notifySaved
     * A boolean value indicating whether the notification should indicate that
     * a login has been saved
     * @param autoFilledLoginGuid
     * A string guid value for the login which was autofilled into the form
     * @param possibleValues
     * Contains values from anything that we think, but are not sure, might be
     * a username or password.  Has two properties, 'usernames' and 'passwords'.
     */
    promptToSavePassword(aBrowser: Element, aLogin: nsILoginInfoType, dismissed: boolean, notifySaved: boolean, autoFilledLoginGuid: AString, possibleValues: jsval): nsIPromptInstance;
    /**
     * Ask the user if they want to change a login's password or username.
     * If the user consents, modifyLogin() will be called.
     *
     * @param aBrowser
     * The browser of the webpage request that triggered the prompt.
     * @param aOldLogin
     * The existing login (with the old password).
     * @param aNewLogin
     * The new login.
     * @param dismissed
     * A boolean value indicating whether the save logins doorhanger should
     * be dismissed automatically when shown.
     * @param autoSavedLoginGuid
     * A string guid value for the old login to be removed if the changes
     * match it to a different login
     * @param autoFilledLoginGuid
     * A string guid value for the login which was autofilled into the form
     * @param possibleValues
     * Contains values from anything that we think, but are not sure, might be
     * a username or password.  Has two properties, 'usernames' and 'passwords'.
     */
    promptToChangePassword(aBrowser: Element, aOldLogin: nsILoginInfoType, aNewLogin: nsILoginInfoType, dismissed: boolean, notifySaved: boolean, autoSavedLoginGuid: AString, autoFilledLoginGuid: AString, possibleValues: jsval): nsIPromptInstance;
    /**
     * Ask the user if they want to change the password for one of
     * multiple logins, when the caller can't determine exactly which
     * login should be changed. If the user consents, modifyLogin() will
     * be called.
     *
     * @param aBrowser
     * The browser of the webpage request that triggered the prompt.
     * @param logins
     * An array of existing logins.
     * @param aNewLogin
     * The new login.
     *
     * Note: Because the caller does not know the username of the login
     * to be changed, aNewLogin.username and aNewLogin.usernameField
     * will be set (using the user's selection) before modifyLogin()
     * is called.
     */
    promptToChangePasswordWithUsernames(aBrowser: Element, logins: invalid, aNewLogin: nsILoginInfoType): nsIPromptInstance;
}

/**
 * NOTE: This interface is intended to be implemented by modules
 * providing storage mechanisms for the login manager.
 * Other code should use the login manager's interfaces
 * (nsILoginManager), and should not call storage modules
 * directly.
 */
declare interface nsILoginManagerStorageType extends nsISupportsType {
    /**
     * Initialize the component.
     *
     * At present, other methods of this interface may be called before the
     * returned promise is resolved or rejected.
     *
     * @return {Promise}
     * @resolves When initialization is complete.
     * @rejects JavaScript exception.
     */
    initialize(): Promise;
    /**
     * Ensures that all data has been written to disk and all files are closed.
     *
     * At present, this method is called by regression tests only.  Finalization
     * on shutdown is done by observers within the component.
     *
     * @return {Promise}
     * @resolves When finalization is complete.
     * @rejects JavaScript exception.
     */
    terminate(): Promise;
    /**
     * Store a new login in the storage module.
     *
     * @param aLogin
     * The login to be added.
     * @param aPreEncrypted
     * Whether the login was already encrypted or not.
     * @param aPlaintextUsername
     * The plaintext username, if the login was already encrypted.
     * @param aPlaintextPassword
     * The plaintext password, if the login was already encrypted.
     * @return a clone of the login info with the guid set (even if it was not provided).
     *
     * Default values for the login's nsILoginMetaInfo properties will be
     * created. However, if the caller specifies non-default values, they will
     * be used instead.
     */
    addLogin(aLogin: nsILoginInfoType, aPreEncrypted: boolean, aPlaintextUsername: jsval, aPlaintextPassword: jsval): nsILoginInfo;
    /**
     * Remove a login from the storage module.
     *
     * @param aLogin
     * The login to be removed.
     *
     * The specified login must exactly match a stored login. However, the
     * values of any nsILoginMetaInfo properties are ignored.
     */
    removeLogin(aLogin: nsILoginInfoType): void;
    /**
     * Modify an existing login in the storage module.
     *
     * @param oldLogin
     * The login to be modified.
     * @param newLoginData
     * The new login values (either a nsILoginInfo or nsIProperyBag)
     *
     * If newLoginData is a nsILoginInfo, all of the old login's nsILoginInfo
     * properties are changed to the values from newLoginData (but the old
     * login's nsILoginMetaInfo properties are unmodified).
     *
     * If newLoginData is a nsIPropertyBag, only the specified properties
     * will be changed. The nsILoginMetaInfo properties of oldLogin can be
     * changed in this manner.
     *
     * If the propertybag contains an item named "timesUsedIncrement", the
     * login's timesUsed property will be incremented by the item's value.
     */
    modifyLogin(oldLogin: nsILoginInfoType, newLoginData: nsISupportsType): void;
    /**
     * Record that the password of a saved login was used (e.g. submitted or copied).
     *
     * @param nsILoginInfo aLogin
     * The login record of the password that was used.
     *
     * If only the username was used, this method shouldn't be called as we don't
     * want to double-count the use if both the username and password are copied.
     * Copying of the username normally precedes the copying of the password anyways.
     */
    recordPasswordUse(aLogin: nsILoginInfoType): void;
    /**
     * Remove all stored user facing logins.
     *
     * This will remove all the logins that a user can access through about:logins.
     * This will not remove the FxA Sync key which is stored with the rest of a user's logins
     * but is not accessible through about:logins
     *
     * The browser sanitization feature allows the user to clear any stored
     * passwords. This interface allows that to be done without getting each
     * login first.
     */
    removeAllUserFacingLogins(): void;
    /**
     * Completely remove all logins, including the user's FxA key.
     */
    removeAllLogins(): void;
    /**
     * Fetch all logins in the login manager. An array is always returned;
     * if there are no logins the array is empty.
     *
     * @return An array of nsILoginInfo objects.
     */
    getAllLoginsAsync(): Promise;
    /**
     * Asynchonously search for logins in the login manager. The Promise always
     * resolves to an array; if there are no logins the array is empty.
     *
     * @param {object} matchData
     * The data used to search as a JS object. This does not follow the same
     * requirements as findLogins for those fields. Wildcard matches are
     * simply not specified.
     * @return A promise resolving to an array of nsILoginInfo objects.
     */
    searchLoginsAsync(matchData: jsval): Promise;
    /**
     * Search for logins matching the specified criteria, as with
     * findLogins(). This interface only returns the number of matching
     * logins (and not the logins themselves), which allows a caller to
     * check for logins without causing the user to be prompted for a primary
     * password to decrypt the logins.
     *
     * @param aOrigin
     * The origin to restrict searches to. Specify an empty string
     * to match all origins. A null value will not match any logins, and
     * will thus always return a count of 0.
     * @param aActionOrigin
     * The origin to which a form login will be submitted. To match any
     * form login, specify an empty string. To not match any form
     * login, specify null.
     * @param aHttpRealm
     * The HTTP Realm for which the login applies. To match logins for
     * any realm, specify an empty string. To not match logins for any
     * realm, specify null.
     */
    countLogins(aOrigin: AString, aActionOrigin: AString, aHttpRealm: AString): unsigned_long;
    /**
     * Returns the "sync id" used by Sync to know whether the store is current with
     * respect to the sync servers.
     *
     * Returns null if the data doesn't exist or if the data can't be
     * decrypted (including if the primary-password prompt is cancelled). This is
     * OK for Sync as it can't even begin syncing if the primary-password is
     * locked as the sync encrytion keys are stored in this login manager.
     */
    getSyncID(): Promise;
    /**
     * Sets the "sync id" used by Sync to know whether the store is current with
     * respect to the sync servers. May be set to null.
     *
     * Throws if the data can't be encrypted (including if the primary-password
     * prompt is cancelled)
     */
    setSyncID(syncID: AString): Promise;
    /**
     * Returns the timestamp of the last sync as a double (in seconds since Epoch
     * rounded to two decimal places), or 0.0 if the data doesn't exist.
     */
    getLastSync(): Promise;
    /**
     * Sets the timestamp of the last sync.
     */
    setLastSync(timestamp: double): Promise;
    /**
     * True when a primary password prompt is being shown.
     */
    readonly uiBusy: boolean;
    /**
     * True when the primary password has already been entered, and so a caller
     * can ask for decrypted logins without triggering a prompt.
     */
    readonly isLoggedIn: boolean;
}

/**
 * An object containing metainfo for a login stored by the login manager.
 *
 * Code using login manager can generally ignore this interface. When adding
 * logins, default value will be created. When modifying logins, these
 * properties will be unchanged unless a change is explicitly requested [by
 * using modifyLogin() with a nsIPropertyBag]. When deleting a login or
 * comparing logins, these properties are ignored.
 */
declare interface nsILoginMetaInfoType extends nsISupportsType {
    /**
     * The GUID to uniquely identify the login. This can be any arbitrary
     * string, but a format as created by nsIUUIDGenerator is recommended.
     * For example, "{d4e1a1f6-5ea0-40ee-bff5-da57982f21cf}"
     *
     * addLogin will generate a random value unless a value is provided.
     *
     * addLogin and modifyLogin will throw if the GUID already exists.
     */
    guid: AString;
    /**
     * The time, in Unix Epoch milliseconds, when the login was first created.
     */
    timeCreated: unsigned_long_long;
    /**
     * The time, in Unix Epoch milliseconds, when the login was last submitted
     * in a form or used to begin an HTTP auth session.
     */
    timeLastUsed: unsigned_long_long;
    /**
     * The time, in Unix Epoch milliseconds, when the login was last modified.
     *
     * Contrary to what the name may suggest, this attribute takes into account
     * not only the password but also the username attribute.
     */
    timePasswordChanged: unsigned_long_long;
    /**
     * The number of times the login was submitted in a form or used to begin
     * an HTTP auth session.
     */
    timesUsed: unsigned_long;
}

/**
 *
 */
declare interface nsILoginReputationVerdictTypeType extends nsISupportsType {
}

/**
 *
 */
declare interface nsILoginReputationQueryType extends nsISupportsType {
    /**
     *
     */
    readonly formURI: nsIURI;
}

/**
 *
 */
declare interface nsILoginReputationQueryCallbackType extends nsISupportsType {
    /**
     *
     */
    onComplete(aStatus: nsresult, aVerdict: unsigned_long): void;
}

/**
 *
 */
declare interface nsILoginReputationServiceType extends nsISupportsType {
    /**
     *
     */
    init(): void;
    /**
     *
     */
    queryReputationAsync(aInput: HTMLInputElement, aCallback: nsILoginReputationQueryCallbackType): void;
    /**
     *
     */
    queryReputation(aQuery: nsILoginReputationQueryType, aCallback: nsILoginReputationQueryCallbackType): void;
}

/**
 *
 */
declare interface nsIMIMEHeaderParamType extends nsISupportsType {
    /**
     * Given the value of a single header field  (such as
     * Content-Disposition and Content-Type) and the name of a parameter
     * (e.g. filename, name, charset), returns the value of the parameter.
     * The value is obtained by decoding RFC 2231/5987-style encoding,
     * RFC 2047-style encoding, and converting to UniChar(UTF-16)
     * from charset specified in RFC 2231/2047 encoding, UTF-8,
     * `aFallbackCharset`, the locale charset as fallback if
     * `TryLocaleCharset` is set, and null-padding as last resort
     * if all else fails.
     *
     *
     *
     * This method internally invokes `getParameterInternal`,
     * However, it does not stop at decoding RFC 2231 (the task for
     * `getParameterInternal` but tries to cope
     * with several non-standard-compliant cases mentioned below.
     *
     *
     *
     * Note that a lot of MUAs put RFC 2047-encoded parameters. Unfortunately,
     * this includes Mozilla as of 2003-05-30. Even more standard-ignorant MUAs,
     * web servers and application servers put 'raw 8bit characters'. This will
     * try to cope with all these cases as gracefully as possible. Additionally,
     * it returns the language tag if the parameter is encoded per RFC 2231 and
     * includes lang.
     *
     *
     *
     * Note that GetParameterHTTP skips some of the workarounds used for
     * mail (MIME) header fields, and thus SHOULD be used from non-mail
     * code.
     *
     *
     * @param  aHeaderVal        a header string to get the value of a parameter
     * from.
     * @param  aParamName        the name of a MIME header parameter (e.g.
     * filename, name, charset). If empty,  returns
     * the first (possibly) _unnamed_ 'parameter'.
     * @param  aFallbackCharset  fallback charset to try if  the string after
     * RFC 2231/2047 decoding or the raw 8bit
     * string is not UTF-8
     * @param  aTryLocaleCharset If set, makes yet another attempt
     * with the locale charset.
     * @param  aLang             If non-null, assigns it to a pointer
     * to a string containing the value of language
     * obtained from RFC 2231 parsing. Caller has to
     * free it.
     * @return the value of `aParamName` in Unichar(UTF-16).
     */
    getParameter(aHeaderVal: ACString, aParamName: string, aFallbackCharset: ACString, aTryLocaleCharset: boolean, aLang: string): AString;
    /**
     * Like getParameter, but disabling encodings and workarounds specific to
     * MIME (as opposed to HTTP).
     */
    getParameterHTTP(aHeaderVal: ACString, aParamName: string, aFallbackCharset: ACString, aTryLocaleCharset: boolean, aLang: string): AString;
    /**
     * Given the value of a header field parameter using the encoding
     * defined in RFC 5987, decode the value into a Unicode string, and extract
     * the optional language parameter.
     *
     *
     *
     * This function is purposefully picky; it will abort for all (most?)
     * invalid inputs. This is by design. In particular, it does not support
     * any character encodings other than UTF-8, in order not to promote
     * non-interoperable usage.
     *
     *
     *
     * Code that parses HTTP header fields (as opposed to MIME header fields)
     * should use this function.
     *
     * @param  aParamVal         a header field parameter to decode.
     * @param  aLang             will be set to the language part (possibly
     * empty).
     * @return the decoded parameter value.
     */
    decodeRFC5987Param(aParamVal: ACString, aLang: ACString): AString;
}

/**
 * nsIHandlerInfo gives access to the information about how a given protocol
 * scheme or MIME-type is handled.
 */
declare interface nsIHandlerInfoType extends nsISupportsType {
    /**
     * The type of this handler info.  For MIME handlers, this is the MIME type.
     * For protocol handlers, it's the scheme.
     *
     * @return String representing the type.
     */
    readonly type: ACString;
    /**
     * A human readable description of the handler type
     */
    description: AString;
    /**
     * The application the user has said they want associated with this content
     * type. This is not always guaranteed to be set!!
     */
    preferredApplicationHandler: nsIHandlerApp;
    /**
     * Applications that can handle this content type.
     *
     * The list will include the preferred handler, if any.  Elements of this
     * array are nsIHandlerApp objects, and this attribute will always reference
     * an array, whether or not there are any possible handlers.  If there are
     * no possible handlers, the array will contain no elements, so just check
     * its length (nsIArray::length) to see if there are any possible handlers.
     */
    readonly possibleApplicationHandlers: nsIMutableArray;
    /**
     * Indicates whether a default application handler exists,
     * i.e. whether launchWithFile with action = useSystemDefault is possible
     * and defaultDescription will contain usable information.
     */
    readonly hasDefaultHandler: boolean;
    /**
     * A pretty name description of the associated default application. Only
     * usable if hasDefaultHandler is true.
     */
    readonly defaultDescription: AString;
    /**
     * Launches the application with the specified URI, in a way that
     * depends on the value of preferredAction. preferredAction must be
     * useHelperApp or useSystemDefault.
     *
     * @note Only the URI scheme is used to determine how to launch.  This is
     * essentially a pass-by-value operation.  This means that in the case of
     * a file: URI, the handler that is registered for file: will be launched
     * and our code will not make any decision based on the content-type or
     * extension, though the invoked file: handler is free to do so.
     *
     * @param aURI
     * The URI to launch this application with
     *
     * @param aBrowsingContext
     * The window to parent the dialog against, and, if a web handler
     * is chosen, it is loaded in this window as well.  See
     * nsIHandlerApp.launchWithURI for more details.
     *
     * @throw NS_ERROR_INVALID_ARG if preferredAction is not valid for this
     * call. Other exceptions may be thrown.
     */
    launchWithURI(aURI: nsIURIType, aBrowsingContext: BrowsingContext): void;
    /**
     * preferredAction is how the user specified they would like to handle
     * this content type: save to disk, use specified helper app, use OS
     * default handler or handle using navigator; possible value constants
     * listed below
     */
    preferredAction: nsHandlerInfoAction;
    /**
     * alwaysAskBeforeHandling: if true, we should always give the user a
     * dialog asking how to dispose of this content.
     */
    alwaysAskBeforeHandling: boolean;
}

/**
 * nsIMIMEInfo extends nsIHandlerInfo with a bunch of information specific to
 * MIME content-types. There is a one-to-many relationship between MIME types
 * and file extensions. This means that a MIMEInfo object may have multiple
 * file extensions associated with it.  However, the reverse is not true.
 *
 * MIMEInfo objects are generally retrieved from the MIME Service
 * @see nsIMIMEService
 */
declare interface nsIMIMEInfoType extends nsIHandlerInfoType {
    /**
     * Gives you an array of file types associated with this type.
     *
     * @return Number of elements in the array.
     * @return Array of extensions.
     */
    getFileExtensions(): nsIUTF8StringEnumerator;
    /**
     * Set File Extensions. Input is a comma delimited list of extensions.
     */
    setFileExtensions(aExtensions: AUTF8String): void;
    /**
     * Returns whether or not the given extension is
     * associated with this MIME info.
     *
     * @return TRUE if the association exists.
     */
    extensionExists(aExtension: AUTF8String): boolean;
    /**
     * Append a given extension to the set of extensions
     */
    appendExtension(aExtension: AUTF8String): void;
    /**
     * Returns the first extension association in
     * the internal set of extensions.
     *
     * @return The first extension.
     */
    primaryExtension: AUTF8String;
    /**
     * The MIME type of this MIMEInfo.
     *
     * @return String representing the MIME type.
     *
     * @deprecated  use nsIHandlerInfo::type instead.
     */
    readonly MIMEType: ACString;
    /**
     * Returns whether or not these two nsIMIMEInfos are logically
     * equivalent.
     *
     * @returns PR_TRUE if the two are considered equal
     */
    equals(aMIMEInfo: nsIMIMEInfoType): boolean;
    /**
     * Returns a list of nsILocalHandlerApp objects containing
     * handlers associated with this mimeinfo. Implemented per
     * platform using information in this object to generate the
     * best list. Typically used for an "open with" style user
     * option.
     *
     * @return nsIArray of nsILocalHandlerApp
     */
    readonly possibleLocalHandlers: nsIArray;
    /**
     * Launches the application with the specified file, in a way that
     * depends on the value of preferredAction. preferredAction must be
     * useHelperApp or useSystemDefault.
     *
     * @param aFile The file to launch this application with.
     *
     * @throw NS_ERROR_INVALID_ARG if action is not valid for this function.
     * Other exceptions may be thrown.
     */
    launchWithFile(aFile: nsIFileType): void;
    /**
     * Check if we ourselves are registered as the OS default for this type.
     */
    isCurrentAppOSDefault(): boolean;
}

/**
 * nsIHandlerApp represents an external application that can handle content
 * of some sort (either a MIME type or a protocol).
 *
 * FIXME: now that we've made nsIWebHandlerApp inherit from nsIHandlerApp,
 * we should also try to make nsIWebContentHandlerInfo inherit from or possibly
 * be replaced by nsIWebHandlerApp (bug 394710).
 */
declare interface nsIHandlerAppType extends nsISupportsType {
    /**
     * Human readable name for the handler
     */
    name: AString;
    /**
     * Detailed description for this handler. Suitable for
     * a tooltip or short informative sentence.
     */
    detailedDescription: AString;
    /**
     * Whether or not the given handler app is logically equivalent to the
     * invokant (i.e. they represent the same app).
     *
     * Two apps are the same if they are both either local or web handlers
     * and their executables/URI templates and command line parameters are
     * the same.
     *
     * @param aHandlerApp the handler app to compare to the invokant
     *
     * @returns true if the two are logically equivalent, false otherwise
     */
    equals(aHandlerApp: nsIHandlerAppType): boolean;
    /**
     * Launches the application with the specified URI.
     *
     * @param aURI
     * The URI to launch this application with
     *
     * @param aBrowsingContext
     *
     * This represents the docshell to load the handler in and is passed
     * through to nsIURILoader.openURI.  If this parameter is null or
     * not present, the web handler app implementation will attempt to
     * find/create a place to load the handler and do so.  As of this
     * writing, it tries to load the web handler in a new window using
     * nsIBrowserDOMWindow.openURI.  In the future, it may attempt to
     * have a more comprehensive strategy which could include handing
     * off to the system default browser (bug 394479).
     */
    launchWithURI(aURI: nsIURIType, aBrowsingContext: BrowsingContext): void;
}

/**
 * nsILocalHandlerApp is a local OS-level executable
 */
declare interface nsILocalHandlerAppType extends nsIHandlerAppType {
    /**
     * Pointer to the executable file used to handle content
     */
    executable: nsIFile;
    /**
     * Returns the current number of command line parameters.
     */
    readonly parameterCount: unsigned_long;
    /**
     * Clears the current list of command line parameters.
     */
    clearParameters(): void;
    /**
     * Appends a command line parameter to the command line
     * parameter list.
     *
     * @param param the parameter to add.
     */
    appendParameter(param: AString): void;
    /**
     * Retrieves a specific command line parameter.
     *
     * @param param the index of the parameter to return.
     *
     * @return the parameter string.
     *
     * @throw NS_ERROR_INVALID_ARG if the index is out of range.
     */
    getParameter(parameterIndex: unsigned_long): AString;
    /**
     * Checks to see if a parameter exists in the command line
     * parameter list.
     *
     * @param param the parameter to search for.
     *
     * @return TRUE if the parameter exists in the current list.
     */
    parameterExists(param: AString): boolean;
}

/**
 * nsIWebHandlerApp is a web-based handler, as speced by the WhatWG HTML5
 * draft.  Currently, only GET-based handlers are supported.  At some point,
 * we probably want to work with WhatWG to spec out and implement POST-based
 * handlers as well.
 */
declare interface nsIWebHandlerAppType extends nsIHandlerAppType {
    /**
     * Template used to construct the URI to GET.  Template is expected to have
     * a %s in it, and the escaped URI to be handled is inserted in place of
     * that %s, as per the HTML5 spec.
     */
    uriTemplate: AUTF8String;
}

/**
 * nsIDBusHandlerApp represents local applications launched by DBus a message
 * invoking a method taking a single string argument descibing a URI
 */
declare interface nsIDBusHandlerAppType extends nsIHandlerAppType {
    /**
     * Service defines the dbus service that should handle this protocol.
     * If its not set,  NS_ERROR_FAILURE will be returned by LaunchWithURI
     */
    service: AUTF8String;
    /**
     * Objpath defines the object path of the dbus service that should handle
     * this protocol. If its not set,  NS_ERROR_FAILURE will be returned
     * by LaunchWithURI
     */
    objectPath: AUTF8String;
    /**
     * DBusInterface defines the interface of the dbus service that should
     * handle this protocol. If its not set,  NS_ERROR_FAILURE will be
     * returned by LaunchWithURI
     */
    dBusInterface: AUTF8String;
    /**
     * Method defines the dbus method that should be invoked to handle this
     * protocol. If its not set,  NS_ERROR_FAILURE will be returned by
     * LaunchWithURI
     */
    method: AUTF8String;
}

/**
 * The MIME stream separates headers and a datastream. It also allows
 * automatic creation of the content-length header.
 */
declare interface nsIMIMEInputStreamType extends nsIInputStreamType {
    /**
     * Adds an additional header to the stream on the form "name: value". May
     * not be called once the stream has been started to be read.
     * @param name   name of the header
     * @param value  value of the header
     */
    addHeader(name: string, value: string): void;
    /**
     * Visits all headers which have been added via addHeader.  Calling
     * addHeader while visiting request headers has undefined behavior.
     *
     * @param aVisitor
     * The header visitor instance.
     */
    visitHeaders(visitor: nsIHttpHeaderVisitorType): void;
    /**
     * Sets data-stream. May not be called once the stream has been started
     * to be read.
     * The cursor of the new stream should be located at the beginning of the
     * stream if the implementation of the nsIMIMEInputStream also is used as
     * an nsISeekableStream.
     * @param stream  stream containing the data for the stream
     */
    setData(stream: nsIInputStreamType): void;
    /**
     * Get the wrapped data stream
     */
    readonly data: nsIInputStream;
}

/**
 * The MIME service is responsible for mapping file extensions to MIME-types
 * (see RFC 2045). It also provides access to nsIMIMEInfo interfaces and
 * acts as a general convenience wrapper of nsIMIMEInfo interfaces.
 *
 * The MIME service maintains a database with a **one** MIME type **to many**
 * file extensions rule. Adding the same file extension to multiple MIME types
 * is illegal and behavior is undefined.
 *
 * @see nsIMIMEInfo
 */
declare interface nsIMIMEServiceType extends nsISupportsType {
    /**
     * Retrieves an nsIMIMEInfo using both the extension
     * and the type of a file. The type is given preference
     * during the lookup. One of aMIMEType and aFileExt
     * can be an empty string. At least one of aMIMEType and aFileExt
     * must be nonempty.
     */
    getFromTypeAndExtension(aMIMEType: ACString, aFileExt: AUTF8String): nsIMIMEInfo;
    /**
     * Retrieves a ACString representation of the MIME type
     * associated with this file extension.
     *
     * @param  A file extension (excluding the dot ('.')).
     * @return The MIME type, if any.
     */
    getTypeFromExtension(aFileExt: AUTF8String): ACString;
    /**
     * Retrieves a ACString representation of the MIME type
     * associated with this URI. The association is purely
     * file extension to MIME type based. No attempt to determine
     * the type via server headers or byte scanning is made.
     *
     * @param  The URI the user wants MIME info on.
     * @return The MIME type, if any.
     */
    getTypeFromURI(aURI: nsIURIType): ACString;
    /**
     * Retrieves a ACString representation of the MIME type
     * associated with this file extension.  Only the default
     * builtin list is examined.  Unless you need a restricted
     * set use getTypeFromURI.
     *
     * @param  The URI the user wants MIME info on.
     * @return The MIME type, if any.
     */
    getDefaultTypeFromURI(aURI: nsIURIType): ACString;
    /**
     *
     */
    getTypeFromFile(aFile: nsIFileType): ACString;
    /**
     * Given a Type/Extension combination, returns the default extension
     * for this type. This may be identical to the passed-in extension.
     *
     * @param aMIMEType The Type to get information on. Must not be empty.
     * @param aFileExt  File Extension. Can be empty.
     */
    getPrimaryExtension(aMIMEType: ACString, aFileExt: AUTF8String): AUTF8String;
    /**
     * Returns an nsIMIMEInfo for the provided MIME type and extension
     * obtained from an OS lookup. If no handler is found for the type and
     * extension, returns a generic nsIMIMEInfo object. The MIME type and
     * extension can be the empty string. When the type and extension don't
     * map to the same handler, the semantics/resolution are platform
     * specific. See the platform implementations for details.
     *
     * @param aType           The MIME type to get handler information for.
     * @param aFileExtension  The filename extension to use either alone
     * or with the MIME type to get handler information
     * for. UTF-8 encoded.
     * @param [out] aFound    Out param indicating whether a MIMEInfo could
     * be found for the provided type and/or extension.
     * Set to false when neither extension nor the MIME
     * type are mapped to a handler.
     * @return                A nsIMIMEInfo object. This function must return
     * a MIMEInfo object if it can allocate one. The
     * only justifiable reason for not returning one is
     * an out-of-memory error.
     */
    getMIMEInfoFromOS(aType: ACString, aFileExtension: ACString, aFound: boolean): nsIMIMEInfo;
    /**
     * Update the mime info's default app information based on OS
     * lookups.
     * Note: normally called automatically by nsIMIMEInfo. If you find
     * yourself needing to call this from elsewhere, file a bug instead.
     */
    updateDefaultAppInfo(aMIMEInfo: nsIMIMEInfoType): void;
    /**
     * Generate a valid filename from the channel that can be used to save
     * the content of the channel to the local disk.
     *
     * The filename is determined from the content disposition, the filename
     * of the uri, or a default filename. The following modifications are
     * applied:
     * - If the VALIDATE_SANITIZE_ONLY flag is not specified, then the
     * extension of the filename is modified to suit the supplied content type.
     * - Path separators (typically / and \) are replaced by underscores (_)
     * - Characters that are not valid or would be confusing in filenames are
     * replaced by spaces (*, :, etc)
     * - Bidi related marks are replaced by underscores (_)
     * - Whitespace and periods are removed from the beginning and end.
     * - Unless VALIDATE_DONT_COLLAPSE_WHITESPACE is specified, multiple
     * consecutive whitespace characters are collapsed to a single space
     * character, either ' ' or an ideographic space 0x3000 if present.
     * - Unless VALIDATE_DONT_TRUNCATE is specified, the filename is truncated
     * to a maximum length, preserving the extension if possible.
     * - Some filenames and extensions are invalid on certain platforms.
     * These are replaced if possible unless VALIDATE_ALLOW_INVALID_FILENAMES
     * is specified.
     *
     * If the VALIDATE_NO_DEFAULT_FILENAME flag is not specified, and after the
     * rules above are applied, the resulting filename is empty, a default
     * filename is used.
     *
     * If the VALIDATE_ALLOW_EMPTY flag is specified, an empty string may be
     * returned only if the filename could not be determined or was blank.
     *
     * If either the VALIDATE_SANITIZE_ONLY or VALIDATE_GUESS_FROM_EXTENSION flags
     * are specified, then the content type may be empty. Otherwise, the type must
     * not be empty.
     *
     * The aOriginalURI would be specified if the channel is for a local file but
     * it was originally sourced from a different uri.
     *
     * When saving an image, use validateFileNameForSaving instead and
     * pass the result of imgIRequest::GetFileName() as the filename to
     * check.
     *
     * @param aChannel The channel of the content to save.
     * @param aType The MIME type to use, which would usually be the
     * same as the content type of the channel.
     * @param aOriginalURL the source url of the file, but may be null.
     * @param aFlags one or more of the flags above.
     * @returns The resulting filename.
     */
    getValidFileName(aChannel: nsIChannelType, aType: ACString, aOriginalURI: nsIURIType, aFlags: unsigned_long): AString;
    /**
     * Similar to getValidFileName, but used when a specific filename needs
     * to be validated. The filename is modified as needed based on the
     * content type in the same manner as getValidFileName.
     *
     * If the filename came from a uri, it should not be escaped, that is,
     * any needed unescaping of the filename should happen before calling
     * this method.
     *
     * @param aType The MIME type to use.
     * @param aFlags one or more of the flags above.
     * @param aFileName The filename to validate.
     * @returns The validated filename.
     */
    validateFileNameForSaving(aFileName: AString, aType: ACString, aFlags: unsigned_long): AString;
}

/**
 *
 */
declare interface nsIMacAttributionServiceType extends nsISupportsType {
    /**
     * Set the referrer URL on a given path.
     *
     * @param aFilePath A path to the file to set the quarantine data on.
     * @param aReferrer A url to set as the referrer for the download.
     * @param aCreate   If true, creates new quarantine properties, overwriting
     * any existing properties.  If false, the referrer is only
     * set if quarantine properties already exist on the file.
     */
    setReferrerUrl(aFilePath: AUTF8String, aReferrer: AUTF8String, aCreate: boolean): void;
}

/**
 * Allow applications to interface with the Mac OS X Dock.
 *
 * Applications may indicate progress on their Dock icon. Only one such
 * progress indicator is available to the entire application.
 */
declare interface nsIMacDockSupportType extends nsISupportsType {
    /**
     * Menu to use for application-specific dock menu items.
     */
    dockMenu: nsIStandaloneNativeMenu;
    /**
     * Activate the application. This should be used by an application to
     * activate itself when a dock menu is selected as selection of a dock menu
     * item does not automatically activate the application.
     *
     * @param aIgnoreOtherApplications If false, the application is activated
     * only if no other application is currently active. If true, the
     * application activates regardless.
     */
    activateApplication(aIgnoreOtherApplications: boolean): void;
    /**
     * Text used to badge the dock tile.
     */
    badgeText: AString;
    /**
     * True if this app is in the list of apps that are persisted to the macOS
     * Dock (as if the user selected "Keep in Dock").
     */
    readonly isAppInDock: bool;
    /**
     * Ensure that there is a tile for this app in the list of apps that are
     * persisted to the macOS Dock (equivalent to the user selected "Keep in
     * Dock").
     *
     * The position for the [new] app tile is:
     *
     * - its current position if it already exists, else
     * - the position of `aAppToReplacePath` if it exists, else
     * - directly after the last app with the same .app name, else
     * - directly after the last known browser app (see `browserAppNames` in
     * nsMacDockSupport.mm), else
     * - at the end of the persisted app list.
     *
     * @param aAppPath [optional] The path of the .app to persist to the Dock
     * (defaults to the path of the current app).
     * @param aAppToReplacePath [optional] The path of a .app that should be
     * replaced if it is in the list of persisted apps.  This is useful when we
     * prompt the user to install the app when the app is being run directly
     * from a .dmg and the user may have dragged that .app file to the dock.
     * @return true if the app was already in the list of persisted apps or if it
     * was successfully added, else returns false.
     */
    ensureAppIsPinnedToDock(aAppPath: AString, aAppToReplacePath: AString): bool;
}

/**
 *
 */
declare interface nsIMacFinderProgressCanceledCallbackType extends nsISupportsType {
    /**
     *
     */
    canceled(): void;
}

/**
 *
 */
declare interface nsIMacFinderProgressType extends nsISupportsType {
    /**
     * Initialize and display a new Finder progressbar on the given file
     *
     * @param      path              The path of the file
     *
     * @param      canceledCallback  Callback which is called when cancelation is requested
     */
    init(path: AString, canceledCallback: nsIMacFinderProgressCanceledCallbackType): void;
    /**
     * Update the current and total progess. If currentProgress and totalProgress are both 0,
     * the progress is indetermined
     *
     * @param      currentProgress  The current progress
     *
     * @param      totalProgress    The total progress
     */
    updateProgress(currentProgress: unsigned_long_long, totalProgress: unsigned_long_long): void;
    /**
     * End displaying the progressbar on the file
     */
    end(): void;
}

/**
 * This interface is designed to provide scriptable access to the macOS
 * preferences system.
 *
 * This interface is highly macOS specific.
 */
declare interface nsIMacPreferencesReaderType extends nsISupportsType {
    /**
     * This method checks whether macOS policies are enabled.
     *
     * @return true if macOS policies are enabled, false otherwise.
     */
    policiesEnabled(): bool;
    /**
     * This method reads and returns the macOS preferences.
     *
     * @return A JSON object containing all macOS preferences.
     */
    readPreferences(): jsval;
}

/**
 * Allow applications to interface with the Mac OS X Sharing APIs.
 */
declare interface nsIMacSharingServiceType extends nsISupportsType {
    /**
     * Get list of sharing providers
     */
    getSharingProviders(pageUrl: AString): jsval;
    /**
     * Launch service with shareTitle with given url
     */
    shareUrl(serviceName: AString, pageUrl: AString, pageTitle: AString): void;
    /**
     * Open the MacOS preferences window to the sharing panel
     */
    openSharingPreferences(): void;
}

/**
 *
 */
declare interface nsIMacShellServiceType extends nsIShellServiceType {
    /**
     * Opens the desktop preferences, e.g. for after setting the background.
     */
    showDesktopPreferences(): void;
    /**
     * @param aPaneID used by macOS to identify the pane to open.
     * Example arguments:
     * * "" - use the default Security and Privacy pane.
     * * General
     * * Privacy
     * * Privacy_AllFiles
     * * Privacy_Camera
     * * Privacy_Microphone
     */
    showSecurityPreferences(aPaneID: ACString): void;
}

/**
 * Updates macOS widget code with the current URI and page title. Widget code
 * can use this information to update NSUserActivity, enabling Handoff
 * functionality.
 */
declare interface nsIMacUserActivityUpdaterType extends nsISupportsType {
    /**
     * Update active URL and page title for the given window.
     */
    updateLocation(pageUrl: AString, pageTitle: AString, window: nsIBaseWindowType): void;
}

/**
 *
 */
declare interface nsITrashAppCallbackType extends nsISupportsType {
    /**
     *
     */
    trashAppFinished(rv: nsresult): void;
}

/**
 * Allow MozApps API to locate and manipulate natively installed apps
 */
declare interface nsIMacWebAppUtilsType extends nsISupportsType {
    /**
     * Find the path for an app with the given signature.
     */
    pathForAppWithIdentifier(bundleIdentifier: AString): AString;
    /**
     * Launch the app with the given identifier, if it exists.
     */
    launchAppWithIdentifier(bundleIdentifier: AString): void;
    /**
     * Move the app from the given directory to the Trash.
     */
    trashApp(path: AString, callback: nsITrashAppCallbackType): void;
}

/**
 * Interface for accessing the Marionette server instance.
 */
declare interface nsIMarionetteType extends nsISupportsType {
    /**
     * Indicates whether Marionette is running.
     */
    readonly running: boolean;
}

/**
 *
 */
declare interface nsIMediaDeviceType extends nsISupportsType {
    /**
     *
     */
    readonly type: AString;
    /**
     *
     */
    readonly mediaSource: AString;
    /**
     *
     */
    readonly rawId: AString;
    /**
     *
     */
    readonly id: AString;
    /**
     *
     */
    readonly scary: boolean;
    /**
     *
     */
    readonly canRequestOsLevelPrompt: boolean;
    /**
     *
     */
    readonly rawName: AString;
}

/**
 *
 */
declare interface nsIMediaManagerServiceType extends nsISupportsType {
    /**
     * return a array of inner windows that have active captures
     */
    readonly activeMediaCaptureWindows: nsIArray;
    /**
     * Get the capture state for the given window. This will not check
     * descendants, such as iframes. Callers who need to check descendants should
     * iterate descendants manually and call this on each.
     */
    mediaCaptureWindowState(aWindow: nsIDOMWindowType, aCamera: unsigned_short, aMicrophone: unsigned_short, aScreenShare: unsigned_short, aWindowShare: unsigned_short, aBrowserShare: unsigned_short, devices: invalid): void;
    /**
     * Clear per-orgin list of persistent DeviceIds stored for enumerateDevices
     * sinceTime is milliseconds since 1 January 1970 00:00:00 UTC. 0 = clear all
     */
    sanitizeDeviceIds(sinceWhen: long_long): void;
}

/**
 *
 */
declare interface nsIFinishDumpingCallbackType extends nsISupportsType {
    /**
     *
     */
    callback(data: nsISupportsType): void;
}

/**
 * Callback interface for |dumpGCAndCCLogsToFile|, below.  Note that
 * these method calls can occur before |dumpGCAndCCLogsToFile|
 * returns.
 */
declare interface nsIDumpGCAndCCLogsCallbackType extends nsISupportsType {
    /**
     * Called whenever a process has successfully finished dumping its GC/CC logs.
     * Incomplete dumps (e.g., if the child crashes or is killed due to memory
     * exhaustion) are not reported.
     *
     * @param aGCLog The file that the GC log was written to.
     *
     * @param aCCLog The file that the CC log was written to.
     *
     * @param aIsParent indicates whether this log file pair is from the
     * parent process.
     */
    onDump(aGCLog: nsIFileType, aCCLog: nsIFileType, aIsParent: bool): void;
    /**
     * Called when GC/CC logging has finished, after all calls to |onDump|.
     */
    onFinish(): void;
}

/**
 *
 */
declare interface nsIMemoryInfoDumperType extends nsISupportsType {
    /**
     * This dumps gzipped memory reports for this process and its child
     * processes.  If a file of the given name exists, it will be overwritten.
     *
     * @param aFilename The output file.
     *
     * @param aFinishDumping The callback called on completion.
     *
     * @param aFinishDumpingData The environment for the callback.
     *
     * @param aAnonymize Should the reports be anonymized?
     *
     * @param aMinimizeMemoryUsage indicates whether we should run a series of
     * GC/CC's in an attempt to reduce our memory usage before collecting our
     * memory report.
     *
     * Sample output, annotated with comments for explanatory purposes.
     *
     * {
     * // The version number of the format, which will be incremented each time
     * // backwards-incompatible changes are made. A mandatory integer.
     * "version": 1
     *
     * // Equal to nsIMemoryReporterManager::hasMozMallocUsableSize. A
     * // mandatory boolean.
     * "hasMozMallocUsableSize": true,
     *
     * // The memory reports. A mandatory array.
     * "reports": [
     * // The properties correspond to the arguments of
     * // nsIHandleReportCallback::callback. Every one is mandatory.
     * {"process":"Main Process (pid 12345)", "path":"explicit/foo/bar",
     * "kind":1, "units":0, "amount":2000000, "description":"Foo bar."},
     * {"process":"Main Process (pid 12345)", "path":"heap-allocated",
     * "kind":1, "units":0, "amount":3000000, "description":"Heap allocated."},
     * {"process":"Main Process (pid 12345)", "path":"vsize",
     * "kind":1, "units":0, "amount":10000000, "description":"Vsize."}
     * ]
     * }
     */
    dumpMemoryReportsToNamedFile(aFilename: AString, aFinishDumping: nsIFinishDumpingCallbackType, aFinishDumpingData: nsISupportsType, aAnonymize: boolean, aMinimizeMemoryUsage: boolean): void;
    /**
     * Similar to dumpMemoryReportsToNamedFile, this method dumps gzipped memory
     * reports for this process and its child processes to files in the tmp
     * directory called memory-reports-<identifier>-<pid>.json.gz (or something
     * similar, such as memory-reports-<identifier>-<pid>-1.json.gz; no existing
     * file will be overwritten).
     *
     * If DMD is enabled, this method also dumps gzipped DMD output for this
     * process and its child processes to files in the tmp directory called
     * dmd-<identifier>-<pid>.txt.gz (or something similar; again, no existing
     * file will be overwritten).
     *
     * @param aIdentifier this identifier will appear in the filename of our
     * about:memory dump and those of our children.
     *
     * If the identifier is empty, the implementation may set it arbitrarily
     * and use that new value for its own dump and the dumps of its child
     * processes.  For example, the implementation may set |aIdentifier| to the
     * number of seconds since the epoch.
     *
     * @param aAnonymize Should the reports be anonymized?
     *
     * @param aMinimizeMemoryUsage indicates whether we should run a series of
     * GC/CC's in an attempt to reduce our memory usage before collecting our
     * memory report.
     */
    dumpMemoryInfoToTempDir(aIdentifier: AString, aAnonymize: boolean, aMinimizeMemoryUsage: boolean): void;
    /**
     * Dump GC and CC logs to files in the OS's temp directory (or in
     * $MOZ_CC_LOG_DIRECTORY, if that environment variable is specified).
     *
     * @param aIdentifier If aIdentifier is non-empty, this string will appear in
     * the filenames of the logs we create (both for this process and, if
     * aDumpChildProcesses is true, for our child processes).
     *
     * If aIdentifier is empty, the implementation may set it to an
     * arbitrary value; for example, it may set aIdentifier to the number
     * of seconds since the epoch.
     *
     * @param aDumpAllTraces indicates whether we should run an all-traces CC
     * log.  An all-traces log visits all objects currently eligible for cycle
     * collection, while a non-all-traces log avoids visiting some objects
     * which we know are reachable.
     *
     * All-traces logs are much bigger than the alternative, but they may be
     * helpful when trying to understand why a particular object is alive.  For
     * example, a non-traces-log will skip references held by an active
     * document; if your object is being held alive by such a document, you
     * probably want to see those references.
     *
     * @param aDumpChildProcesses indicates whether we should call
     * DumpGCAndCCLogsToFile in our child processes.  If so, the child processes
     * will dump their children, and so on.
     */
    dumpGCAndCCLogsToFile(aIdentifier: AString, aDumpAllTraces: bool, aDumpChildProcesses: bool, aCallback: nsIDumpGCAndCCLogsCallbackType): void;
    /**
     * Like |dumpGCAndCCLogsToFile|, but sends the logs to the given log
     * sink object instead of accessing the filesystem directly, and
     * dumps the current process only.
     */
    dumpGCAndCCLogsToSink(aDumpAllTraces: bool, aSink: nsICycleCollectorLogSinkType): void;
}

/**
 * Memory reporters measure Firefox's memory usage.  They are primarily used to
 * generate the about:memory page.  You should read
 * https://developer.mozilla.org/en-US/docs/Mozilla/Performance/Memory_reporting
 * before writing a memory reporter.
 */
declare interface nsIHandleReportCallbackType extends nsISupportsType {
    /**
     * The arguments to the callback are as follows.
     *
     *
     * |process|  The name of the process containing this reporter.  Each
     * reporter initially has "" in this field, indicating that it applies to the
     * current process.  (This is true even for reporters in a child process.)
     * When a reporter from a child process is copied into the main process, the
     * copy has its 'process' field set appropriately.
     *
     *
     * |path|  The path that this memory usage should be reported under.  Paths
     * are '/'-delimited, eg. "a/b/c".
     *
     * Each reporter can be viewed as representing a leaf node in a tree.
     * Internal nodes of the tree don't have reporters.  So, for example, the
     * reporters "explicit/a/b", "explicit/a/c", "explicit/d/e", and
     * "explicit/d/f" define this tree:
     *
     * explicit
     * |--a
     * |  |--b [*]
     * |  \--c [*]
     * \--d
     * |--e [*]
     * \--f [*]
     *
     * Nodes marked with a [*] have a reporter.  Notice that the internal
     * nodes are implicitly defined by the paths.
     *
     * Nodes within a tree should not overlap measurements, otherwise the
     * parent node measurements will be double-counted.  So in the example
     * above, |b| should not count any allocations counted by |c|, and vice
     * versa.
     *
     * All nodes within each tree must have the same units.
     *
     * If you want to include a '/' not as a path separator, e.g. because the
     * path contains a URL, you need to convert each '/' in the URL to a '\'.
     * Consumers of the path will undo this change.  Any other '\' character
     * in a path will also be changed.  This is clumsy but hasn't caused any
     * problems so far.
     *
     * The paths of all reporters form a set of trees.  Trees can be
     * "degenerate", i.e. contain a single entry with no '/'.
     *
     *
     * |kind|  There are three kinds of memory reporters.
     *
     * - HEAP: reporters measuring memory allocated by the heap allocator,
     * e.g. by calling malloc, calloc, realloc, memalign, operator new, or
     * operator new[].  Reporters in this category must have units
     * UNITS_BYTES.
     *
     * - NONHEAP: reporters measuring memory which the program explicitly
     * allocated, but does not live on the heap.  Such memory is commonly
     * allocated by calling one of the OS's memory-mapping functions (e.g.
     * mmap, VirtualAlloc, or vm_allocate).  Reporters in this category
     * must have units UNITS_BYTES.
     *
     * - OTHER: reporters which don't fit into either of these categories.
     * They can have any units.
     *
     * The kind only matters for reporters in the "explicit" tree;
     * aboutMemory.js uses it to calculate "heap-unclassified".
     *
     *
     * |units|  The units on the reporter's amount.  One of the following.
     *
     * - BYTES: The amount contains a number of bytes.
     *
     * - COUNT: The amount is an instantaneous count of things currently in
     * existence.  For instance, the number of tabs currently open would have
     * units COUNT.
     *
     * - COUNT_CUMULATIVE: The amount contains the number of times some event
     * has occurred since the application started up.  For instance, the
     * number of times the user has opened a new tab would have units
     * COUNT_CUMULATIVE.
     *
     * The amount returned by a reporter with units COUNT_CUMULATIVE must
     * never decrease over the lifetime of the application.
     *
     * - PERCENTAGE: The amount contains a fraction that should be expressed as
     * a percentage.  NOTE!  The |amount| field should be given a value 100x
     * the actual percentage;  this number will be divided by 100 when shown.
     * This allows a fractional percentage to be shown even though |amount| is
     * an integer.  E.g. if the actual percentage is 12.34%, |amount| should
     * be 1234.
     *
     * Values greater than 100% are allowed.
     *
     *
     * |amount|  The numeric value reported by this memory reporter.  Accesses
     * can fail if something goes wrong when getting the amount.
     *
     *
     * |description|  A human-readable description of this memory usage report.
     */
    callback(process: ACString, path: AUTF8String, kind: int32_t, units: int32_t, amount: int64_t, description: AUTF8String, data: nsISupportsType): void;
}

/**
 * An nsIMemoryReporter reports one or more memory measurements via a
 * callback function which is called once for each measurement.
 *
 * An nsIMemoryReporter that reports a single measurement is sometimes called a
 * "uni-reporter".  One that reports multiple measurements is sometimes called
 * a "multi-reporter".
 *
 * aboutMemory.js is the most important consumer of memory reports.  It
 * places the following constraints on reports.
 *
 * - All reports within a single sub-tree must have the same units.
 *
 * - There may be an "explicit" tree.  If present, it represents
 * non-overlapping regions of memory that have been explicitly allocated with
 * an OS-level allocation (e.g. mmap/VirtualAlloc/vm_allocate) or a
 * heap-level allocation (e.g. malloc/calloc/operator new).  Reporters in
 * this tree must have kind HEAP or NONHEAP, units BYTES.
 *
 * It is preferred, but not required, that report descriptions use complete
 * sentences (i.e. start with a capital letter and end with a period, or
 * similar).
 */
declare interface nsIMemoryReporterType extends nsISupportsType {
    /**
     * Run the reporter.
     *
     * If |anonymize| is true, the memory reporter should anonymize any
     * privacy-sensitive details in memory report paths, by replacing them with a
     * string such as "<anonymized>". Anonymized memory reports may be sent
     * automatically via crash reports or telemetry.
     *
     * The following things are considered privacy-sensitive.
     *
     * - Content domains and URLs, and information derived from them.
     * - Content data, such as strings.
     * - Details about content code, such as filenames, function names or stack
     * traces.
     * - Details about or data from the user's system, such as filenames.
     * - Running apps.
     *
     * In short, anything that could identify parts of the user's browsing
     * history is considered privacy-sensitive.
     *
     * The following thing are not considered privacy-sensitive.
     *
     * - Chrome domains and URLs.
     * - Information about installed extensions.
     */
    collectReports(callback: nsIHandleReportCallbackType, data: nsISupportsType, anonymize: boolean): void;
}

/**
 *
 */
declare interface nsIFinishReportingCallbackType extends nsISupportsType {
    /**
     *
     */
    callback(data: nsISupportsType): void;
}

/**
 *
 */
declare interface nsIHeapAllocatedCallbackType extends nsISupportsType {
    /**
     *
     */
    callback(bytesAllocated: int64_t): void;
}

/**
 *
 */
declare interface nsIMemoryReporterManagerType extends nsISupportsType {
    /**
     * Initialize.
     */
    init(): void;
    /**
     * Register the given nsIMemoryReporter.  The Manager service will hold a
     * strong reference to the given reporter, and will be responsible for freeing
     * the reporter at shutdown.  You may manually unregister the reporter with
     * unregisterStrongReporter() at any point.
     */
    registerStrongReporter(reporter: nsIMemoryReporterType): void;
    /**
     *
     */
    registerStrongAsyncReporter(reporter: nsIMemoryReporterType): void;
    /**
     * Like registerReporter, but the Manager service will hold a weak reference
     * via a raw pointer to the given reporter.  The reporter should be
     * unregistered before shutdown.
     * You cannot register JavaScript components with this function!  Always
     * register your JavaScript components with registerStrongReporter().
     */
    registerWeakReporter(reporter: nsIMemoryReporterType): void;
    /**
     *
     */
    registerWeakAsyncReporter(reporter: nsIMemoryReporterType): void;
    /**
     * Unregister the given memory reporter, which must have been registered with
     * registerStrongReporter().  You normally don't need to unregister your
     * strong reporters, as nsIMemoryReporterManager will take care of that at
     * shutdown.
     */
    unregisterStrongReporter(reporter: nsIMemoryReporterType): void;
    /**
     * Unregister the given memory reporter, which must have been registered with
     * registerWeakReporter().
     */
    unregisterWeakReporter(reporter: nsIMemoryReporterType): void;
    /**
     * These functions should only be used for testing purposes.
     */
    blockRegistrationAndHideExistingReporters(): void;
    /**
     *
     */
    unblockRegistrationAndRestoreOriginalReporters(): void;
    /**
     *
     */
    registerStrongReporterEvenIfBlocked(aReporter: nsIMemoryReporterType): void;
    /**
     * Get memory reports for the current process and all child processes.
     * |handleReport| is called for each report, and |finishReporting| is called
     * once all reports have been handled.
     *
     * |finishReporting| is called even if, for example, some child processes
     * fail to report back.  However, calls to this method will silently and
     * immediately abort -- and |finishReporting| will not be called -- if a
     * previous getReports() call is still in flight, i.e. if it has not yet
     * finished invoking |finishReporting|.  The silent abort is because the
     * in-flight request will finish soon, and the caller would very likely just
     * catch and ignore any error anyway.
     *
     * If |anonymize| is true, it indicates that the memory reporters should
     * anonymize any privacy-sensitive data (see above).
     */
    getReports(handleReport: nsIHandleReportCallbackType, handleReportData: nsISupportsType, finishReporting: nsIFinishReportingCallbackType, finishReportingData: nsISupportsType, anonymize: boolean): void;
    /**
     * The memory reporter manager, for the most part, treats reporters
     * registered with it as a black box.  However, there are some
     * "distinguished" amounts (as could be reported by a memory reporter) that
     * the manager provides as attributes, because they are sufficiently
     * interesting that we want external code (e.g. telemetry) to be able to rely
     * on them.
     *
     * Note that these are not reporters and so getReports() does not look at
     * them.  However, distinguished amounts can be embedded in a reporter.
     *
     * Access to these attributes can fail.  In particular, some of them are not
     * available on all platforms.
     *
     * If you add a new distinguished amount, please update
     * toolkit/components/aboutmemory/tests/test_memoryReporters.xul.
     *
     * |vsize| (UNITS_BYTES)  The virtual size, i.e. the amount of address space
     * taken up.
     *
     * |vsizeMaxContiguous| (UNITS_BYTES)  The size of the largest contiguous
     * block of virtual memory.
     *
     * |resident| (UNITS_BYTES)  The resident size (a.k.a. RSS or physical memory
     * used).
     *
     * |residentFast| (UNITS_BYTES)  This is like |resident|, but on Mac OS
     * |resident| can purge pages, which is slow.  It also affects the result of
     * |residentFast|, and so |resident| and |residentFast| should not be used
     * together.
     *
     * |residentPeak| (UNITS_BYTES)  The peak resident size.
     *
     * |residentUnique| (UNITS_BYTES)  The unique set size (a.k.a. USS).
     *
     * |heapAllocated| (UNITS_BYTES)  Memory mapped by the heap allocator.
     *
     * |heapOverheadFraction| (UNITS_PERCENTAGE)  In the heap allocator, this is
     * the fraction of committed heap bytes that are overhead. Like all
     * UNITS_PERCENTAGE measurements, its amount is multiplied by 100x so it can
     * be represented by an int64_t.
     *
     * |JSMainRuntimeGCHeap| (UNITS_BYTES)  Size of the main JS runtime's GC
     * heap.
     *
     * |JSMainRuntimeTemporaryPeak| (UNITS_BYTES)  Peak size of the transient
     * storage in the main JSRuntime.
     *
     * |JSMainRuntimeCompartments{System,User}| (UNITS_COUNT)  The number of
     * {system,user} compartments in the main JS runtime.
     *
     * |JSMainRuntimeRealms{System,User}| (UNITS_COUNT)  The number of
     * {system,user} realms in the main JS runtime.
     *
     * |imagesContentUsedUncompressed| (UNITS_BYTES)  Memory used for decoded
     * raster images in content.
     *
     * |storageSQLite| (UNITS_BYTES)  Memory used by SQLite.
     *
     * |lowMemoryEventsPhysical| (UNITS_COUNT_CUMULATIVE)
     * The number of low-physical-memory events that have occurred since the
     * process started.
     *
     * |ghostWindows| (UNITS_COUNT)  A cached value of the number of ghost
     * windows. This should have been updated within the past 60s.
     *
     * |pageFaultsHard| (UNITS_COUNT_CUMULATIVE)  The number of hard (a.k.a.
     * major) page faults that have occurred since the process started.
     */
    readonly vsize: int64_t;
    /**
     *
     */
    readonly vsizeMaxContiguous: int64_t;
    /**
     *
     */
    readonly resident: int64_t;
    /**
     *
     */
    readonly residentFast: int64_t;
    /**
     *
     */
    readonly residentPeak: int64_t;
    /**
     *
     */
    readonly residentUnique: int64_t;
    /**
     *
     */
    readonly heapAllocated: int64_t;
    /**
     *
     */
    readonly heapOverheadFraction: int64_t;
    /**
     *
     */
    readonly JSMainRuntimeGCHeap: int64_t;
    /**
     *
     */
    readonly JSMainRuntimeTemporaryPeak: int64_t;
    /**
     *
     */
    readonly JSMainRuntimeCompartmentsSystem: int64_t;
    /**
     *
     */
    readonly JSMainRuntimeCompartmentsUser: int64_t;
    /**
     *
     */
    readonly JSMainRuntimeRealmsSystem: int64_t;
    /**
     *
     */
    readonly JSMainRuntimeRealmsUser: int64_t;
    /**
     *
     */
    readonly imagesContentUsedUncompressed: int64_t;
    /**
     *
     */
    readonly storageSQLite: int64_t;
    /**
     *
     */
    readonly lowMemoryEventsPhysical: int64_t;
    /**
     *
     */
    readonly ghostWindows: int64_t;
    /**
     *
     */
    readonly pageFaultsHard: int64_t;
    /**
     * This attribute indicates if moz_malloc_usable_size() works.
     */
    readonly hasMozMallocUsableSize: boolean;
    /**
     * These attributes indicate DMD's status. "Enabled" means enabled at
     * build-time.
     */
    readonly isDMDEnabled: boolean;
    /**
     *
     */
    readonly isDMDRunning: boolean;
    /**
     * Run a series of GC/CC's in an attempt to minimize the application's memory
     * usage.  When we're finished doing this for the current process, we invoke
     * the given runnable if it's not null.  We do not wait for any child processes
     * that might be doing their own minimization via child-mmu-request to finish.
     */
    minimizeMemoryUsage(callback: nsIRunnableType): void;
    /**
     * Measure the memory that is known to be owned by this tab, split up into
     * several broad categories.  Note that this will be an underestimate of the
     * true number, due to imperfect memory reporter coverage (corresponding to
     * about:memory's "heap-unclassified"), and due to some memory shared between
     * tabs not being counted.
     *
     * The time taken for the measurement (split into JS and non-JS parts) is
     * also returned.
     */
    sizeOfTab(window: mozIDOMWindowProxy, jsObjectsSize: int64_t, jsStringsSize: int64_t, jsOtherSize: int64_t, domSize: int64_t, styleSize: int64_t, otherSize: int64_t, totalSize: int64_t, jsMilliseconds: double, nonJSMilliseconds: double): void;
}

/**
 * This service allows access to the current thread's Chromium MessageLoop
 * instance, with some extra sugar added.  If you're calling from C++, it may
 * or may not make sense for you to use this interface.  If you're calling from
 * JS, you don't have a choice!
 *
 * Right now, you can only call PostIdleTask(), and the wrath of khuey is
 * stopping you from adding other methods.
 *
 * nsIMessageLoop's contractid is "@mozilla.org/message-loop;1".
 */
declare interface nsIMessageLoopType extends nsISupportsType {
    /**
     * Posts a task to be run when this thread's message loop is idle, or after
     * ensureRunsAfterMS milliseconds have elapsed.  (That is, the task is
     * guaranteed to run /eventually/.)
     *
     * Note that if the event loop is busy, we will hold a reference to the task
     * until ensureRunsAfterMS milliseconds have elapsed.  Be careful when
     * specifying long timeouts and tasks which hold references to windows or
     * other large objects, because you can leak memory in a difficult-to-detect
     * way!
     */
    postIdleTask(task: nsIRunnableType, ensureRunsAfterMS: uint32_t): void;
}

/**
 *
 */
declare interface nsIMessageSenderType extends nsISupportsType {
}

/**
 *
 */
declare interface nsIInProcessContentFrameMessageManagerType extends nsIMessageSenderType {
    /**
     *
     */
    getOwnerContent(): nsIContent;
}

/**
 *
 */
declare interface nsIMozBrowserFrameType extends nsIDOMMozBrowserFrameType {
    /**
     * Gets whether this frame really is a browser frame.
     *
     * In order to really be a browser frame, this frame's
     * nsIDOMMozBrowserFrame::mozbrowser attribute must be true, and the frame
     * may have to pass various security checks.
     */
    readonly reallyIsBrowser: boolean;
}

/**
 * An interface to access the the base channel
 * associated with a MultiPartChannel.
 */
declare interface nsIMultiPartChannelType extends nsISupportsType {
    /**
     * readonly attribute to access the underlying channel
     */
    readonly baseChannel: nsIChannel;
    /**
     * Attribute guaranteed to be different for different parts of
     * the same multipart document.
     */
    readonly partID: uint32_t;
    /**
     *
     */
    readonly isFirstPart: boolean;
    /**
     * Set to true when onStopRequest is received from the base channel.
     * The listener can check this from its onStopRequest to determine
     * whether more data can be expected.
     */
    readonly isLastPart: boolean;
}

/**
 * An interface that listeners can implement to receive a notification
 * when the last part of the multi-part channel has finished, and the
 * final OnStopRequest has been sent.
 */
declare interface nsIMultiPartChannelListenerType extends nsISupportsType {
    /**
     * Sent when all parts have finished and sent OnStopRequest.
     */
    onAfterLastPart(status: nsresult): void;
}

/**
 * The multiplex stream concatenates a list of input streams into a single
 * stream.
 */
declare interface nsIMultiplexInputStreamType extends nsISupportsType {
    /**
     * Number of streams in this multiplex-stream
     */
    readonly count: unsigned_long;
    /**
     * Appends a stream to the end of the streams. The cursor of the stream
     * should be located at the beginning of the stream if the implementation
     * of this nsIMultiplexInputStream also is used as an nsISeekableStream.
     * @param stream  stream to append
     */
    appendStream(stream: nsIInputStreamType): void;
    /**
     * Get stream at specified index.
     * @param index   return stream at this index, must be < count
     * @return        stream at specified index
     */
    getStream(index: unsigned_long): nsIInputStream;
}

/**
 * nsIMutableArray
 * A separate set of methods that will act on the array. Consumers of
 * nsIArray should not QueryInterface to nsIMutableArray unless they
 * own the array.
 *
 * As above, it is legal to add null elements to the array. Note also
 * that null elements can be created as a side effect of
 * insertElementAt(). Conversely, if insertElementAt() is never used,
 * and null elements are never explicitly added to the array, then it
 * is guaranteed that queryElementAt() will never return a null value.
 *
 * Any of these methods may throw NS_ERROR_OUT_OF_MEMORY when the
 * array must grow to complete the call, but the allocation fails.
 */
declare interface nsIMutableArrayType extends nsIArrayExtensionsType {
    /**
     * appendElement()
     *
     * Append an element at the end of the array.
     *
     * @param element The element to append.
     */
    appendElement(element: nsISupportsType): void;
    /**
     * removeElementAt()
     *
     * Remove an element at a specific position, moving all elements
     * stored at a higher position down one.
     * To remove a specific element, use indexOf() to find the index
     * first, then call removeElementAt().
     *
     * @param index the position of the item
     */
    removeElementAt(index: unsigned_long): void;
    /**
     * insertElementAt()
     *
     * Insert an element at the given position, moving the element
     * currently located in that position, and all elements in higher
     * position, up by one.
     *
     * @param element The element to insert
     * @param index   The position in the array:
     * If the position is lower than the current length
     * of the array, the elements at that position and
     * onwards are bumped one position up.
     * If the position is equal to the current length
     * of the array, the new element is appended.
     * An index lower than 0 or higher than the current
     * length of the array is invalid and will be ignored.
     */
    insertElementAt(element: nsISupportsType, index: unsigned_long): void;
    /**
     * replaceElementAt()
     *
     * Replace the element at the given position.
     *
     * @param element The new element to insert
     * @param index   The position in the array
     * If the position is lower than the current length
     * of the array, an existing element will be replaced.
     * If the position is equal to the current length
     * of the array, the new element is appended.
     * If the position is higher than the current length
     * of the array, empty elements are appended followed
     * by the new element at the specified position.
     * An index lower than 0 is invalid and will be ignored.
     */
    replaceElementAt(element: nsISupportsType, index: unsigned_long): void;
    /**
     * clear()
     *
     * clear the entire array, releasing all stored objects
     */
    clear(): void;
}

/**
 *
 */
declare interface nsINSSComponentType extends nsISupportsType {
    /**
     * Test utility for adding an intermediate certificate to the current set of
     * imported enterprise intermediates, if any. Additions to the set made using
     * this function will be cleared when the value of the preference
     * "security.enterprise_roots.enabled" changes.
     */
    addEnterpriseIntermediate(intermediateBytes: invalid): void;
    /**
     * For clearing both SSL internal and external session cache from JS.
     * WARNING: May be racy when using the socket process.
     */
    clearSSLExternalAndInternalSessionCache(): void;
    /**
     * For clearing both SSL internal and external session cache from JS.
     */
    asyncClearSSLExternalAndInternalSessionCache(): Promise;
}

/**
 *
 */
declare interface nsINSSErrorsServiceType extends nsISupportsType {
    /**
     * @param aNSPRCode An error code obtained using PR_GetError()
     * @return True if it is error code defined by the NSS library
     */
    isNSSErrorCode(aNSPRCode: int32_t): boolean;
    /**
     * Function will fail if aNSPRCode is not an NSS error code.
     * @param aNSPRCode An error code obtained using PR_GetError()
     * @return The result of the conversion, an XPCOM error code
     */
    getXPCOMFromNSSError(aNSPRCode: int32_t): nsresult;
    /**
     * Function will fail if aXPCOMErrorCode is not an NSS error code.
     * @param aXPCOMErrorCode An error code obtained using getXPCOMFromNSSError
     * return A localized human readable error explanation.
     */
    getErrorMessage(aXPCOMErrorCode: nsresult): AString;
    /**
     * Function will fail if aXPCOMErrorCode is not an NSS error code.
     * @param aXPCOMErrorCode An error code obtained using getXPCOMFromNSSError
     * return the error class of the code, either ERROR_CLASS_BAD_CERT
     * or ERROR_CLASS_SSL_PROTOCOL
     */
    getErrorClass(aXPCOMErrorCode: nsresult): uint32_t;
}

/**
 *
 */
declare interface nsINSSVersionType extends nsISupportsType {
    /**
     * Minimal required versions as used at build time
     */
    readonly NSPR_MinVersion: AString;
    /**
     *
     */
    readonly NSS_MinVersion: AString;
    /**
     *
     */
    readonly NSSUTIL_MinVersion: AString;
    /**
     *
     */
    readonly NSSSSL_MinVersion: AString;
    /**
     *
     */
    readonly NSSSMIME_MinVersion: AString;
    /**
     * Versions of libraries currently in use
     */
    readonly NSPR_Version: AString;
    /**
     *
     */
    readonly NSS_Version: AString;
    /**
     *
     */
    readonly NSSUTIL_Version: AString;
    /**
     *
     */
    readonly NSSSSL_Version: AString;
    /**
     *
     */
    readonly NSSSMIME_Version: AString;
}

/**
 * Represents an object with a name, such as a runnable or a timer.
 */
declare interface nsINamedType extends nsISupportsType {
    /**
     * A string describing the purpose of the runnable/timer/whatever. Useful
     * for debugging. This attribute is read-only, but you can change it to a
     * compile-time string literal with setName.
     *
     * WARNING: This attribute will be included in telemetry, so it should
     * never contain privacy sensitive information.
     */
    readonly name: AUTF8String;
}

/**
 * nsINamedPipeDataObserver
 *
 * This is the callback interface for nsINamedPipeService.
 * The functions are called by the internal thread in the nsINamedPipeService.
 */
declare interface nsINamedPipeDataObserverType extends nsISupportsType {
    /**
     * onDataAvailable
     *
     * @param aBytesTransferred
     * Transfered bytes during last transmission.
     * @param aOverlapped
     * Corresponding overlapped structure used by the async I/O
     */
    onDataAvailable(aBytesTransferred: unsigned_long, aOverlapped: voidPtr): void;
    /**
     * onError
     *
     * @param aError
     * Error code of the error.
     * @param aOverlapped
     * Corresponding overlapped structure used by the async I/O
     */
    onError(aError: unsigned_long, aOverlapped: voidPtr): void;
}

/**
 * nsINamedPipeService
 */
declare interface nsINamedPipeServiceType extends nsISupportsType {
    /**
     * addDataObserver
     *
     * @param aHandle
     * The handle that is going to be monitored for read/write operations.
     * Only handles that are opened with overlapped IO are supported.
     * @param aObserver
     * The observer of the handle, the service strong-refs of the observer.
     */
    addDataObserver(aHandle: voidPtr, aObserver: nsINamedPipeDataObserverType): void;
    /**
     * removeDataObserver
     *
     * @param aHandle
     * The handle associated to the observer, and will be closed by the
     * service.
     * @param aObserver
     * The observer to be removed.
     */
    removeDataObserver(aHandle: voidPtr, aObserver: nsINamedPipeDataObserverType): void;
    /**
     * isOnCurrentThread
     *
     * @return the caller runs within the internal thread.
     */
    isOnCurrentThread(): boolean;
}

/**
 * nsINativeAppSupport
 *
 * This "pseudo" (in the XPCOM sense) interface provides for
 * platform-specific general application support
 *
 * Due to the nature of the beast, this interface is not a full-blown
 * XPCOM component.  The primary reason is that objects that implement
 * this interface generally must be operational *before* XPCOM (or any
 * of the rest of Mozilla) are initialized.  As a result, this
 * interface is instantiated by somewhat unconventional means.
 *
 * To create the implementor of this interface, you call the function
 * NS_CreateNativeAppSupport.  This is done in the startup code
 * in nsAppRunner.cpp
 *
 * The interface provides these functions:
 * start - You call this to inform the native app support that the
 * application is starting.  In addition, it serves as a
 * query as to whether the application should continue to
 * run.
 *
 * If the returned boolean result is PR_FALSE, then the
 * application should exit without further processing.  In
 * such cases, the returned nsresult indicates whether the
 * reason to exit is due to an error or not.
 *
 * Win32 Note: In the case of starting a second instance
 * of this executable, this function will return
 * PR_FALSE and nsresult==NS_OK.  This means that
 * the command line arguments have been
 * successfully passed to the instance of the
 * application acting as a remote server.
 * quit - Informs the native app support that the application is stopping. The
 * app support should disable any functionality enabled by start.
 *
 * onLastWindowClosing -  Called when the last window is closed. Used as a
 * "soft" shutdown, passwords are flushed.
 */
declare interface nsINativeAppSupportType extends nsISupportsType {
    /**
     *
     */
    start(): boolean;
    /**
     *
     */
    enable(): void;
    /**
     *
     */
    onLastWindowClosing(): void;
    /**
     *
     */
    ReOpen(): void;
}

/**
 *
 */
declare interface nsINativeDNSResolverOverrideType extends nsISupportsType {
    /**
     * Adds an IP override for this specific host.
     */
    addIPOverride(aHost: AUTF8String, aIPLiteral: ACString): void;
    /**
     * Sets a CNAME override for this specific host.
     */
    setCnameOverride(aHost: AUTF8String, aCNAME: ACString): void;
    /**
     * Clears the overrides for this specific host
     */
    clearHostOverride(aHost: AUTF8String): void;
    /**
     * Clears all the host overrides that were previously set.
     */
    clearOverrides(): void;
}

/**
 * The result of a successful asynchronous operation.
 */
declare interface nsINativeOSFileResultType extends nsISupportsType {
    /**
     * The actual value produced by the operation.
     *
     * Actual type of this value depends on the options passed to the
     * operation.
     */
    readonly result: jsval;
    /**
     * Delay between when the operation was requested on the main thread and
     * when the operation was started off main thread.
     */
    readonly dispatchDurationMS: double;
    /**
     * Duration of the off main thread execution.
     */
    readonly executionDurationMS: double;
}

/**
 * A callback invoked in case of success.
 */
declare interface nsINativeOSFileSuccessCallbackType extends nsISupportsType {
    /**
     *
     */
    complete(result: nsINativeOSFileResultType): void;
}

/**
 * A callback invoked in case of error.
 */
declare interface nsINativeOSFileErrorCallbackType extends nsISupportsType {
    /**
     * @param operation The name of the failed operation. Provided to aid
     * debugging only, may change without notice.
     * @param OSstatus The OS status of the operation (errno under Unix,
     * GetLastError under Windows).
     */
    complete(operation: ACString, OSstatus: long): void;
}

/**
 * A service providing native implementations of some of the features
 * of OS.File.
 */
declare interface nsINativeOSFileInternalsServiceType extends nsISupportsType {
    /**
     * Implementation of OS.File.read
     *
     * @param path The absolute path to the file to read.
     * @param options An object that may contain some of the following fields
     * - {number} bytes The maximal number of bytes to read.
     * - {string} encoding If provided, return the result as a string, decoded
     * using this encoding. Otherwise, pass the result as an ArrayBuffer.
     * Invalid encodings cause onError to be called with the platform-specific
     * "invalid argument" constant.
     * - {string} compression Unimplemented at the moment.
     * @param onSuccess The success callback.
     * @param onError The error callback.
     */
    read(path: AString, options: jsval, onSuccess: nsINativeOSFileSuccessCallbackType, onError: nsINativeOSFileErrorCallbackType): void;
    /**
     * Implementation of OS.File.writeAtomic
     *
     * @param path the absolute path of the file to write to.
     * @param buffer the data as an array buffer to be written to the file.
     * @param options An object that may contain the following fields
     * - {number} bytes If provided, the number of bytes written is equal to this.
     * The default value is the size of the |buffer|.
     * - {string} tmpPath If provided and not null, first write to this path, and
     * move to |path| after writing.
     * - {string} backupPath if provided, backup file at |path| to this path
     * before overwriting it.
     * - {bool} flush if provided and true, flush the contents of the buffer after
     * writing. This is slower, but safer.
     * - {bool} noOverwrite if provided and true, do not write if a file already
     * exists at |path|.
     * @param onSuccess The success callback.
     * @param onError The error callback.
     */
    writeAtomic(path: AString, buffer: jsval, options: jsval, onSuccess: nsINativeOSFileSuccessCallbackType, onError: nsINativeOSFileErrorCallbackType): void;
}

/**
 * The BookmarksService interface provides methods for managing bookmarked
 * history items.  Bookmarks consist of a set of user-customizable
 * folders.  A URI in history can be contained in one or more such folders.
 */
declare interface nsINavBookmarksServiceType extends nsISupportsType {
    /**
     * The item ID of the top-level folder that contain the tag "folders".
     */
    readonly tagsFolder: long_long;
    /**
     * The total number of Sync changes (inserts, updates, deletes, merges, and
     * uploads) recorded since Places startup for all bookmarks.
     *
     * Note that this is *not* the number of bookmark syncs. It's a monotonically
     * increasing counter incremented for every change that affects a bookmark's
     * `syncChangeCounter`.
     *
     * The counter can be used to avoid keeping an exclusive transaction open for
     * time-consuming work. One way to do that is to store the current value of
     * the counter, do the work, start a transaction, check the current value
     * again, and compare it to the stored value to determine if the database
     * changed during the work.
     *
     * The bookmarks mirror does this to check for changes between building and
     * applying a merged tree. This avoids blocking the main Places connection
     * during the merge, and ensures that the new tree still applies cleanly.
     */
    readonly totalSyncChanges: long_long;
    /**
     * Inserts a child bookmark into the given folder.
     *
     * @param aParentId
     * The id of the parent folder
     * @param aURI
     * The URI to insert
     * @param aIndex
     * The index to insert at, or DEFAULT_INDEX to append
     * @param aTitle
     * The title for the new bookmark
     * @param [optional] aGuid
     * The GUID to be set for the new item.  If not set, a new GUID is
     * generated.  Unless you've a very sound reason, such as an undo
     * manager implementation, do not pass this argument.
     * @param [optional] aSource
     * The change source. This is forwarded to all bookmark observers,
     * allowing them to distinguish between insertions from different
     * callers. Defaults to SOURCE_DEFAULT if omitted.
     * @return The ID of the newly-created bookmark.
     *
     * @note aTitle will be truncated to TITLE_LENGTH_MAX and
     * aURI will be truncated to URI_LENGTH_MAX.
     * @throws if aGuid is malformed.
     */
    insertBookmark(aParentId: long_long, aURI: nsIURIType, aIndex: long, aTitle: AUTF8String, aGuid: ACString, aSource: unsigned_short): long_long;
    /**
     * Removes a child item. Used to delete a bookmark or separator.
     * @param aItemId
     * The child item to remove
     * @param [optional] aSource
     * The change source, forwarded to all bookmark observers. Defaults
     * to SOURCE_DEFAULT.
     */
    removeItem(aItemId: long_long, aSource: unsigned_short): void;
    /**
     * Creates a new child folder and inserts it under the given parent.
     * @param aParentFolder
     * The id of the parent folder
     * @param aName
     * The name of the new folder
     * @param aIndex
     * The index to insert at, or DEFAULT_INDEX to append
     * @param [optional] aGuid
     * The GUID to be set for the new item.  If not set, a new GUID is
     * generated.  Unless you've a very sound reason, such as an undo
     * manager implementation, do not pass this argument.
     * @param [optional] aSource
     * The change source, forwarded to all bookmark observers. Defaults
     * to SOURCE_DEFAULT.
     * @return The ID of the newly-inserted folder.
     * @throws if aGuid is malformed.
     */
    createFolder(aParentFolder: long_long, name: AUTF8String, index: long, aGuid: ACString, aSource: unsigned_short): long_long;
    /**
     * Set the title for an item.
     * @param aItemId
     * The id of the item whose title should be updated.
     * @param aTitle
     * The new title for the bookmark.
     * @param [optional] aSource
     * The change source, forwarded to all bookmark observers. Defaults
     * to SOURCE_DEFAULT.
     *
     * @note  aTitle will be truncated to TITLE_LENGTH_MAX.
     */
    setItemTitle(aItemId: long_long, aTitle: AUTF8String, aSource: unsigned_short): void;
    /**
     * Get the title for an item.
     *
     * If no item title is available it will return a void string (null in JS).
     *
     * @param aItemId
     * The id of the item whose title should be retrieved
     * @return The title of the item.
     */
    getItemTitle(aItemId: long_long): AUTF8String;
    /**
     * Set the last modified time for an item.
     *
     * @param aItemId
     * the id of the item whose last modified time should be updated.
     * @param aLastModified
     * the new last modified value in microseconds.  Note that it is
     * rounded down to milliseconds precision.
     * @param [optional] aSource
     * The change source, forwarded to all bookmark observers. Defaults
     * to SOURCE_DEFAULT.
     *
     * @note This is the only method that will send an itemChanged notification
     * for the property.  lastModified will still be updated in
     * any other method that changes an item property, but we will send
     * the corresponding itemChanged notification instead.
     */
    setItemLastModified(aItemId: long_long, aLastModified: PRTime, aSource: unsigned_short): void;
}

/**
 *
 */
declare interface nsINavHistoryResultNodeType extends nsISupportsType {
    /**
     * Indentifies the parent result node in the result set. This is null for
     * top level nodes.
     */
    readonly parent: nsINavHistoryContainerResultNode;
    /**
     * The history-result to which this node belongs.
     */
    readonly parentResult: nsINavHistoryResult;
    /**
     * URI of the resource in question. For visits and URLs, this is the URL of
     * the page. For folders and queries, this is the place: URI of the
     * corresponding folder or query. This may be empty for other types of
     * objects like host containers.
     */
    readonly uri: AUTF8String;
    /**
     *
     */
    readonly type: unsigned_long;
    /**
     * Title of the web page, or of the node's query (day, host, folder, etc)
     */
    readonly title: AUTF8String;
    /**
     * Total number of times the URI has ever been accessed. For hosts, this
     * is the total of the children under it, NOT the total times the host has
     * been accessed (this would require an additional query, so is not given
     * by default when most of the time it is never needed).
     */
    readonly accessCount: unsigned_long;
    /**
     * This is the time the user accessed the page.
     *
     * If this is a visit, it is the exact time that the page visit occurred.
     *
     * If this is a URI, it is the most recent time that the URI was visited.
     * Even if you ask for all URIs for a given date range long ago, this might
     * contain today's date if the URI was visited today.
     *
     * For hosts, or other node types with children, this is the most recent
     * access time for any of the children.
     *
     * For days queries this is the respective endTime - a maximum possible
     * visit time to fit in the day range.
     */
    readonly time: PRTime;
    /**
     * This URI can be used as an image source URI and will give you the favicon
     * for the page. It is *not* the URI of the favicon, but rather something
     * that will resolve to the actual image.
     *
     * In most cases, this is an annotation URI that will query the favicon
     * service. If the entry has no favicon, this is the chrome URI of the
     * default favicon. If the favicon originally lived in chrome, this will
     * be the original chrome URI of the icon.
     */
    readonly icon: AUTF8String;
    /**
     * This is the number of levels between this node and the top of the
     * hierarchy. The members of result.children have indentLevel = 0, their
     * children have indentLevel = 1, etc. The indent level of the root node is
     * set to -1.
     */
    readonly indentLevel: long;
    /**
     * When this item is in a bookmark folder (parent is of type folder), this is
     * the index into that folder of this node. These indices start at 0 and
     * increase in the order that they appear in the bookmark folder. For items
     * that are not in a bookmark folder, this value is -1.
     */
    readonly bookmarkIndex: long;
    /**
     * If the node is an item (bookmark, folder or a separator) this value is the
     * row ID of that bookmark in the database. For other nodes, this value is
     * set to -1.
     */
    readonly itemId: long_long;
    /**
     * If the node is an item (bookmark, folder or a separator) this value is the
     * time that the item was created. For other nodes, this value is 0.
     */
    readonly dateAdded: PRTime;
    /**
     * If the node is an item (bookmark, folder or a separator) this value is the
     * time that the item was last modified. For other nodes, this value is 0.
     *
     * @note When an item is added lastModified is set to the same value as
     * dateAdded.
     */
    readonly lastModified: PRTime;
    /**
     * For uri nodes, this is a sorted list of the tags, delimited with commans,
     * for the uri represented by this node. Otherwise this is an empty string.
     */
    readonly tags: AString;
    /**
     * The unique ID associated with the page. It my return an empty string
     * if the result node is a non-URI node.
     */
    readonly pageGuid: ACString;
    /**
     * The unique ID associated with the bookmark. It returns an empty string
     * if the result node is not associated with a bookmark, a folder or a
     * separator.
     */
    readonly bookmarkGuid: ACString;
    /**
     * The unique ID associated with the history visit. For node types other than
     * history visit nodes, this value is -1.
     */
    readonly visitId: long_long;
    /**
     * The transition type associated with this visit. For node types other than
     * history visit nodes, this value is 0.
     */
    readonly visitType: unsigned_long;
}

/**
 * Base class for container results. This includes all types of groupings.
 * Bookmark folders and places queries will be QueryResultNodes which extends
 * these items.
 */
declare interface nsINavHistoryContainerResultNodeType extends nsINavHistoryResultNodeType {
    /**
     * Set this to allow descent into the container. When closed, attempting
     * to call getChildren or childCount will result in an error. You should
     * set this to false when you are done reading.
     *
     * For HOST and DAY groupings, doing this is free since the children have
     * been precomputed. For queries and bookmark folders, being open means they
     * will keep themselves up-to-date by listening for updates and re-querying
     * as needed.
     */
    containerOpen: boolean;
    /**
     * Indicates whether the container is closed, loading, or opened.  Loading
     * implies that the container has been opened asynchronously and has not yet
     * fully opened.
     */
    readonly state: unsigned_short;
    /**
     * This indicates whether this node "may" have children, and can be used
     * when the container is open or closed. When the container is closed, it
     * will give you an exact answer if the node can easily be populated (for
     * example, a bookmark folder). If not (for example, a complex history query),
     * it will return true. When the container is open, it will always be
     * accurate. It is intended to be used to see if we should draw the "+" next
     * to a tree item.
     */
    readonly hasChildren: boolean;
    /**
     * This gives you the children of the nodes. It is preferrable to use this
     * interface over the array one, since it avoids creating an nsIArray object
     * and the interface is already the correct type.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if containerOpen is false.
     */
    readonly childCount: unsigned_long;
    /**
     *
     */
    getChild(aIndex: unsigned_long): nsINavHistoryResultNode;
    /**
     * Get the index of a direct child in this container.
     *
     * @param aNode
     * a result node.
     *
     * @return aNode's index in this container.
     * @throws NS_ERROR_NOT_AVAILABLE if containerOpen is false.
     * @throws NS_ERROR_INVALID_ARG if aNode isn't a direct child of this
     * container.
     */
    getChildIndex(aNode: nsINavHistoryResultNodeType): unsigned_long;
}

/**
 * Used for places queries and as a base for bookmark folders.
 *
 * Note that if you request places to *not* be expanded in the options that
 * generated this node, this item will report it has no children and never try
 * to populate itself.
 */
declare interface nsINavHistoryQueryResultNodeType extends nsINavHistoryContainerResultNodeType {
    /**
     * Get the query which builds this node's children.
     * Only valid for RESULT_TYPE_QUERY nodes.
     */
    readonly query: nsINavHistoryQuery;
    /**
     * Get the options which group this node's children.
     * Only valid for RESULT_TYPE_QUERY nodes.
     */
    readonly queryOptions: nsINavHistoryQueryOptions;
    /**
     * For both simple folder queries and folder shortcut queries, this is set to
     * the concrete itemId of the folder (i.e. for folder shortcuts it's the
     * target folder id).  Otherwise, this is set to -1.
     */
    readonly folderItemId: long_long;
    /**
     * For both simple folder queries and folder shortcut queries, this is set to
     * the concrete guid of the folder (i.e. for folder shortcuts it's the target
     * folder guid). Otherwise, this is set to an empty string.
     */
    readonly targetFolderGuid: ACString;
}

/**
 * Allows clients to observe what is happening to a result as it updates itself
 * according to history and bookmark system events. Register this observer on a
 * result using nsINavHistoryResult::addObserver.
 */
declare interface nsINavHistoryResultObserverType extends nsISupportsType {
    /**
     * Whether the observer is interested into history details changes.
     * Those include visits additions and removals. If the observer doesn't
     * provide this attribute, it will default to false.
     * In practice, the observer won't receive nodeHistoryDetailsChanged.
     * Note: this is only read when the observer is added, it cannot be changed
     * dynamically.
     */
    readonly skipHistoryDetailsNotifications: boolean;
    /**
     * Called when 'aItem' is inserted into 'aParent' at index 'aNewIndex'.
     * The item previously at index (if any) and everything below it will have
     * been shifted down by one. The item may be a container or a leaf.
     */
    nodeInserted(aParent: nsINavHistoryContainerResultNodeType, aNode: nsINavHistoryResultNodeType, aNewIndex: unsigned_long): void;
    /**
     * Called whan 'aItem' is removed from 'aParent' at 'aOldIndex'. The item
     * may be a container or a leaf. This function will be called after the item
     * has been removed from its parent list, but before anything else (including
     * NULLing out the item's parent) has happened.
     */
    nodeRemoved(aParent: nsINavHistoryContainerResultNodeType, aItem: nsINavHistoryResultNodeType, aOldIndex: unsigned_long): void;
    /**
     * Called whan 'aItem' is moved from 'aOldParent' at 'aOldIndex' to
     * aNewParent at aNewIndex. The item may be a container or a leaf.
     *
     * XXX: at the moment, this method is called only when an item is moved
     * within the same container. When an item is moved between containers,
     * a new node is created for the item, and the itemRemoved/itemAdded methods
     * are used.
     */
    nodeMoved(aNode: nsINavHistoryResultNodeType, aOldParent: nsINavHistoryContainerResultNodeType, aOldIndex: unsigned_long, aNewParent: nsINavHistoryContainerResultNodeType, aNewIndex: unsigned_long): void;
    /**
     * Called right after aNode's title has changed.
     *
     * @param aNode
     * a result node
     * @param aNewTitle
     * the new title
     */
    nodeTitleChanged(aNode: nsINavHistoryResultNodeType, aNewTitle: AUTF8String): void;
    /**
     * Called right after aNode's uri property has changed.
     *
     * @param aNode
     * a result node
     * @param aNewURI
     * the old uri
     */
    nodeURIChanged(aNode: nsINavHistoryResultNodeType, aOldURI: AUTF8String): void;
    /**
     * Called right after aNode's icon property has changed.
     *
     * @param aNode
     * a result node
     *
     * @note: The new icon is accessible through aNode.icon.
     */
    nodeIconChanged(aNode: nsINavHistoryResultNodeType): void;
    /**
     * Called right after aNode's time property or accessCount property, or both,
     * have changed.
     *
     * @param aNode
     * a uri result node
     * @param aOldVisitDate
     * the old visit date
     * @param aOldAccessCount
     * the old access-count
     */
    nodeHistoryDetailsChanged(aNode: nsINavHistoryResultNodeType, aOldVisitDate: PRTime, aOldAccessCount: unsigned_long): void;
    /**
     * Called when the tags set on the uri represented by aNode have changed.
     *
     * @param aNode
     * a uri result node
     *
     * @note: The new tags list is accessible through aNode.tags.
     */
    nodeTagsChanged(aNode: nsINavHistoryResultNodeType): void;
    /**
     * Called right after the aNode's keyword property has changed.
     *
     * @param aNode
     * a uri result node
     * @param aNewKeyword
     * the new keyword
     */
    nodeKeywordChanged(aNode: nsINavHistoryResultNodeType, aNewKeyword: AUTF8String): void;
    /**
     * Called right after aNode's dateAdded property has changed.
     *
     * @param aNode
     * a result node
     * @param aNewValue
     * the new value of the dateAdded property
     */
    nodeDateAddedChanged(aNode: nsINavHistoryResultNodeType, aNewValue: PRTime): void;
    /**
     * Called right after aNode's dateModified property has changed.
     *
     * @param aNode
     * a result node
     * @param aNewValue
     * the new value of the dateModified property
     */
    nodeLastModifiedChanged(aNode: nsINavHistoryResultNodeType, aNewValue: PRTime): void;
    /**
     * Called after a container changes state.
     *
     * @param aContainerNode
     * The container that has changed state.
     * @param aOldState
     * The state that aContainerNode has transitioned out of.
     * @param aNewState
     * The state that aContainerNode has transitioned into.
     */
    containerStateChanged(aContainerNode: nsINavHistoryContainerResultNodeType, aOldState: unsigned_long, aNewState: unsigned_long): void;
    /**
     * Called when something significant has happened within the container. The
     * contents of the container should be re-built.
     *
     * @param aContainerNode
     * the container node to invalidate
     */
    invalidateContainer(aContainerNode: nsINavHistoryContainerResultNodeType): void;
    /**
     * This is called to indicate to the UI that the sort has changed to the
     * given mode. For trees, for example, this would update the column headers
     * to reflect the sorting. For many other types of views, this won't be
     * applicable.
     *
     * @param sortingMode  One of nsINavHistoryQueryOptions.SORT_BY_* that
     * indicates the new sorting mode.
     *
     * This only is expected to update the sorting UI. invalidateAll() will also
     * get called if the sorting changes to update everything.
     */
    sortingChanged(sortingMode: unsigned_short): void;
    /**
     * This is called to indicate that a batch operation is about to start or end.
     * The observer could want to disable some events or updates during batches,
     * since multiple operations are packed in a short time.
     * For example treeviews could temporarily suppress select notifications.
     *
     * @param aToggleMode
     * true if a batch is starting, false if it's ending.
     */
    batching(aToggleMode: boolean): void;
    /**
     * Called by the result when this observer is added.
     */
    result: nsINavHistoryResult;
}

/**
 * The result of a history/bookmark query.
 */
declare interface nsINavHistoryResultType extends nsISupportsType {
    /**
     * Sorts all nodes recursively by the given parameter, one of
     * nsINavHistoryQueryOptions.SORT_BY_*  This will update the corresponding
     * options for this result, so that re-using the current options/queries will
     * always give you the current view.
     */
    sortingMode: unsigned_short;
    /**
     * Whether or not notifications on result changes are suppressed.
     * Initially set to false.
     *
     * Use this to avoid flickering and to improve performance when you
     * do temporary changes to the result structure (e.g. when searching for a
     * node recursively).
     */
    suppressNotifications: boolean;
    /**
     * Adds an observer for changes done in the result.
     *
     * @param aObserver
     * a result observer.
     * @param aOwnsWeak
     * If false, the result will keep an owning reference to the observer,
     * which must be removed using removeObserver.
     * If true, the result will keep a weak reference to the observer, which
     * must implement nsISupportsWeakReference.
     *
     * @see nsINavHistoryResultObserver
     */
    addObserver(aObserver: nsINavHistoryResultObserverType, aOwnsWeak: boolean): void;
    /**
     * Removes an observer that was added by addObserver.
     *
     * @param aObserver
     * a result observer that was added by addObserver.
     */
    removeObserver(aObserver: nsINavHistoryResultObserverType): void;
    /**
     * This is the root of the results. Remember that you need to open all
     * containers for their contents to be valid.
     *
     * When a result goes out of scope it will continue to observe changes till
     * it is cycle collected.  While the result waits to be collected it will stay
     * in memory, and continue to update itself, potentially causing unwanted
     * additional work.  When you close the root node the result will stop
     * observing changes, so it is good practice to close the root node when you
     * are done with a result, since that will avoid unwanted performance hits.
     */
    readonly root: nsINavHistoryContainerResultNode;
    /**
     * Notifies you that a bunch of things are about to change, don't do any
     * heavy-duty processing until onEndUpdateBatch is called.
     */
    onBeginUpdateBatch(): void;
    /**
     * Notifies you that we are done doing a bunch of things and you should go
     * ahead and update UI, etc.
     */
    onEndUpdateBatch(): void;
}

/**
 * This object encapsulates all the query parameters you're likely to need
 * when building up history UI. All parameters are ANDed together.
 *
 * This is not intended to be a super-general query mechanism. This was designed
 * so that most queries can be done in only one SQL query. This is important
 * because, if the user has their profile on a networked drive, query latency
 * can be non-negligible.
 */
declare interface nsINavHistoryQueryType extends nsISupportsType {
    /**
     *
     */
    beginTime: PRTime;
    /**
     *
     */
    beginTimeReference: unsigned_long;
    /**
     *
     */
    readonly hasBeginTime: boolean;
    /**
     *
     */
    readonly absoluteBeginTime: PRTime;
    /**
     *
     */
    endTime: PRTime;
    /**
     *
     */
    endTimeReference: unsigned_long;
    /**
     *
     */
    readonly hasEndTime: boolean;
    /**
     *
     */
    readonly absoluteEndTime: PRTime;
    /**
     * Text search terms.
     */
    searchTerms: AString;
    /**
     *
     */
    readonly hasSearchTerms: boolean;
    /**
     * Set lower or upper limits for how many times an item has been
     * visited.  The default is -1, and in that case all items are
     * matched regardless of their visit count.
     */
    minVisits: long;
    /**
     *
     */
    maxVisits: long;
    /**
     * When the set of transitions is nonempty, results are limited to pages which
     * have at least one visit for each of the transition types.
     * @note: For searching on more than one transition this can be very slow.
     *
     * Limit results to the specified list of transition types.
     */
    setTransitions(transitions: invalid): void;
    /**
     * Get the count of the set query transitions.
     */
    readonly transitionCount: unsigned_long;
    /**
     * This controls the meaning of 'domain', and whether it is an exact match
     * 'domainIsHost' = true, or hierarchical (= false).
     */
    domainIsHost: boolean;
    /**
     * This is the host or domain name (controlled by domainIsHost). When
     * domainIsHost, domain only does exact matching on host names. Otherwise,
     * it will return anything whose host name ends in 'domain'.
     *
     * This one is a little different than most. Setting it to an empty string
     * is a real query and will match any URI that has no host name (local files
     * and such). Set this to NULL (in C++ use SetIsVoid) if you don't want
     * domain matching.
     */
    domain: AUTF8String;
    /**
     *
     */
    readonly hasDomain: boolean;
    /**
     * This is a URI to match, to, for example, find out every time you visited
     * a given URI. This is an exact match.
     */
    uri: nsIURI;
    /**
     *
     */
    readonly hasUri: boolean;
    /**
     * Limit results to items that are tagged with all of the given tags.  This
     * attribute must be set to an array of strings.  When called as a getter it
     * will return an array of strings sorted ascending in lexicographical order.
     * The array may be empty in either case.  Duplicate tags may be specified
     * when setting the attribute, but the getter returns only unique tags.
     */
    tags: nsIVariant;
    /**
     * If 'tagsAreNot' is true, the results are instead limited to items that
     * are not tagged with any of the given tags.  This attribute is used in
     * conjunction with the 'tags' attribute.
     */
    tagsAreNot: boolean;
    /**
     *
     */
    readonly parentCount: unsigned_long;
    /**
     * This is not recursive so results will be returned from the first level of
     * that folder.
     */
    setParents(aGuids: invalid): void;
    /**
     * Creates a new query item with the same parameters of this one.
     */
    clone(): nsINavHistoryQuery;
}

/**
 * This object represents the global options for executing a query.
 */
declare interface nsINavHistoryQueryOptionsType extends nsISupportsType {
    /**
     * The sorting mode to be used for this query.
     * mode is one of SORT_BY_*
     */
    sortingMode: unsigned_short;
    /**
     * Sets the result type. One of RESULT_TYPE_* which includes how URIs are
     * represented.
     */
    resultType: unsigned_short;
    /**
     * This option excludes all URIs and separators from a bookmarks query.
     * This would be used if you just wanted a list of bookmark folders and
     * queries (such as the left pane of the places page).
     * Defaults to false.
     */
    excludeItems: boolean;
    /**
     * Set to true to exclude queries ("place:" URIs) from the query results.
     * Simple folder queries (bookmark folder symlinks) will still be included.
     * Defaults to false.
     */
    excludeQueries: boolean;
    /**
     * When set, allows items with "place:" URIs to appear as containers,
     * with the container's contents filled in from the stored query.
     * If not set, these will appear as normal items. Doesn't do anything if
     * excludeQueries is set. Defaults to false.
     *
     * Note that this has no effect on folder links, which are place: URIs
     * returned by nsINavBookmarkService.GetFolderURI. These are always expanded
     * and will appear as bookmark folders.
     */
    expandQueries: boolean;
    /**
     * Some pages in history are marked "hidden" and thus don't appear by default
     * in queries.  These include automatic framed visits and redirects.  Setting
     * this attribute will return all pages, even hidden ones.  Does nothing for
     * bookmark queries. Defaults to false.
     */
    includeHidden: boolean;
    /**
     * This is the maximum number of results that you want. The query is executed,
     * the results are sorted, and then the top 'maxResults' results are taken
     * and returned. Set to 0 (the default) to get all results.
     *
     * THIS DOES NOT WORK IN CONJUNCTION WITH SORTING BY TITLE. This is because
     * sorting by title requires us to sort after using locale-sensetive sorting
     * (as opposed to letting the database do it for us).
     *
     * Instead, we get the result ordered by date, pick the maxResult most recent
     * ones, and THEN sort by title.
     */
    maxResults: unsigned_long;
    /**
     * The type of search to use when querying the DB; This attribute is only
     * honored by query nodes. It is silently ignored for simple folder queries.
     */
    queryType: unsigned_short;
    /**
     * When this is true, the root container node generated by these options and
     * its descendant containers will be opened asynchronously if they support it.
     * This is false by default.
     *
     * @note Currently only bookmark folder containers support being opened
     * asynchronously.
     */
    asyncEnabled: boolean;
    /**
     * Creates a new options item with the same parameters of this one.
     */
    clone(): nsINavHistoryQueryOptions;
}

/**
 *
 */
declare interface nsINavHistoryServiceType extends nsISupportsType {
    /**
     * Returns the current database status
     */
    readonly databaseStatus: unsigned_short;
    /**
     * This is just like markPageAsTyped (in nsIBrowserHistory, also implemented
     * by the history service), but for bookmarks. It declares that the given URI
     * is being opened as a result of following a bookmark. If this URI is loaded
     * soon after this message has been received, that transition will be marked
     * as following a bookmark.
     */
    markPageAsFollowedBookmark(aURI: nsIURIType): void;
    /**
     * Designates the url as having been explicitly typed in by the user.
     *
     * @param aURI
     * URI of the page to be marked.
     */
    markPageAsTyped(aURI: nsIURIType): void;
    /**
     * Designates the url as coming from a link explicitly followed by
     * the user (for example by clicking on it).
     *
     * @param aURI
     * URI of the page to be marked.
     */
    markPageAsFollowedLink(aURI: nsIURIType): void;
    /**
     * Returns true if this URI would be added to the history. You don't have to
     * worry about calling this, adding a visit will always check before
     * actually adding the page. This function is public because some components
     * may want to check if this page would go in the history (i.e. for
     * annotations).
     */
    canAddURI(aURI: nsIURIType): boolean;
    /**
     * This returns a new query object that you can pass to executeQuer[y/ies].
     * It will be initialized to all empty (so using it will give you all history).
     */
    getNewQuery(): nsINavHistoryQuery;
    /**
     * This returns a new options object that you can pass to executeQuer[y/ies]
     * after setting the desired options.
     */
    getNewQueryOptions(): nsINavHistoryQueryOptions;
    /**
     * Executes a single query.
     */
    executeQuery(aQuery: nsINavHistoryQueryType, options: nsINavHistoryQueryOptionsType): nsINavHistoryResult;
    /**
     * Converts a query URI-like string to a query object.
     */
    queryStringToQuery(aQueryString: AUTF8String, aQuery: nsINavHistoryQueryType, options: nsINavHistoryQueryOptionsType): void;
    /**
     * Converts a query into an equivalent string that can be persisted. Inverse
     * of queryStringToQuery()
     */
    queryToQueryString(aQuery: nsINavHistoryQueryType, options: nsINavHistoryQueryOptionsType): AUTF8String;
    /**
     * True if history is disabled. currently,
     * history is disabled if the places.history.enabled pref is false.
     */
    readonly historyDisabled: boolean;
    /**
     * Generate a guid.
     * Guids can be used for any places purposes (history, bookmarks, etc.)
     * Returns null if the generation of the guid failed.
     */
    makeGuid(): ACString;
    /**
     * Returns a 48-bit hash for a URI spec.
     *
     * @param aSpec
     * The URI spec to hash.
     * @param aMode
     * The hash mode: `""` (default), `"prefix_lo"`, or `"prefix_hi"`.
     */
    hashURL(aSpec: ACString, aMode: ACString): unsigned_long_long;
    /**
     * Whether frecency is in the process of being decayed. The value can also
     * be read through the is_frecency_decaying() SQL function exposed by Places
     * database connections.
     */
    isFrecencyDecaying: boolean;
    /**
     * This is set to true when a frecency is invalidated and set back to false
     * when all the outdated values have been recalculated.
     */
    shouldStartFrecencyRecalculation: boolean;
    /**
     * The database connection used by Places.
     */
    readonly DBConnection: mozIStorageConnection;
    /**
     * Asynchronously executes the statement created from a query.
     *
     * @see nsINavHistoryService::executeQuery
     * @note THIS IS A TEMPORARY API.  Don't rely on it, since it will be replaced
     * in future versions by a real async querying API.
     * @note Results obtained from this method differ from results obtained from
     * executeQuery, because there is additional filtering and sorting
     * done by the latter.  Thus you should use executeQuery, unless you
     * are absolutely sure that the returned results are fine for
     * your use-case.
     */
    asyncExecuteLegacyQuery(aQuery: nsINavHistoryQueryType, aOptions: nsINavHistoryQueryOptionsType, aCallback: mozIStorageStatementCallback): mozIStoragePendingStatement;
    /**
     * Hook for clients who need to perform actions during/by the end of
     * the shutdown of the database.
     * May be null if it's too late to get one.
     */
    readonly shutdownClient: nsIAsyncShutdownClient;
    /**
     * Hook for internal clients who need to perform actions just before the
     * connection gets closed.
     * May be null if it's too late to get one.
     */
    readonly connectionShutdownClient: nsIAsyncShutdownClient;
}

/**
 * nsINestedURI is an interface that must be implemented by any nsIURI
 * implementation which has an "inner" URI that it actually gets data
 * from.
 *
 * For example, if URIs for the scheme "sanitize" have the structure:
 *
 * sanitize:http://example.com
 *
 * and opening a channel on such a sanitize: URI gets the data from
 * http://example.com, sanitizes it, and returns it, then the sanitize: URI
 * should implement nsINestedURI and return the http://example.com URI as its
 * inner URI.
 */
declare interface nsINestedURIType extends nsISupportsType {
    /**
     * The inner URI for this nested URI.  This must not return null if the
     * getter succeeds; URIs that have no inner must not QI to this interface.
     * Dynamically changing whether there is an inner URI is not allowed.
     *
     * Modifying the returned URI must not in any way modify the nested URI; this
     * means the returned URI must be either immutable or a clone.
     */
    readonly innerURI: nsIURI;
    /**
     * The innermost URI for this nested URI.  This must not return null if the
     * getter succeeds.  This is equivalent to repeatedly calling innerURI while
     * the returned URI QIs to nsINestedURI.
     *
     * Modifying the returned URI must not in any way modify the nested URI; this
     * means the returned URI must be either immutable or a clone.
     */
    readonly innermostURI: nsIURI;
}

/**
 *
 */
declare interface nsINestedURIMutatorType extends nsISupportsType {
}

/**
 *
 */
declare interface nsINestedAboutURIMutatorType extends nsISupportsType {
}

/**
 *
 */
declare interface nsIJSURIMutatorType extends nsISupportsType {
}

/**
 * nsINetAddr
 *
 * This interface represents a native NetAddr struct in a readonly
 * interface.
 */
declare interface nsINetAddrType extends nsISupportsType {
    /**
     * @return the address family of the network address, which corresponds to
     * one of the FAMILY_ constants.
     */
    readonly family: unsigned_short;
    /**
     * @return Either the IP address (FAMILY_INET, FAMILY_INET6) or the path
     * (FAMILY_LOCAL) in string form. IP addresses are in the format produced by
     * mozilla::net::NetAddr::ToStringBuffer.
     *
     * Note: Paths for FAMILY_LOCAL may have length limitations which are
     * implementation dependent and not documented as part of this interface.
     */
    readonly address: AUTF8String;
    /**
     * @return the port number for a FAMILY_INET or FAMILY_INET6 address.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if the address family is not FAMILY_INET or
     * FAMILY_INET6.
     */
    readonly port: unsigned_short;
    /**
     * @return the flow label for a FAMILY_INET6 address.
     *
     * @see http://www.ietf.org/rfc/rfc3697.txt
     *
     * @throws NS_ERROR_NOT_AVAILABLE if the address family is not FAMILY_INET6
     */
    readonly flow: unsigned_long;
    /**
     * @return the address scope of a FAMILY_INET6 address.
     *
     * @see http://tools.ietf.org/html/rfc4007
     *
     * @throws NS_ERROR_NOT_AVAILABLE if the address family is not FAMILY_INET6
     */
    readonly scope: unsigned_long;
    /**
     * @return whether a FAMILY_INET6 address is mapped from FAMILY_INET.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if the address family is not FAMILY_INET6
     */
    readonly isV4Mapped: boolean;
}

/**
 * nsINetUtil provides various network-related utility methods.
 */
declare interface nsINetUtilType extends nsISupportsType {
    /**
     * Parse a Content-Type header value in strict mode.  This is a more
     * conservative parser that reject things that violate RFC 7231 section
     * 3.1.1.1.  This is typically useful for parsing Content-Type header values
     * that are used for HTTP requests, and those that are used to make security
     * decisions.
     *
     * @param aTypeHeader the header string to parse
     * @param [out] aCharset the charset parameter specified in the
     * header, if any.
     * @param [out] aHadCharset whether a charset was explicitly specified.
     * @return the MIME type specified in the header, in lower-case.
     */
    parseRequestContentType(aTypeHeader: AUTF8String, aCharset: AUTF8String, aHadCharset: boolean): AUTF8String;
    /**
     * Parse a Content-Type header value in relaxed mode.  This is a more
     * permissive parser that ignores things that go against RFC 7231 section
     * 3.1.1.1.  This is typically useful for parsing Content-Type header values
     * received from web servers where we want to make a best effort attempt
     * at extracting a useful MIME type and charset.
     *
     * NOTE: DO NOT USE THIS if you're going to make security decisions
     * based on the result.
     *
     * @param aTypeHeader the header string to parse
     * @param [out] aCharset the charset parameter specified in the
     * header, if any.
     * @param [out] aHadCharset whether a charset was explicitly specified.
     * @return the MIME type specified in the header, in lower-case.
     */
    parseResponseContentType(aTypeHeader: AUTF8String, aCharset: AUTF8String, aHadCharset: boolean): AUTF8String;
    /**
     * Test whether the given URI's handler has the given protocol flags.
     *
     * @param aURI the URI in question
     * @param aFlags the flags we're testing for.
     *
     * @return whether the protocol handler for aURI has all the flags
     * in aFlags.
     */
    protocolHasFlags(aURI: nsIURIType, aFlag: unsigned_long): boolean;
    /**
     * Test whether the protocol handler for this URI or that for any of
     * its inner URIs has the given protocol flags.  This will QI aURI to
     * nsINestedURI and walk the nested URI chain.
     *
     * @param aURI the URI in question
     * @param aFlags the flags we're testing for.
     *
     * @return whether any of the protocol handlers involved have all the flags
     * in aFlags.
     */
    URIChainHasFlags(aURI: nsIURIType, aFlags: unsigned_long): boolean;
    /**
     * escape a string with %00-style escaping
     */
    escapeString(aString: ACString, aEscapeType: unsigned_long): ACString;
    /**
     * %XX-Escape invalid chars in a URL segment.
     *
     * @param aStr the URL to be escaped
     * @param aFlags the URL segment type flags
     *
     * @return the escaped string (the string itself if escaping did not happen)
     */
    escapeURL(aStr: ACString, aFlags: unsigned_long): ACString;
    /**
     * Expands URL escape sequences
     *
     * @param aStr the URL to be unescaped
     * @param aFlags only ESCAPE_URL_ONLY_NONASCII and ESCAPE_URL_SKIP_CONTROL
     * are recognized.  If |aFlags| is 0 all escape sequences are
     * unescaped
     * @return unescaped string
     */
    unescapeString(aStr: AUTF8String, aFlags: unsigned_long): ACString;
    /**
     * Extract the charset parameter location and value from a content-type
     * header.
     *
     * @param aTypeHeader the header string to parse
     * @param [out] aCharset the charset parameter specified in the
     * header, if any.
     * @param [out] aCharsetStart index of the start of the charset parameter
     * (the ';' separating it from what came before) in aTypeHeader.
     * If this function returns false, this argument will still be
     * set, to the index of the location where a new charset should
     * be inserted.
     * @param [out] aCharsetEnd index of the end of the charset parameter (the
     * ';' separating it from what comes after, or the end
     * of the string) in aTypeHeader.  If this function returns
     * false, this argument will still be set, to the index of the
     * location where a new charset should be inserted.
     *
     * @return whether a charset parameter was found.  This can be false even in
     * cases when parseContentType would claim to have a charset, if the type
     * that won out does not have a charset parameter specified.
     */
    extractCharsetFromContentType(aTypeHeader: AUTF8String, aCharset: AUTF8String, aCharsetStart: long, aCharsetEnd: long): boolean;
    /**
     * This is test-only. Send an IPC message to let socket process send a
     * telemetry.
     */
    socketProcessTelemetryPing(): void;
    /**
     * This is a void method that is C++ implemented and always
     * returns NS_ERROR_NOT_IMPLEMENTED. To be used for testing.
     */
    notImplemented(): void;
}

/**
 *
 */
declare interface nsINetworkConnectivityServiceType extends nsISupportsType {
    /**
     * If DNS v4/v6 queries actually work on the current network
     */
    readonly DNSv4: nsINetworkConnectivityService_ConnectivityState;
    /**
     *
     */
    readonly DNSv6: nsINetworkConnectivityService_ConnectivityState;
    /**
     * If connecting to IPv4/v6 works on the current network
     */
    readonly IPv4: nsINetworkConnectivityService_ConnectivityState;
    /**
     *
     */
    readonly IPv6: nsINetworkConnectivityService_ConnectivityState;
    /**
     * If a NAT64 gateway was detected on the current network
     */
    readonly NAT64: nsINetworkConnectivityService_ConnectivityState;
    /**
     * Starts the DNS request to check for DNS v4/v6 availability
     */
    recheckDNS(): void;
    /**
     * Starts HTTP requests over IPv4 and IPv6, and checks if they work
     */
    recheckIPConnectivity(): void;
}

/**
 * Listener for getting list of addresses.
 */
declare interface nsIListNetworkAddressesListenerType extends nsISupportsType {
    /**
     * Callback function that gets called by nsINetworkInfoService.listNetworkAddresses.
     * Each address in the array is a string IP address in canonical form,
     * e.g. 192.168.1.10, or an IPV6 address in string form.
     */
    onListedNetworkAddresses(aAddressArray: invalid): void;
    /**
     *
     */
    onListNetworkAddressesFailed(): void;
}

/**
 * Listener for getting hostname.
 */
declare interface nsIGetHostnameListenerType extends nsISupportsType {
    /**
     *
     */
    onGotHostname(aHostname: AUTF8String): void;
    /**
     *
     */
    onGetHostnameFailed(): void;
}

/**
 * Service information
 */
declare interface nsINetworkInfoServiceType extends nsISupportsType {
    /**
     * Obtain a list of local machine network addresses.  The listener object's
     * onListedNetworkAddresses will be called with the obtained addresses.
     * On failure, the listener object's onListNetworkAddressesFailed() will be called.
     */
    listNetworkAddresses(aListener: nsIListNetworkAddressesListenerType): void;
    /**
     * Obtain the hostname of the local machine.  The listener object's
     * onGotHostname will be called with the obtained hostname.
     * On failure, the listener object's onGetHostnameFailed() will be called.
     */
    getHostname(aListener: nsIGetHostnameListenerType): void;
}

/**
 * Interface allowing the nsIInterceptedChannel to callback when it is
 * done reading from the body stream.
 */
declare interface nsIInterceptedBodyCallbackType extends nsISupportsType {
    /**
     *
     */
    bodyComplete(aRv: nsresult): void;
}

/**
 * Interface to allow implementors of nsINetworkInterceptController to control the behaviour
 * of intercepted channels without tying implementation details of the interception to
 * the actual channel. nsIInterceptedChannel is expected to be implemented by objects
 * which do not implement nsIChannel.
 */
declare interface nsIInterceptedChannelType extends nsISupportsType {
    /**
     * Instruct a channel that has been intercepted to continue with the original
     * network request.
     *
     * For our mitigations, we support this reset triggering "bypass" mode which
     * results in the resulting client not being controlled.
     */
    resetInterception(bypass: boolean): void;
    /**
     * Set the status and reason for the forthcoming synthesized response.
     * Multiple calls overwrite existing values.
     */
    synthesizeStatus(status: uint16_t, reason: ACString): void;
    /**
     * Attach a header name/value pair to the forthcoming synthesized response.
     * Overwrites any existing header value.
     */
    synthesizeHeader(name: ACString, value: ACString): void;
    /**
     * Instruct a channel that has been intercepted that a response is
     * starting to be synthesized.  No further header modification is allowed
     * after this point.  There are a few parameters:
     * - A body stream may be optionally passed.  If nullptr, then an
     * empty body is assumed.
     * - A callback may be optionally passed.  It will be invoked
     * when the body is complete.  For a nullptr body this may be
     * synchronously on the current thread.  Otherwise it will be invoked
     * asynchronously on the current thread.
     * - A cacheInfoChannel may be optionally passed. If the body stream is
     * from alternative data cache, this cacheInfoChannel provides needed
     * cache information.
     * - The caller may optionally pass a spec for a URL that this response
     * originates from; an empty string will cause the original
     * intercepted request's URL to be used instead.
     * - The responseRedirected flag is false will cause the channel do an
     * internal redirect when the original intercepted reauest's URL is
     * different from the response's URL. The flag is true will cause the
     * chaanel do a non-internal redirect when the URLs are different.
     */
    startSynthesizedResponse(body: nsIInputStreamType, callback: nsIInterceptedBodyCallbackType, channel: nsICacheInfoChannelType, finalURLSpec: ACString, responseRedirected: bool): void;
    /**
     * Instruct a channel that has been intercepted that response synthesis
     * has completed and all outstanding resources can be closed.
     */
    finishSynthesizedResponse(): void;
    /**
     * Cancel the pending intercepted request.
     * @return NS_ERROR_FAILURE if the response has already been synthesized or
     * the original request has been instructed to continue.
     */
    cancelInterception(status: nsresult): void;
    /**
     * The underlying channel object that was intercepted.
     */
    readonly channel: nsIChannel;
    /**
     * The URL of the underlying channel object, corrected for a potential
     * secure upgrade.
     */
    readonly secureUpgradedChannelURI: nsIURI;
    /**
     * Get the internal load type from the underlying channel.
     */
    readonly internalContentPolicyType: nsContentPolicyType;
    /**
     *
     */
    readonly consoleReportCollector: nsIConsoleReportCollector;
}

/**
 * Interface to allow consumers to attach themselves to a channel's
 * notification callbacks/loadgroup and determine if a given channel
 * request should be intercepted before any network request is initiated.
 */
declare interface nsINetworkInterceptControllerType extends nsISupportsType {
    /**
     * Returns true if a channel should avoid initiating any network
     * requests until specifically instructed to do so.
     *
     * @param aURI The URI to be loaded.  Note, this may differ from
     * the channel's current URL in some cases.
     * @param aChannel The channel that may be intercepted.  It will
     * be in the state prior to calling OnStartRequest().
     */
    shouldPrepareForIntercept(aURI: nsIURIType, aChannel: nsIChannelType): bool;
    /**
     * Notification when a given intercepted channel is prepared to accept a synthesized
     * response via the provided stream.
     *
     * @param aChannel the controlling interface for a channel that has been intercepted
     */
    channelIntercepted(aChannel: nsIInterceptedChannelType): void;
}

/**
 * Network link status monitoring service.
 */
declare interface nsINetworkLinkServiceType extends nsISupportsType {
    /**
     * This is set to true when the system is believed to have a usable
     * network connection.
     *
     * The link is only up when network connections can be established. For
     * example, the link is down during DHCP configuration (unless there
     * is another usable interface already configured).
     *
     * If the link status is not currently known, we generally assume that
     * it is up.
     */
    readonly isLinkUp: boolean;
    /**
     * This is set to true when we believe that isLinkUp is accurate.
     */
    readonly linkStatusKnown: boolean;
    /**
     * The type of network connection.
     */
    readonly linkType: unsigned_long;
    /**
     * A string uniquely identifying the current active network interfaces.
     * Empty when there are no active network interfaces.
     */
    readonly networkID: ACString;
    /**
     * A bitfield that encodes the platform attributes we detected which
     * indicate that we should only use DNS, not TRR.
     */
    readonly platformDNSIndications: unsigned_long;
}

/**
 * nsINetworkPredictor - learn about pages users visit, and allow us to take
 * predictive actions upon future visits.
 * NOTE: nsINetworkPredictor should only
 * be used on the main thread.
 */
declare interface nsINetworkPredictorType extends nsISupportsType {
    /**
     * Start taking predictive actions
     *
     * Calling this will cause the predictor to (possibly) start
     * taking actions such as DNS prefetch and/or TCP preconnect based on
     * (1) the host name that we are given, and (2) the reason we are being
     * asked to take actions.
     *
     * @param targetURI - The URI we are being asked to take actions based on.
     * @param sourceURI - The URI that is currently loaded. This is so we can
     * avoid doing predictive actions for link hover on an HTTPS page (for
     * example).
     * @param reason - The reason we are being asked to take actions. Can be
     * any of the PREDICT_* values above.
     * In the case of PREDICT_LINK, targetURI should be the URI of the link
     * that is being hovered over, and sourceURI should be the URI of the page
     * on which the link appears.
     * In the case of PREDICT_LOAD, targetURI should be the URI of the page that
     * is being loaded and sourceURI should be null.
     * In the case of PREDICT_STARTUP, both targetURI and sourceURI should be
     * null.
     * @param originAttributes - The originAttributes of the page load we are
     * predicting about.
     * @param verifier - An nsINetworkPredictorVerifier used in testing to ensure
     * we're predicting the way we expect to. Not necessary (or desired) for
     * normal operation.
     */
    predict(targetURI: nsIURIType, sourceURI: nsIURIType, reason: PredictorPredictReason, originAttributes: jsval, verifier: nsINetworkPredictorVerifierType): void;
    /**
     *
     */
    predictNative(targetURI: nsIURIType, sourceURI: nsIURIType, reason: PredictorPredictReason, originAttributes: OriginAttributes, verifier: nsINetworkPredictorVerifierType): nsresult;
    /**
     * Add to our compendium of knowledge
     *
     * This adds to our prediction database to make things (hopefully)
     * smarter next time we predict something.
     *
     * @param targetURI - The URI that was loaded that we are keeping track of.
     * @param sourceURI - The URI that caused targetURI to be loaded (for page
     * loads). This means the DOCUMENT URI.
     * @param reason - The reason we are learning this bit of knowledge.
     * Reason can be any of the LEARN_* values.
     * In the case of LEARN_LOAD_SUBRESOURCE, targetURI should be the URI of a
     * subresource of a page, and sourceURI should be the top-level URI.
     * In the case of LEARN_LOAD_REDIRECT, targetURI is the NEW URI of a
     * top-level resource that was redirected to, and sourceURI is the
     * ORIGINAL URI of said top-level resource.
     * In the case of LEARN_STARTUP, targetURI should be the URI of a page
     * that was loaded immediately after browser startup, and sourceURI should
     * be null.
     * @param originAttributes - The originAttributes for the page load that we
     * are learning about.
     */
    learn(targetURI: nsIURIType, sourceURI: nsIURIType, reason: PredictorLearnReason, originAttributes: jsval): void;
    /**
     *
     */
    learnNative(targetURI: nsIURIType, sourceURI: nsIURIType, reason: PredictorLearnReason, originAttributes: OriginAttributes): nsresult;
    /**
     * Clear out all our learned knowledge
     *
     * This removes everything from our database so that any predictions begun
     * after this completes will start from a blank slate.
     */
    reset(): void;
}

/**
 *
 */
declare interface nsINetworkPredictorVerifierType extends nsISupportsType {
    /**
     * Callback for when we do a predictive prefetch
     *
     * @param uri - The URI that was prefetched
     * @param status - The request status code returned by the
     * prefetch attempt e.g. 200 (OK):w
     */
    onPredictPrefetch(uri: nsIURIType, status: uint32_t): void;
    /**
     * Callback for when we do a predictive preconnect
     *
     * @param uri - The URI that was preconnected to
     */
    onPredictPreconnect(uri: nsIURIType): void;
    /**
     * Callback for when we do a predictive DNS lookup
     *
     * @param uri - The URI that was looked up
     */
    onPredictDNS(uri: nsIURIType): void;
}

/**
 *
 */
declare interface nsINotificationStorageCallbackType extends nsISupportsType {
    /**
     * Callback function used to pass single notification back
     * into C++ land for Notification.get return data.
     *
     * @param id: a uuid for this notification
     * @param title: the notification title
     * @param dir: the notification direction,
     * possible values are "ltr", "rtl", "auto"
     * @param lang: the notification language
     * @param body: the notification body
     * @param tag: the notification tag
     */
    handle(id: AString, title: AString, dir: AString, lang: AString, body: AString, tag: AString, icon: AString, data: AString, behavior: AString, serviceWorkerRegistrationScope: AString): void;
    /**
     * Callback function used to notify C++ the we have returned
     * all notification objects for this Notification.get call.
     */
    done(): void;
}

/**
 * Interface for notification persistence layer.
 */
declare interface nsINotificationStorageType extends nsISupportsType {
    /**
     * Add/replace a notification to the persistence layer.
     *
     * @param origin: the origin/app of this notification
     * @param id: a uuid for this notification
     * @param title: the notification title
     * @param dir: the notification direction,
     * possible values are "ltr", "rtl", "auto"
     * @param lang: the notification language
     * @param body: the notification body
     * @param tag: notification tag, will replace any existing
     * notifications with same origin/tag pair
     * @param alertName: the alert identifier as used by system app.
     * Stored in the database to avoid re-computing
     * it. Built from origin and tag or id depending
     * whether there is a tag defined.
     * @param registrationID: Opaque string that identifies the service worker
     * registration this Notification is associated with.
     * May be empty. Only set for Notifications created by
     * showNotification().
     */
    put(origin: AString, id: AString, title: AString, dir: AString, lang: AString, body: AString, tag: AString, icon: AString, alertName: AString, data: AString, behavior: AString, serviceWorkerRegistrationScope: AString): void;
    /**
     * Retrieve a list of notifications.
     *
     * @param origin: the origin/app for which to fetch notifications from
     * @param tag: used to fetch only a specific tag
     * @param callback: nsINotificationStorageCallback, used for
     * returning notifications objects
     */
    get(origin: AString, tag: AString, aCallback: nsINotificationStorageCallbackType): void;
    /**
     * Remove a notification from storage.
     *
     * @param origin: the origin/app to delete the notification from
     * @param id: the uuid for the notification to delete
     */
    delete(origin: AString, id: AString): void;
}

/**
 * This interface is only used in order to mark the fact that
 * an object isn't a complete implementation of its interfaces.
 * For example, a consumer can QI NullHttpChannel to nsINullChannel,
 * to determine if the object is just a dummy implementation of nsIHttpChannel.
 */
declare interface nsINullChannelType extends nsISupportsType {
}

/**
 *
 */
declare interface nsIOSFileConstantsServiceType extends nsISupportsType {
    /**
     * Inject module OS.Constants in the environment.
     *
     * This method must be called only from the main thread.
     * Method is idempotent.
     */
    init(): void;
}

/**
 *
 */
declare interface nsIOSKeyStoreType extends nsISupportsType {
    /**
     * This interface provides encryption and decryption operations for data at
     * rest. The key used to encrypt and decrypt the data is stored in the OS
     * key store.
     *
     * NB: To first authenticate the user to the system, use
     * nsIOSReauthenticator.
     *
     * Usage:
     *
     * // obtain the singleton OSKeyStore instance
     * const oskeystore = Cc["@mozilla.org/security/oskeystore;1"].getService(Ci.nsIOSKeyStore);
     *
     * const PASSWORD_LABEL = "mylabel1";
     *
     * // Check if there's a secret for your label already.
     * if (!await oskeystore.asyncSecretAvailable(PASSWORD_LABEL)) {
     * // Fail or generate a new secret for your label.
     * // If you want to generate a new secret, do.
     * // Hold onto `recoveryPhrase` to present to the user.
     * let recoveryPhrase = await oskeystore.asyncGenerateSecret(PASSWORD_LABEL);
     * }
     *
     * // Assuming there's a secret with your label. Encrypt/Decrypt as follows.
     * let encryptedPasswordBytes = await oskeystore.asyncEncryptBytes(PASSWORD_LABEL, passwordBytes);
     * let newPasswordBytes = await oskeystore.asyncDecryptBytes(PASSWORD_LABEL, encryptedPasswordBytes);
     *
     * // Delete the secret from the key store.
     * await oskeystore.asyncDeleteSecret(PASSWORD_LABEL);
     *
     * // Recover a secret from a recovery code.
     * await oskeystore.asyncRecoverSecret(PASSWORD_LABEL, recoveryPhrase);
     *
     * Generate a new secret and store it in the OS key store with the given label.
     * The caller should make sure that no other secrets with the same label are
     * present before calling this function.
     * This invalidates all previous ciphertexts created with the key
     * corresponding to the given label.
     *
     * @param label The label to use for the secret.
     * @return Promise that resolves to the recoveryPhrase string used to generate
     * the secret.
     */
    asyncGenerateSecret(label: ACString): Promise;
    /**
     * Check whether a secret for a given label exists.
     *
     * @param label The label to lookup.
     * @return Promise that resolves to a bool (whether a secret with label is
     * known or not) or an error.
     */
    asyncSecretAvailable(label: ACString): Promise;
    /**
     * Set a secret from a given recovery phrase.
     * This might not be implemented on all platforms.
     * This invalidates all previous ciphertexts.
     *
     * @param label The label to use for the secret.
     * @param recoveryPhrase The recovery phrase that's used to generate the secret.
     * @return Promise that resolves to undefined or an error.
     */
    asyncRecoverSecret(label: ACString, recoveryPhrase: ACString): Promise;
    /**
     * Delete secret with a given label. If there is no secret with the given
     * label, no action is taken.
     *
     * @param label The label of the secret to delete.
     * @return Promise that resolves to undefined or an error.
     */
    asyncDeleteSecret(label: ACString): Promise;
    /**
     * Encrypt the given data and then return the result as a base64-encoded
     * string.
     *
     * @param label The label of the key to use to encrypt.
     * @param inBytes The bytes to encrypt.
     * @return Promise resolving to the encrypted text, encoded as Base64, or an
     * error.
     */
    asyncEncryptBytes(label: ACString, inBytes: invalid): Promise;
    /**
     * Decode and then decrypt the given base64-encoded string.
     *
     * @param label The label of the key to use to decrypt.
     * @param encryptedBase64Text Encrypted input text, encoded as Base64.
     * @return Promise resolving to the plaintext bytes or an error.
     */
    asyncDecryptBytes(label: ACString, encryptedBase64Text: ACString): Promise;
}

/**
 *
 */
declare interface nsIOSPermissionRequestType extends nsISupportsType {
    /**
     * Get the permission state for both audio and video capture
     */
    getMediaCapturePermissionState(aVideo: uint16_t, aAudio: uint16_t): void;
    /**
     * Get the permission state for audio capture
     */
    getAudioCapturePermissionState(aAudio: uint16_t): void;
    /**
     * Get the permission state for video capture
     */
    getVideoCapturePermissionState(aVideo: uint16_t): void;
    /**
     * Get the permission state for screen capture
     */
    getScreenCapturePermissionState(aScreen: uint16_t): void;
    /**
     * Request permission to access video capture devices. Returns a
     * promise that resolves with |true| after the browser has been
     * granted permission to capture video. If capture access is denied,
     * the promise is resolved with |false|. The promise is rejected if
     * an error occurs.
     */
    requestVideoCapturePermission(): Promise;
    /**
     * Request permission to access audio capture devices. Returns a
     * promise with the same semantics as |requestVideoCapturePermission|.
     */
    requestAudioCapturePermission(): Promise;
    /**
     * Request permission to capture the screen using an unreliable method.
     * Attemps to trigger a screen capture permission dialog. Whether or not
     * the dialog is displayed and whether or not the user grants permission
     * to record the screen is not available to the caller. This method has
     * limited utility because it does not block to wait for a dialog
     * prompt or the user's reponse if a dialog is displayed. And the dialog
     * is not guaranteed to be displayed per OS restrictions.
     */
    maybeRequestScreenCapturePermission(): void;
}

/**
 *
 */
declare interface nsIOSReauthenticatorType extends nsISupportsType {
    /**
     * This interface provides an abstract way to request that the user
     * reauthenticate themselves to the operating system. It may be useful in
     * conjunction with nsIOSKeyStore, whereby consumers of these APIs may
     * consider some secrets too sensitive to access without first
     * reauthenticating the user.
     *
     * Usage:
     *
     * // obtain the singleton nsIOSReauthenticator instance
     * const reauthenticator = Cc["@mozilla.org/security/osreauthenticator;1"]
     * .getService(Ci.nsIOSReauthenticator);
     * if (await reauthenticator.asyncReauthenticate()) {
     * // do something only authenticated users are allowed to do...
     * } else {
     * // show a "sorry, this isn't allowed" error
     * }
     *
     * Asynchronously cause the operating system to request that the user
     * reauthenticate. This is typically in the form of a dialog box asking the
     * user for their login password. The actual behaviour of this depends on the
     * OS.
     *
     * @param prompt A short string that may be incorporated in the dialog
     * @param caption A short string that may be shown as the dialog caption (usually Product Name)
     * @param parentWindow Used to associate the OS dialog with the calling window.
     * @return Promise resolving to true if the user successfully authenticated
     * and false otherwise.
     */
    asyncReauthenticateUser(prompt: AString, caption: AString, parentWindow: mozIDOMWindow): Promise;
}

/**
 * @see nsIObjectOutputStream
 * @see nsIBinaryInputStream
 */
declare interface nsIObjectInputStreamType extends nsIBinaryInputStreamType {
    /**
     * Read an object from this stream to satisfy a strong or weak reference
     * to one of its interfaces.  If the interface was not along the primary
     * inheritance chain ending in the "root" or XPCOM-identity nsISupports,
     * readObject will QueryInterface from the deserialized object root to the
     * correct interface, which was specified when the object was serialized.
     *
     * @see nsIObjectOutputStream
     */
    readObject(aIsStrongRef: boolean): nsISupports;
    /**
     *
     */
    readID(aID: nsIDType): nsresult;
    /**
     * Optimized deserialization support -- see nsIStreamBufferAccess.idl.
     */
    getBuffer(aLength: uint32_t, aAlignMask: uint32_t): charPtr;
    /**
     *
     */
    putBuffer(aBuffer: charPtr, aLength: uint32_t): void;
}

/**
 * This interface represents a content node that loads objects.
 *
 * Please make sure to update the MozObjectLoadingContent WebIDL
 * mixin to mirror this interface when changing it.
 */
declare interface nsIObjectLoadingContentType extends nsISupportsType {
    /**
     * The actual mime type (the one we got back from the network
     * request) for the element.
     */
    readonly actualType: ACString;
    /**
     * Gets the type of the content that's currently loaded. See
     * the constants above for the list of possible values.
     */
    readonly displayedType: unsigned_long;
    /**
     * Gets the content type that corresponds to the give MIME type.  See the
     * constants above for the list of possible values.  If nothing else fits,
     * TYPE_FALLBACK will be returned.
     */
    getContentTypeForMIMEType(aMimeType: AUTF8String): unsigned_long;
    /**
     * Forces a re-evaluation and reload of the tag, optionally invalidating its
     * click-to-play state.  This can be used when the MIME type that provides a
     * type has changed, for instance, to force the tag to re-evalulate the
     * handler to use.
     */
    reload(aClearActivation: boolean): void;
    /**
     * The URL of the data/src loaded in the object. This may be null (i.e.
     * an <embed> with no src).
     */
    readonly srcURI: nsIURI;
    /**
     * Disable the use of fake plugins and reload the tag if necessary.
     */
    skipFakePlugins(): void;
}

/**
 * @See nsIObjectInputStream
 * @See nsIBinaryOutputStream
 */
declare interface nsIObjectOutputStreamType extends nsIBinaryOutputStreamType {
    /**
     * Write the object whose "root" or XPCOM-identity nsISupports is aObject.
     * The cause for writing this object is a strong or weak reference, so the
     * aIsStrongRef argument must tell which kind of pointer is being followed
     * here during serialization.
     *
     * If the object has only one strong reference in the serialization and no
     * weak refs, use writeSingleRefObject.  This is a valuable optimization:
     * it saves space in the stream, and cycles on both ends of the process.
     *
     * If the reference being serialized is a pointer to an interface not on
     * the primary inheritance chain ending in the root nsISupports, you must
     * call writeCompoundObject instead of this method.
     */
    writeObject(aObject: nsISupportsType, aIsStrongRef: boolean): void;
    /**
     * Write an object referenced singly and strongly via its root nsISupports
     * or a subclass of its root nsISupports.  There must not be other refs to
     * aObject in memory, or in the serialization.
     */
    writeSingleRefObject(aObject: nsISupportsType): void;
    /**
     * Write the object referenced by an interface pointer at aObject that
     * inherits from a non-primary nsISupports, i.e., a reference to one of
     * the multiply inherited interfaces derived from an nsISupports other
     * than the root or XPCOM-identity nsISupports; or a reference to an
     * inner object in the case of true XPCOM aggregation.  aIID identifies
     * this interface.
     */
    writeCompoundObject(aObject: nsISupportsType, aIID: nsIIDRefType, aIsStrongRef: boolean): void;
    /**
     *
     */
    writeID(aID: nsIDRefType): void;
    /**
     * Optimized serialization support -- see nsIStreamBufferAccess.idl.
     */
    getBuffer(aLength: uint32_t, aAlignMask: uint32_t): charPtr;
    /**
     *
     */
    putBuffer(aBuffer: charPtr, aLength: uint32_t): void;
}

/**
 *
 */
declare interface nsIObliviousHttpClientResponseType extends nsISupportsType {
}

/**
 *
 */
declare interface nsIObliviousHttpClientRequestType extends nsISupportsType {
    /**
     *
     */
    readonly response: nsIObliviousHttpClientResponse;
}

/**
 *
 */
declare interface nsIObliviousHttpServerResponseType extends nsISupportsType {
}

/**
 *
 */
declare interface nsIObliviousHttpServerType extends nsISupportsType {
    /**
     *
     */
    decapsulate(encRequest: invalid): nsIObliviousHttpServerResponse;
}

/**
 *
 */
declare interface nsIObliviousHttpType extends nsISupportsType {
    /**
     *
     */
    encapsulateRequest(encodedConfig: invalid, request: invalid): nsIObliviousHttpClientRequest;
    /**
     *
     */
    server(): nsIObliviousHttpServer;
}

/**
 *
 */
declare interface nsIObliviousHttpServiceType extends nsISupportsType {
    /**
     *
     */
    newChannel(relayURI: nsIURIType, targetURI: nsIURIType, encodedConfig: invalid): nsIChannel;
    /**
     *
     */
    getTRRSettings(relayURI: nsIURIType, encodedConfig: invalid): void;
    /**
     *
     */
    clearTRRConfig(): void;
}

/**
 * This interface is implemented by an object that wants
 * to observe an event corresponding to a topic.
 */
declare interface nsIObserverType extends nsISupportsType {
    /**
     * Observe will be called when there is a notification for the
     * topic |aTopic|.  This assumes that the object implementing
     * this interface has been registered with an observer service
     * such as the nsIObserverService.
     *
     * If you expect multiple topics/subjects, the impl is
     * responsible for filtering.
     *
     * You should not modify, add, remove, or enumerate
     * notifications in the implemention of observe.
     *
     * @param aSubject : Notification specific interface pointer.
     * @param aTopic   : The notification topic or subject.
     * @param aData    : Notification specific wide string.
     * subject event.
     */
    observe(aSubject: nsISupportsType, aTopic: string, aData: wstring): void;
}

/**
 * nsIObserverService
 *
 * Service allows a client listener (nsIObserver) to register and unregister for
 * notifications of specific string referenced topic. Service also provides a
 * way to notify registered listeners and a way to enumerate registered client
 * listeners.
 */
declare interface nsIObserverServiceType extends nsISupportsType {
    /**
     * AddObserver
     *
     * Registers a given listener for a notifications regarding the specified
     * topic.
     *
     * @param anObserve : The interface pointer which will receive notifications.
     * @param aTopic    : The notification topic or subject.
     * @param ownsWeak  : If set to false, the nsIObserverService will hold a
     * strong reference to |anObserver|.  If set to true and
     * |anObserver| supports the nsIWeakReference interface,
     * a weak reference will be held.  Otherwise an error will be
     * returned.
     */
    addObserver(anObserver: nsIObserverType, aTopic: string, ownsWeak: boolean): void;
    /**
     * removeObserver
     *
     * Unregisters a given listener from notifications regarding the specified
     * topic.
     *
     * @param anObserver : The interface pointer which will stop recieving
     * notifications.
     * @param aTopic     : The notification topic or subject.
     */
    removeObserver(anObserver: nsIObserverType, aTopic: string): void;
    /**
     * notifyObservers
     *
     * Notifies all registered listeners of the given topic.
     * Must not be used with shutdown topics (will assert
     * on the parent process).
     *
     * @param aSubject : Notification specific interface pointer.
     * @param aTopic   : The notification topic or subject.
     * @param someData : Notification specific wide string.
     */
    notifyObservers(aSubject: nsISupportsType, aTopic: string, someData: wstring): void;
    /**
     * enumerateObservers
     *
     * Returns an enumeration of all registered listeners.
     *
     * @param aTopic   : The notification topic or subject.
     */
    enumerateObservers(aTopic: string): nsISimpleEnumerator;
}

/**
 * nsIBrowsingContextReadyCallback.browsingContextReady() is called within
 * nsFrameLoader to indicate that the browsing context for a newly opened
 * window/tab is ready.
 */
declare interface nsIBrowsingContextReadyCallbackType extends nsISupportsType {
    /**
     *
     */
    browsingContextReady(bc: BrowsingContext): void;
}

/**
 * nsIOpenWindowInfo is a helper type which contains details used when opening
 * new content windows. This object is used to correctly create new initial
 * content documents when creating a new window.
 */
declare interface nsIOpenWindowInfoType extends nsISupportsType {
    /**
     * BrowsingContext which requested the creation of this new window
     */
    readonly parent: BrowsingContext;
    /**
     * If `true`, the content document should be created initially-remote
     */
    readonly isRemote: boolean;
    /**
     * Should |opener| be set on the newly-created content window?
     */
    readonly forceNoOpener: boolean;
    /**
     * Whether this is a window opened for printing
     */
    readonly isForPrinting: boolean;
    /**
     * Whether this is a window opened for window.print().
     * When this is true, isForPrinting is necessarily true as well.
     */
    readonly isForWindowDotPrint: boolean;
    /**
     * BrowserParent instance to use in the new window
     */
    getNextRemoteBrowser(): BrowserParent;
    /**
     * Origin Attributes for the to-be-created toplevel BrowsingContext
     */
    readonly originAttributes: jsval;
    /**
     *
     */
    binaryGetOriginAttributes(): const_OriginAttributes;
    /**
     * Callback to invoke when the browsing context for a new window is ready.
     */
    browsingContextReadyCallback(): nsIBrowsingContextReadyCallback;
}

/**
 * nsIOutputStream
 *
 * An interface describing a writable stream of data.  An output stream may be
 * "blocking" or "non-blocking" (see the IsNonBlocking method).  A blocking
 * output stream may suspend the calling thread in order to satisfy a call to
 * Close, Flush, Write, WriteFrom, or WriteSegments.  A non-blocking output
 * stream, on the other hand, must not block the calling thread of execution.
 *
 * NOTE: blocking output streams are often written to on a background thread to
 * avoid locking up the main application thread.  For this reason, it is
 * generally the case that a blocking output stream should be implemented using
 * thread- safe AddRef and Release.
 */
declare interface nsIOutputStreamType extends nsISupportsType {
    /**
     * Close the stream. Forces the output stream to flush any buffered data.
     * Any subsequent calls to StreamStatus should throw NS_BASE_STREAM_CLOSED.
     * Succeeds without effect if already closed.
     *
     * @throws NS_BASE_STREAM_WOULD_BLOCK if unable to flush without blocking
     * the calling thread (non-blocking mode only)
     */
    close(): void;
    /**
     * Flush the stream.
     *
     * @throws NS_BASE_STREAM_WOULD_BLOCK if unable to flush without blocking
     * the calling thread (non-blocking mode only)
     */
    flush(): void;
    /**
     * Check the current status of the stream.  A stream that is closed will
     * throw an exception when this method is called.  That enables the caller
     * to know the condition of the stream before attempting to write into it.
     *
     * This method will not throw NS_BASE_STREAM_WOULD_BLOCK, even if the stream
     * is a non-blocking stream with no available space. A non-blocking stream
     * which has not been closed, but has no available room should return NS_OK.
     *
     * NOTE: This method should not block the calling thread (e.g. to query the
     * state of a file descriptor), even when called on a blocking stream.
     *
     * @throws NS_BASE_STREAM_CLOSED if the stream closed normally
     * @throws <other-error> if the stream closed with a different status
     */
    streamStatus(): void;
    /**
     * Write data into the stream.
     *
     * @param aBuf the buffer containing the data to be written
     * @param aCount the maximum number of bytes to be written
     *
     * @return number of bytes written (may be less than aCount)
     *
     * @throws NS_BASE_STREAM_WOULD_BLOCK if writing to the output stream would
     * block the calling thread (non-blocking mode only)
     * @throws <other-error> on failure
     */
    write(aBuf: string, aCount: unsigned_long): unsigned_long;
    /**
     * Writes data into the stream from an input stream.
     *
     * @param aFromStream the stream containing the data to be written
     * @param aCount the maximum number of bytes to be written
     *
     * @return number of bytes written (may be less than aCount)
     *
     * @throws NS_BASE_STREAM_WOULD_BLOCK if writing to the output stream would
     * block the calling thread (non-blocking mode only). This failure
     * means no bytes were transferred.
     * @throws <other-error> on failure
     *
     * NOTE: This method is defined by this interface in order to allow the
     * output stream to efficiently copy the data from the input stream into
     * its internal buffer (if any). If this method was provided as an external
     * facility, a separate char* buffer would need to be used in order to call
     * the output stream's other Write method.
     */
    writeFrom(aFromStream: nsIInputStreamType, aCount: unsigned_long): unsigned_long;
    /**
     * @return true if stream is non-blocking
     *
     * NOTE: writing to a blocking output stream will block the calling thread
     * until all given data can be consumed by the stream.
     *
     * NOTE: a non-blocking output stream may implement nsIAsyncOutputStream to
     * provide consumers with a way to wait for the stream to accept more data
     * once its write method is unable to accept any data without blocking.
     */
    isNonBlocking(): boolean;
}

/**
 *
 */
declare interface nsIPK11TokenType extends nsISupportsType {
    /**
     * The name of the token
     */
    readonly tokenName: AUTF8String;
    /**
     *
     */
    readonly isInternalKeyToken: boolean;
    /**
     * Manufacturer ID of the token.
     */
    readonly tokenManID: AUTF8String;
    /**
     * Hardware version of the token.
     */
    readonly tokenHWVersion: AUTF8String;
    /**
     * Firmware version of the token.
     */
    readonly tokenFWVersion: AUTF8String;
    /**
     *
     */
    readonly tokenSerialNumber: AUTF8String;
    /**
     * Login information
     */
    isLoggedIn(): boolean;
    /**
     *
     */
    login(force: boolean): void;
    /**
     *
     */
    logoutSimple(): void;
    /**
     *
     */
    logoutAndDropAuthenticatedResources(): void;
    /**
     *
     */
    needsLogin(): boolean;
    /**
     *
     */
    readonly needsUserInit: boolean;
    /**
     * Reset password
     */
    reset(): void;
    /**
     * Checks whether the given password is correct. Logs the token out if an
     * incorrect password is given.
     *
     * @param password The password to check.
     * @return true if the password was correct, false otherwise.
     */
    checkPassword(password: AUTF8String): boolean;
    /**
     *
     */
    initPassword(initialPassword: AUTF8String): void;
    /**
     *
     */
    changePassword(oldPassword: AUTF8String, newPassword: AUTF8String): void;
    /**
     * True if a password has been configured for this token, and false otherwise.
     * (Whether or not the user is currently logged in makes no difference.)
     * In particular, this can be used to determine if a user has set a master
     * password (if this is the internal key token).
     */
    readonly hasPassword: boolean;
}

/**
 * nsIPK11TokenDB - Manages PK11 Tokens
 */
declare interface nsIPK11TokenDBType extends nsISupportsType {
    /**
     * Get the internal key database token
     */
    getInternalKeyToken(): nsIPK11Token;
}

/**
 *
 */
declare interface nsIPKCS11ModuleType extends nsISupportsType {
    /**
     *
     */
    readonly name: AUTF8String;
    /**
     *
     */
    readonly libName: AUTF8String;
    /**
     *
     */
    listSlots(): nsISimpleEnumerator;
}

/**
 *
 */
declare interface nsIPKCS11ModuleDBType extends nsISupportsType {
    /**
     *
     */
    deleteModule(moduleName: AString): void;
    /**
     *
     */
    addModule(moduleName: AString, libraryFullPath: AString, cryptoMechanismFlags: long, cipherFlags: long): void;
    /**
     *
     */
    listModules(): nsISimpleEnumerator;
    /**
     *
     */
    readonly canToggleFIPS: boolean;
    /**
     *
     */
    toggleFIPSMode(): void;
    /**
     *
     */
    readonly isFIPSEnabled: boolean;
}

/**
 *
 */
declare interface nsIPKCS11SlotType extends nsISupportsType {
    /**
     *
     */
    readonly name: AUTF8String;
    /**
     *
     */
    readonly desc: AUTF8String;
    /**
     * Manufacturer ID of the slot.
     */
    readonly manID: AUTF8String;
    /**
     * Hardware version of the slot.
     */
    readonly HWVersion: AUTF8String;
    /**
     * Firmware version of the slot.
     */
    readonly FWVersion: AUTF8String;
    /**
     *
     */
    readonly status: unsigned_long;
    /**
     * This is really a workaround for now.  All of the "slot" functions
     * (isTokenPresent(), etc.) are in nsIPK11Token.  For now, return the
     * token and handle those things there.
     */
    getToken(): nsIPK11Token;
    /**
     * more fun with workarounds - we're referring to everything by token name
     */
    readonly tokenName: AUTF8String;
}

/**
 * A service which returns information about file paths where the
 * screenshots for URLs are stored. These screenshots are used by the
 * moz-page-thumb protocol
 */
declare interface nsIPageThumbsStorageServiceType extends nsISupportsType {
    /**
     * Returns the leaf name of the file containing the screenshot for a given URL
     */
    getLeafNameForURL(aURL: AString): AString;
    /**
     * Returns the path where the thumbnails are stored
     */
    readonly path: AString;
    /**
     * Returns the full file path containing the screenshot for a given URL
     */
    getFilePathForURL(aURL: AString): AString;
}

/**
 *
 */
declare interface nsIPaperType extends nsISupportsType {
    /**
     * The internal name of the paper (a fixed, non-localized ID).
     * (For CUPS, this is the PWG-standardized name as used internally by CUPS;
     * on Windows, it is the integer paper ID as a string.)
     */
    readonly id: AString;
    /**
     * The human-readable (potentially localized) name of the paper.
     */
    readonly name: AString;
    /**
     * The width of the paper assuming portrait orientation, in points.
     * That is, the length of the shorter edges of the paper.
     */
    readonly width: double;
    /**
     * The height of the paper assuming portrait orientation, in points.
     * That is, the length of the longer edges of the paper.
     */
    readonly height: double;
    /**
     * The Promise resolves with an nsIPaperMargin object. The margin widths contained
     * in that object's top/bottom/left/right properties are relative to the paper in
     * portrait orientation. That is, top and bottom are the margins for the short edges,
     * and left and right are the margins for the long edges.
     */
    readonly unwriteableMargin: Promise;
}

/**
 *
 */
declare interface nsIPaperMarginType extends nsISupportsType {
    /**
     *
     */
    readonly top: double;
    /**
     *
     */
    readonly right: double;
    /**
     *
     */
    readonly bottom: double;
    /**
     *
     */
    readonly left: double;
}

/**
 * Implemented by chrome side of IPC protocols.
 */
declare interface nsIParentChannelType extends nsIStreamListenerType {
    /**
     * Called to invoke deletion of the IPC protocol.
     */
    delete(): void;
    /**
     * The remote type of the target process for this load.
     */
    readonly remoteType: AUTF8String;
}

/**
 *
 */
declare interface nsIAsyncVerifyRedirectReadyCallbackType extends nsISupportsType {
    /**
     * Asynchronous callback when redirected channel finishes the preparation for
     * completing the verification procedure.
     *
     * @param result
     * SUCCEEDED if preparation for redirection verification succceed.
     * If FAILED the redirection must be aborted.
     */
    readyToVerify(result: nsresult): void;
}

/**
 * Implemented by chrome side of IPC protocols that support redirect responses.
 */
declare interface nsIParentRedirectingChannelType extends nsIParentChannelType {
    /**
     * Called when the channel got a response that redirects it to a different
     * URI.  The implementation is responsible for calling the redirect observers
     * on the child process and provide the decision result to the callback.
     *
     * @param newURI
     * the URI we redirect to
     * @param callback
     * redirect result callback, usage is compatible with how
     * nsIChannelEventSink defines it
     */
    startRedirect(newChannel: nsIChannelType, redirectFlags: uint32_t, callback: nsIAsyncVerifyRedirectCallbackType): void;
    /**
     * Called to new channel when the original channel got Redirect2Verify
     * response from child. Callback will be invoked when the new channel
     * finishes the preparation for Redirect2Verify and can be called immediately.
     *
     * @param callback
     * redirect ready callback, will be called when redirect verification
     * procedure can proceed.
     */
    continueVerification(callback: nsIAsyncVerifyRedirectReadyCallbackType): void;
    /**
     * Called after we are done with redirecting process and we know if to
     * redirect or not.  Forward the redirect result to the child process.  From
     * that moment the nsIParentChannel implementation expects it will be
     * forwarded all notifications from the 'real' channel.
     *
     * Primarilly used by HttpChannelParent::OnRedirectResult and kept as
     * mActiveChannel and mRedirectChannel in that class.
     */
    completeRedirect(succeeded: nsresult): void;
}

/**
 *
 */
declare interface nsIParentalControlsServiceType extends nsISupportsType {
    /**
     * @returns true if the current user account has parental controls
     * restrictions enabled.
     */
    readonly parentalControlsEnabled: boolean;
    /**
     * @returns true if the current user account parental controls
     * restrictions include the blocking of all file downloads.
     */
    readonly blockFileDownloadsEnabled: boolean;
    /**
     * Check if the user can do the prescibed action for this uri.
     *
     * @param aAction             Action being performed
     * @param aUri                The uri requesting this action
     * @param aWindow             The window generating this event.
     */
    isAllowed(aAction: short, aUri: nsIURIType): boolean;
    /**
     * @returns true if the current user account has parental controls
     * logging enabled. If true, applications should log relevent events
     * using 'log'.
     */
    readonly loggingEnabled: boolean;
    /**
     * File downloads
     *
     * Log an application specific parental controls
     * event.
     *
     * @param aEntryType       Constant defining the type of event.
     * @param aFlag            A flag indicating if the subject content
     * was blocked.
     * @param aSource          The URI source of the subject content.
     * @param aTarget          The location the content was saved to if
     * no blocking occurred.
     */
    log(aEntryType: short, aFlag: boolean, aSource: nsIURIType, aTarget: nsIFileType): void;
}

/**
 * Non-Web HTML parser functionality to Firefox extensions and XULRunner apps.
 * Don't use this from within Gecko--use nsContentUtils, nsTreeSanitizer, etc.
 * directly instead.
 */
declare interface nsIParserUtilsType extends nsISupportsType {
    /**
     * Parses a string into an HTML document, sanitizes the document and
     * returns the result serialized to a string.
     *
     * The sanitizer is designed to protect against XSS when sanitized content
     * is inserted into a different-origin context without an iframe-equivalent
     * sandboxing mechanism.
     *
     * By default, the sanitizer doesn't try to avoid leaking information that
     * the content was viewed to third parties. That is, by default, e.g.
     * <img src> pointing to an HTTP server potentially controlled by a third
     * party is not removed. To avoid ambient information leakage upon loading
     * the sanitized content, use the SanitizerInternalEmbedsOnly flag. In that
     * case, <a href> links (and similar) to other content are preserved, so an
     * explicit user action (following a link) after the content has been loaded
     * can still leak information.
     *
     * By default, non-dangerous non-CSS presentational HTML elements and
     * attributes or forms are not removed. To remove these, use
     * SanitizerDropNonCSSPresentation and/or SanitizerDropForms.
     *
     * By default, comments and CSS is removed. To preserve comments, use
     * SanitizerAllowComments. To preserve <style> and style="", use
     * SanitizerAllowStyle. -moz-binding is removed from <style> and style="" if
     * present. In this case, properties that Gecko doesn't recognize can get
     * removed as a side effect. Note! If -moz-binding is not present, <style>
     * and style="" and SanitizerAllowStyle is specified, the sanitized content
     * may still be XSS dangerous if loaded into a non-Gecko Web engine!
     *
     * @param src the HTML source to parse (C++ callers are allowed but not
     * required to use the same string for the return value.)
     * @param flags sanitization option flags defined above
     */
    sanitize(src: AString, flags: unsigned_long): AString;
    /**
     * Removes conditional CSS (@media / etc) from the input string.
     */
    removeConditionalCSS(src: AString): AString;
    /**
     * Convert HTML to plain text.
     *
     * @param src the HTML source to parse (C++ callers are allowed but not
     * required to use the same string for the return value.)
     * @param flags conversion option flags defined in nsIDocumentEncoder
     * @param wrapCol number of characters per line; 0 for no auto-wrapping
     */
    convertToPlainText(src: AString, flags: unsigned_long, wrapCol: unsigned_long): AString;
    /**
     * Parses markup into a sanitized document fragment.
     *
     * @param fragment the input markup
     * @param flags sanitization option flags defined above
     * @param isXML true if |fragment| is XML and false if HTML
     * @param baseURI the base URL for this fragment
     * @param element the context node for the fragment parsing algorithm
     */
    parseFragment(fragment: AString, flags: unsigned_long, isXML: boolean, baseURI: nsIURIType, element: Element): DocumentFragment;
}

/**
 * Observer for exception list updates.
 */
declare interface nsIPartitioningExceptionListObserverType extends nsISupportsType {
    /**
     * Called by nsIPartitioningExceptionListService when the exception list
     * changes and when the observer is first registered.
     *
     * @param aList
     * A semicolon-separated list of comma-separated url pairs.
     */
    onExceptionListUpdate(aList: ACString): void;
}

/**
 * A service that monitors updates to the exception list of partitioning
 * from sources such as a local pref and remote settings updates.
 */
declare interface nsIPartitioningExceptionListServiceType extends nsISupportsType {
    /**
     * Register a new observer to exception list updates. When the observer is
     * registered it is called immediately once. Afterwards it will be called
     * whenever the specified pref changes or when remote settings for
     * partitioning updates.
     *
     * @param aObserver
     * An nsIPartitioningExceptionListObserver object or function that
     * will receive updates to the exception list as a comma-separated
     * string. Will be called immediately with the current exception
     * list value.
     */
    registerAndRunExceptionListObserver(aObserver: nsIPartitioningExceptionListObserverType): void;
    /**
     * Unregister an observer.
     *
     * @param aObserver
     * The nsIPartitioningExceptionListObserver object to unregister.
     */
    unregisterExceptionListObserver(aObserver: nsIPartitioningExceptionListObserverType): void;
}

/**
 * The base interface of response data for the specified payment method.
 * The response data is the content of the PaymentResponse's detail attribute.
 */
declare interface nsIPaymentResponseDataType extends nsISupportsType {
    /**
     * The response data type.
     * Using the above defined consts(GENERAL_RESPONSE or BASICCARD_RESPONSE).
     */
    readonly type: uint32_t;
    /**
     * The initial method.
     * @param aType - the response data type.
     */
    init(aType: uint32_t): void;
}

/**
 * The general purpose response data.
 */
declare interface nsIGeneralResponseDataType extends nsIPaymentResponseDataType {
    /**
     * The stringified response data.
     */
    readonly data: AString;
    /**
     * The initial method for nsIGeneralResponseData.
     * @param aData - the javascript object of the content.
     */
    initData(aData: jsval): void;
}

/**
 * The basic card response data.
 * Since PaymentAddress is an no constructor interface type, UI code can not
 * easy create PaymentAddress by calling new PaymentAddress().
 * Unfortunately, BasicCardResponse has a PaymentAddress attribute, billingAddress
 * , it means UI can not create BsaicCardResponse by calling the init() with a
 * given JSObject directly, because PaymentAddress creation in JS code is hard.
 * To let UI code can create BasicCardResponse easier, nsIBasicCardResponse is
 * provided for UI by passing the raw data of BasicCardResponse,
 */
declare interface nsIBasicCardResponseDataType extends nsIPaymentResponseDataType {
    /**
     * The cardholder name.
     */
    readonly cardholderName: AString;
    /**
     * The card number.
     */
    readonly cardNumber: AString;
    /**
     * The expiry month.
     */
    readonly expiryMonth: AString;
    /**
     * The expiry year.
     */
    readonly expiryYear: AString;
    /**
     * The card security number.
     */
    readonly cardSecurityCode: AString;
    /**
     * The billing address.
     */
    readonly billingAddress: nsIPaymentAddress;
    /**
     * The initial method for nsIBasicCardResponseData.
     * @param aCardholderName   - the cardholder name.
     * @param aCardNumber       - the card number.
     * @param aExpiryMonth      - the expiry month.
     * @param aExpiryYear       - the expiry year.
     * @param aCardSecurityCode - the card security code.
     * @param aBillingAddreess  - the billing address.
     */
    initData(aCardholderName: AString, aCardNumber: AString, aExpiryMonth: AString, aExpiryYear: AString, aCardSecurityCode: AString, billingAddress: nsIPaymentAddressType): void;
}

/**
 * The base interface of user's response.
 * Payment UI should create different sub-interface of nsIPaymentActionResponse
 * according to user's action, and call nsIPaymentRequestService::respondPayment
 * with the created action to inform the merchant.
 */
declare interface nsIPaymentActionResponseType extends nsISupportsType {
    /**
     * The payment request identity.
     */
    readonly requestId: AString;
    /**
     * The response type.
     */
    readonly type: uint32_t;
}

/**
 * The response for canMakePayment action.
 */
declare interface nsIPaymentCanMakeActionResponseType extends nsIPaymentActionResponseType {
    /**
     * The result of canMakePayment action.
     */
    readonly result: bool;
    /**
     * The initial method.
     * @param aRequestId - the request identifier of the payment request.
     * @param aResult - the canMakePayment result.
     */
    init(aRequestId: AString, aResult: bool): void;
}

/**
 * The response for show action.
 * Notice that to represent user's cancel, we should use nsIPaymentShowActionResponse
 * with PAYMENT_REJECTED status, not nsIPaymentAbortActionResponse.
 */
declare interface nsIPaymentShowActionResponseType extends nsIPaymentActionResponseType {
    /**
     * Accept status of the payment.
     * Using the defined consts(PAYMENT_XXX) in nsIPaymentActionResponse.
     */
    readonly acceptStatus: uint32_t;
    /**
     * The decided payment method name. i.e. "basic-card".
     */
    readonly methodName: AString;
    /**
     * The data needed by the payment method. (it must be serializable)
     */
    readonly data: nsIPaymentResponseData;
    /**
     * The payer name information.
     */
    readonly payerName: AString;
    /**
     * The payer email information.
     */
    readonly payerEmail: AString;
    /**
     * The payer phone information.
     */
    readonly payerPhone: AString;
    /**
     * The initial method.
     * @param aRequestId - the request identifier of the payment request.
     * @param aAcceptStatus - the payment status.
     * @param aMethodName - the decided method name.
     * @param aData - the response data for the decided payment method.
     * @param aPayerName - the payer's name.
     * @param aPayerEmail - the payer's email.
     * @param aPayerPhone - the payer's phone.
     */
    init(aRequestId: AString, aAcceptStatus: uint32_t, aMethodName: AString, aData: nsIPaymentResponseDataType, aPayerName: AString, aPayerEmail: AString, aPayerPhone: AString): void;
}

/**
 * The response for abort action.
 */
declare interface nsIPaymentAbortActionResponseType extends nsIPaymentActionResponseType {
    /**
     * The abort action status.
     * Using the defined consts(ABORT_XXX) in nsIPaymentActionResponse.
     */
    readonly abortStatus: uint32_t;
    /**
     * The Initial method.
     * @param aRequestId - the request identifier of payment request.
     * @param aAbortStatus - the abort action result.
     */
    init(aRequestId: AString, aAbortStatus: uint32_t): void;
    /**
     * Check if the abort action is succeeded
     */
    isSucceeded(): bool;
}

/**
 *
 */
declare interface nsIPaymentCompleteActionResponseType extends nsIPaymentActionResponseType {
    /**
     * The complete action status.
     * Using the defined consts(COMPLETE_XXX) in nsIPaymentActionResponse.
     */
    readonly completeStatus: uint32_t;
    /**
     * The Initial method.
     * @param aRequestId - the request identifier of payment request.
     * @param aCompleteStatus - the complete action result.
     */
    init(aRequestId: AString, aCompleteStatus: uint32_t): void;
    /**
     * Check if the complete action is succeeded.
     */
    isCompleted(): bool;
}

/**
 *
 */
declare interface nsIMethodChangeDetailsType extends nsISupportsType {
    /**
     * The method change details data type.
     * Using the above defined consts(GENERAL_DETAILS or BASICCARD_DETAILS).
     */
    readonly type: uint32_t;
    /**
     * The initial method.
     * @param aType - the method change details data type.
     */
    init(aType: uint32_t): void;
}

/**
 * The general purpose method change details.
 */
declare interface nsIGeneralChangeDetailsType extends nsIMethodChangeDetailsType {
    /**
     * The stringified change details.
     */
    readonly details: AString;
    /**
     * The initial method for nsIGeneralChangeDetails.
     * @param aData - the javascript object of the content.
     */
    initData(aDetails: jsval): void;
}

/**
 * The basic card change details.
 * Since PaymentAddress is an no constructor interface type, UI code can not
 * easy create PaymentAddress by calling new PaymentAddress().
 * Unfortunately, BasicCardResponse has a PaymentAddress attribute, billingAddress
 * , it means UI can not create BsaicCardChangeDetails by calling the init() with a
 * given JSObject directly, because PaymentAddress creation in JS code is hard.
 * To let UI code can create BasicCardResponse easier, nsIBasicCardResponse is
 * provided for UI by passing the raw data of BasicCardResponse,
 */
declare interface nsIBasicCardChangeDetailsType extends nsIMethodChangeDetailsType {
    /**
     * The billing address.
     */
    readonly billingAddress: nsIPaymentAddress;
    /**
     * The initial method for nsIBasicCardChangeDetails.
     * @param aBillingAddreess  - the billing address.
     */
    initData(billingAddress: nsIPaymentAddressType): void;
}

/**
 *
 */
declare interface nsIPaymentAddressType extends nsISupportsType {
    /**
     *
     */
    readonly country: AString;
    /**
     *
     */
    readonly addressLine: nsIArray;
    /**
     *
     */
    readonly region: AString;
    /**
     *
     */
    readonly regionCode: AString;
    /**
     *
     */
    readonly city: AString;
    /**
     *
     */
    readonly dependentLocality: AString;
    /**
     *
     */
    readonly postalCode: AString;
    /**
     *
     */
    readonly sortingCode: AString;
    /**
     *
     */
    readonly organization: AString;
    /**
     *
     */
    readonly recipient: AString;
    /**
     *
     */
    readonly phone: AString;
    /**
     *
     */
    init(aCountry: AString, aAddressLine: nsIArrayType, aRegion: AString, aRegionCode: AString, aCity: AString, aDependentLocality: AString, aPostalCode: AString, aSortingCode: AString, aOrganization: AString, aRecipient: AString, aPhone: AString): void;
}

/**
 *
 */
declare interface nsIPaymentMethodDataType extends nsISupportsType {
    /**
     *
     */
    readonly supportedMethods: AString;
    /**
     *
     */
    readonly data: jsval;
}

/**
 *
 */
declare interface nsIPaymentCurrencyAmountType extends nsISupportsType {
    /**
     *
     */
    readonly currency: AString;
    /**
     *
     */
    readonly value: AString;
}

/**
 *
 */
declare interface nsIPaymentItemType extends nsISupportsType {
    /**
     *
     */
    readonly label: AString;
    /**
     *
     */
    readonly amount: nsIPaymentCurrencyAmount;
    /**
     *
     */
    readonly pending: boolean;
}

/**
 *
 */
declare interface nsIPaymentDetailsModifierType extends nsISupportsType {
    /**
     *
     */
    readonly supportedMethods: AString;
    /**
     *
     */
    readonly total: nsIPaymentItem;
    /**
     *
     */
    readonly additionalDisplayItems: nsIArray;
    /**
     *
     */
    readonly data: jsval;
}

/**
 *
 */
declare interface nsIPaymentShippingOptionType extends nsISupportsType {
    /**
     *
     */
    readonly id: AString;
    /**
     *
     */
    readonly label: AString;
    /**
     *
     */
    readonly amount: nsIPaymentCurrencyAmount;
    /**
     *
     */
    selected: boolean;
}

/**
 *
 */
declare interface nsIPaymentDetailsType extends nsISupportsType {
    /**
     *
     */
    readonly id: AString;
    /**
     *
     */
    readonly totalItem: nsIPaymentItem;
    /**
     *
     */
    readonly displayItems: nsIArray;
    /**
     *
     */
    readonly shippingOptions: nsIArray;
    /**
     *
     */
    readonly modifiers: nsIArray;
    /**
     *
     */
    readonly error: AString;
    /**
     *
     */
    readonly shippingAddressErrors: jsval;
    /**
     *
     */
    readonly payerErrors: jsval;
    /**
     *
     */
    readonly paymentMethodErrors: jsval;
}

/**
 *
 */
declare interface nsIPaymentOptionsType extends nsISupportsType {
    /**
     *
     */
    readonly requestPayerName: boolean;
    /**
     *
     */
    readonly requestPayerEmail: boolean;
    /**
     *
     */
    readonly requestPayerPhone: boolean;
    /**
     *
     */
    readonly requestShipping: boolean;
    /**
     *
     */
    readonly requestBillingAddress: boolean;
    /**
     *
     */
    readonly shippingType: AString;
}

/**
 *
 */
declare interface nsIPaymentRequestType extends nsISupportsType {
    /**
     *
     */
    readonly topOuterWindowId: uint64_t;
    /**
     *
     */
    readonly topLevelPrincipal: nsIPrincipal;
    /**
     *
     */
    readonly requestId: AString;
    /**
     *
     */
    readonly completeStatus: AString;
    /**
     *
     */
    readonly paymentMethods: nsIArray;
    /**
     *
     */
    readonly paymentDetails: nsIPaymentDetails;
    /**
     *
     */
    readonly paymentOptions: nsIPaymentOptions;
    /**
     *
     */
    readonly shippingOption: AString;
}

/**
 * nsPaymentRequestService is used to manage the created PaymentRequest in the
 * chrome process. It is also the IPC agent for payment UI to communicate with
 * merchant side.
 */
declare interface nsIPaymentRequestServiceType extends nsISupportsType {
    /**
     * Get the nsIPaymentRequest through the given payment request identifier.
     * @param aRequestId - the payment request identifier.
     * This is an internal id generated by Gecko.
     * @return           - the requested payment request. null if there is no
     * coressponding nsIPaymentRequest for aRequestId.
     */
    getPaymentRequestById(aRequestId: AString): nsIPaymentRequest;
    /**
     * Get the enumerator for all managed nsIPaymentRequests.
     * @return - an enumerator for all managed nsIPaymentRequests.
     */
    enumerate(): nsISimpleEnumerator;
    /**
     * Send the user's response to the merchant.
     * @param aResponse - the user's response.
     */
    respondPayment(aResponse: nsIPaymentActionResponseType): void;
    /**
     * Inform the merchant the shipping address has changed.
     * @param requestId - the request identifier of the payment request.
     * @param aAddress - the new payment address.
     */
    changeShippingAddress(requestId: AString, aAddress: nsIPaymentAddressType): void;
    /**
     * Inform the merchant the shipping option has changed.
     * @param requestId - the request identifier of the payment request.
     * @param option - the shipping option ID string.
     */
    changeShippingOption(requestId: AString, option: AString): void;
    /**
     * Inform the merchant the payer's details changed in the PaymentResponse.
     * @param requestId - the request identifier of the payment request.
     * @param aPayerName - the changed payer's name.
     * @param aPayerEmail - the changed payer's email.
     * @param aPayerPhone - the changed payer's phone.
     */
    changePayerDetail(requestId: AString, aPayerName: AString, aPayerEmail: AString, aPayerPhone: AString): void;
    /**
     * Inform the merchant the payment method has changed.
     * @param requestId - the request identifier of the payment request.
     * @param aMethodName - the changed payment method's name.
     * @param aMethodDetails - the changed payment method's details.
     */
    changePaymentMethod(requestId: AString, aMethodName: AString, aMethodDetails: nsIMethodChangeDetailsType): void;
    /**
     * Following APIs are for testing or platform code only. UI implementation
     * should not use them.
     *
     * Clean up the all managed payment requests.
     * This API is for testing only.
     */
    cleanup(): void;
    /**
     * Setup the customized nsIPaymentUIService.
     * This API is for testing only.
     */
    setTestingUIService(aUIService: nsIPaymentUIServiceType): void;
}

/**
 * nsIPaymentUIService is the interface used by Gecko to communicate with the
 * payment UI.
 * In general, the implementation of this interface should be a service that
 * manages all payment UI components and receives the requested payment actions
 * from Gecko and perform the corresponding UI behavior.
 */
declare interface nsIPaymentUIServiceType extends nsISupportsType {
    /**
     * Show the payment UI to users.
     * The implementation gets the payment data through nsIPaymentRequestService
     * by the passed in requestId, then shows the payment UI and start to interact
     * with users.
     * According to user's action, nsIPaymentRequestService's APIs respondPayment,
     * changeShippingAddress, or changeShippingOtpion is possible to called in the
     * implementation.
     * @param requestId - the request identify of the payment request.
     * Notice that this requestId is an internal request Id
     * generated by Gecko
     */
    showPayment(requestId: AString): void;
    /**
     * Abort the payment.
     * The implementation must abort and close the showing payment UI then call
     * nsIPaymentRequestService respondPayment with nsIPaymentAbortActionResponse
     * to inform Gecko of the abort status.
     * @param requestId - the request identify of the payment request.
     * Notice that this requestId is an internal request Id
     * generated by Gecko
     */
    abortPayment(requestId: AString): void;
    /**
     * Complete the payment.
     * The implementation should close the showing payment UI, then call
     * nsIPaymentRequestService respondPayment with nsIPaymentCompleteActionResponse
     * to inform Gecko of the complete status.
     * @param requestId - the request identify of the payment request.
     * Notice that this requestId is an internal request Id
     * generated by Gecko
     */
    completePayment(requestId: AString): void;
    /**
     * Update the payment data in the payment UI.
     * The implementation should get the updated payment data through the
     * nsIPaymentRequestService again, and update the UI.
     * @param requestId - the request identify of the payment request.
     * Notice that this requestId is an internal request Id
     * generated by Gecko
     */
    updatePayment(requestId: AString): void;
    /**
     * Close the payment UI for the specified PaymentRequest.
     * The implementation should clean up the PaymentRequest data saved in the UI
     * component and close the UI if the specified PaymentRequest is showing to
     * the user.
     * Notice when the method is called, that means the PaymentRequest is invalid
     * in nsIPaymentRequestService.
     * @param requestId - the request identify of the payment request.
     * Notice that this requestId is an internal request Id
     * generated by Gecko
     */
    closePayment(requestId: AString): void;
}

/**
 * This interface defines a "permission" object,
 * used to specify allowed/blocked objects from
 * user-specified sites (cookies, images etc).
 */
declare interface nsIPermissionType extends nsISupportsType {
    /**
     * The principal for which this permission applies.
     */
    readonly principal: nsIPrincipal;
    /**
     * a case-sensitive ASCII string, indicating the type of permission
     * (e.g., "cookie", "image", etc).
     * This string is specified by the consumer when adding a permission
     * via nsIPermissionManager.
     * @see nsIPermissionManager
     */
    readonly type: ACString;
    /**
     * The permission (see nsIPermissionManager.idl for allowed values)
     */
    readonly capability: uint32_t;
    /**
     * The expiration type of the permission (session, time-based or none).
     * Constants are EXPIRE_*, defined in nsIPermissionManager.
     * @see nsIPermissionManager
     */
    readonly expireType: uint32_t;
    /**
     * The expiration time of the permission (milliseconds since Jan 1 1970
     * 0:00:00).
     */
    readonly expireTime: int64_t;
    /**
     * The last modification time of the permission (milliseconds since Jan 1 1970
     * 0:00:00).
     */
    readonly modificationTime: int64_t;
    /**
     * Test whether a principal would be affected by this permission.
     *
     * @param principal  the principal to test
     * @param exactHost  If true, only the specific host will be matched,
     * @see nsIPermissionManager::testExactPermission.
     * If false, subdomains will also be searched,
     * @see nsIPermissionManager::testPermission.
     */
    matches(principal: nsIPrincipalType, exactHost: boolean): boolean;
    /**
     * Test whether a URI would be affected by this permission.
     * NOTE: This performs matches with default origin attribute values.
     *
     * @param uri        the uri to test
     * @param exactHost  If true, only the specific host will be matched,
     * @see nsIPermissionManager::testExactPermission.
     * If false, subdomains will also be searched,
     * @see nsIPermissionManager::testPermission.
     */
    matchesURI(uri: nsIURIType, exactHost: boolean): boolean;
}

/**
 *
 */
declare interface nsIPermissionDelegateHandlerType extends nsISupportsType {
    /**
     * Return true if we are delegating permission to a third party which is not
     * explicitly trusted. An orgin is not explicitly trusted means it is not
     * presented in the Feature Policy ancestor chain, via src, explicitly listed
     * in allow, and it is not the top-level origin.
     *
     * @param aTypes the permission types to check
     */
    maybeUnsafePermissionDelegate(aTypes: invalid): boolean;
}

/**
 *
 */
declare interface nsIPermissionManagerType extends nsISupportsType {
    /**
     * Add permission information for a given principal.
     * It is internally calling the other add() method using the nsIURI from the
     * principal.
     * Passing a system principal will be a no-op because they will always be
     * granted permissions.
     */
    addFromPrincipal(principal: nsIPrincipalType, type: ACString, permission: uint32_t, expireType: uint32_t, expireTime: int64_t): void;
    /**
     * Add permanent permission information for a given principal in private
     * browsing.
     *
     * Normally permissions in private browsing are cleared at the end of the
     * session, this method allows you to override this behavior and set
     * permanent permissions.
     *
     * WARNING: setting permanent permissions _will_ leak data in private
     * browsing. Only use if you understand the consequences and trade-offs. If
     * you are unsure, |addFromPrincipal| is very likely what you want to use
     * instead.
     */
    addFromPrincipalAndPersistInPrivateBrowsing(principal: nsIPrincipalType, type: ACString, permission: uint32_t): void;
    /**
     * Remove permission information for a given principal.
     * This is internally calling remove() with the host from the principal's URI.
     * Passing system principal will be a no-op because we never add them to the
     * database.
     */
    removeFromPrincipal(principal: nsIPrincipalType, type: ACString): void;
    /**
     * Remove the given permission from the permission manager.
     *
     * @param perm   a permission obtained from the permission manager.
     */
    removePermission(perm: nsIPermissionType): void;
    /**
     * Clear permission information for all websites.
     */
    removeAll(): void;
    /**
     * Clear all permission information added since the specified time.
     */
    removeAllSince(since: int64_t): void;
    /**
     * Clear all permissions of the passed type.
     */
    removeByType(type: ACString): void;
    /**
     * Clear all permissions of the passed type added since the specified time.
     * @param type    a case-sensitive ASCII string, identifying the permission.
     * @param since   a unix timestamp representing the number of milliseconds from
     * Jan 1, 1970 00:00:00 UTC.
     */
    removeByTypeSince(type: ACString, since: int64_t): void;
    /**
     * Test whether the principal has the permission to perform a given action.
     * System principals will always have permissions granted.
     * This function will perform a pref lookup to permissions.default.<type>
     * if the specific permission type is part of the whitelist for that functionality.
     */
    testPermissionFromPrincipal(principal: nsIPrincipalType, type: ACString): uint32_t;
    /**
     * Test whether the principal has the permission to perform a given action.
     * This requires an exact hostname match. Subdomain principals do not match
     * permissions of base domains.
     * System principals will always have permissions granted.
     * This function will perform a pref lookup to permissions.default.<type>
     * if the specific permission type is part of the whitelist for that functionality.
     */
    testExactPermissionFromPrincipal(principal: nsIPrincipalType, type: ACString): uint32_t;
    /**
     * Test whether a website has permission to perform the given action
     * ignoring active sessions.
     * System principals will always have permissions granted.
     * This function will perform a pref lookup to permissions.default.<type>
     * if the specific permission type is part of the whitelist for that functionality.
     *
     * @param principal the principal
     * @param type      a case-sensitive ASCII string, identifying the consumer
     * @param return    see add(), param permission. returns UNKNOWN_ACTION when
     * there is no stored permission for this uri and / or type.
     */
    testExactPermanentPermission(principal: nsIPrincipalType, type: ACString): uint32_t;
    /**
     * Get the permission object associated with the given principal and action.
     * @param principal The principal
     * @param type      A case-sensitive ASCII string identifying the consumer
     * @param exactHost If true, only the specific host will be matched.
     * If false, base domains of the principal will also
     * be searched.
     * @returns The matching permission object, or null if no matching object
     * was found. No matching object is equivalent to UNKNOWN_ACTION.
     * @note Clients in general should prefer the test* methods unless they
     * need to know the specific stored details.
     * @note This method will always return null for the system principal.
     */
    getPermissionObject(principal: nsIPrincipalType, type: ACString, exactHost: boolean): nsIPermission;
    /**
     * Remove all permissions that will match the origin pattern.
     */
    removePermissionsWithAttributes(patternAsJSON: AString): void;
}

/**
 *
 */
declare interface nsIPropertyElementType extends nsISupportsType {
    /**
     *
     */
    key: AUTF8String;
    /**
     *
     */
    value: AString;
}

/**
 *
 */
declare interface nsIPersistentPropertiesType extends nsIPropertiesType {
    /**
     * load a set of name/value pairs from the input stream
     * names and values should be in UTF8
     */
    load(input: nsIInputStreamType): void;
    /**
     * output the values to the stream - results will be in UTF8
     */
    save(output: nsIOutputStreamType, header: AUTF8String): void;
    /**
     * get an enumeration of nsIPropertyElement objects,
     * which are read-only (i.e. setting properties on the element will
     * not make changes back into the source nsIPersistentProperties
     */
    enumerate(): nsISimpleEnumerator;
    /**
     * shortcut to nsIProperty's get() which retrieves a string value
     * directly (and thus faster)
     */
    getStringProperty(key: AUTF8String): AString;
    /**
     * shortcut to nsIProperty's set() which sets a string value
     * directly (and thus faster). If the given property already exists,
     * then the old value will be returned
     */
    setStringProperty(key: AUTF8String, value: AString): AString;
    /**
     *
     */
    sizeOfIncludingThis(aMallocSizeOf: MallocSizeOf): size_t;
}

/**
 * nsIPipe represents an in-process buffer that can be read using nsIInputStream
 * and written using nsIOutputStream.  The reader and writer of a pipe do not
 * have to be on the same thread.  As a result, the pipe is an ideal mechanism
 * to bridge data exchange between two threads.  For example, a worker thread
 * might write data to a pipe from which the main thread will read.
 *
 * Each end of the pipe can be either blocking or non-blocking.  Recall that a
 * non-blocking stream will return NS_BASE_STREAM_WOULD_BLOCK if it cannot be
 * read or written to without blocking the calling thread.  For example, if you
 * try to read from an empty pipe that has not yet been closed, then if that
 * pipe's input end is non-blocking, then the read call will fail immediately
 * with NS_BASE_STREAM_WOULD_BLOCK as the error condition.  However, if that
 * pipe's input end is blocking, then the read call will not return until the
 * pipe has data or until the pipe is closed.  This example presumes that the
 * pipe is being filled asynchronously on some background thread.
 *
 * The pipe supports nsIAsyncInputStream and nsIAsyncOutputStream, which give
 * the user of a non-blocking pipe the ability to wait for the pipe to become
 * ready again.  For example, in the case of an empty non-blocking pipe, the
 * user can call AsyncWait on the input end of the pipe to be notified when
 * the pipe has data to read (or when the pipe becomes closed).
 *
 * NS_NewPipe2 and NS_NewPipe provide convenient pipe constructors.  In most
 * cases nsIPipe is not actually used.  It is usually enough to just get
 * references to the pipe's input and output end.  In which case, the pipe is
 * automatically closed when the respective pipe ends are released.
 */
declare interface nsIPipeType extends nsISupportsType {
    /**
     * initialize this pipe
     *
     * @param nonBlockingInput
     * true specifies non-blocking input stream behavior
     * @param nonBlockingOutput
     * true specifies non-blocking output stream behavior
     * @param segmentSize
     * specifies the segment size in bytes (pass 0 to use default value)
     * @param segmentCount
     * specifies the max number of segments (pass 0 to use default
     * value).   Passing UINT32_MAX here causes the pipe to have
     * "infinite" space.  This mode can be useful in some cases, but
     * should always be used with caution.  The default value for this
     * parameter is a finite value.
     */
    init(nonBlockingInput: boolean, nonBlockingOutput: boolean, segmentSize: unsigned_long, segmentCount: unsigned_long): void;
    /**
     * The pipe's input end, which also implements nsISearchableInputStream.
     * Getting fails if the pipe hasn't been initialized.
     */
    readonly inputStream: nsIAsyncInputStream;
    /**
     * The pipe's output end. Getting fails if the pipe hasn't been
     * initialized.
     */
    readonly outputStream: nsIAsyncOutputStream;
}

/**
 * XXX this interface doesn't really belong in here.  It is here because
 * currently nsPipeInputStream is the only implementation of this interface.
 */
declare interface nsISearchableInputStreamType extends nsISupportsType {
    /**
     * Searches for a string in the input stream. Since the stream has a notion
     * of EOF, it is possible that the string may at some time be in the
     * buffer, but is is not currently found up to some offset. Consequently,
     * both the found and not found cases return an offset:
     * if found, return offset where it was found
     * if not found, return offset of the first byte not searched
     * In the case the stream is at EOF and the string is not found, the first
     * byte not searched will correspond to the length of the buffer.
     */
    search(forString: string, ignoreCase: boolean, found: boolean, offsetSearchedTo: unsigned_long): void;
}

/**
 * A service which returns information about file paths where the
 * previews for URLs are stored. These previews are used by the
 * moz-page-thumb protocol
 */
declare interface nsIPlacesPreviewsHelperServiceType extends nsISupportsType {
    /**
     * Returns the full file path containing the screenshot for a given URL
     */
    getFilePathForURL(aURL: AString): AString;
}

/**
 *
 */
declare interface nsIPlatformInfoType extends nsISupportsType {
    /**
     * The version of the XULRunner platform.
     */
    readonly platformVersion: ACString;
    /**
     * The build ID/date of gecko and the XULRunner platform.
     */
    readonly platformBuildID: ACString;
}

/**
 *
 */
declare interface nsIPluginTagType extends nsISupportsType {
    /**
     *
     */
    readonly description: AUTF8String;
    /**
     *
     */
    readonly filename: AUTF8String;
    /**
     *
     */
    readonly fullpath: AUTF8String;
    /**
     *
     */
    readonly version: AUTF8String;
    /**
     *
     */
    readonly name: AUTF8String;
    /**
     *
     */
    readonly niceName: AUTF8String;
    /**
     * true only if this plugin is "hardblocked" and cannot be enabled.
     */
    readonly blocklisted: boolean;
    /**
     * true if the state is non-default and locked, false otherwise.
     */
    readonly isEnabledStateLocked: boolean;
    /**
     *
     */
    readonly active: boolean;
    /**
     *
     */
    readonly blocklistState: unsigned_long;
    /**
     *
     */
    readonly disabled: boolean;
    /**
     *
     */
    readonly clicktoplay: boolean;
    /**
     *
     */
    readonly loaded: boolean;
    /**
     *
     */
    enabledState: unsigned_long;
    /**
     *
     */
    readonly lastModifiedTime: PRTime;
    /**
     *
     */
    readonly isFlashPlugin: boolean;
    /**
     * An id for this plugin. 0 is a valid id.
     */
    readonly id: unsigned_long;
}

/**
 * An interface representing a "fake" plugin: one implemented in JavaScript, not
 * as a NPAPI plug-in.  See nsIPluginHost.registerFakePlugin and the
 * documentation for the FakePluginTagInit dictionary.
 */
declare interface nsIFakePluginTagType extends nsIPluginTagType {
    /**
     * The URI that should be loaded into the tag (as a frame) to handle the
     * plugin. Note that the original data/src value for the plugin is not loaded
     * and will need to be requested by the handler via XHR or similar if desired.
     */
    readonly handlerURI: nsIURI;
    /**
     * Optional script to run in a sandbox when instantiating a plugin. If this
     * value is an empty string then no such script will be run.
     * The script runs in a sandbox with system principal in the process that
     * contains the element that instantiates the plugin (ie the EMBED or OBJECT
     * element). The sandbox global has a 'pluginElement' property that the script
     * can use to access the element that instantiates the plugin.
     */
    readonly sandboxScript: AString;
}

/**
 * For use with non-content code.
 */
declare interface nsIPowerManagerServiceType extends nsISupportsType {
    /**
     *
     */
    addWakeLockListener(aListener: nsIDOMMozWakeLockListenerType): void;
    /**
     *
     */
    removeWakeLockListener(aListener: nsIDOMMozWakeLockListenerType): void;
    /**
     *
     */
    getWakeLockState(aTopic: AString): AString;
    /**
     * Return a wake lock (MozWakeLock) object of aTopic associated with aWindow.
     * A wake lock without associated window, e.g. used in chrome, is
     * always considered invisible.
     */
    newWakeLock(aTopic: AString, aWindow: mozIDOMWindow): nsIWakeLock;
}

/**
 * The nsIPrefBranch interface is used to manipulate the preferences data. This
 * object may be obtained from the preferences service (nsIPrefService) and
 * used to get and set default and/or user preferences across the application.
 *
 * This object is created with a "root" value which describes the base point in
 * the preferences "tree" from which this "branch" stems. Preferences are
 * accessed off of this root by using just the final portion of the preference.
 * For example, if this object is created with the root "browser.startup.",
 * the preferences "browser.startup.page", "browser.startup.homepage",
 * and "browser.startup.homepage_override" can be accessed by simply passing
 * "page", "homepage", or "homepage_override" to the various Get/Set methods.
 *
 * @see nsIPrefService
 */
declare interface nsIPrefBranchType extends nsISupportsType {
    /**
     * Called to get the root on which this branch is based, such as
     * "browser.startup."
     */
    readonly root: ACString;
    /**
     * Called to determine the type of a specific preference.
     *
     * @param aPrefName The preference to get the type of.
     *
     * @return long     A value representing the type of the preference. This
     * value will be PREF_STRING, PREF_INT, or PREF_BOOL.
     */
    getPrefType(aPrefName: string): long;
    /**
     * Called to get the state of an individual boolean preference.
     *
     * @param aPrefName The boolean preference to get the state of.
     * @param aDefaultValue The value to return if the preference is not set.
     *
     * @return boolean  The value of the requested boolean preference.
     *
     * @see setBoolPref
     */
    getBoolPref(aPrefName: string, aDefaultValue: boolean): boolean;
    /**
     * Called to set the state of an individual boolean preference.
     *
     * @param aPrefName The boolean preference to set the state of.
     * @param aValue    The boolean value to set the preference to.
     *
     * @throws Error if setting failed or the preference has a default
     * value of a type other than boolean.
     *
     * @see getBoolPref
     */
    setBoolPref(aPrefName: string, aValue: boolean): void;
    /**
     * Called to get the state of an individual floating-point preference.
     * "Floating point" preferences are really string preferences that
     * are converted to floating point numbers.
     *
     * @param aPrefName The floating point preference to get the state of.
     * @param aDefaultValue The value to return if the preference is not set.
     *
     * @return float  The value of the requested floating point preference.
     *
     * @see setCharPref
     */
    getFloatPref(aPrefName: string, aDefaultValue: float): float;
    /**
     * Called to get the state of an individual ascii string preference.
     *
     * @param aPrefName The string preference to retrieve.
     * @param aDefaultValue The string to return if the preference is not set.
     *
     * @return ACString   The value of the requested string preference.
     *
     * @see setCharPref
     */
    getCharPref(aPrefName: string, aDefaultValue: ACString): ACString;
    /**
     * Called to set the state of an individual ascii string preference.
     *
     * @param aPrefName The string preference to set.
     * @param aValue    The string value to set the preference to.
     *
     * @throws Error if setting failed or the preference has a default
     * value of a type other than string.
     *
     * @see getCharPref
     */
    setCharPref(aPrefName: string, aValue: ACString): void;
    /**
     * Called to get the state of an individual unicode string preference.
     *
     * @param aPrefName The string preference to retrieve.
     * @param aDefaultValue The string to return if the preference is not set.
     *
     * @return AUTF8String   The value of the requested string preference.
     *
     * @see setStringPref
     */
    getStringPref(aPrefName: string, aDefaultValue: AUTF8String): AUTF8String;
    /**
     * Called to set the state of an individual unicode string preference.
     *
     * @param aPrefName The string preference to set.
     * @param aValue    The string value to set the preference to.
     *
     * @throws Error if setting failed or the preference has a default
     * value of a type other than string.
     *
     * @see getStringPref
     */
    setStringPref(aPrefName: string, aValue: AUTF8String): void;
    /**
     * Called to get the state of an individual integer preference.
     *
     * @param aPrefName The integer preference to get the value of.
     * @param aDefaultValue The value to return if the preference is not set.
     *
     * @return long     The value of the requested integer preference.
     *
     * @see setIntPref
     */
    getIntPref(aPrefName: string, aDefaultValue: long): long;
    /**
     * Called to set the state of an individual integer preference.
     *
     * @param aPrefName The integer preference to set the value of.
     * @param aValue    The integer value to set the preference to.
     *
     * @throws Error if setting failed or the preference has a default
     * value of a type other than integer.
     *
     * @see getIntPref
     */
    setIntPref(aPrefName: string, aValue: long): void;
    /**
     * Called to get the state of an individual complex preference. A complex
     * preference is a preference which represents an XPCOM object that can not
     * be easily represented using a standard boolean, integer or string value.
     *
     * @param aPrefName The complex preference to get the value of.
     * @param aType     The XPCOM interface that this complex preference
     * represents. Interfaces currently supported are:
     * - nsIFile
     * - nsIPrefLocalizedString (Localized UniChar)
     * @param aValue    The XPCOM object into which to the complex preference
     * value should be retrieved.
     *
     * @throws Error The value does not exist or is the wrong type.
     *
     * @see setComplexValue
     */
    getComplexValue(aPrefName: string, aType: nsIIDRefType, aValue: nsQIResult): void;
    /**
     * Called to set the state of an individual complex preference. A complex
     * preference is a preference which represents an XPCOM object that can not
     * be easily represented using a standard boolean, integer or string value.
     *
     * @param aPrefName The complex preference to set the value of.
     * @param aType     The XPCOM interface that this complex preference
     * represents. Interfaces currently supported are:
     * - nsIFile
     * - nsISupportsString (UniChar)
     * (deprecated; see setStringPref)
     * - nsIPrefLocalizedString (Localized UniChar)
     * @param aValue    The XPCOM object from which to set the complex preference
     * value.
     *
     * @throws Error if setting failed or the value is the wrong type.
     *
     * @see getComplexValue
     */
    setComplexValue(aPrefName: string, aType: nsIIDRefType, aValue: nsISupportsType): void;
    /**
     * Called to clear a user set value from a specific preference. This will, in
     * effect, reset the value to the default value. If no default value exists
     * the preference will cease to exist.
     *
     * @param aPrefName The preference to be cleared.
     *
     * @note
     * This method does nothing if this object is a default branch.
     */
    clearUserPref(aPrefName: string): void;
    /**
     * Called to lock a specific preference. Locking a preference will cause the
     * preference service to always return the default value regardless of
     * whether there is a user set value or not.
     *
     * @param aPrefName The preference to be locked.
     *
     * @note
     * This method can be called on either a default or user branch but, in
     * effect, always operates on the default branch.
     *
     * @throws Error The preference does not exist or an error occurred.
     *
     * @see unlockPref
     */
    lockPref(aPrefName: string): void;
    /**
     * Called to check if a specific preference has a user value associated to
     * it.
     *
     * @param aPrefName The preference to be tested.
     *
     * @note
     * This method can be called on either a default or user branch but, in
     * effect, always operates on the user branch.
     *
     * @note
     * If a preference was manually set to a value that equals the default value,
     * then the preference no longer has a user set value, i.e. it is
     * considered reset to its default value.
     * In particular, this method will return false for such a preference and
     * the preference will not be saved to a file by nsIPrefService.savePrefFile.
     *
     * @return boolean  true  The preference has a user set value.
     * false The preference only has a default value.
     */
    prefHasUserValue(aPrefName: string): boolean;
    /**
     * Called to check if a specific preference has a default value associated to
     * it.
     *
     * @param aPrefName The preference to be tested.
     *
     * @note
     * This method can be called on either a default or user branch but, in
     * effect, always operates on the user branch.
     *
     * @note
     * This method can be used to distinguish between a built-in preference and a
     * user-added preference.
     *
     * @return boolean  true  The preference has a default value.
     * false The preference only has a user value.
     */
    prefHasDefaultValue(aPrefName: string): boolean;
    /**
     * Called to check if a specific preference is locked. If a preference is
     * locked calling its Get method will always return the default value.
     *
     * @param aPrefName The preference to be tested.
     *
     * @note
     * This method can be called on either a default or user branch but, in
     * effect, always operates on the default branch.
     *
     * @return boolean  true  The preference is locked.
     * false The preference is not locked.
     *
     * @see lockPref
     * @see unlockPref
     */
    prefIsLocked(aPrefName: string): boolean;
    /**
     * Called to check if a specific preference has been sanitized. If a
     * preference is sanitized, any user value the preference may have will not
     * be present in a sub-process.  A preference is never sanitized in the
     * parent process; it is only marked as sanitized when it is converted
     * to a dom::Pref for serialization to a child process.
     *
     * @param aPrefName The preference to be tested.
     *
     * @note
     * This method can be called on either a default or user branch but it
     * makes no difference.
     *
     * @return boolean  true  The preference is sanitized.
     * false The preference is not sanitized.
     */
    prefIsSanitized(aPrefName: string): boolean;
    /**
     * Called to unlock a specific preference. Unlocking a previously locked
     * preference allows the preference service to once again return the user set
     * value of the preference.
     *
     * @param aPrefName The preference to be unlocked.
     *
     * @note
     * This method can be called on either a default or user branch but, in
     * effect, always operates on the default branch.
     *
     * @throws Error The preference does not exist or an error occurred.
     *
     * @see lockPref
     */
    unlockPref(aPrefName: string): void;
    /**
     * Called to remove all of the preferences referenced by this branch.
     *
     * @param aStartingAt The point on the branch at which to start the deleting
     * preferences. Pass in "" to remove all preferences
     * referenced by this branch.
     *
     * @note
     * This method can be called on either a default or user branch but, in
     * effect, always operates on both.
     *
     * @throws Error The preference(s) do not exist or an error occurred.
     */
    deleteBranch(aStartingAt: string): void;
    /**
     * Add a preference change observer. On preference changes, the following
     * arguments will be passed to the nsIObserver.observe() method:
     * aSubject - The nsIPrefBranch object (this)
     * aTopic   - The string defined by NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
     * aData    - The name of the preference which has changed, relative to
     * the |root| of the aSubject branch.
     *
     * aSubject.get*Pref(aData) will get the new value of the modified
     * preference. For example, if your observer is registered with
     * addObserver("bar.", ...) on a branch with root "foo.", modifying
     * the preference "foo.bar.baz" will trigger the observer, and aData
     * parameter will be "bar.baz".
     *
     * @param aDomain   The preference on which to listen for changes. This can
     * be the name of an entire branch to observe.
     * e.g. Holding the "root" prefbranch and calling
     * addObserver("foo.bar.", ...) will observe changes to
     * foo.bar.baz and foo.bar.bzip
     * @param aObserver The object to be notified if the preference changes.
     * @param aHoldWeak true  Hold a weak reference to |aObserver|. The object
     * must implement the nsISupportsWeakReference
     * interface or this will fail.
     * false Hold a strong reference to |aObserver|.
     *
     * @note
     * Registering as a preference observer can open an object to potential
     * cyclical references which will cause memory leaks. These cycles generally
     * occur because an object both registers itself as an observer (causing the
     * branch to hold a reference to the observer) and holds a reference to the
     * branch object for the purpose of getting/setting preference values. There
     * are 3 approaches which have been implemented in an attempt to avoid these
     * situations.
     * 1) The nsPrefBranch object supports nsISupportsWeakReference. Any consumer
     * may hold a weak reference to it instead of a strong one.
     * 2) The nsPrefBranch object listens for xpcom-shutdown and frees all of the
     * objects currently in its observer list. This ensures that long lived
     * objects (services for example) will be freed correctly.
     * 3) The observer can request to be held as a weak reference when it is
     * registered. This insures that shorter lived objects (say one tied to an
     * open window) will not fall into the cyclical reference trap.
     *
     * @note
     * The list of registered observers may be changed during the dispatch of
     * nsPref:changed notification. However, the observers are not guaranteed
     * to be notified in any particular order, so you can't be sure whether the
     * added/removed observer will be called during the notification when it
     * is added/removed.
     *
     * @note
     * It is possible to change preferences during the notification.
     *
     * @note
     * It is not safe to change observers during this callback in Gecko
     * releases before 1.9. If you want a safe way to remove a pref observer,
     * please use an nsITimer.
     *
     * @see nsIObserver
     * @see removeObserver
     */
    addObserver(aDomain: ACString, aObserver: nsIObserverType, aHoldWeak: boolean): void;
    /**
     * Remove a preference change observer.
     *
     * @param aDomain   The preference which is being observed for changes.
     * @param aObserver An observer previously registered with addObserver().
     *
     * @note
     * Note that you must call removeObserver() on the same nsIPrefBranch
     * instance on which you called addObserver() in order to remove aObserver;
     * otherwise, the observer will not be removed.
     *
     * @see nsIObserver
     * @see addObserver
     */
    removeObserver(aDomain: ACString, aObserver: nsIObserverType): void;
}

/**
 * The nsIPrefLocalizedString interface is simply a wrapper interface for
 * nsISupportsString so the preferences service can have a unique identifier
 * to distinguish between requests for normal wide strings (nsISupportsString)
 * and "localized" wide strings, which get their default values from properites
 * files.
 *
 * @see nsIPrefBranch
 * @see nsISupportsString
 */
declare interface nsIPrefLocalizedStringType extends nsISupportsStringType {
}

/**
 * A helper function for reading access statistics for preferences.
 * See nsIPrefService.readStats for more details.
 */
declare interface nsIPrefStatsCallbackType extends nsISupportsType {
    /**
     *
     */
    visit(prefName: ACString, accessCount: unsigned_long): void;
}

/**
 *
 */
declare interface nsIPrefObserverType extends nsISupportsType {
    /**
     * Invoked when a string preference is witnessed.  kind will be "Default" or "User".
     */
    onStringPref(kind: string, name: string, value: string, isSticky: boolean, isLocked: boolean): void;
    /**
     * Invoked when a integer preference is witnessed.  kind will be "Default" or "User".
     */
    onIntPref(kind: string, name: string, value: long, isSticky: boolean, isLocked: boolean): void;
    /**
     * Invoked when a boolean preference is witnessed.  kind will be "Default" or "User".
     */
    onBoolPref(kind: string, name: string, value: boolean, isSticky: boolean, isLocked: boolean): void;
    /**
     * Invoked when the prefs parser encounters an error.
     */
    onError(message: string): void;
}

/**
 * The nsIPrefService interface is the main entry point into the back end
 * preferences management library. The preference service is directly
 * responsible for the management of the preferences files and also facilitates
 * access to the preference branch object which allows the direct manipulation
 * of the preferences themselves.
 *
 * @see nsIPrefBranch
 */
declare interface nsIPrefServiceType extends nsISupportsType {
    /**
     * Called to completely flush and re-initialize the preferences system.
     *
     * @throws Error The preference service failed to restart correctly.
     */
    resetPrefs(): void;
    /**
     * Called to write current preferences state to a file.
     *
     * @param aFile The file to be written.
     *
     * @note
     * If nullptr is passed in for the aFile parameter the preference data is
     * written out to the current preferences file (usually prefs.js.)
     *
     * @throws Error File failed to write.
     *
     * @see readUserPrefsFromFile
     * @see nsIFile
     */
    savePrefFile(aFile: nsIFileType): void;
    /**
     * Call to get a Preferences "Branch" which accesses user preference data.
     * Using a Set method on this object will always create or set a user
     * preference value. When using a Get method a user set value will be
     * returned if one exists, otherwise a default value will be returned.
     *
     * @param aPrefRoot The preference "root" on which to base this "branch".
     * For example, if the root "browser.startup." is used, the
     * branch will be able to easily access the preferences
     * "browser.startup.page", "browser.startup.homepage", or
     * "browser.startup.homepage_override" by simply requesting
     * "page", "homepage", or "homepage_override". nullptr or ""
     * may be used to access to the entire preference "tree".
     *
     * @return nsIPrefBranch The object representing the requested branch.
     *
     * @see getDefaultBranch
     */
    getBranch(aPrefRoot: string): nsIPrefBranch;
    /**
     * Call to get a Preferences "Branch" which accesses only the default
     * preference data. Using a Set method on this object will always create or
     * set a default preference value. When using a Get method a default value
     * will always be returned.
     *
     * @param aPrefRoot The preference "root" on which to base this "branch".
     * For example, if the root "browser.startup." is used, the
     * branch will be able to easily access the preferences
     * "browser.startup.page", "browser.startup.homepage", or
     * "browser.startup.homepage_override" by simply requesting
     * "page", "homepage", or "homepage_override". nullptr or ""
     * may be used to access to the entire preference "tree".
     *
     * @note
     * Few consumers will want to create default branch objects. Many of the
     * branch methods do nothing on a default branch because the operations only
     * make sense when applied to user set preferences.
     *
     * @return nsIPrefBranch The object representing the requested default branch.
     *
     * @see getBranch
     */
    getDefaultBranch(aPrefRoot: string): nsIPrefBranch;
    /**
     * The preference service is 'dirty' if there are changes to user preferences
     * that have not been written to disk
     */
    readonly dirty: boolean;
    /**
     * Read in the preferences specified in a default preference file. This
     * method does not clear preferences that were already set, but it may
     * overwrite existing preferences.
     *
     * @param aFile The file to be read.
     *
     * @throws Error File failed to read or contained invalid data.
     * @note This method is intended for internal unit testing only!
     */
    readDefaultPrefsFromFile(aFile: nsIFileType): void;
    /**
     * Like readDefaultPrefsFromFile, but for a user prefs file.
     */
    readUserPrefsFromFile(aFile: nsIFileType): void;
    /**
     * Usage statistics for performance tests. This function takes a function
     * that is passed (preferenceName, accessCount) as arguments for every
     * recorded preference. You can use this function to build e.g. a JS object
     * holding that data.
     *
     * This is not implemented in non-debug builds and will throw an error.
     */
    readStats(callback: nsIPrefStatsCallbackType): void;
    /**
     * Reset usage statistics for performance tests.
     *
     * This is not implemented in non-debug builds and will throw an error.
     */
    resetStats(): void;
    /**
     * Parse the given bytes, invoking callbacks on the given observer.
     *
     * This method does not modify any preferences.
     *
     * @param bytes The data to parse.  This data may be UTF-8 encoded, but is not
     * required to be so: the prefs parser will determine the encoding
     * automatically.
     * @param observer The observer to invoke callbacks on.  Parsing errors will
     * be reported via the onError callback.
     * @param pathLabel An optional string with which to label errors.
     */
    parsePrefsFromBuffer(bytes: invalid, observer: nsIPrefObserverType, pathLabel: string): void;
}

/**
 *
 */
declare interface nsIPrefetchServiceType extends nsISupportsType {
    /**
     * Enqueue a request to prefetch the specified URI.
     *
     * @param aURI the URI of the document to prefetch
     * @param aReferrerInfo the referrerInfo of the request
     * @param aSource the DOM node (such as a <link> tag) that requested this
     * fetch, or null if the prefetch was not requested by a DOM node.
     * @param aExplicit the link element has an explicit prefetch link type
     */
    prefetchURI(aURI: nsIURIType, aReferrerInfo: nsIReferrerInfoType, aSource: Node, aExplicit: boolean): void;
    /**
     * Start a preload of the specified URI.
     *
     * @param aURI the URI of the document to preload
     * @param aReferrerInfo the referrerInfo of the request
     * @param aSource the DOM node (such as a <link> tag) that requested this
     * fetch, or null if the prefetch was not requested by a DOM node.
     * @param aPolicyType content policy to be used for this load.
     */
    preloadURI(aURI: nsIURIType, aReferrerInfo: nsIReferrerInfoType, aSource: Node, aPolicyType: nsContentPolicyType): void;
    /**
     * Find out if there are any prefetches running or queued
     */
    hasMoreElements(): boolean;
    /**
     * Cancel prefetch or preload for a Node.
     */
    cancelPrefetchPreloadURI(aURI: nsIURIType, aSource: Node): void;
}

/**
 * The nsIPreloadedStyleSheet interface is an opaque interface for
 * style sheets returned by nsIStyleSheetService.preloadSheet, and
 * which can be passed to nsIDOMWindowUtils.addSheet.
 */
declare interface nsIPreloadedStyleSheetType extends nsISupportsType {
}

/**
 *
 */
declare interface nsIPrincipalType extends nsISupportsType {
    /**
     * Returns whether the other principal is equivalent to this principal.
     * Principals are considered equal if they are the same principal, or
     * they have the same origin.
     *
     * May be called from any thread.
     */
    equals(other: nsIPrincipalType): boolean;
    /**
     * Returns whether the other principal is equivalent to this principal
     * for permission purposes
     * Matches {originAttributes ,equalsURIForPermission}
     *
     * May be called from any thread.
     */
    equalsForPermission(other: nsIPrincipalType, aExactHost: bool): boolean;
    /**
     * Like equals, but takes document.domain changes into account.
     *
     * May be called from any thread, though document.domain may racily change
     * during the comparison when called from off-main-thread.
     */
    equalsConsideringDomain(other: nsIPrincipalType): boolean;
    /**
     * Returns whether the Principals URI is equal to the other URI
     *
     * May be called from any thread.
     */
    equalsURI(aOtherURI: nsIURIType): boolean;
    /**
     * Returns a hash value for the principal.
     *
     * May be called from any thread.
     */
    readonly hashValue: unsigned_long;
    /**
     * The principal URI to which this principal pertains.  This is
     * generally the document URI.
     *
     * May be called from any thread.
     */
    readonly URI: nsIURI;
    /**
     * The domain URI to which this principal pertains.
     * This is null unless script successfully sets document.domain to our URI
     * or a superdomain of our URI.
     * Setting this has no effect on the URI.
     * See https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy#Changing_origin
     *
     * The getter may be called from any thread, but may only be set on the main thread.
     */
    domain: nsIURI;
    /**
     * Returns whether the other principal is equal to or weaker than this
     * principal. Principals are equal if they are the same object or they
     * have the same origin.
     *
     * Thus a principal always subsumes itself.
     *
     * The system principal subsumes itself and all other principals.
     *
     * A null principal (corresponding to an unknown, hence assumed minimally
     * privileged, security context) is not equal to any other principal
     * (including other null principals), and therefore does not subsume
     * anything but itself.
     *
     * May be called from any thread.
     */
    subsumes(other: nsIPrincipalType): boolean;
    /**
     * Same as the previous method, subsumes(), but takes document.domain into
     * account.
     *
     * May be called from any thread, though document.domain may racily change
     * during the comparison when called from off-main-thread.
     */
    subsumesConsideringDomain(other: nsIPrincipalType): boolean;
    /**
     * Same as the subsumesConsideringDomain(), but ignores the first party
     * domain in its originAttributes.
     *
     * May be called from any thread, though document.domain may racily change
     * during the comparison when called from off-main-thread.
     */
    subsumesConsideringDomainIgnoringFPD(other: nsIPrincipalType): boolean;
    /**
     * Checks whether this principal is allowed to load the network resource
     * located at the given URI under the same-origin policy. This means that
     * content principals are only allowed to load resources from the same
     * domain, the system principal is allowed to load anything, and null
     * principals can only load URIs where they are the principal. This is
     * changed by the optional flag allowIfInheritsPrincipal (which defaults to
     * false) which allows URIs that inherit their loader's principal.
     *
     * If the load is allowed this function does nothing. If the load is not
     * allowed the function throws NS_ERROR_DOM_BAD_URI.
     *
     * NOTE: Other policies might override this, such as the Access-Control
     * specification.
     * NOTE: The 'domain' attribute has no effect on the behaviour of this
     * function.
     * NOTE: Main-Thread Only.
     *
     *
     * @param uri    The URI about to be loaded.
     * @param allowIfInheritsPrincipal   If true, the load is allowed if the
     * loadee inherits the principal of the
     * loader.
     * @throws NS_ERROR_DOM_BAD_URI if the load is not allowed.
     */
    checkMayLoad(uri: nsIURIType, allowIfInheritsPrincipal: boolean): void;
    /**
     * Like checkMayLoad, but if returning an error will also report that error
     * to the console, using the provided window id.  The window id may be 0 to
     * report to just the browser console, not web consoles.
     *
     * NOTE: Main-Thread Only.
     */
    checkMayLoadWithReporting(uri: nsIURIType, allowIfInheritsPrincipal: boolean, innerWindowID: unsigned_long_long): void;
    /**
     * Checks if the provided URI is considered third-party to the
     * URI of the principal.
     * Returns true if the URI is third-party.
     *
     * May be called from any thread.
     *
     * @param uri - The URI to check
     */
    isThirdPartyURI(uri: nsIURIType): boolean;
    /**
     * Checks if the provided principal is considered third-party to the
     * URI of the Principal.
     * Returns true if the principal is third-party.
     *
     * May be called from any thread.
     *
     * @param principal - The principal to check
     */
    isThirdPartyPrincipal(principal: nsIPrincipalType): boolean;
    /**
     * Checks if the provided channel is considered third-party to the
     * URI of the principal.
     * Returns true if the channel is third-party.
     * Returns false if the Principal is a System Principal
     *
     * NOTE: Main-Thread Only.
     *
     * @param channel - The Channel to check
     */
    isThirdPartyChannel(channel: nsIChannelType): boolean;
    /**
     * A dictionary of the non-default origin attributes associated with this
     * nsIPrincipal.
     *
     * Attributes are tokens that are taken into account when determining whether
     * two principals are same-origin - if any attributes differ, the principals
     * are cross-origin, even if the scheme, host, and port are the same.
     * Attributes should also be considered for all security and bucketing decisions,
     * even those which make non-standard comparisons (like cookies, which ignore
     * scheme, or quotas, which ignore subdomains).
     *
     * If you're looking for an easy-to-use canonical stringification of the origin
     * attributes, see |originSuffix| below.
     */
    readonly originAttributes: jsval;
    /**
     * A canonical representation of the origin for this principal. This
     * consists of a base string (which, for content principals, is of the
     * format scheme://host:port), concatenated with |originAttributes| (see
     * below).
     *
     * We maintain the invariant that principalA.equals(principalB) if and only
     * if principalA.origin == principalB.origin.
     *
     * May be called from any thread.
     */
    readonly origin: ACString;
    /**
     * Returns an ASCII compatible serialization of the principal's origin, as
     * specified by the whatwg HTML specification. If the principal does not
     * have a host, the origin will be "null".
     *
     * https://html.spec.whatwg.org/multipage/browsers.html#ascii-serialisation-of-an-origin
     *
     * Note that this is different from `origin`, does not contain
     * gecko-specific metadata like origin attributes, and should not be used
     * for permissions or security checks.
     *
     * May be called from any thread.
     */
    readonly webExposedOriginSerialization: ACString;
    /**
     * Returns the "host:port" portion of the
     * Principals URI, if any.
     *
     * May be called from any thread.
     */
    readonly hostPort: ACString;
    /**
     * Returns the "host:port" portion of the
     * Principals URI, if any.
     *
     * May be called from any thread.
     */
    readonly asciiHost: ACString;
    /**
     * Returns the "host" portion of the
     * Principals URI, if any.
     *
     * May be called from any thread.
     */
    readonly host: ACString;
    /**
     * Returns the prePath of the principals uri
     * follows the format scheme:
     * "scheme://username:password@hostname:portnumber/"
     *
     * May be called from any thread.
     */
    readonly prePath: ACString;
    /**
     * Returns the filePath of the principals uri. See nsIURI.
     *
     * May be called from any thread.
     */
    readonly filePath: ACString;
    /**
     * Returns the ASCII Spec from the Principals URI.
     * Might return the empty string, e.g. for the case of
     * a SystemPrincipal or an EpxandedPrincipal.
     *
     * May be called from any thread.
     *
     * WARNING: DO NOT USE FOR SECURITY CHECKS.
     * just for logging purposes!
     */
    readonly asciiSpec: ACString;
    /**
     * Returns the Spec from the Principals URI.
     * Might return the empty string, e.g. for the case of
     * a SystemPrincipal or an EpxandedPrincipal.
     *
     * May be called from any thread.
     *
     * WARNING: Do not land new Code using, as this will be removed soon
     */
    readonly spec: ACString;
    /**
     * Returns the Pre Path of the Principals URI with
     * user:pass stripped for privacy and spoof prevention
     *
     * May be called from any thread.
     */
    readonly exposablePrePath: ACString;
    /**
     * Returns the Spec of the Principals URI with
     * user/pass/ref/query stripped for privacy and spoof prevention
     *
     * May be called from any thread.
     */
    readonly exposableSpec: ACString;
    /**
     * Return the scheme of the principals URI
     *
     * May be called from any thread.
     */
    readonly scheme: ACString;
    /**
     * Checks if the Principal's URI Scheme matches with the parameter
     *
     * May be called from any thread.
     *
     * @param scheme    The scheme to be checked
     */
    schemeIs(scheme: string): boolean;
    /**
     * Checks if the Principal's URI is contained in the given Pref
     *
     * NOTE: Main-Thread Only.
     *
     * @param pref    The pref to be checked
     */
    isURIInPrefList(pref: string): boolean;
    /**
     * Check if the Principal's URI is contained in the given list
     *
     * May be called from any thread.
     *
     * @param list The list to be checked
     */
    isURIInList(list: ACString): boolean;
    /**
     * Check if the Principal's URI is a content-accessible about: page
     *
     * May be called from any thread.
     */
    isContentAccessibleAboutURI(): boolean;
    /**
     * Uses NS_Security Compare to determine if the
     * other URI is same-origin as the uri of the Principal
     *
     * May be called from any thread.
     */
    isSameOrigin(otherURI: nsIURIType): boolean;
    /**
     * Checks if the Principal is allowed to load the Provided file:// URI
     * using NS_RelaxStrictFileOriginPolicy
     *
     * May be called from any thread.
     */
    allowsRelaxStrictFileOriginPolicy(aURI: nsIURIType): bool;
    /**
     * Checks if the Principals URI has first party storage access
     * when loaded inside the provided 3rd party resource window.
     * See also: ContentBlocking::ShouldAllowAccessFor
     *
     * NOTE: Main-Thread Only.
     */
    hasFirstpartyStorageAccess(aWindow: mozIDOMWindow, rejectedReason: uint32_t): bool;
    /**
     * Returns a Key for the LocalStorage Manager, used to
     * check the Principals Origin Storage usage.
     *
     * May be called from any thread.
     */
    readonly localStorageQuotaKey: ACString;
    /**
     * Implementation of
     * https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy
     *
     * The value returned by this method feeds into the the Secure Context
     * algorithm that determins the value of Window.isSecureContext and
     * WorkerGlobalScope.isSecureContext.
     *
     * This method returns false instead of throwing upon errors.
     *
     * NOTE: Main-Thread Only.
     */
    readonly isOriginPotentiallyTrustworthy: boolean;
    /**
     * NOTE: Main-Thread Only.
     */
    readonly isLoopbackHost: boolean;
    /**
     * Returns the Flags of the Principals
     * associated AboutModule, in case there is one.
     *
     * NOTE: Main-Thread Only.
     */
    getAboutModuleFlags(): uint32_t;
    /**
     * Returns the Key to access the Principals
     * Origin Local/Session Storage
     *
     * May be called from any thread.
     */
    readonly storageOriginKey: ACString;
    /**
     * Creates and Returns a new ReferrerInfo with the
     * Principals URI
     *
     * May be called from any thread.
     */
    createReferrerInfo(aReferrerPolicy: ReferrerPolicy): nsIReferrerInfo;
    /**
     * The base part of |origin| without the concatenation with |originSuffix|.
     * This doesn't have the important invariants described above with |origin|,
     * and as such should only be used for legacy situations.
     *
     * May be called from any thread.
     */
    readonly originNoSuffix: ACString;
    /**
     * A string of the form ^key1=value1&key2=value2, where each pair represents
     * an attribute with a non-default value. If all attributes have default
     * values, this is the empty string.
     *
     * The value of .originSuffix is automatically serialized into .origin, so any
     * consumers using that are automatically origin-attribute-aware. Consumers with
     * special requirements must inspect and compare .originSuffix manually.
     *
     * May be called from any thread.
     */
    readonly originSuffix: AUTF8String;
    /**
     * A canonical representation of the site-origin for this principal.
     * This string has the same format as |origin| (see above). Two principals
     * with differing |siteOrigin| values will never compare equal, even when
     * considering domain mutations.
     *
     * For most principals, |siteOrigin| matches |origin| precisely. Only
     * principals which allow mutating |domain|, such as ContentPrincipal,
     * override the default implementation in BasePrincipal.
     *
     * May be called from any thread.
     */
    readonly siteOrigin: ACString;
    /**
     * The base part of |siteOrigin| without the concatenation with
     * |originSuffix|.
     *
     * May be called from any thread.
     */
    readonly siteOriginNoSuffix: ACString;
    /**
     * The base domain of the principal URI to which this principal pertains
     * (generally the document URI), handling null principals and
     * non-hierarchical schemes correctly.
     *
     * May be called from any thread.
     */
    readonly baseDomain: ACString;
    /**
     * Gets the ID of the add-on this principal belongs to.
     *
     * May be called from any thread.
     */
    readonly addonId: AString;
    /**
     * Gets the WebExtensionPolicy of the add-on this principal belongs to.
     *
     * NOTE: Main-Thread Only.
     */
    readonly addonPolicy: WebExtensionPolicy;
    /**
     *
     */
    readonly contentScriptAddonPolicy: WebExtensionPolicy;
    /**
     * Gets the id of the user context this principal is inside.  If this
     * principal is inside the default userContext, this returns
     * nsIScriptSecurityManager::DEFAULT_USER_CONTEXT_ID.
     *
     * May be called from any thread.
     */
    readonly userContextId: unsigned_long;
    /**
     * Gets the id of the private browsing state of the context containing
     * this principal. If the principal has a private browsing value of 0, it
     * is not in private browsing.
     *
     * May be called from any thread.
     */
    readonly privateBrowsingId: unsigned_long;
    /**
     * Returns true iff the principal is inside an isolated mozbrowser element.
     * <xul:browser> is not considered to be a mozbrowser element.
     * <iframe mozbrowser noisolation> does not count as isolated since
     * isolation is disabled.  Isolation can only be disabled if the
     * containing document is chrome.
     *
     * May be called from any thread.
     */
    readonly isInIsolatedMozBrowserElement: boolean;
    /**
     * Returns true iff this is a null principal (corresponding to an
     * unknown, hence assumed minimally privileged, security context).
     *
     * May be called from any thread.
     */
    readonly isNullPrincipal: boolean;
    /**
     * Returns true iff this principal corresponds to a principal origin.
     *
     * May be called from any thread.
     */
    readonly isContentPrincipal: boolean;
    /**
     * Returns true iff this is an expanded principal.
     *
     * May be called from any thread.
     */
    readonly isExpandedPrincipal: boolean;
    /**
     * Returns true iff this is the system principal.  C++ callers should use
     * IsSystemPrincipal() instead of this scriptable accessor.
     *
     * May be called from any thread.
     */
    readonly isSystemPrincipal: boolean;
    /**
     * Returns true iff the principal is either an addon principal or
     * an expanded principal, which contains at least one addon principal.
     *
     * May be called from any thread.
     */
    readonly isAddonOrExpandedAddonPrincipal: boolean;
    /**
     * Returns true if the URI is an Onion URI.
     *
     * May be called from any thread.
     */
    readonly isOnion: boolean;
    /**
     * Returns true if the Domain Policy allows js execution
     * for the Principal's URI
     *
     * NOTE: Main-Thread Only.
     */
    readonly isScriptAllowedByPolicy: boolean;
    /**
     * Returns true if the Principal can acess l10n
     * features for the Provided DocumentURI
     *
     * NOTE: Main-Thread Only.
     */
    isL10nAllowed(aDocumentURI: nsIURIType): boolean;
    /**
     * Returns a nsIPrincipal, with one less Subdomain Segment
     * Returns `nullptr` if there are no more segments to remove.
     *
     * May be called from any thread.
     */
    readonly nextSubDomainPrincipal: nsIPrincipal;
    /**
     * Returns if the principal is for an IP address.
     *
     * May be called from any thread.
     */
    readonly isIpAddress: boolean;
    /**
     * Returns if the principal is for a local IP address.
     *
     * May be called from any thread.
     */
    readonly isLocalIpAddress: boolean;
    /**
     * If this principal is a null principal, reconstruct the precursor
     * principal which this null principal was derived from. This may be null,
     * in which case this is not a null principal, there is no known precursor
     * to this null principal, it was created by a privileged context, or there
     * was a bugged origin in the precursor string.
     *
     * May be called from any thread.
     *
     * WARNING: Be careful when using this principal, as it is not part of the
     * security properties of the null principal, and should NOT be used to
     * grant a resource with a null principal access to resources from its
     * precursor origin. This is only to be used for places where tracking how
     * null principals were created is necessary.
     */
    readonly precursorPrincipal: nsIPrincipal;
}

/**
 * If SystemPrincipal is too risky to use, but we want a principal to access
 * more than one origin, ExpandedPrincipals letting us define an array of
 * principals it subsumes. So script with an ExpandedPrincipals will gain
 * same origin access when at least one of its principals it contains gained
 * sameorigin acccess. An ExpandedPrincipal will be subsumed by the system
 * principal, and by another ExpandedPrincipal that has all its principals.
 * It is added for jetpack content-scripts to let them interact with the
 * content and a well defined set of other domains, without the risk of
 * leaking out a system principal to the content. See: Bug 734891
 */
declare interface nsIExpandedPrincipalType extends nsISupportsType {
    /**
     * Bug 1548468: Move CSP off ExpandedPrincipal.
     *
     * A Content Security Policy associated with this principal. Use this function
     * to query the associated CSP with this principal.
     *
     * NOTE: Main-Thread Only.
     */
    readonly csp: nsIContentSecurityPolicy;
}

/**
 * Service for opening native print dialogs provided by the operating system.
 * (The widget code may customize the dialog.)
 */
declare interface nsIPrintDialogServiceType extends nsISupportsType {
    /**
     * Initialize the service.
     */
    init(): void;
    /**
     * Show the print dialog.
     * @param aParent   A DOM window the dialog will be parented to.
     * @param aHaveSelection A boolean indicating whether the document to be
     * printed has some selected text, which is used to
     * determine whether the "Print selection only" radio
     * button is enabled in the print settings dialog.
     * @param aSettings On entry, this contains initial settings for the
     * print dialog. On return, if the print operation should
     * proceed, then this has been updated with the settings
     * that the user selected in the dialog.
     * @return NS_OK if the print operation should proceed
     * @return NS_ERROR_ABORT if the user indicated not to proceed
     * @return a suitable error for failures to show the print dialog.
     */
    showPrintDialog(aParent: mozIDOMWindowProxy, aHaveSelection: boolean, aPrintSettings: nsIPrintSettingsType): void;
    /**
     * Show the page setup dialog. Note that there is no way to tell whether the
     * user clicked OK or Cancel on the dialog.
     * @param aParent   A DOM window the dialog will be parented to.
     * @param aSettings On entry, this contains initial settings for the
     * page setup dialog. On return, if the dialog wasn't
     * cancelled, then this has been updated with the settings
     * that the user selected in the dialog.
     */
    showPageSetupDialog(aParent: mozIDOMWindowProxy, aPrintSettings: nsIPrintSettingsType): void;
}

/**
 * The nsIPrintPreviewNavigation
 */
declare interface nsIPrintPreviewNavigationType extends nsISupportsType {
    /**
     *
     */
    readonly pageCount: long;
    /**
     * Preview the next Page
     *
     * Return - PR_TRUE if success
     */
    nextPage(): boolean;
    /**
     * Preview the previous Page
     *
     * Return - PR_TRUE if success
     */
    previousPage(): boolean;
    /**
     * Go to a page to preview
     *
     * aPageNumber - Page to go preview
     * Return - PR_TRUE if success
     */
    goToPage(aPageNumber: unsigned_long): boolean;
    /**
     * Skip pages
     *
     * aNumPages - number of pages to skip including the current page. Neg. goes back
     * Return - true if success
     */
    skipPages(aNumPages: long): boolean;
}

/**
 * Simplified graphics interface for JS rendering.
 */
declare interface nsIPrintSettingsType extends nsISupportsType {
    /**
     * Get the page size in twips, considering the
     * orientation (portrait or landscape).
     */
    GetEffectivePageSize(aWidth: double, aHeight: double): void;
    /**
     * Makes a new copy
     */
    clone(): nsIPrintSettings;
    /**
     * Assigns the internal values from the "in" arg to the current object
     */
    assign(aPS: nsIPrintSettingsType): void;
    /**
     * Returns true if the settings will result in an equivalent preview and
     * therefore print. The printer name is ignored and it allows for a small
     * delta in sizes to allow for rounding differences.
     */
    equivalentTo(aPrintSettings: nsIPrintSettingsType): bool;
    /**
     * The edge measurements define the positioning of the headers
     * and footers on the page. They're treated as an offset from the edges of
     * the page, but are forced to be at least the "unwriteable margin"
     * (described below).
     */
    edgeTop: double;
    /**
     * these are in inches
     */
    edgeLeft: double;
    /**
     *
     */
    edgeBottom: double;
    /**
     *
     */
    edgeRight: double;
    /**
     * The margins define the positioning of the content on the page.
     * and footers on the page. They're treated as an offset from the edges of
     * the page, but are forced to be at least the "unwriteable margin," unless
     * set to be ignored (described below).
     */
    marginTop: double;
    /**
     * these are in inches
     */
    marginLeft: double;
    /**
     *
     */
    marginBottom: double;
    /**
     *
     */
    marginRight: double;
    /**
     * The unwriteable margin defines the printable region of the paper.
     */
    unwriteableMarginTop: double;
    /**
     * these are in inches
     */
    unwriteableMarginLeft: double;
    /**
     *
     */
    unwriteableMarginBottom: double;
    /**
     *
     */
    unwriteableMarginRight: double;
    /**
     *
     */
    scaling: double;
    /**
     * values 0.0 - 1.0
     */
    printBGColors: boolean;
    /**
     * Print Background Colors
     */
    printBGImages: boolean;
    /**
     * Print Background Images
     * Whether @page rule margins should be honored or not. If the @page
     * rule sets its margins to zero, we automatically ignore unwriteable
     * margins, but nonzero values will be clamped to unwriteable margins.
     */
    honorPageRuleMargins: boolean;
    /**
     * Whether @page rule size should be used for the output paper size.
     */
    usePageRuleSizeAsPaperSize: boolean;
    /**
     * Whether unwritable margins should be ignored. This should be set when
     * when the user explicitly requests "Margins: None", e.g. for documents
     * where accurate scaling matters. Note: While `honorPageRuleMargins` and
     * this flag can't be set at the same time through the UI, doing so will
     * cause even the nonzero @page rule margins to ignore unwriteable margins.
     */
    ignoreUnwriteableMargins: boolean;
    /**
     * Whether to draw guidelines showing the margin settings
     */
    showMarginGuides: boolean;
    /**
     * Whether to only print the selected nodes
     */
    printSelectionOnly: boolean;
    /**
     *
     */
    title: AString;
    /**
     *
     */
    docURL: AString;
    /**
     *
     */
    headerStrLeft: AString;
    /**
     *
     */
    headerStrCenter: AString;
    /**
     *
     */
    headerStrRight: AString;
    /**
     *
     */
    footerStrLeft: AString;
    /**
     *
     */
    footerStrCenter: AString;
    /**
     *
     */
    footerStrRight: AString;
    /**
     *
     */
    printSilent: boolean;
    /**
     * print without putting up the dialog
     */
    shrinkToFit: boolean;
    /**
     * shrinks content to fit on page
     * Additional XP Related
     */
    paperId: AString;
    /**
     * identifier of paper (not display name)
     */
    paperWidth: double;
    /**
     * width of the paper in inches or mm
     */
    paperHeight: double;
    /**
     * height of the paper in inches or mm
     */
    paperSizeUnit: short;
    /**
     * paper is in inches or mm
     */
    printReversed: boolean;
    /**
     *
     */
    printInColor: boolean;
    /**
     * a false means grayscale
     */
    orientation: long;
    /**
     * see orientation consts
     */
    numCopies: long;
    /**
     * For numPagesPerSheet, we support these values: 1, 2, 4, 6, 9, 16.
     *
     * Unsupported values will be treated internally as 1 page per sheet, and
     * will trigger assertion failures in debug builds.
     */
    numPagesPerSheet: long;
    /**
     * Output device information
     */
    outputDestination: nsIPrintSettings_OutputDestinationType;
    /**
     *
     */
    outputFormat: short;
    /**
     * If outputDestination==kOutputDestinationPrinter, this is set to the name
     * of the printer that the print output should be saved to, but only in the
     * parent process (we don't want to leak printer names to potentially
     * compromised content processes).
     */
    printerName: AString;
    /**
     * If outputDestination==kOutputDestinationFile, this is set to the path
     * of the file that the print output should be saved to, but only in the
     * parent process (we don't want to leak system paths to potentially
     * compromised content processes).
     */
    toFileName: AString;
    /**
     *
     */
    outputStream: nsIOutputStream;
    /**
     * for kOutputDestinationPrinter
     */
    printPageDelay: long;
    /**
     * in milliseconds
     */
    resolution: long;
    /**
     * print resolution (dpi)
     */
    duplex: long;
    /**
     * duplex mode
     * initialize helpers
     * This attribute tracks whether the PS has been initialized
     * from a printer specified by the "printerName" attr.
     * If a different name is set into the "printerName"
     * attribute than the one it was initialized with the PS
     * will then get initialized from that printer.
     */
    isInitializedFromPrinter: boolean;
    /**
     * This attribute tracks whether the PS has been initialized
     * from prefs. If a different name is set into the "printerName"
     * attribute than the one it was initialized with the PS
     * will then get initialized from prefs again.
     */
    isInitializedFromPrefs: boolean;
    /**
     * Get a PrintSettingsInitializer populated with the relevant current settings.
     */
    getSettingsInitializer(): PrintSettingsInitializer;
}

/**
 *
 */
declare interface nsIPrintSettingsServiceType extends nsISupportsType {
    /**
     * Returns the default print settings as used for printing.
     */
    readonly defaultPrintSettingsForPrinting: nsIPrintSettings;
    /**
     * Creates a new nsIPrintSettings object.
     *
     * Initializes the settings object from the unprefixed printer
     * (Note: this may not happen if there is an OS specific implementation.)
     */
    createNewPrintSettings(): nsIPrintSettings;
    /**
     * The name of the last printer used. Note that this may not be set, or may
     * no longer be a valid printer. The caller is responsible for checking and
     * falling back to some other printer (such as the system default printer).
     *
     * XXX: make it [infallible] when AString supports that (bug 1491187).
     */
    readonly lastUsedPrinterName: AString;
    /**
     * Initializes certain settings from the native printer into the PrintSettings
     * if aPrinterName is null then it uses the default printer name if it can
     * These settings include, but are not limited to:
     * Page Orientation
     * Page Size
     * Number of Copies
     */
    initPrintSettingsFromPrinter(aPrinterName: AString, aPrintSettings: nsIPrintSettingsType): void;
    /**
     * Reads PrintSettings values from Prefs,
     * the values to be read are indicated by the "flags" arg.
     *
     * aPrintSettings should be initialized with the name of a printer. First
     * it reads in the PrintSettings from the last print job. Then it uses the
     * PrinterName in the PrinterSettings to read any settings that were saved
     * just for that printer.
     *
     * aPS - PrintSettings to have its settings read
     * aUsePrinterNamePrefix - indicates whether to use the printer name as a prefix
     * aFlags - indicates which prefs to read, see nsIPrintSettings.idl for the
     * const values.
     *
     * Items not read:
     * startPageRange, endPageRange, scaling, printRange, title
     * docURL, isCancelled,
     * printSilent, shrinkToFit, numCopies,
     * printerName
     */
    initPrintSettingsFromPrefs(aPrintSettings: nsIPrintSettingsType, aUsePrinterNamePrefix: boolean, aFlags: unsigned_long): void;
    /**
     * As long as the pref print.save_print_settings isn't set to false, this
     * saves to prefs the settings from aPrintSettings that are indicated by
     * aFlags.
     *
     * If there is no PrinterName in the PrinterSettings
     * the values are saved as the "generic" values not associated with any printer.
     * If a PrinterName is there, then it saves the items qualified for that Printer
     *
     * aPS - PrintSettings to have its settings saved
     * aFlags - indicates which prefs to save, see nsIPrintSettings.idl for the const values.
     *
     * Items not written:
     * startPageRange, endPageRange, scaling, printRange, title
     * docURL, isCancelled,
     * printSilent, shrinkToFit, numCopies
     */
    maybeSavePrintSettingsToPrefs(aPrintSettings: nsIPrintSettingsType, aFlags: unsigned_long): void;
    /**
     * As long as the pref print.save_print_settings isn't set to false, this
     * saves the given printer name as the last used printer name.
     */
    maybeSaveLastUsedPrinterNameToPrefs(aPrinterName: AString): void;
}

/**
 * Simplified PrintSettings for Windows interface
 */
declare interface nsIPrintSettingsWinType extends nsISupportsType {
    /**
     * Data Members
     *
     * Each of these data members make a copy
     * of the contents. If you get the value,
     * you own the memory.
     *
     * The following three pieces of data are needed
     * to create a DC for printing. These are typcially
     * gotten via the PrintDLG call ro can be obtained
     * via the "m_pd" data member of the CPrintDialog
     * in MFC.
     */
    deviceName: AString;
    /**
     *
     */
    driverName: AString;
    /**
     *
     */
    devMode: nsDevMode;
    /**
     * Copy relevant print settings from native Windows device.
     *
     * @param hdc HDC to copy from
     * @param devMode DEVMODE to copy from
     */
    copyFromNative(hdc: nsHdc, devMode: nsDevMode): void;
    /**
     * Copy relevant print settings to native windows structures.
     *
     * @param devMode DEVMODE to be populated.
     */
    copyToNative(devMode: nsDevMode): void;
}

/**
 *
 */
declare interface nsIPrinterInfoType extends nsISupportsType {
    /**
     * nsIPrintSettings object containing the default settings for a printer.
     */
    readonly defaultSettings: nsIPrintSettings;
}

/**
 *
 */
declare interface nsIPrinterType extends nsISupportsType {
    /**
     * The name of the printer.
     */
    readonly name: AString;
    /**
     * The system name of the printer.
     *
     * This may be faster for lookup in nsIPrinterList functions, but will only
     * work for functions that will accept the system name.
     */
    readonly systemName: AString;
    /**
     * Returns a Promise that resolves to a nsIPrinterInfo.
     * This will contain the default printer settings, and the list of paper
     * sizes supported by the printer.
     */
    readonly printerInfo: Promise;
    /**
     * Returns a Promise that resolves to a new settings object that contains all
     * of the settings from aSettingsToCopyFrom that are valid for this printer.
     * Any settings that are not valid for the printer are set to default/fallback
     * values.
     */
    copyFromWithValidation(aSettingsToCopyFrom: nsIPrintSettingsType): Promise;
    /**
     * Returns a Promise that resolves to true or false to indicate whether this
     * printer supports duplex printing.
     */
    readonly supportsDuplex: Promise;
    /**
     * Returns a Promise that resolves to true or false to indicate whether this
     * printer supports color printing.
     */
    readonly supportsColor: Promise;
    /**
     * Returns a Promise that resolves to true or false to indicate whether this
     * printer supports monochrome printing.
     */
    readonly supportsMonochrome: Promise;
    /**
     * Returns a Promise that resolves to true or false to indicate whether this
     * printer supports collation.
     */
    readonly supportsCollation: Promise;
}

/**
 *
 */
declare interface nsIPrinterListType extends nsISupportsType {
    /**
     * Initializes certain settings from the native printer into the PrintSettings
     * These settings include, but are not limited to:
     * Page Orientation
     * Page Size
     * Number of Copies
     */
    initPrintSettingsFromPrinter(aPrinterName: AString, aPrintSettings: nsIPrintSettingsType): void;
    /**
     * The system default printer name. This is not necessarily gecko's
     * default printer; see nsIPrintSettingsService.lastUsedPrinterName
     * for that.
     */
    readonly systemDefaultPrinterName: AString;
    /**
     * Returns a promise that resolves to the printer of a given name, or is
     * rejected if there is no such printer.
     */
    getPrinterByName(aPrinterName: AString): Promise;
    /**
     * Returns a promise that resolves to the printer of a given system name, or
     * is rejected if there is no such printer.
     * This may be more efficient than using getNamedPrinter, but requires the
     * caller to know the system name of the printer they want to find.
     */
    getPrinterBySystemName(aPrinterName: AString): Promise;
    /**
     * Returns a promise that resolves to the printer of the given name, or
     * the default system printer, or is rejected if there are no printers
     * available.
     */
    getNamedOrDefaultPrinter(aPrinterName: AString): Promise;
    /**
     * Returns a promise that resolves to an array of printers.
     */
    readonly printers: Promise;
    /**
     * Returns a Promise that resolves to an array of nsIPaper instances
     * for common paper sizes suitable to be supported for Save to PDF.
     */
    readonly fallbackPaperList: Promise;
}

/**
 *
 */
declare interface nsIPrivacyTransitionObserverType extends nsISupportsType {
    /**
     *
     */
    privateModeChanged(enabled: bool): void;
}

/**
 * This interface is implemented by channels which support overriding the
 * privacy state of the channel.
 *
 * This interface must be used only from the XPCOM main thread.
 */
declare interface nsIPrivateBrowsingChannelType extends nsISupportsType {
    /**
     * Determine whether the channel is tied to a private browsing window.
     *
     * This value can be set only before the channel is opened.  Setting it
     * after that does not have any effect.  This value overrides the privacy
     * state of the channel, which means that if you call this method, then
     * the loadGroup and load context will no longer be consulted when we
     * need to know the private mode status for a channel.
     *
     * Note that this value is only meant to be used when the channel's privacy
     * status cannot be obtained from the loadGroup or load context (for
     * example, when the channel is not associated with any loadGroup or load
     * context.)  Setting this value directly should be avoided if possible.
     *
     * Implementations must enforce the ordering semantics of this function by
     * raising errors if setPrivate is called on a channel which has a loadGroup
     * and/or callbacks that implement nsILoadContext, or if the loadGroup
     * or notificationCallbacks are set after setPrivate has been called.
     *
     * @param aPrivate whether the channel should be opened in private mode.
     */
    setPrivate(aPrivate: boolean): void;
    /**
     * States whether the channel is in private browsing mode. This may either
     * happen because the channel is opened from a private mode context or
     * when the mode is explicitly set with ::setPrivate().
     *
     * This attribute is equivalent to NS_UsePrivateBrowsing(), but scriptable.
     */
    readonly isChannelPrivate: boolean;
}

/**
 *
 */
declare interface nsIProcessType extends nsISupportsType {
    /**
     * Initialises the process with an executable to be run. Call the run method
     * to run the executable.
     * @param executable The executable to run.
     */
    init(executable: nsIFileType): void;
    /**
     * Kills the running process. After exiting the process will either have
     * been killed or a failure will have been returned.
     */
    kill(): void;
    /**
     * Executes the file this object was initialized with
     * @param blocking   Whether to wait until the process terminates before
     * returning or not.
     * @param args       An array of arguments to pass to the process in the
     * native character set.
     * @param count      The length of the args array.
     */
    run(blocking: boolean, args: string[], count: unsigned_long): void;
    /**
     * Executes the file this object was initialized with optionally calling
     * an observer after the process has finished running.
     * @param args       An array of arguments to pass to the process in the
     * native character set.
     * @param count      The length of the args array.
     * @param observer   An observer to notify when the process has completed. It
     * will receive this process instance as the subject and
     * "process-finished" or "process-failed" as the topic. The
     * observer will be notified on the main thread.
     * @param holdWeak   Whether to use a weak reference to hold the observer.
     */
    runAsync(args: string[], count: unsigned_long, observer: nsIObserverType, holdWeak: boolean): void;
    /**
     * Executes the file this object was initialized with
     * @param blocking   Whether to wait until the process terminates before
     * returning or not.
     * @param args       An array of arguments to pass to the process in UTF-16
     * @param count      The length of the args array.
     */
    runw(blocking: boolean, args: wstring[], count: unsigned_long): void;
    /**
     * Executes the file this object was initialized with optionally calling
     * an observer after the process has finished running.
     * @param args       An array of arguments to pass to the process in UTF-16
     * @param count      The length of the args array.
     * @param observer   An observer to notify when the process has completed. It
     * will receive this process instance as the subject and
     * "process-finished" or "process-failed" as the topic. The
     * observer will be notified on the main thread.
     * @param holdWeak   Whether to use a weak reference to hold the observer.
     */
    runwAsync(args: wstring[], count: unsigned_long, observer: nsIObserverType, holdWeak: boolean): void;
    /**
     * When set to true the process will not open a new window when started and
     * will run hidden from the user. This currently affects only the Windows
     * platform.
     */
    startHidden: boolean;
    /**
     * When set to true the process will be launched directly without using the
     * shell. This currently affects only the Windows platform.
     */
    noShell: boolean;
    /**
     * The process identifier of the currently running process. This will only
     * be available after the process has started and may not be available on
     * some platforms.
     */
    readonly pid: unsigned_long;
    /**
     * The exit value of the process. This is only valid after the process has
     * exited.
     */
    readonly exitValue: long;
    /**
     * Returns whether the process is currently running or not.
     */
    readonly isRunning: boolean;
}

/**
 *
 */
declare interface nsIProcessToolsServiceType extends nsISupportsType {
    /**
     * Kill a process running on this system.
     *
     * Does not cause a crash report to be generated and sent.
     *
     * # Note
     *
     * `pid` is the unique-to-the-system process identifier, as
     * obtained with attribute `pid` of this service.
     *
     * Under Un*ix, that's what you obtain with `getpid()`, etc.
     * Under Windows, that's what you obtain with `GetCurrentProcessId()`,
     * NOT the same thing as the process `HANDLE`.
     *
     * # Failure
     *
     * Under Windows, if two processes race to `kill()` a third process,
     * or two threads race to `kill()` a process there is a (small) window
     * during which this can cause a crash in the losing process.
     *
     * # Caveats
     *
     * Under Windows, process killing is asynchronous. Therefore, this
     * function can return before process `pid` is actually dead.
     */
    kill(pid: unsigned_long_long): void;
    /**
     * Crash a process running on this system. Generates a SIGABRT on Linux and
     * macOS, and a STATUS_ILLEGAL_INSTRUCTION on Windows.
     *
     * Does cause a crash report to be generated.
     */
    crash(pid: unsigned_long_long): void;
    /**
     * The pid for the current process.
     */
    readonly pid: unsigned_long_long;
}

/**
 * Helper interface for nsIProfileMigrator.
 *
 * @provider Toolkit (Startup code)
 * @client   Application (Profile-migration code)
 * @obtainable nsIProfileMigrator.migrate
 */
declare interface nsIProfileStartupType extends nsISupportsType {
    /**
     * The root directory of the semi-current profile, during profile migration.
     * After nsIProfileMigrator.migrate has returned, this object will not be
     * useful.
     */
    readonly directory: nsIFile;
    /**
     * Do profile-startup by setting NS_APP_USER_PROFILE_50_DIR in the directory
     * service and notifying the profile-startup observer topics.
     */
    doStartup(): void;
}

/**
 * Migrate application settings from an outside source.
 *
 * @provider Application (Profile-migration code)
 * @client   Toolkit (Startup code)
 * @obtainable service, contractid("@mozilla.org/toolkit/profile-migrator;1")
 */
declare interface nsIProfileMigratorType extends nsISupportsType {
    /**
     * Migrate data from an outside source, if possible.  Does nothing
     * otherwise.
     *
     * When this method is called, a default profile has been created;
     * XPCOM has been initialized such that compreg.dat is in the
     * profile; the directory service does *not* return a key for
     * NS_APP_USER_PROFILE_50_DIR or any of the keys depending on an active
     * profile. To figure out the directory of the "current" profile, use
     * aStartup.directory.
     *
     * If your migrator needs to access services that use the profile (to
     * set profile prefs or bookmarks, for example), use aStartup.doStartup.
     *
     * @param  aStartup nsIProfileStartup object to use during migration.
     * @param  aKey     optional key of a migrator to use to skip source selection.
     * @param  aProfileName optional name of the profile to use for migration.
     *
     * @note The startup code ignores COM exceptions thrown from this method.
     */
    migrate(aStartup: nsIProfileStartupType, aKey: ACString, aProfileName: AUTF8String): void;
}

/**
 *
 */
declare interface nsIProfileUnlockerType extends nsISupportsType {
    /**
     * Try to unlock the specified profile by attempting or forcing the
     * process that currently holds the lock to quit.
     *
     * @param aSeverity either ATTEMPT_QUIT or FORCE_QUIT
     * @throws NS_ERROR_FAILURE if unlocking failed.
     */
    unlock(aSeverity: unsigned_long): void;
}

/**
 * Start-up parameters for subprocesses are passed through nsIObserverService,
 * which, unfortunately, means we need to implement nsISupports in order to
 * go through it.
 */
declare interface nsIProfilerStartParamsType extends nsISupportsType {
    /**
     *
     */
    readonly entries: uint32_t;
    /**
     *
     */
    readonly duration: double;
    /**
     *
     */
    readonly interval: double;
    /**
     *
     */
    readonly features: uint32_t;
    /**
     *
     */
    readonly activeTabID: uint64_t;
}

/**
 *
 */
declare interface nsIProfilerType extends nsISupportsType {
    /**
     * Control functions return as soon as this process' profiler has done its
     * work. The returned promise gets resolved when sub-processes have completed
     * their operation, or immediately if there are no sub-processes.
     */
    StartProfiler(aEntries: uint32_t, aInterval: double, aFeatures: invalid, aFilters: invalid, aActiveTabID: uint64_t, aDuration: double): Promise;
    /**
     *
     */
    StopProfiler(): Promise;
    /**
     *
     */
    IsPaused(): boolean;
    /**
     *
     */
    Pause(): Promise;
    /**
     *
     */
    Resume(): Promise;
    /**
     *
     */
    IsSamplingPaused(): boolean;
    /**
     *
     */
    PauseSampling(): Promise;
    /**
     *
     */
    ResumeSampling(): Promise;
    /**
     * Resolves the returned promise after at least one full periodic sampling in
     * each process.
     * Rejects the promise if sampler is not running (yet, or anymore, or paused)
     * in the parent process.
     * This is mainly useful in tests, to wait just long enough to guarantee that
     * at least one sample was taken in each process.
     */
    waitOnePeriodicSampling(): Promise;
    /**
     * Returns the JSON string of the profile. If aSinceTime is passed, only
     * report samples taken at >= aSinceTime.
     */
    GetProfile(aSinceTime: double): string;
    /**
     * Returns a JS object of the profile. If aSinceTime is passed, only report
     * samples taken at >= aSinceTime.
     */
    getProfileData(aSinceTime: double): jsval;
    /**
     *
     */
    getProfileDataAsync(aSinceTime: double): Promise;
    /**
     *
     */
    getProfileDataAsArrayBuffer(aSinceTime: double): Promise;
    /**
     *
     */
    getProfileDataAsGzippedArrayBuffer(aSinceTime: double): Promise;
    /**
     * Asynchronously dump the profile collected so far to a file.
     * Returns a promise that resolves once the file has been written, with data
     * from all responsive Firefox processes. Note: This blocks the parent process
     * while collecting its own data, then unblocks while child processes data is
     * being collected.
     * `aFilename` may be a full path, or a path relative to where Firefox was
     * launched. The target directory must already exist.
     */
    dumpProfileToFileAsync(aFilename: ACString, aSinceTime: double): Promise;
    /**
     * Synchronously dump the profile collected so far in this process to a file.
     * This profile will only contain data from the parent process, and from child
     * processes that have ended during the session; other currently-live
     * processes are ignored.
     * `aFilename` may be a full path, or a path relative to where Firefox was
     * launched. The target directory must already exist.
     */
    dumpProfileToFile(aFilename: string): void;
    /**
     *
     */
    IsActive(): boolean;
    /**
     * Clear all registered and unregistered page information in prifiler.
     */
    ClearAllPages(): void;
    /**
     * Returns a JavaScript object that contains a description of the currently configured
     * state of the profiler when the profiler is active. This can be useful to assert
     * the UI of the profiler's recording panel in tests. It returns null when the profiler
     * is not active.
     */
    readonly activeConfiguration: jsval;
    /**
     *
     */
    GetBufferInfo(aCurrentPosition: uint32_t, aTotalSize: uint32_t, aGeneration: uint32_t): void;
    /**
     * Returns the elapsed time, in milliseconds, since the profiler's epoch.
     * The epoch is guaranteed to be constant for the duration of the
     * process, but is otherwise arbitrary.
     */
    getElapsedTime(): double;
    /**
     * Contains an array of shared library objects.
     * Every object has the properties:
     * - start:      The start address of the memory region occupied by this library.
     * - end:        The end address of the memory region occupied by this library.
     * - offset:     Usually zero, except on Linux / Android if the first mapped
     * section of the library has been mapped to an address that's
     * different from the library's base address.
     * Then offset = start - baseAddress.
     * - name:       The name (file basename) of the binary.
     * - path:       The full absolute path to the binary.
     * - debugName:  On Windows, the name of the pdb file for the binary. On other
     * platforms, the same as |name|.
     * - debugPath:  On Windows, the full absolute path of the pdb file for the
     * binary. On other platforms, the same as |path|.
     * - arch:       On Mac, the name of the architecture that identifies the right
     * binary image of a fat binary. Example values are "i386", "x86_64",
     * and "x86_64h". (x86_64h is used for binaries that contain
     * instructions that are specific to the Intel Haswell microarchitecture.)
     * On non-Mac platforms, arch is "".
     * - breakpadId: A unique identifier string for this library, as used by breakpad.
     */
    readonly sharedLibraries: jsval;
    /**
     * Returns a promise that resolves to a SymbolTableAsTuple for the binary at
     * the given path.
     *
     * SymbolTable as tuple: [addrs, index, buffer]
     * Contains a symbol table, which can be used to map addresses to strings.
     *
     * The first element of this tuple, commonly named "addrs", is a sorted array of
     * symbol addresses, as library-relative offsets in bytes, in ascending order.
     * The third element of this tuple, commonly named "buffer", is a buffer of
     * bytes that contains all strings from this symbol table, in the order of the
     * addresses they correspond to, in utf-8 encoded form, all concatenated
     * together.
     * The second element of this tuple, commonly named "index", contains positions
     * into "buffer". For every address, that position is where the string for that
     * address starts in the buffer.
     * index.length == addrs.length + 1.
     * index[addrs.length] is the end position of the last string in the buffer.
     *
     * The string for the address addrs[i] is
     * (new TextDecoder()).decode(buffer.subarray(index[i], index[i + 1]))
     */
    getSymbolTable(aDebugPath: ACString, aBreakpadID: ACString): Promise;
    /**
     *
     */
    getProfileDataAsGzippedArrayBufferAndroid(aSinceTime: double): ProfileDataBufferMozPromise;
}

/**
 * nsIProgressEventSink
 *
 * This interface is used to asynchronously convey channel status and progress
 * information that is generally not critical to the processing of the channel.
 * The information is intended to be displayed to the user in some meaningful
 * way.
 *
 * An implementation of this interface can be passed to a channel via the
 * channel's notificationCallbacks attribute.  See nsIChannel for more info.
 *
 * The channel will begin passing notifications to the progress event sink
 * after its asyncOpen method has been called.  Notifications will cease once
 * the channel calls its listener's onStopRequest method or once the channel
 * is canceled (via nsIRequest::cancel).
 *
 * NOTE: This interface is actually not specific to channels and may be used
 * with other implementations of nsIRequest.
 */
declare interface nsIProgressEventSinkType extends nsISupportsType {
    /**
     * Called to notify the event sink that progress has occurred for the
     * given request.
     *
     * @param aRequest
     * the request being observed (may QI to nsIChannel).
     * @param aProgress
     * numeric value in the range 0 to aProgressMax indicating the
     * number of bytes transfered thus far.
     * @param aProgressMax
     * numeric value indicating maximum number of bytes that will be
     * transfered (or -1 if total is unknown).
     */
    onProgress(aRequest: nsIRequestType, aProgress: long_long, aProgressMax: long_long): void;
    /**
     * Called to notify the event sink with a status message for the given
     * request.
     *
     * @param aRequest
     * the request being observed (may QI to nsIChannel).
     * @param aStatus
     * status code (not necessarily an error code) indicating the
     * state of the channel (usually the state of the underlying
     * transport).  see nsISocketTransport for socket specific status
     * codes.
     * @param aStatusArg
     * status code argument to be used with the string bundle service
     * to convert the status message into localized, human readable
     * text.  the meaning of this parameter is specific to the value
     * of the status code.  for socket status codes, this parameter
     * indicates the host:port associated with the status code.
     */
    onStatus(aRequest: nsIRequestType, aStatus: nsresult, aStatusArg: wstring): void;
}

/**
 *
 */
declare interface nsIPromptType extends nsISupportsType {
    /**
     *
     */
    alert(dialogTitle: wstring, text: wstring): void;
    /**
     *
     */
    alertCheck(dialogTitle: wstring, text: wstring, checkMsg: wstring, checkValue: boolean): void;
    /**
     *
     */
    confirm(dialogTitle: wstring, text: wstring): boolean;
    /**
     *
     */
    confirmCheck(dialogTitle: wstring, text: wstring, checkMsg: wstring, checkValue: boolean): boolean;
    /**
     *
     */
    confirmEx(dialogTitle: wstring, text: wstring, buttonFlags: unsigned_long, button0Title: wstring, button1Title: wstring, button2Title: wstring, checkMsg: wstring, checkValue: boolean): int32_t;
    /**
     *
     */
    prompt(dialogTitle: wstring, text: wstring, value: wstring, checkMsg: wstring, checkValue: boolean): boolean;
    /**
     *
     */
    promptPassword(dialogTitle: wstring, text: wstring, password: wstring): boolean;
    /**
     *
     */
    promptUsernameAndPassword(dialogTitle: wstring, text: wstring, username: wstring, password: wstring): boolean;
    /**
     *
     */
    select(dialogTitle: wstring, text: wstring, selectList: invalid, outSelection: long): boolean;
}

/**
 * This interface contains various specialized prompts that the app can
 * implement.
 */
declare interface nsIPromptCollectionType extends nsISupportsType {
    /**
     * Puts up a dialog for the before unload prompt.
     *
     * @param aBrowsingContext
     * The browsing context the prompt should be opened for.
     *
     * @return Promise which resolves to true if the page should be allowed to
     * navigate away
     */
    asyncBeforeUnloadCheck(aBrowsingContext: BrowsingContext): Promise;
    /**
     * Puts up a dialog for the confirm repost prompt.
     *
     * @param aBrowsingContext
     * The browsing context the prompt should be opened for.
     *
     * @return true if the page should be allowed to repost data.
     */
    confirmRepost(aBrowsingContext: BrowsingContext): boolean;
    /**
     * Ask the user for confirmation to upload a selected folder.
     *
     * @param aBrowsingContext
     * The browsing context the prompt should be opened for.
     * @param aDirectoryName
     * Name of the folder that will be uploaded.
     *
     * @return true if the user confirmed the upload, false otherwise.
     */
    confirmFolderUpload(aBrowsingContext: BrowsingContext, aDirectoryName: AString): boolean;
}

/**
 * This interface allows creating various prompts that have a specific parent.
 */
declare interface nsIPromptFactoryType extends nsISupportsType {
    /**
     * Returns an object implementing the specified interface that creates
     * prompts parented to aParent.
     */
    getPrompt(aParent: mozIDOMWindowProxy, iid: nsIIDRefType, result: nsQIResult): void;
}

/**
 * An object representing a prompt or doorhanger.
 */
declare interface nsIPromptInstanceType extends nsISupportsType {
    /**
     * Dismiss this prompt (e.g. because it's not relevant anymore).
     */
    dismiss(): void;
}

/**
 * This is the interface to the embeddable prompt service; the service that
 * implements nsIPrompt.  Its interface is designed to be just nsIPrompt, each
 * method modified to take a parent window parameter.
 *
 * Accesskeys can be attached to buttons and checkboxes by inserting an &
 * before the accesskey character in the checkbox message or button title.  For
 * a real &, use && instead.  (A "button title" generally refers to the text
 * label of a button.)
 *
 * One note: in all cases, the parent window parameter can be null.  However,
 * these windows are all intended to have parents.  So when no parent is
 * specified, the implementation should try hard to find a suitable foster
 * parent.
 *
 * Implementations are free to choose how they present the various button
 * types.  For example, while prompts that give the user a choice between OK
 * and Cancel are required to return a boolean value indicating whether or not
 * the user accepted the prompt (pressed OK) or rejected the prompt (pressed
 * Cancel), the implementation of this interface could very well speak the
 * prompt to the user instead of rendering any visual user-interface.  The
 * standard button types are merely idioms used to convey the nature of the
 * choice the user is to make.
 *
 * Because implementations of this interface may loosely interpret the various
 * button types, it is advised that text messages passed to these prompts do
 * not refer to the button types by name.  For example, it is inadvisable to
 * tell the user to "Press OK to proceed."  Instead, such a prompt might be
 * rewritten to ask the user: "Would you like to proceed?"
 */
declare interface nsIPromptServiceType extends nsISupportsType {
    /**
     * Puts up an alert dialog with an OK button.
     *
     * @param aParent
     * The parent window or null.
     * @param aDialogTitle
     * Text to appear in the title of the dialog.
     * @param aText
     * Text to appear in the body of the dialog.
     */
    alert(aParent: mozIDOMWindowProxy, aDialogTitle: wstring, aText: wstring): void;
    /**
     * Like alert, but with a BrowsingContext as parent.
     *
     * @param aBrowsingContext
     * The browsing context the prompt should be opened for.
     * @param modalType
     * Whether the prompt should be window, tab or content modal.
     */
    alertBC(aBrowsingContext: BrowsingContext, modalType: unsigned_long, aDialogTitle: wstring, aText: wstring): void;
    /**
     * Async version of alertBC
     *
     * @return A promise which resolves when the prompt is dismissed.
     */
    asyncAlert(aBrowsingContext: BrowsingContext, modalType: unsigned_long, aDialogTitle: wstring, aText: wstring): Promise;
    /**
     * Puts up an alert dialog with an OK button and a labeled checkbox.
     *
     * @param aParent
     * The parent window or null.
     * @param aDialogTitle
     * Text to appear in the title of the dialog.
     * @param aText
     * Text to appear in the body of the dialog.
     * @param aCheckMsg
     * Text to appear with the checkbox.
     * @param aCheckState
     * Contains the initial checked state of the checkbox when this method
     * is called and the final checked state after this method returns.
     */
    alertCheck(aParent: mozIDOMWindowProxy, aDialogTitle: wstring, aText: wstring, aCheckMsg: wstring, aCheckState: boolean): void;
    /**
     * Like alertCheck, but with a BrowsingContext as parent.
     *
     * @param aBrowsingContext
     * The browsing context the prompt should be opened for.
     * @param modalType
     * Whether the prompt should be window, tab or content modal.
     */
    alertCheckBC(aBrowsingContext: BrowsingContext, modalType: unsigned_long, aDialogTitle: wstring, aText: wstring, aCheckMsg: wstring, aCheckState: boolean): void;
    /**
     * Async version of alertCheckBC
     *
     * @return A promise which resolves when the prompt is dismissed.
     *
     * @resolves nsIPropertyBag { checked: boolean }
     */
    asyncAlertCheck(aBrowsingContext: BrowsingContext, modalType: unsigned_long, aDialogTitle: wstring, aText: wstring, aCheckMsg: wstring, aCheckState: boolean): Promise;
    /**
     * Puts up a dialog with OK and Cancel buttons.
     *
     * @param aParent
     * The parent window or null.
     * @param aDialogTitle
     * Text to appear in the title of the dialog.
     * @param aText
     * Text to appear in the body of the dialog.
     *
     * @return true for OK, false for Cancel
     */
    confirm(aParent: mozIDOMWindowProxy, aDialogTitle: wstring, aText: wstring): boolean;
    /**
     * Like confirm, but with a BrowsingContext as parent.
     *
     * @param aBrowsingContext
     * The browsing context the prompt should be opened for.
     * @param modalType
     * Whether the prompt should be window, tab or content modal.
     */
    confirmBC(aBrowsingContext: BrowsingContext, modalType: unsigned_long, aDialogTitle: wstring, aText: wstring): boolean;
    /**
     * Async version of confirmBC
     *
     * @return A promise which resolves when the prompt is dismissed.
     *
     * @resolves nsIPropertyBag { ok: boolean }
     */
    asyncConfirm(aBrowsingContext: BrowsingContext, modalType: unsigned_long, aDialogTitle: wstring, aText: wstring): Promise;
    /**
     * Puts up a dialog with OK and Cancel buttons and a labeled checkbox.
     *
     * @param aParent
     * The parent window or null.
     * @param aDialogTitle
     * Text to appear in the title of the dialog.
     * @param aText
     * Text to appear in the body of the dialog.
     * @param aCheckMsg
     * Text to appear with the checkbox.
     * @param aCheckState
     * Contains the initial checked state of the checkbox when this method
     * is called and the final checked state after this method returns.
     *
     * @return true for OK, false for Cancel
     */
    confirmCheck(aParent: mozIDOMWindowProxy, aDialogTitle: wstring, aText: wstring, aCheckMsg: wstring, aCheckState: boolean): boolean;
    /**
     * Like confirmCheck, but with a BrowsingContext as parent.
     *
     * @param aBrowsingContext
     * The browsing context the prompt should be opened for.
     * @param modalType
     * Whether the prompt should be window, tab or content modal.
     */
    confirmCheckBC(aBrowsingContext: BrowsingContext, modalType: unsigned_long, aDialogTitle: wstring, aText: wstring, aCheckMsg: wstring, aCheckState: boolean): boolean;
    /**
     * Async version of confirmCheckBC
     *
     * @return A promise which resolves when the prompt is dismissed.
     *
     * @resolves nsIPropertyBag { ok: boolean, checked: boolean }
     */
    asyncConfirmCheck(aBrowsingContext: BrowsingContext, modalType: unsigned_long, aDialogTitle: wstring, aText: wstring, aCheckMsg: wstring, aCheckState: boolean): Promise;
    /**
     * Puts up a dialog with up to 3 buttons and an optional, labeled checkbox.
     *
     * @param aParent
     * The parent window or null.
     * @param aDialogTitle
     * Text to appear in the title of the dialog.
     * @param aText
     * Text to appear in the body of the dialog.
     * @param aButtonFlags
     * A combination of Button Flags.
     * @param aButton0Title
     * Used when button 0 uses TITLE_IS_STRING
     * @param aButton1Title
     * Used when button 1 uses TITLE_IS_STRING
     * @param aButton2Title
     * Used when button 2 uses TITLE_IS_STRING
     * @param aCheckMsg
     * Text to appear with the checkbox.  Null if no checkbox.
     * @param aCheckState
     * Contains the initial checked state of the checkbox when this method
     * is called and the final checked state after this method returns.
     *
     * @return index of the button pressed.
     *
     * Buttons are numbered 0 - 2. The implementation can decide whether the
     * sequence goes from right to left or left to right.  Button 0 is the
     * default button unless one of the Button Default Flags is specified.
     *
     * A button may use a predefined title, specified by one of the Button Title
     * Flags values.  Each title value can be multiplied by a position value to
     * assign the title to a particular button.  If BUTTON_TITLE_IS_STRING is
     * used for a button, the string parameter for that button will be used.  If
     * the value for a button position is zero, the button will not be shown.
     *
     * In general, aButtonFlags is constructed per the following example:
     *
     * aButtonFlags = (BUTTON_POS_0) * (BUTTON_TITLE_AAA) +
     * (BUTTON_POS_1) * (BUTTON_TITLE_BBB) +
     * BUTTON_POS_1_DEFAULT;
     *
     * where "AAA" and "BBB" correspond to one of the button titles.
     */
    confirmEx(aParent: mozIDOMWindowProxy, aDialogTitle: wstring, aText: wstring, aButtonFlags: unsigned_long, aButton0Title: wstring, aButton1Title: wstring, aButton2Title: wstring, aCheckMsg: wstring, aCheckState: boolean): int32_t;
    /**
     * Like confirmEx, but with a BrowsingContext as parent.
     *
     * @param aBrowsingContext
     * The browsing context the prompt should be opened for.
     * @param modalType
     * Whether the prompt should be window, tab or content modal.
     */
    confirmExBC(aBrowsingContext: BrowsingContext, modalType: unsigned_long, aDialogTitle: wstring, aText: wstring, aButtonFlags: unsigned_long, aButton0Title: wstring, aButton1Title: wstring, aButton2Title: wstring, aCheckMsg: wstring, aCheckState: boolean): int32_t;
    /**
     * Async version of confirmExBC
     *
     * @return A promise which resolves when the prompt is dismissed.
     *
     * @resolves nsIPropertyBag { checked: boolean, buttonNumClicked: int }
     */
    asyncConfirmEx(aBrowsingContext: BrowsingContext, modalType: unsigned_long, aDialogTitle: wstring, aText: wstring, aButtonFlags: unsigned_long, aButton0Title: wstring, aButton1Title: wstring, aButton2Title: wstring, aCheckMsg: wstring, aCheckState: boolean, aExtraArgs: jsval): Promise;
    /**
     * Puts up a dialog with an edit field and an optional, labeled checkbox.
     *
     * @param aParent
     * The parent window or null.
     * @param aDialogTitle
     * Text to appear in the title of the dialog.
     * @param aText
     * Text to appear in the body of the dialog.
     * @param aValue
     * Contains the default value for the dialog field when this method
     * is called (null value is ok).  Upon return, if the user pressed
     * OK, then this parameter contains a newly allocated string value.
     * Otherwise, the parameter's value is unmodified.
     * @param aCheckMsg
     * Text to appear with the checkbox.  If null, check box will not be shown.
     * @param aCheckState
     * Contains the initial checked state of the checkbox when this method
     * is called and the final checked state after this method returns.
     *
     * @return true for OK, false for Cancel.
     */
    prompt(aParent: mozIDOMWindowProxy, aDialogTitle: wstring, aText: wstring, aValue: wstring, aCheckMsg: wstring, aCheckState: boolean): boolean;
    /**
     * Like prompt, but with a BrowsingContext as parent.
     *
     * @param aBrowsingContext
     * The browsing context the prompt should be opened for.
     * @param modalType
     * Whether the prompt should be window, tab or content modal.
     */
    promptBC(aBrowsingContext: BrowsingContext, modalType: unsigned_long, aDialogTitle: wstring, aText: wstring, aValue: wstring, aCheckMsg: wstring, aCheckState: boolean): boolean;
    /**
     * Async version of promptBC
     *
     * @return A promise which resolves when the prompt is dismissed.
     *
     * @resolves nsIPropertyBag { checked: boolean, value: string, ok: boolean }
     */
    asyncPrompt(aBrowsingContext: BrowsingContext, modalType: unsigned_long, aDialogTitle: wstring, aText: wstring, aValue: wstring, aCheckMsg: wstring, aCheckState: boolean): Promise;
    /**
     * Puts up a dialog with an edit field and a password field.
     *
     * @param aParent
     * The parent window or null.
     * @param aDialogTitle
     * Text to appear in the title of the dialog.
     * @param aText
     * Text to appear in the body of the dialog.
     * @param aUsername
     * Contains the default value for the username field when this method
     * is called (null value is ok).  Upon return, if the user pressed OK,
     * then this parameter contains a newly allocated string value.
     * Otherwise, the parameter's value is unmodified.
     * @param aPassword
     * Contains the default value for the password field when this method
     * is called (null value is ok).  Upon return, if the user pressed OK,
     * then this parameter contains a newly allocated string value.
     * Otherwise, the parameter's value is unmodified.
     *
     * @return true for OK, false for Cancel.
     */
    promptUsernameAndPassword(aParent: mozIDOMWindowProxy, aDialogTitle: wstring, aText: wstring, aUsername: wstring, aPassword: wstring): boolean;
    /**
     * Like promptUsernameAndPassword, but with a BrowsingContext as parent.
     *
     * @param aBrowsingContext
     * The browsing context the prompt should be opened for.
     * @param modalType
     * Whether the prompt should be window, tab or content modal.
     */
    promptUsernameAndPasswordBC(aBrowsingContext: BrowsingContext, modalType: unsigned_long, aDialogTitle: wstring, aText: wstring, aUsername: wstring, aPassword: wstring): boolean;
    /**
     * Async version of promptUsernameAndPasswordBC
     *
     * @return A promise which resolves when the prompt is dismissed.
     *
     * @resolves nsIPropertyBag { user: string, pass: string, ok: boolean }
     */
    asyncPromptUsernameAndPassword(aBrowsingContext: BrowsingContext, modalType: unsigned_long, aDialogTitle: wstring, aText: wstring, aUsername: wstring, aPassword: wstring): Promise;
    /**
     * Puts up a dialog with a password field.
     *
     * @param aParent
     * The parent window or null.
     * @param aDialogTitle
     * Text to appear in the title of the dialog.
     * @param aText
     * Text to appear in the body of the dialog.
     * @param aPassword
     * Contains the default value for the password field when this method
     * is called (null value is ok).  Upon return, if the user pressed OK,
     * then this parameter contains a newly allocated string value.
     * Otherwise, the parameter's value is unmodified.
     *
     * @return true for OK, false for Cancel.
     */
    promptPassword(aParent: mozIDOMWindowProxy, aDialogTitle: wstring, aText: wstring, aPassword: wstring): boolean;
    /**
     * Like promptPassword, but with a BrowsingContext as parent.
     *
     * @param aBrowsingContext
     * The browsing context the prompt should be opened for.
     * @param modalType
     * Whether the prompt should be window, tab or content modal.
     */
    promptPasswordBC(aBrowsingContext: BrowsingContext, modalType: unsigned_long, aDialogTitle: wstring, aText: wstring, aPassword: wstring): boolean;
    /**
     * Async version of promptPasswordBC
     *
     * @return A promise which resolves when the prompt is dismissed.
     *
     * @resolves nsIPropertyBag { pass: string, ok: boolean }
     */
    asyncPromptPassword(aBrowsingContext: BrowsingContext, modalType: unsigned_long, aDialogTitle: wstring, aText: wstring, aPassword: wstring): Promise;
    /**
     * Puts up a dialog box which has a list box of strings from which the user
     * may make a single selection.
     *
     * @param aParent
     * The parent window or null.
     * @param aDialogTitle
     * Text to appear in the title of the dialog.
     * @param aText
     * Text to appear in the body of the dialog.
     * @param aSelectList
     * The list of strings to display.
     * @param aOutSelection
     * Contains the index of the selected item in the list when this
     * method returns true.
     *
     * @return true for OK, false for Cancel.
     */
    select(aParent: mozIDOMWindowProxy, aDialogTitle: wstring, aText: wstring, aSelectList: invalid, aOutSelection: long): boolean;
    /**
     * Like select, but with a BrowsingContext as parent.
     *
     * @param aBrowsingContext
     * The browsing context the prompt should be opened for.
     * @param modalType
     * Whether the prompt should be window, tab or content modal.
     */
    selectBC(aBrowsingContext: BrowsingContext, modalType: unsigned_long, aDialogTitle: wstring, aText: wstring, aSelectList: invalid, aOutSelection: long): boolean;
    /**
     * Async version of selectBC
     *
     * @return A promise which resolves when the prompt is dismissed.
     *
     * @resolves nsIPropertyBag { selected: int, ok: boolean }
     */
    asyncSelect(aBrowsingContext: BrowsingContext, modalType: unsigned_long, aDialogTitle: wstring, aText: wstring, aSelectList: invalid): Promise;
    /**
     *
     */
    promptAuth(aParent: mozIDOMWindowProxy, aChannel: nsIChannelType, level: uint32_t, authInfo: nsIAuthInformationType): boolean;
    /**
     * Like promptAuth, but with a BrowsingContext as parent.
     *
     * @param aBrowsingContext
     * The browsing context the prompt should be opened for.
     * @param modalType
     * Whether the prompt should be window, tab or content modal.
     */
    promptAuthBC(aBrowsingContext: BrowsingContext, modalType: unsigned_long, aChannel: nsIChannelType, level: uint32_t, authInfo: nsIAuthInformationType): boolean;
    /**
     * Async version of promptAuthBC
     *
     * @return A promise which resolves when the prompt is dismissed.
     *
     * @resolves nsIPropertyBag { ok: boolean }
     */
    asyncPromptAuth(aBrowsingContext: BrowsingContext, modalType: unsigned_long, aChannel: nsIChannelType, level: uint32_t, authInfo: nsIAuthInformationType): Promise;
}

/**
 * Simple mapping service interface.
 */
declare interface nsIPropertiesType extends nsISupportsType {
    /**
     * Gets a property with a given name.
     *
     * @throws NS_ERROR_FAILURE if a property with that name doesn't exist.
     * @throws NS_ERROR_NO_INTERFACE if the found property fails to QI to the
     * given iid.
     */
    get(prop: string, iid: nsIIDRefType, result: nsQIResult): void;
    /**
     * Sets a property with a given name to a given value.
     */
    set(prop: string, value: nsISupportsType): void;
    /**
     * Returns true if the property with the given name exists.
     */
    has(prop: string): boolean;
    /**
     * Undefines a property.
     * @throws NS_ERROR_FAILURE if a property with that name doesn't
     * already exist.
     */
    undefine(prop: string): void;
}

/**
 *
 */
declare interface nsIPropertyType extends nsISupportsType {
    /**
     * Get the name of the property.
     */
    readonly name: AString;
    /**
     * Get the value of the property.
     */
    readonly value: nsIVariant;
}

/**
 *
 */
declare interface nsIPropertyBagType extends nsISupportsType {
    /**
     * Get a nsISimpleEnumerator whose elements are nsIProperty objects.
     */
    readonly enumerator: nsISimpleEnumerator;
    /**
     * Get a property value for the given name.
     * @throws NS_ERROR_FAILURE if a property with that name doesn't
     * exist.
     */
    getProperty(name: AString): nsIVariant;
}

/**
 *
 */
declare interface nsIPropertyBag2Type extends nsIPropertyBagType {
    /**
     *
     */
    getPropertyAsInt32(prop: AString): int32_t;
    /**
     *
     */
    getPropertyAsUint32(prop: AString): uint32_t;
    /**
     *
     */
    getPropertyAsInt64(prop: AString): int64_t;
    /**
     *
     */
    getPropertyAsUint64(prop: AString): uint64_t;
    /**
     *
     */
    getPropertyAsDouble(prop: AString): double;
    /**
     *
     */
    getPropertyAsAString(prop: AString): AString;
    /**
     *
     */
    getPropertyAsACString(prop: AString): ACString;
    /**
     *
     */
    getPropertyAsAUTF8String(prop: AString): AUTF8String;
    /**
     *
     */
    getPropertyAsBool(prop: AString): boolean;
    /**
     * This method returns null if the value exists, but is null.
     *
     * Note: C++ callers should not use this method. They should use the
     * typesafe `do_GetProperty` wrapper instead.
     */
    getPropertyAsInterface(prop: AString, iid: nsIIDRefType, result: nsQIResult): void;
    /**
     * This method returns null if the value does not exist,
     * or exists but is null.
     */
    get(prop: AString): nsIVariant;
    /**
     * Check for the existence of a key.
     */
    hasKey(prop: AString): boolean;
}

/**
 * Used to communicate with the thread for logging on to a token with
 * CKF_PROTECTED_AUTHENTICATION_PATH set.
 */
declare interface nsIProtectedAuthThreadType extends nsISupportsType {
    /**
     * login - run the thread
     * A user interface implementing this interface needs to
     * call this method as soon as the message to the user is
     * displayed. This will trigger login operation. No user
     * cancellation is possible during login operation.
     *
     * When the login is done, the observe method of @observer will
     * be called on the UI thread with a topic of "login-finished"
     * and null data and subject.
     */
    login(observer: nsIObserverType): void;
    /**
     * The PKCS11 slot
     */
    readonly slot: nsIPKCS11Slot;
    /**
     * Gets token to be logged in name.
     */
    getTokenName(): AString;
}

/**
 * nsIProtocolHandlerWithDynamicFlags
 *
 * Protocols that wish to return different flags depending on the URI should
 * implement this interface.
 */
declare interface nsIProtocolHandlerWithDynamicFlagsType extends nsISupportsType {
    /**
     * Returns protocol flags for the given URI, which may be different from the
     * flags for another URI of the same scheme.
     *
     * Only DYNAMIC_URI_FLAGS may be different from the registered flags for the
     * protocol handler.
     */
    getFlagsForURI(aURI: nsIURIType): unsigned_long;
}

/**
 * nsIProtocolHandler
 */
declare interface nsIProtocolHandlerType extends nsISupportsType {
    /**
     * The scheme of this protocol (e.g., "file").
     */
    readonly scheme: ACString;
    /**
     * Constructs a new channel from the given URI for this protocol handler and
     * sets the loadInfo for the constructed channel.
     */
    newChannel(aURI: nsIURIType, aLoadinfo: nsILoadInfoType): nsIChannel;
    /**
     * Allows a protocol to override blacklisted ports.
     *
     * This method will be called when there is an attempt to connect to a port
     * that is blacklisted.  For example, for most protocols, port 25 (Simple Mail
     * Transfer) is banned.  When a URI containing this "known-to-do-bad-things"
     * port number is encountered, this function will be called to ask if the
     * protocol handler wants to override the ban.
     */
    allowPort(port: long, scheme: string): boolean;
}

/**
 * This interface serves as a closure for nsIProtocolProxyService's
 * asyncResolve method.
 */
declare interface nsIProtocolProxyCallbackType extends nsISupportsType {
    /**
     * This method is called when proxy info is available or when an error
     * in the proxy resolution occurs.
     *
     * @param aRequest
     * The value returned from asyncResolve.
     * @param aChannel
     * The channel passed to asyncResolve.
     * @param aProxyInfo
     * The resulting proxy info or null if there is no associated proxy
     * info for aURI.  As with the result of nsIProtocolProxyService's
     * resolve method, a null result implies that a direct connection
     * should be used.
     * @param aStatus
     * The status of the callback.  This is a failure code if the request
     * could not be satisfied, in which case the value of aStatus
     * indicates the reason for the failure and aProxyInfo will be null.
     */
    onProxyAvailable(aRequest: nsICancelableType, aChannel: nsIChannelType, aProxyInfo: nsIProxyInfoType, aStatus: nsresult): void;
}

/**
 * Recipient of the result of implementers of nsIProtocolProxy(Channel)Filter
 * allowing the proxyinfo be provided asynchronously.
 */
declare interface nsIProxyProtocolFilterResultType extends nsISupportsType {
    /**
     * It's mandatory to call this method exactly once when the applyFilter()
     * implementation doesn't throw and to not call it when applyFilter() does
     * throw.
     *
     * It's mandatory to call this method on the same thread as the call to
     * applyFilter() has been made on.
     *
     * Following the above conditions, can be called either from within
     * applyFilter() or asynchronouly any time later.
     */
    onProxyFilterResult(aProxy: nsIProxyInfoType): void;
}

/**
 * This interface is used to apply filters to the proxies selected for a given
 * URI.  Use nsIProtocolProxyService::registerFilter to hook up instances of
 * this interface. See also nsIProtocolProxyChannelFilter.
 */
declare interface nsIProtocolProxyFilterType extends nsISupportsType {
    /**
     * This method is called to apply proxy filter rules for the given URI
     * and proxy object (or list of proxy objects).
     *
     * @param aURI
     * The URI for which these proxy settings apply.
     * @param aProxy
     * The proxy (or list of proxies) that would be used by default for
     * the given URI.  This may be null.
     *
     * @param aCallback
     * An object that the implementer is obligated to call on with
     * the result (from within applyFilter() or asynchronously) when
     * applyFilter didn't throw.  The argument passed to onProxyFilterResult
     * is the proxy (or list of proxies) that should be used in place of
     * aProxy.  This can be just be aProxy if the filter chooses not to
     * modify the proxy.  It can also be null to indicate that a direct
     * connection should be used.  Use nsIProtocolProxyService.newProxyInfo
     * to construct nsIProxyInfo objects.
     */
    applyFilter(aURI: nsIURIType, aProxy: nsIProxyInfoType, aCallback: nsIProxyProtocolFilterResultType): void;
}

/**
 * This interface is used to apply filters to the proxies selected for a given
 * channel.  Use nsIProtocolProxyService::registerChannelFilter to hook up instances of
 * this interface. See also nsIProtocolProxyFilter.
 */
declare interface nsIProtocolProxyChannelFilterType extends nsISupportsType {
    /**
     * This method is called to apply proxy filter rules for the given channel
     * and proxy object (or list of proxy objects).
     *
     * @param aChannel
     * The channel for which these proxy settings apply.
     * @param aProxy
     * The proxy (or list of proxies) that would be used by default for
     * the given channel. This may be null.
     *
     * @param aCallback
     * An object that the implementer is obligated to call on with
     * the result (from within applyFilter() or asynchronously) when
     * applyFilter didn't throw.  The argument passed to onProxyFilterResult
     * is the proxy (or list of proxies) that should be used in place of
     * aProxy.  This can be just be aProxy if the filter chooses not to
     * modify the proxy.  It can also be null to indicate that a direct
     * connection should be used.  Use nsIProtocolProxyService.newProxyInfo
     * to construct nsIProxyInfo objects.
     */
    applyFilter(aChannel: nsIChannelType, aProxy: nsIProxyInfoType, aCallback: nsIProxyProtocolFilterResultType): void;
}

/**
 *
 */
declare interface nsIProxyConfigChangedCallbackType extends nsISupportsType {
    /**
     * Called when one of the following conditions are changed.
     * 1. System proxy settings changed.
     * 2. A proxy filter is registered or unregistered.
     * 3. Proxy related prefs changed.
     */
    onProxyConfigChanged(): void;
}

/**
 * nsIProtocolProxyService provides methods to access information about
 * various network proxies.
 */
declare interface nsIProtocolProxyServiceType extends nsISupportsType {
    /**
     * This method returns via callback a nsIProxyInfo instance that identifies
     * a proxy to be used for the given channel.  Otherwise, this method returns
     * null indicating that a direct connection should be used.
     *
     * @param aChannelOrURI
     * The channel for which a proxy is to be found, or, if no channel is
     * available, a URI indicating the same. This method will return
     * NS_ERROR_NOINTERFACE if this argument isn't either an nsIURI or an
     * nsIChannel.
     * @param aFlags
     * A bit-wise combination of the RESOLVE_ flags defined above.  Pass
     * 0 to specify the default behavior.  Any additional bits that do
     * not correspond to a RESOLVE_ flag are reserved for future use.
     * @param aCallback
     * The object to be notified when the result is available.
     * @param aMainThreadTarget
     * A labelled event target for dispatching runnables to main thread.
     *
     * @return An object that can be used to cancel the asychronous operation.
     * If canceled, the cancelation status (aReason) will be forwarded
     * to the callback's onProxyAvailable method via the aStatus param.
     *
     * NOTE: If this proxy is unavailable, getFailoverForProxy may be called
     * to determine the correct secondary proxy to be used.
     *
     * NOTE: If the protocol handler for the given URI supports
     * nsIProxiedProtocolHandler, then the nsIProxyInfo instance returned from
     * resolve may be passed to the newProxiedChannel method to create a
     * nsIChannel to the given URI that uses the specified proxy.
     *
     * NOTE: However, if the nsIProxyInfo type is "http", then it means that
     * the given URI should be loaded using the HTTP protocol handler, which
     * also supports nsIProxiedProtocolHandler.
     *
     * @see nsIProxiedProtocolHandler::newProxiedChannel
     */
    asyncResolve(aChannelOrURI: nsISupportsType, aFlags: unsigned_long, aCallback: nsIProtocolProxyCallbackType, aMainThreadTarget: nsISerialEventTargetType): nsICancelable;
    /**
     * This method may be called to construct a nsIProxyInfo instance from
     * the given parameters.  This method may be useful in conjunction with
     * nsISocketTransportService::createTransport for creating, for example,
     * a SOCKS connection.
     *
     * @param aType
     * The proxy type.  This is a string value that identifies the proxy
     * type.  Standard values include:
     * "http"    - specifies a HTTP proxy
     * "https"   - specifies HTTP proxying over TLS connection to proxy
     * "socks"   - specifies a SOCKS version 5 proxy
     * "socks4"  - specifies a SOCKS version 4 proxy
     * "direct"  - specifies a direct connection (useful for failover)
     * The type name is case-insensitive.  Other string values may be
     * possible, and new types may be defined by a future version of
     * this interface.
     * @param aHost
     * The proxy hostname or IP address.
     * @param aPort
     * The proxy port.
     * @param aFlags
     * Flags associated with this connection.  See nsIProxyInfo.idl
     * for currently defined flags.
     * @param aFailoverTimeout
     * Specifies the length of time (in seconds) to ignore this proxy if
     * this proxy fails.  Pass UINT32_MAX to specify the default
     * timeout value, causing nsIProxyInfo::failoverTimeout to be
     * assigned the default value.
     * @param aFailoverProxy
     * Specifies the next proxy to try if this proxy fails.  This
     * parameter may be null.
     */
    newProxyInfo(aType: ACString, aHost: AUTF8String, aPort: long, aProxyAuthorizationHeader: ACString, aConnectionIsolationKey: ACString, aFlags: unsigned_long, aFailoverTimeout: unsigned_long, aFailoverProxy: nsIProxyInfoType): nsIProxyInfo;
    /**
     * This method may be called to construct a nsIProxyInfo instance for
     * with the specified username and password.
     * Currently implemented for SOCKS proxies only.
     * @param aType
     * The proxy type.  This is a string value that identifies the proxy
     * type.  Standard values include:
     * "socks"   - specifies a SOCKS version 5 proxy
     * "socks4"  - specifies a SOCKS version 4 proxy
     * The type name is case-insensitive.  Other string values may be
     * possible, and new types may be defined by a future version of
     * this interface.
     * @param aHost
     * The proxy hostname or IP address.
     * @param aPort
     * The proxy port.
     * @param aUsername
     * The proxy username
     * @param aPassword
     * The proxy password
     * @param aFlags
     * Flags associated with this connection.  See nsIProxyInfo.idl
     * for currently defined flags.
     * @param aFailoverTimeout
     * Specifies the length of time (in seconds) to ignore this proxy if
     * this proxy fails.  Pass UINT32_MAX to specify the default
     * timeout value, causing nsIProxyInfo::failoverTimeout to be
     * assigned the default value.
     * @param aFailoverProxy
     * Specifies the next proxy to try if this proxy fails.  This
     * parameter may be null.
     */
    newProxyInfoWithAuth(aType: ACString, aHost: AUTF8String, aPort: long, aUsername: AUTF8String, aPassword: AUTF8String, aProxyAuthorizationHeader: ACString, aConnectionIsolationKey: ACString, aFlags: unsigned_long, aFailoverTimeout: unsigned_long, aFailoverProxy: nsIProxyInfoType): nsIProxyInfo;
    /**
     * If the proxy identified by aProxyInfo is unavailable for some reason,
     * this method may be called to access an alternate proxy that may be used
     * instead.  As a side-effect, this method may affect future result values
     * from resolve/asyncResolve as well as from getFailoverForProxy.
     *
     * @param aProxyInfo
     * The proxy that was unavailable.
     * @param aURI
     * The URI that was originally passed to resolve/asyncResolve.
     * @param aReason
     * The error code corresponding to the proxy failure.  This value
     * may be used to tune the delay before this proxy is used again.
     *
     * @throw NS_ERROR_NOT_AVAILABLE if there is no alternate proxy available.
     */
    getFailoverForProxy(aProxyInfo: nsIProxyInfoType, aURI: nsIURIType, aReason: nsresult): nsIProxyInfo;
    /**
     * This method may be used to register a proxy filter instance.  Each proxy
     * filter is registered with an associated position that determines the
     * order in which the filters are applied (starting from position 0).  When
     * resolve/asyncResolve is called, it generates a list of proxies for the
     * given URI, and then it applies the proxy filters.  The filters have the
     * opportunity to modify the list of proxies.
     *
     * If two filters register for the same position, then the filters will be
     * visited in the order in which they were registered.
     *
     * If the filter is already registered, then its position will be updated.
     *
     * After filters have been run, any disabled or disallowed proxies will be
     * removed from the list.  A proxy is disabled if it had previously failed-
     * over to another proxy (see getFailoverForProxy).  A proxy is disallowed,
     * for example, if it is a HTTP proxy and the nsIProtocolHandler for the
     * queried URI does not permit proxying via HTTP.
     *
     * If a nsIProtocolHandler disallows all proxying, then filters will never
     * have a chance to intercept proxy requests for such URLs.
     *
     * @param aFilter
     * The nsIProtocolProxyFilter instance to be registered.
     * @param aPosition
     * The position of the filter.
     *
     * NOTE: It is possible to construct filters that compete with one another
     * in undesirable ways.  This API does not attempt to protect against such
     * problems.  It is recommended that any extensions that choose to call
     * this method make their position value configurable at runtime (perhaps
     * via the preferences service).
     */
    registerFilter(aFilter: nsIProtocolProxyFilterType, aPosition: unsigned_long): void;
    /**
     * Similar to registerFilter, but accepts an nsIProtocolProxyChannelFilter,
     * which selects proxies according to channel rather than URI.
     *
     * @param aFilter
     * The nsIProtocolProxyChannelFilter instance to be registered.
     * @param aPosition
     * The position of the filter.
     */
    registerChannelFilter(aFilter: nsIProtocolProxyChannelFilterType, aPosition: unsigned_long): void;
    /**
     * This method may be used to unregister a proxy filter instance.  All
     * filters will be automatically unregistered at XPCOM shutdown.
     *
     * @param aFilter
     * The nsIProtocolProxyFilter instance to be unregistered.
     */
    unregisterFilter(aFilter: nsIProtocolProxyFilterType): void;
    /**
     * This method may be used to unregister a proxy channel filter instance.  All
     * filters will be automatically unregistered at XPCOM shutdown.
     *
     * @param aFilter
     * The nsIProtocolProxyChannelFilter instance to be unregistered.
     */
    unregisterChannelFilter(aFilter: nsIProtocolProxyChannelFilterType): void;
    /**
     * This method is used to register a nsIProxyConfigChangedCallback.
     *
     * @param aCallback
     * The aCallback instance to be registered.
     */
    addProxyConfigCallback(aCallback: nsIProxyConfigChangedCallbackType): void;
    /**
     * This method is used to unregister a nsIProxyConfigChangedCallback.
     *
     * @param aCallback
     * The aCallback instance to be unregistered.
     */
    removeProxyConfigCallback(aCallback: nsIProxyConfigChangedCallbackType): void;
    /**
     * This method is used internal only. Called when proxy config is changed.
     */
    notifyProxyConfigChangedInternal(): void;
    /**
     * This attribute specifies the current type of proxy configuration.
     */
    readonly proxyConfigType: unsigned_long;
    /**
     * True if there is a PAC download in progress.
     */
    readonly isPACLoading: boolean;
}

/**
 * An extension of nsIProtocolProxyService
 */
declare interface nsIProtocolProxyService2Type extends nsIProtocolProxyServiceType {
    /**
     * Call this method to cause the PAC file (if any is configured) to be
     * reloaded.  The PAC file is loaded asynchronously.
     */
    reloadPAC(): void;
    /**
     * This method is identical to asyncResolve() except:
     * - it only accepts an nsIChannel, not an nsIURI;
     * - it may execute the callback function immediately (i.e from the stack
     * of asyncResolve2()) if it is immediately ready to run.
     * The nsICancelable return value will be null in that case.
     */
    asyncResolve2(aChannel: nsIChannelType, aFlags: unsigned_long, aCallback: nsIProtocolProxyCallbackType, aMainThreadTarget: nsISerialEventTargetType): nsICancelable;
}

/**
 * An interface for accessing the proxy info that a channel was
 * constructed with.
 *
 * @see nsIProxiedProtocolHandler
 */
declare interface nsIProxiedChannelType extends nsISupportsType {
    /**
     * Gets the proxy info the channel was constructed with. null or a
     * proxyInfo with type "direct" mean no proxy.
     *
     * The returned proxy info must not be modified.
     */
    readonly proxyInfo: nsIProxyInfo;
    /**
     * The HTTP response code returned from the proxy to the CONNECT method.
     * The response code is only available when we get the response from
     * the proxy server, so this value is known in and after OnStartRequest.
     *
     * If CONNECT method is not used, httpProxyConnectResponseCode is always -1.
     * After OnStartRequest, httpProxyConnectResponseCode is the real HTTP
     * response code or 0 if we can't reach to the proxy.
     */
    readonly httpProxyConnectResponseCode: int32_t;
}

/**
 *
 */
declare interface nsIProxiedProtocolHandlerType extends nsIProtocolHandlerType {
    /**
     * Create a new channel with the given proxyInfo
     *
     * @param uri the channel uri
     * @param proxyInfo any proxy information that has already been determined,
     * or null if channel should later determine the proxy on its own using
     * proxyResolveFlags/proxyURI
     * @param proxyResolveFlags used if the proxy is later determined
     * from nsIProtocolProxyService::asyncResolve
     * @param proxyURI used if the proxy is later determined from
     * nsIProtocolProxyService::asyncResolve with this as the proxyURI name.
     * Generally this is the same as uri (or null which has the same
     * effect), except in the case of websockets which wants to bootstrap
     * to an http:// channel but make its proxy determination based on
     * a ws:// uri.
     * @param aLoadInfo used to evaluate who initated the resource request.
     */
    newProxiedChannel(uri: nsIURIType, proxyInfo: nsIProxyInfoType, proxyResolveFlags: unsigned_long, proxyURI: nsIURIType, aLoadInfo: nsILoadInfoType): nsIChannel;
}

/**
 * This interface identifies a proxy server.
 */
declare interface nsIProxyInfoType extends nsISupportsType {
    /**
     * This attribute specifies the hostname of the proxy server.
     */
    readonly host: AUTF8String;
    /**
     * This attribute specifies the port number of the proxy server.
     */
    readonly port: long;
    /**
     * This attribute specifies the type of the proxy server as an ASCII string.
     *
     * Some special values for this attribute include (but are not limited to)
     * the following:
     * "http"     HTTP proxy (or SSL CONNECT for HTTPS)
     * "https"    HTTP proxying over TLS connection to proxy
     * "socks"    SOCKS v5 proxy
     * "socks4"   SOCKS v4 proxy
     * "direct"   no proxy
     * "unknown"  unknown proxy (see nsIProtocolProxyService::resolve)
     *
     * A future version of this interface may define additional types.
     */
    readonly type: ACString;
    /**
     * This attribute specifies flags that modify the proxy type.  The value of
     * this attribute is the bit-wise combination of the Proxy Flags defined
     * below.  Any undefined bits are reserved for future use.
     */
    readonly flags: unsigned_long;
    /**
     * This attribute specifies flags that were used by nsIProxyProtocolService when
     * creating this ProxyInfo element.
     */
    readonly resolveFlags: unsigned_long;
    /**
     * Specifies a proxy username.
     */
    readonly username: ACString;
    /**
     * Specifies a proxy password.
     */
    readonly password: ACString;
    /**
     * This attribute specifies the failover timeout in seconds for this proxy.
     * If a nsIProxyInfo is reported as failed via nsIProtocolProxyService::
     * getFailoverForProxy, then the failed proxy will not be used again for this
     * many seconds.
     */
    readonly failoverTimeout: unsigned_long;
    /**
     * This attribute specifies the proxy to failover to when this proxy fails.
     */
    failoverProxy: nsIProxyInfo;
    /**
     * Specifies an ID related to the source of this proxy configuration.  If
     * it is created in response to an extension API, it will be the extension ID.
     */
    sourceId: ACString;
    /**
     * Any non-empty value will be passed directly as Proxy-Authorization header
     * value for the CONNECT request attempt.  However, this header set on the
     * resource request itself takes precedence.
     */
    readonly proxyAuthorizationHeader: ACString;
    /**
     * An optional key used for additional isolation of this proxy connection.
     */
    readonly connectionIsolationKey: ACString;
}

/**
 *
 */
declare interface nsIPublicKeyPinningServiceType extends nsISupportsType {
    /**
     * Returns true if the host of the given URI has pinning information, and
     * false otherwise.
     */
    hostHasPins(aURI: nsIURIType): bool;
}

/**
 *
 */
declare interface nsIPurgeTrackerServiceType extends nsISupportsType {
    /**
     * Purge cookies and associated data of sites which no longer have the user interaction permission.
     */
    purgeTrackingCookieJars(): Promise;
}

/**
 *
 */
declare interface nsIPushErrorReporterType extends nsISupportsType {
    /**
     * Reports a `push` event handler error to the Push service. |messageId| is
     * an opaque string passed to `nsIPushNotifier.notifyPush{WithData}`.
     * |reason| is a delivery error reason.
     */
    reportDeliveryError(messageId: AString, reason: uint16_t): void;
}

/**
 * Fires XPCOM observer notifications and service worker events for
 * messages sent to push subscriptions.
 */
declare interface nsIPushNotifierType extends nsISupportsType {
    /**
     * Fires a `push-message` observer notification, and sends a `push` event to
     * the service worker registered for the |scope|. |messageId| is an opaque ID
     * used to report errors if the worker fails to handle the message.
     */
    notifyPush(scope: ACString, principal: nsIPrincipalType, messageId: AString): void;
    /**
     * Same as `notifyPush`, except the subject of the observer notification
     * receives an `nsIPushMessage` instance containing the |data|. Service
     * workers can access the |data| via the `PushMessageData` WebIDL interface.
     */
    notifyPushWithData(scope: ACString, principal: nsIPrincipalType, messageId: AString, data: invalid): void;
    /**
     * Fires a `push-subscription-change` observer notification, and sends a
     * `pushsubscriptionchange` event to the service worker registered for the
     * |scope|.
     */
    notifySubscriptionChange(scope: ACString, principal: nsIPrincipalType): void;
    /**
     * Fires a `push-subscription-modified` observer notification. Chrome code
     * can listen for this notification to see when a subscription is added,
     * updated, removed, or expired for any |scope|.
     *
     * This is useful for Dev Tools and debugging add-ons that passively observe
     * when subscriptions are created or dropped. Other callers should listen for
     * `push-subscription-change` and resubscribe instead.
     */
    notifySubscriptionModified(scope: ACString, principal: nsIPrincipalType): void;
    /**
     *
     */
    notifyError(scope: ACString, principal: nsIPrincipalType, message: AString, flags: uint32_t): void;
}

/**
 * Provides methods for retrieving push message data in different formats.
 * This interface resembles the `PushMessageData` WebIDL interface.
 */
declare interface nsIPushDataType extends nsISupportsType {
    /**
     * Extracts the data as a UTF-8 text string.
     */
    text(): AString;
    /**
     * Extracts the data as a JSON value.
     */
    json(): jsval;
}

/**
 * The subject of a `push-message` observer notification. |data| may be |null|
 * for messages without data.
 */
declare interface nsIPushMessageType extends nsISupportsType {
    /**
     *
     */
    readonly principal: nsIPrincipal;
    /**
     *
     */
    readonly data: nsIPushData;
}

/**
 * A push subscription, passed as an argument to a subscription callback.
 * Similar to the `PushSubscription` WebIDL interface.
 */
declare interface nsIPushSubscriptionType extends nsISupportsType {
    /**
     *
     */
    readonly endpoint: AString;
    /**
     *
     */
    readonly pushCount: long_long;
    /**
     *
     */
    readonly lastPush: long_long;
    /**
     *
     */
    readonly quota: long;
    /**
     *
     */
    readonly isSystemSubscription: bool;
    /**
     *
     */
    readonly p256dhPrivateKey: jsval;
    /**
     *
     */
    quotaApplies(): bool;
    /**
     *
     */
    isExpired(): bool;
}

/**
 * Called by methods that return a push subscription. A non-success
 * |status| indicates that there was a problem returning the
 * subscription, and the |subscription| argument should be ignored. Otherwise,
 * |subscription| will point to a valid push subscription, or |null| if the
 * subscription does not exist.
 */
declare interface nsIPushSubscriptionCallbackType extends nsISupportsType {
    /**
     *
     */
    onPushSubscription(status: nsresult, subscription: nsIPushSubscriptionType): void;
}

/**
 * Called by |unsubscribe|. A non-success |status| indicates that there was
 * a problem unsubscribing, and the |success| argument should be ignored.
 * Otherwise, |success| is true if unsubscribing was successful, and false if
 * the subscription does not exist.
 */
declare interface nsIUnsubscribeResultCallbackType extends nsISupportsType {
    /**
     *
     */
    onUnsubscribe(status: nsresult, success: bool): void;
}

/**
 * Called by |clearForDomain|. A non-success |status| indicates that there was
 * a problem clearing subscriptions for the given domain.
 */
declare interface nsIPushClearResultCallbackType extends nsISupportsType {
    /**
     *
     */
    onClear(status: nsresult): void;
}

/**
 * A service for components to subscribe and receive push messages from web
 * services. This functionality is exposed to content via the Push DOM API,
 * which uses service workers. This interface exists to support the DOM API,
 * and allows privileged code to receive messages without migrating to service
 * workers.
 */
declare interface nsIPushServiceType extends nsISupportsType {
    /**
     * Observer topic names, exported for convenience.
     */
    readonly pushTopic: AString;
    /**
     *
     */
    readonly subscriptionChangeTopic: AString;
    /**
     *
     */
    readonly subscriptionModifiedTopic: AString;
    /**
     * Creates a push subscription for the given |scope| URL and |principal|.
     * If a subscription already exists for this |(scope, principal)| pair,
     * the callback will receive the existing record as the second argument.
     *
     * The |endpoint| property of the subscription record is a URL string
     * that can be used to send push messages to subscribers.
     *
     * Each incoming message fires a `push-message` observer notification, with
     * an `nsIPushMessage` as the subject and the |scope| as the data.
     *
     * If the server drops a subscription, a `push-subscription-change` observer
     * will be fired, with the subject set to |principal| and the data set to
     * |scope|. Servers may drop subscriptions at any time, so callers should
     * recreate subscriptions if desired.
     */
    subscribe(scope: AString, principal: nsIPrincipalType, callback: nsIPushSubscriptionCallbackType): void;
    /**
     * Creates a restricted push subscription with the given public |key|. The
     * application server must use the corresponding private key to authenticate
     * message delivery requests, as described in draft-thomson-webpush-vapid.
     */
    subscribeWithKey(scope: AString, principal: nsIPrincipalType, key: invalid, callback: nsIPushSubscriptionCallbackType): void;
    /**
     * Removes a push subscription for the given |scope|.
     */
    unsubscribe(scope: AString, principal: nsIPrincipalType, callback: nsIUnsubscribeResultCallbackType): void;
    /**
     * Retrieves the subscription record associated with the given
     * |(scope, principal)| pair. If the subscription does not exist, the
     * callback will receive |null| as the second argument.
     */
    getSubscription(scope: AString, principal: nsIPrincipalType, callback: nsIPushSubscriptionCallbackType): void;
    /**
     * Drops every subscription for the given |domain|, or all domains if
     * |domain| is "*".
     */
    clearForDomain(domain: AString, callback: nsIPushClearResultCallbackType): void;
}

/**
 *
 */
declare interface nsIPushQuotaManagerType extends nsISupportsType {
    /**
     * Informs the quota manager that a notification
     * for the given origin has been shown. Used to
     * determine if push quota should be relaxed.
     */
    notificationForOriginShown(origin: string): void;
    /**
     * Informs the quota manager that a notification
     * for the given origin has been closed. Used to
     * determine if push quota should be relaxed.
     */
    notificationForOriginClosed(origin: string): void;
}

/**
 * The result of query content events.  succeeded propery can be used always.
 * Whether other properties can be used or not depends on the event.
 * See nsIDOMWindowUtils.idl, which properites can be used was documented.
 */
declare interface nsIQueryContentEventResultType extends nsISupportsType {
    /**
     *
     */
    readonly offset: unsigned_long;
    /**
     *
     */
    readonly tentativeCaretOffset: unsigned_long;
    /**
     *
     */
    readonly reversed: boolean;
    /**
     *
     */
    readonly left: long;
    /**
     *
     */
    readonly top: long;
    /**
     *
     */
    readonly width: long;
    /**
     *
     */
    readonly height: long;
    /**
     *
     */
    readonly text: AString;
    /**
     *
     */
    getCharacterRect(offset: long, left: long, top: long, width: long, height: long): void;
    /**
     *
     */
    readonly succeeded: boolean;
    /**
     *
     */
    readonly notFound: boolean;
    /**
     *
     */
    readonly tentativeCaretOffsetNotFound: boolean;
}

/**
 *
 */
declare interface nsIQuotaUsageCallbackType extends nsISupportsType {
    /**
     *
     */
    onUsageResult(aRequest: nsIQuotaUsageRequestType): void;
}

/**
 *
 */
declare interface nsIQuotaCallbackType extends nsISupportsType {
    /**
     *
     */
    onComplete(aRequest: nsIQuotaRequestType): void;
}

/**
 *
 */
declare interface nsIQuotaManagerServiceType extends nsISupportsType {
    /**
     * Asynchronously retrieves storage name and returns it as a plain string.
     *
     * If the dom.quotaManager.testing preference is not true the call will be
     * a no-op.
     */
    storageName(): nsIQuotaRequest;
    /**
     * Check if storage is initialized.
     *
     * If the dom.quotaManager.testing preference is not true the call will be
     * a no-op.
     */
    storageInitialized(): nsIQuotaRequest;
    /**
     * Check if temporary storage is initialized.
     *
     * If the dom.quotaManager.testing preference is not true the call will be
     * a no-op.
     */
    temporaryStorageInitialized(): nsIQuotaRequest;
    /**
     * Initializes storage directory. This can be used in tests to verify
     * upgrade methods.
     *
     * If the dom.quotaManager.testing preference is not true the call will be
     * a no-op.
     */
    init(): nsIQuotaRequest;
    /**
     * Initializes temporary storage. This can be used in tests to verify
     * temporary storage initialization.
     *
     * If the dom.quotaManager.testing preference is not true the call will be
     * a no-op.
     */
    initTemporaryStorage(): nsIQuotaRequest;
    /**
     * Initializes persistent origin directory for the given origin. This can be
     * used in tests to verify origin initialization.
     *
     * If the dom.quotaManager.testing preference is not true the call will be
     * a no-op.
     *
     * @param aPrincipal
     * A principal for the origin whose directory is to be initialized.
     */
    initializePersistentOrigin(aPrincipal: nsIPrincipalType): nsIQuotaRequest;
    /**
     * Initializes temporary origin directory for the given origin. This can be
     * used in tests to verify origin initialization.
     *
     * If the dom.quotaManager.testing preference is not true the call will be
     * a no-op.
     *
     * @param aPersistenceType
     * A string that tells what persistence type of origin will be
     * initialized (temporary or default).
     *
     * @param aPrincipal
     * A principal for the origin whose directory is to be initialized.
     */
    initializeTemporaryOrigin(aPersistenceType: ACString, aPrincipal: nsIPrincipalType): nsIQuotaRequest;
    /**
     * Gets full origin metadata cached in memory for the given persistence type
     * and origin.
     *
     * NOTE: This operation may still be delayed by other operations on the QM
     * I/O thread that are peforming I/O.
     *
     * @param aPersistenceType
     * A string that tells what persistence type will be used for getting
     * the metadata (either "temporary" or "default").
     * @param aPrincipal
     * A principal that tells which origin will be used for getting the
     * metadata.
     */
    getFullOriginMetadata(aPersistenceType: ACString, aPrincipal: nsIPrincipalType): nsIQuotaRequest;
    /**
     * Schedules an asynchronous callback that will inspect all origins and
     * return the total amount of disk space being used by storages for each
     * origin separately.
     *
     * @param aCallback
     * The callback that will be called when the usage is available.
     * @param aGetAll
     * An optional boolean to indicate inspection of all origins,
     * including internal ones.
     */
    getUsage(aCallback: nsIQuotaUsageCallbackType, aGetAll: boolean): nsIQuotaUsageRequest;
    /**
     * Schedules an asynchronous callback that will return the total amount of
     * disk space being used by storages for the given origin.
     *
     * @param aPrincipal
     * A principal for the origin whose usage is being queried.
     * @param aCallback
     * The callback that will be called when the usage is available.
     * @param aFromMemory
     * An optional flag to indicate whether the cached usage should be
     * obtained. The default value is false.  Note that this operation may
     * still be delayed by other operations on the QM I/O thread that are
     * peforming I/O.
     * Note:  Origin usage here represents total usage of an origin. However,
     * cached usage here represents only non-persistent usage of an origin.
     */
    getUsageForPrincipal(aPrincipal: nsIPrincipalType, aCallback: nsIQuotaUsageCallbackType, aFromMemory: boolean): nsIQuotaUsageRequest;
    /**
     * Asynchronously lists all origins and returns them as plain strings.
     */
    listOrigins(): nsIQuotaRequest;
    /**
     * Removes all storages. The files may not be deleted immediately depending
     * on prohibitive concurrent operations.
     * Be careful, this removes *all* the data that has ever been stored!
     *
     * If the dom.quotaManager.testing preference is not true the call will be
     * a no-op.
     */
    clear(): nsIQuotaRequest;
    /**
     * Removes all storages stored for private browsing. The files may not be
     * deleted immediately depending on prohibitive concurrent operations.  In
     * terms of locks, it will get an exclusive multi directory lock for entire
     * private repository.
     */
    clearStoragesForPrivateBrowsing(): nsIQuotaRequest;
    /**
     * Removes all storages stored for the given pattern. The files may not be
     * deleted immediately depending on prohibitive concurrent operations.  In
     * terms of locks, it will get an exclusive multi directory lock for given
     * pattern.  For example, given pattern {"userContextId":1007} and set of 3
     * origins ["http://www.mozilla.org^userContextId=1007",
     * "http://www.example.org^userContextId=1007",
     * "http://www.example.org^userContextId=1008"], the method will only lock 2
     * origins ["http://www.mozilla.org^userContextId=1007",
     * "http://www.example.org^userContextId=1007"].
     *
     * @param aPattern
     * A pattern for the origins whose storages are to be cleared.
     * Currently this is expected to be a JSON representation of the
     * OriginAttributesPatternDictionary defined in ChromeUtils.webidl.
     */
    clearStoragesForOriginAttributesPattern(aPattern: AString): nsIQuotaRequest;
    /**
     * Removes all storages stored for the given principal. The files may not be
     * deleted immediately depending on prohibitive concurrent operations.
     *
     * @param aPrincipal
     * A principal for the origin whose storages are to be cleared.
     * @param aPersistenceType
     * An optional string that tells what persistence type of storages
     * will be cleared.  If omitted (or void), all persistence types will
     * be cleared for the principal.  If a single persistence type
     * ("persistent", "temporary", or "default") is provided, then only
     * that persistence directory will be considered.  Note that
     * "persistent" is different than being "persisted" via persist() and
     * is only for chrome principals.  See bug 1354500 for more info.
     * In general, null is the right thing to pass here.
     * @param aClientType
     * An optional string that tells what client type of storages
     * will be cleared.  If omitted (or void), all client types will be
     * cleared for the principal.  If a single client type is provided
     * from Client.h, then only that client's storage will be cleared.
     * If you want to clear multiple client types (but not all), then you
     * must call this method multiple times.
     * @param aClearAll
     * An optional boolean to indicate clearing all storages under the
     * given origin.
     */
    clearStoragesForPrincipal(aPrincipal: nsIPrincipalType, aPersistenceType: ACString, aClientType: AString, aClearAll: boolean): nsIQuotaRequest;
    /**
     * Resets quota and storage management. This can be used to force
     * reinitialization of the temp storage, for example when the pref for
     * overriding the temp storage limit has changed.
     * Be carefull, this invalidates all live storages!
     *
     * If the dom.quotaManager.testing preference is not true the call will be
     * a no-op.
     */
    reset(): nsIQuotaRequest;
    /**
     * Resets all storages stored for the given principal.
     *
     * If the dom.quotaManager.testing preference is not true the call will be
     * a no-op.
     *
     * @param aPrincipal
     * A principal for the origin whose storages are to be reset.
     * @param aPersistenceType
     * An optional string that tells what persistence type of storages
     * will be reset.  If omitted (or void), all persistence types will
     * be cleared for the principal.  If a single persistence type
     * ("persistent", "temporary", or "default") is provided, then only
     * that persistence directory will be considered.  Note that
     * "persistent" is different than being "persisted" via persist() and
     * is only for chrome principals.  See bug 1354500 for more info.
     * In general, null is the right thing to pass here.
     * @param aClientType
     * An optional string that tells what client type of storages
     * will be reset.  If omitted (or void), all client types will be
     * cleared for the principal.  If a single client type is provided
     * from Client.h, then only that client's storage will be cleared.
     * If you want to clear multiple client types (but not all), then you
     * must call this method multiple times.
     */
    resetStoragesForPrincipal(aPrincipal: nsIPrincipalType, aPersistenceType: ACString, aClientType: AString): nsIQuotaRequest;
    /**
     * Check if given origin is persisted.
     *
     * @param aPrincipal
     * A principal for the origin which we want to check.
     */
    persisted(aPrincipal: nsIPrincipalType): nsIQuotaRequest;
    /**
     * Persist given origin.
     *
     * @param aPrincipal
     * A principal for the origin which we want to persist.
     */
    persist(aPrincipal: nsIPrincipalType): nsIQuotaRequest;
    /**
     * Given an origin, asynchronously calculate its group quota usage and quota
     * limit. An origin's group is the set of all origins that share the same
     * eTLD+1. This method is intended to be used for our implementation of the
     * StorageManager.estimate() method. When we fix bug 1305665 and stop tracking
     * quota limits on a group basis, this method will switch to operating on
     * origins. Callers should strongly consider whether they want to be using
     * getUsageForPrincipal() instead.
     *
     * This mechanism uses cached quota values and does not perform any I/O on its
     * own, but it may be delayed by QuotaManager operations that do need to
     * perform I/O on the QuotaManager I/O thread.
     *
     * @param aPrincipal
     * A principal for the origin (group) which we want to estimate.
     */
    estimate(aPrincipal: nsIPrincipalType): nsIQuotaRequest;
}

/**
 *
 */
declare interface nsIQuotaRequestBaseType extends nsISupportsType {
    /**
     *
     */
    readonly principal: nsIPrincipal;
    /**
     *
     */
    readonly resultCode: nsresult;
    /**
     *
     */
    readonly resultName: ACString;
}

/**
 *
 */
declare interface nsIQuotaUsageRequestType extends nsIQuotaRequestBaseType {
    /**
     *
     */
    readonly result: nsIVariant;
    /**
     *
     */
    callback: nsIQuotaUsageCallback;
    /**
     *
     */
    cancel(): void;
}

/**
 *
 */
declare interface nsIQuotaRequestType extends nsIQuotaRequestBaseType {
    /**
     *
     */
    readonly result: nsIVariant;
    /**
     *
     */
    callback: nsIQuotaCallback;
}

/**
 *
 */
declare interface nsIQuotaFullOriginMetadataResultType extends nsISupportsType {
    /**
     *
     */
    readonly suffix: ACString;
    /**
     *
     */
    readonly group: ACString;
    /**
     *
     */
    readonly origin: ACString;
    /**
     *
     */
    readonly storageOrigin: ACString;
    /**
     *
     */
    readonly persistenceType: ACString;
    /**
     *
     */
    readonly persisted: boolean;
    /**
     *
     */
    readonly lastAccessTime: long_long;
}

/**
 *
 */
declare interface nsIQuotaUsageResultType extends nsISupportsType {
    /**
     *
     */
    readonly origin: ACString;
    /**
     *
     */
    readonly persisted: boolean;
    /**
     *
     */
    readonly usage: unsigned_long_long;
    /**
     *
     */
    readonly lastAccessed: unsigned_long_long;
}

/**
 *
 */
declare interface nsIQuotaOriginUsageResultType extends nsISupportsType {
    /**
     *
     */
    readonly usage: unsigned_long_long;
    /**
     *
     */
    readonly fileUsage: unsigned_long_long;
}

/**
 *
 */
declare interface nsIQuotaEstimateResultType extends nsISupportsType {
    /**
     *
     */
    readonly usage: unsigned_long_long;
    /**
     *
     */
    readonly limit: unsigned_long_long;
}

/**
 * This holds methods used to race the cache with the network for a specific
 * channel. This interface is was designed with nsHttpChannel in mind, and it's
 * expected this will be the only class implementing it.
 */
declare interface nsIRaceCacheWithNetworkType extends nsISupportsType {
    /**
     * **************************************************************************
     * TEST ONLY: The following methods are for testing purposes only. Do not use
     * them to do anything important in your code.
     * ***************************************************************************
     *
     * Triggers network activity after given timeout. If timeout is 0, network
     * activity is triggered immediately if asyncOpen has already been called.
     * Otherwise the delayed timer will be set when the normal call to
     * TriggerNetwork is made. If the cache.asyncOpenURI callbacks have already
     * been called, the network activity may have already been triggered
     * or the content may have already been delivered from the cache, so this
     * operation will have no effect.
     *
     * @param timeout
     * - the delay in milliseconds until the network will be triggered.
     */
    test_triggerNetwork(timeout: long): void;
    /**
     * Normally a HTTP channel would immediately call AsyncOpenURI leading to the
     * cache storage to lookup the cache entry and return it. In order to
     * simmulate real life conditions where fetching a cache entry takes a long
     * time, we set a timer to delay the operation.
     * Can only be called on the main thread.
     *
     * @param timeout
     * - the delay in milliseconds until the cache open will be triggered.
     */
    test_delayCacheEntryOpeningBy(timeout: long): void;
    /**
     * Immediatelly triggers AsyncOpenURI if the timer hasn't fired.
     * Can only be called on the main thread.
     * This is only called in tests to reliably trigger the opening of the cache
     * entry.
     * @throws NS_ERROR_NOT_AVAILABLE if opening the cache wasn't delayed.
     */
    test_triggerDelayedOpenCacheEntry(): void;
}

/**
 * nsIRandomAccessStream
 *
 * An interface which supports both reading and writing to a storage starting
 * at the current offset. Both the input stream and the output stream share the
 * offset in the stream. Read operations invoked on the input stream start at
 * the offset and advance it past the bytes read. Write operations invoked on
 * the output stream start the offset and advance it past the bytes written.
 * The offset can be set to an arbitrary value prior reading or writting. Each
 * call to getInputStream or getOutputStream always returns the same object,
 * rather than creating a new stream. It's recommended for objects implementing
 * this interface to also implement nsIInputStream and nsIOutputStream, so they
 * can be easilly used with e.g. NS_AsyncCopy.
 */
declare interface nsIRandomAccessStreamType extends nsISeekableStreamType {
    /**
     * This method always returns the same object.
     */
    getInputStream(): nsIInputStream;
    /**
     * This method always returns the same object.
     */
    getOutputStream(): nsIOutputStream;
    /**
     * Like getInputStream but infallible.
     */
    inputStream(): nsIInputStream;
    /**
     * Like getOutputStream but infallible.
     */
    outputStream(): nsIOutputStream;
    /**
     *
     */
    serialize(aCallbacks: nsIInterfaceRequestorType): RandomAccessStreamParams;
    /**
     *
     */
    deserialize(params: RandomAccessStreamParamsRef): bool;
}

/**
 * Interface used to generate random data.
 *
 * @threadsafe
 */
declare interface nsIRandomGeneratorType extends nsISupportsType {
    /**
     * Generates the specified amount of random bytes.
     *
     * @param aLength
     * The length of the data to generate.
     * @param aBuffer
     * A buffer that contains random bytes of size aLength.
     */
    generateRandomBytes(aLength: unsigned_long, aBuffer: octet[]): void;
    /**
     * Fills aBuffer with random bytes.
     *
     * @param aBuffer
     * A buffer to fill with random bytes.
     * @param aLength
     * Length of aBuffer.
     */
    generateRandomBytesInto(aBuffer: octet[], aLength: unsigned_long): void;
}

/**
 *
 */
declare interface nsIRddProcessTestType extends nsISupportsType {
    /**
     * ** Test-only Method **
     *
     * Sending Telemetry probes
     */
    testTelemetryProbes(): Promise;
    /**
     * ** Test-only Method **
     *
     * Stop existing RDD process
     */
    stopProcess(): void;
}

/**
 * Used on the chrome process as a service to join channel implementation
 * and parent IPC protocol side under a unique id.  Provides this way a generic
 * communication while redirecting to various protocols.
 *
 * See also nsIChildChannel and nsIParentChannel.
 */
declare interface nsIRedirectChannelRegistrarType extends nsISupportsType {
    /**
     * Register the redirect target channel. The passed id needs to be a
     * unique ID for that channel (see `nsContentUtils::GenerateLoadIdentifier`).
     *
     * Primarily used in ParentChannelListener::AsyncOnChannelRedirect to get
     * a channel id sent to the HttpChannelChild being redirected.
     */
    registerChannel(channel: nsIChannelType, id: uint64_t): void;
    /**
     * First, search for the channel registered under the id.  If found return
     * it.  Then, register under the same id the parent side of IPC protocol
     * to let it be later grabbed back by the originator of the redirect and
     * notifications from the real channel could be forwarded to this parent
     * channel.
     *
     * Primarily used in parent side of an IPC protocol implementation
     * in reaction to nsIChildChannel.connectParent(id) called from the child
     * process.
     */
    linkChannels(id: uint64_t, channel: nsIParentChannelType): nsIChannel;
    /**
     * Returns back the channel previously registered under the ID with
     * registerChannel method.
     *
     * Primarilly used in chrome IPC side of protocols when attaching a redirect
     * target channel to an existing 'real' channel implementation.
     */
    getRegisteredChannel(id: uint64_t): nsIChannel;
    /**
     * Returns the stream listener that shall be attached to the redirect target
     * channel, all notification from the redirect target channel will be
     * forwarded to this stream listener.
     *
     * Primarilly used in HttpChannelParent::OnRedirectResult callback to grab
     * the created parent side of the channel and forward notifications to it.
     */
    getParentChannel(id: uint64_t): nsIParentChannel;
    /**
     * To not force all channel implementations to support weak reference
     * consumers of this service must ensure release of registered channels them
     * self.  This releases both the real and parent channel registered under
     * the id.
     *
     * Primarilly used in HttpChannelParent::OnRedirectResult callback.
     */
    deregisterChannels(id: uint64_t): void;
}

/**
 * This nsIRedirectHistoryEntry defines an interface for specifying channel
 * redirect information
 */
declare interface nsIRedirectHistoryEntryType extends nsISupportsType {
    /**
     * The principal of this redirect entry
     */
    readonly principal: nsIPrincipal;
    /**
     * The referring URI of this redirect entry.  This may be null.
     */
    readonly referrerURI: nsIURI;
    /**
     * The remote address of this redirect entry.
     */
    readonly remoteAddress: ACString;
}

/**
 *
 */
declare interface nsIRedirectResultListenerType extends nsISupportsType {
    /**
     * When an HTTP redirect has been processed (either successfully or not)
     * nsIHttpChannel will call this function if its callbacks implement this
     * interface.
     *
     * @param proceeding
     * Indicated whether the redirect will be proceeding, or not (i.e.
     * has been canceled, or failed).
     */
    onRedirectResult(status: nsresult): void;
}

/**
 *
 */
declare interface nsIReferrerInfoType extends nsISerializableType {
    /**
     * The original referrer URI which indicates the full referrer before applying
     * referrer policy
     */
    readonly originalReferrer: nsIURI;
    /**
     * Referrer policy which is applied to the referrer
     */
    readonly referrerPolicy: nsIReferrerInfo_ReferrerPolicyIDL;
    /**
     * Get referrer policy as string
     */
    getReferrerPolicyString(): ACString;
    /**
     * Indicates if the referrer should not be sent or not even when it's available.
     */
    readonly sendReferrer: boolean;
    /**
     * Indicates if the referrer should not be sent or not even when it's available.
     */
    readonly computedReferrerSpec: AString;
    /**
     * Returns whether the other referrerInfo is equivalent to this referrerInfo.
     */
    equals(other: nsIReferrerInfoType): boolean;
    /**
     * Initialize method to create ReferrerInfo object from JS
     * @param aReferrerPolicy referrer policy of the created object
     * @param aSendReferrer sendReferrer of the created object, defaults to false
     * @param aOriginalReferrer the original referrer, defaults to null.
     */
    init(aReferrerPolicy: nsIReferrerInfo_ReferrerPolicyIDLType, aSendReferrer: boolean, aOriginalReferrer: nsIURIType): void;
    /**
     * Initialize with a given document.
     * @param aDocument the document to init referrerInfo object
     */
    initWithDocument(aDocument: Document): void;
    /**
     * Initialize with a given node. It you are working with node which supports
     * referrerpolicy attribute: <a>, <img>, <area>, <script>, <iframe>, please
     * try to use this init instead of initWithDocument, because referrer policy
     * from rel and attribute has a higher priority.
     * @param aNode the element to init referrerInfo object
     */
    initWithElement(aNode: Element): void;
}

/**
 *
 */
declare interface nsIReflowObserverType extends nsISupportsType {
    /**
     * Called when an uninterruptible reflow has occurred.
     *
     * @param start timestamp when reflow ended, in milliseconds since
     * navigationStart (accurate to 1/1000 of a ms)
     * @param end   timestamp when reflow ended, in milliseconds since
     * navigationStart (accurate to 1/1000 of a ms)
     */
    reflow(start: DOMHighResTimeStamp, end: DOMHighResTimeStamp): void;
    /**
     * Called when an interruptible reflow has occurred.
     *
     * @param start timestamp when reflow ended, in milliseconds since
     * navigationStart (accurate to 1/1000 of a ms)
     * @param end   timestamp when reflow ended, in milliseconds since
     * navigationStart (accurate to 1/1000 of a ms)
     */
    reflowInterruptible(start: DOMHighResTimeStamp, end: DOMHighResTimeStamp): void;
}

/**
 *
 */
declare interface nsIRefreshURIType extends nsISupportsType {
    /**
     * Load a uri after waiting for aMillis milliseconds (as a result of a
     * meta refresh). If the docshell is busy loading a page currently, the
     * refresh request will be queued and executed when the current load
     * finishes.
     *
     * @param aUri The uri to refresh.
     * @param aPrincipal The triggeringPrincipal for the refresh load
     * May be null, in which case the principal of current document will be
     * applied.
     * @param aMillis The number of milliseconds to wait.
     */
    refreshURI(aURI: nsIURIType, aPrincipal: nsIPrincipalType, aMillis: unsigned_long): void;
    /**
     * Loads a URI immediately as if it were a meta refresh.
     *
     * @param aURI The URI to refresh.
     * @param aPrincipal The triggeringPrincipal for the refresh load
     * May be null, in which case the principal of current document will be
     * applied.
     * @param aMillis The number of milliseconds by which this refresh would
     * be delayed if it were not being forced.
     */
    forceRefreshURI(aURI: nsIURIType, aPrincipal: nsIPrincipalType, aMillis: unsigned_long): void;
    /**
     * Cancels all timer loads.
     */
    cancelRefreshURITimers(): void;
    /**
     * True when there are pending refreshes, false otherwise.
     */
    readonly refreshPending: boolean;
}

/**
 *
 */
declare interface nsIRegionType extends nsISupportsType {
    /**
     * The users current region.
     */
    readonly current: AString;
    /**
     * The users current home region.
     */
    readonly home: AString;
}

/**
 * The nsIRelativeFilePref interface is a wrapper for an nsIFile and
 * and a directory service key. When used as a pref value, it stores a
 * relative path to the file from the location pointed to by the directory
 * service key. The path has the same syntax across all platforms.
 *
 * @see nsIPrefBranch::getComplexValue
 * @see nsIPrefBranch::setComplexValue
 */
declare interface nsIRelativeFilePrefType extends nsISupportsType {
    /**
     * file
     *
     * The file whose location is stored or retrieved.
     */
    file: nsIFile;
    /**
     * relativeToKey
     *
     * A directory service key for the directory
     * from which the file path is relative.
     */
    relativeToKey: ACString;
}

/**
 * The Gecko remote agent is an RPC subsystem that exposes
 * browser-internal interfaces and services to the surrounding
 * system.
 *
 * Consumers, whether remote or browser-local, can interface with
 * the browser through an assorted set of services ranging from
 * document introspection and script evaluation, to instrumentation,
 * user interaction simulation, and event subscription.
 */
declare interface nsIRemoteAgentType extends nsISupportsType {
    /**
     * Address of the HTTP server under which the remote agent is reachable.
     */
    readonly debuggerAddress: AString;
    /**
     * Indicates whether the Remote Agent is running.
     */
    readonly running: boolean;
}

/**
 *
 */
declare interface nsIRemoteTabType extends nsISupportsType {
    /**
     * When set to true, this tells the child to paint and upload layers to
     * the compositor. When set to false, previous layers are cleared from
     * the compositor, but only if preserveLayers is also set to false.
     */
    renderLayers: boolean;
    /**
     * True if layers are being rendered and the compositor has reported
     * receiving them.
     */
    readonly hasLayers: boolean;
    /**
     * When set to true, this priority hint indicates that the content
     * processes of this tab should be set to a higher process priority.
     */
    priorityHint: boolean;
    /**
     * Adjusts the tab's active state in the process priority manager,
     * allowing its process to be given a lower priority.
     */
    deprioritize(): void;
    /**
     * As an optimisation, setting the docshell's active state to
     * inactive also triggers a layer invalidation to free up some
     * potentially unhelpful memory usage. Calling preserveLayers
     * will cause the layers to be preserved even for inactive
     * docshells.
     */
    preserveLayers(aPreserveLayers: boolean): void;
    /**
     *
     */
    readonly tabId: uint64_t;
    /**
     *
     */
    readonly contentProcessId: uint64_t;
    /**
     * The OS level process Id of the related child process.
     */
    readonly osPid: int32_t;
    /**
     * The toplevel BrowsingContext loaded in this remote tab.
     */
    readonly browsingContext: BrowsingContext;
    /**
     * True if we've previously received layers for this tab when switching to
     * it.
     */
    readonly hasPresented: boolean;
    /**
     * Ensures that the content process which has this remote tab has all of the
     * permissions required to load a document with the given principal.
     */
    transmitPermissionsForPrincipal(aPrincipal: nsIPrincipalType): void;
    /**
     * Similar to `nsIDocShell.createAboutBlankContentViewer` but on a remote
     * frame.  The docShell must not yet have navigated away from the initial
     * about:blank document when this method is called.
     *
     * @param aPrincipal the principal to use for the new document.
     * @param aPartitionedPrincipal the partitioned principal to use for the new
     * document.
     */
    createAboutBlankContentViewer(aPrincipal: nsIPrincipalType, aPartitionedPrincipal: nsIPrincipalType): void;
    /**
     * Interrupt content scripts if possible/needed to allow chrome scripts in the
     * content process to run (in particular, to allow navigating through browser
     * history.
     */
    maybeCancelContentJSExecution(aNavigationType: nsIRemoteTab_NavigationTypeType, aCancelContentJSOptions: jsval): void;
}

/**
 * nsIRequest
 */
declare interface nsIRequestType extends nsISupportsType {
    /**
     * The name of the request.  Often this is the URI of the request.
     */
    readonly name: AUTF8String;
    /**
     * Indicates whether the request is pending. nsIRequest::isPending is
     * true when there is an outstanding asynchronous event that will make
     * the request no longer be pending.  Requests do not necessarily start
     * out pending; in some cases, requests have to be explicitly initiated
     * (e.g. nsIChannel implementations are only pending once asyncOpen
     * returns successfully).
     *
     * Requests can become pending multiple times during their lifetime.
     *
     * @return TRUE if the request has yet to reach completion.
     * @return FALSE if the request has reached completion (e.g., after
     * OnStopRequest has fired).
     * @note Suspended requests are still considered pending.
     */
    isPending(): boolean;
    /**
     * The error status associated with the request.
     */
    readonly status: nsresult;
    /**
     * Cancels the current request.  This will close any open input or
     * output streams and terminate any async requests.  Users should
     * normally pass NS_BINDING_ABORTED, although other errors may also
     * be passed.  The error passed in will become the value of the
     * status attribute.
     *
     * Implementations must not send any notifications (e.g. via
     * nsIRequestObserver) synchronously from this function. Similarly,
     * removal from the load group (if any) must also happen asynchronously.
     *
     * Requests that use nsIStreamListener must not call onDataAvailable
     * anymore after cancel has been called.
     *
     * @param aStatus the reason for canceling this request.
     *
     * NOTE: most nsIRequest implementations expect aStatus to be a
     * failure code; however, some implementations may allow aStatus to
     * be a success code such as NS_OK.  In general, aStatus should be
     * a failure code.
     */
    cancel(aStatus: nsresult): void;
    /**
     * Suspends the current request.  This may have the effect of closing
     * any underlying transport (in order to free up resources), although
     * any open streams remain logically opened and will continue delivering
     * data when the transport is resumed.
     *
     * Calling cancel() on a suspended request must not send any
     * notifications (such as onstopRequest) until the request is resumed.
     *
     * NOTE: some implementations are unable to immediately suspend, and
     * may continue to deliver events already posted to an event queue. In
     * general, callers should be capable of handling events even after
     * suspending a request.
     */
    suspend(): void;
    /**
     * Resumes the current request.  This may have the effect of re-opening
     * any underlying transport and will resume the delivery of data to
     * any open streams.
     */
    resume(): void;
    /**
     * The load group of this request.  While pending, the request is a
     * member of the load group.  It is the responsibility of the request
     * to implement this policy.
     */
    loadGroup: nsILoadGroup;
    /**
     * The load flags of this request.  Bits 0-15 are reserved.
     *
     * When added to a load group, this request's load flags are merged with
     * the load flags of the load group.
     */
    loadFlags: nsLoadFlags;
    /**
     * These methods encode/decode the TRR mode to/from the loadFlags.
     * Helper methods Get/SetTRRModeImpl are provided so implementations don't
     * need to duplicate code.
     *
     * Requests with TRR_DEFAULT_MODE will use the mode indicated by the pref
     * - see network.trr.mode in all.js
     * Requests with TRR_DISABLED_MODE will always use native DNS, even if the
     * pref is set to mode3 (TRR-only).
     * Requests with TRR_FIRST_MODE will first use TRR then fallback to regular
     * DNS, unless TRR is disabled by setting the pref to mode5, parental
     * control being enabled, or the domain being in the exclusion list.
     * Requests with TRR_ONLY_MODE will only use TRR, unless not allowed by
     * the same conditions mentioned above.
     */
    getTRRMode(): nsIRequest_TRRMode;
    /**
     *
     */
    setTRRMode(mode: nsIRequest_TRRModeType): void;
    /**
     *
     */
    cancelWithReason(aStatus: nsresult, aReason: ACString): void;
    /**
     *
     */
    canceledReason: ACString;
}

/**
 * Requests capable of tail-blocking must implement this
 * interfaces (typically channels).
 * If the request is tail-blocked, it will be held in its request
 * context queue until unblocked.
 */
declare interface nsIRequestTailUnblockCallbackType extends nsISupportsType {
    /**
     * Called when the requests is unblocked and proceed.
     * @param result
     * NS_OK - the request is OK to go, unblocking is not
     * caused by cancelation of the request.
     * any error - the request must behave as it were canceled
     * with the result as status.
     */
    onTailUnblock(aResult: nsresult): void;
}

/**
 * The nsIRequestContext is used to maintain state about connections
 * that are in some way associated with each other (often by being part
 * of the same load group) and how they interact with blocking items like
 * HEAD css/js loads.
 *
 * This used to be known as nsILoadGroupConnectionInfo and nsISchedulingContext.
 */
declare interface nsIRequestContextType extends nsISupportsType {
    /**
     * A unique identifier for this request context
     */
    readonly ID: unsigned_long_long;
    /**
     * Called by the associated document when its load starts.  This resets
     * context's internal states.
     */
    beginLoad(): void;
    /**
     * Called when the associated document notified the DOMContentLoaded event.
     */
    DOMContentLoaded(): void;
    /**
     * Number of active blocking transactions associated with this context
     */
    readonly blockingTransactionCount: unsigned_long;
    /**
     * Increase the number of active blocking transactions associated
     * with this context by one.
     */
    addBlockingTransaction(): void;
    /**
     * Decrease the number of active blocking transactions associated
     * with this context by one. The return value is the number of remaining
     * blockers.
     */
    removeBlockingTransaction(): unsigned_long;
    /**
     * This gives out a weak pointer to the push cache.
     * The nsIRequestContext implementation owns the cache
     * and will destroy it when overwritten or when the context
     * ends.
     */
    spdyPushCache: SpdyPushCachePtr;
    /**
     * Increases/decrease the number of non-tailed requests in this context.
     * If the count drops to zero, all tail-blocked callbacks are notified
     * shortly after that to be unblocked.
     */
    addNonTailRequest(): void;
    /**
     *
     */
    removeNonTailRequest(): void;
    /**
     * If the request context is in tail-blocked state, the callback
     * is queued and result is true.  The callback will be notified
     * about tail-unblocking or when the request context is canceled.
     */
    isContextTailBlocked(callback: nsIRequestTailUnblockCallbackType): boolean;
    /**
     * Called when the request is sitting in the tail queue but has been
     * canceled before untailing.  This just removes the request from the
     * queue so that it is not notified on untail and not referenced.
     */
    cancelTailedRequest(request: nsIRequestTailUnblockCallbackType): void;
    /**
     * This notifies all queued tail-blocked requests, they will be notified
     * aResult and released afterwards.  Called by the load group when
     * it's canceled.
     */
    cancelTailPendingRequests(aResult: nsresult): void;
}

/**
 * The nsIRequestContextService is how anyone gets access to a request
 * context when they haven't been explicitly given a strong reference to an
 * existing one. It is responsible for creating and handing out strong
 * references to nsIRequestContexts, but only keeps weak references itself.
 * The shared request context will go away once no one else is keeping a
 * reference to it. If you ask for a request context that has no one else
 * holding a reference to it, you'll get a brand new request context. Anyone
 * who asks for the same request context while you're holding a reference
 * will get a reference to the same request context you have.
 */
declare interface nsIRequestContextServiceType extends nsISupportsType {
    /**
     * Get an existing request context from its ID
     */
    getRequestContext(id: unsigned_long_long): nsIRequestContext;
    /**
     * Shorthand to get request context from a load group
     */
    getRequestContextFromLoadGroup(lg: nsILoadGroupType): nsIRequestContext;
    /**
     * Create a new request context
     */
    newRequestContext(): nsIRequestContext;
    /**
     * Remove an existing request context from its ID
     */
    removeRequestContext(id: unsigned_long_long): void;
}

/**
 * nsIRequestObserver
 */
declare interface nsIRequestObserverType extends nsISupportsType {
    /**
     * Called to signify the beginning of an asynchronous request.
     *
     * @param aRequest request being observed
     *
     * An exception thrown from onStartRequest has the side-effect of
     * causing the request to be canceled.
     */
    onStartRequest(aRequest: nsIRequestType): void;
    /**
     * Called to signify the end of an asynchronous request.  This
     * call is always preceded by a call to onStartRequest.
     *
     * @param aRequest request being observed
     * @param aStatusCode reason for stopping (NS_OK if completed successfully)
     *
     * An exception thrown from onStopRequest is generally ignored.
     */
    onStopRequest(aRequest: nsIRequestType, aStatusCode: nsresult): void;
}

/**
 * A request observer proxy is used to ship data over to another thread
 * specified by the thread's dispatch target. The "true" request observer's
 * methods are invoked on the other thread.
 *
 * This interface only provides the initialization needed after construction.
 * Otherwise, these objects are used simply as nsIRequestObserver's.
 */
declare interface nsIRequestObserverProxyType extends nsIRequestObserverType {
    /**
     * Initializes an nsIRequestObserverProxy.
     *
     * @param observer - receives observer notifications on the main thread
     * @param context  - the context argument that will be passed to OnStopRequest
     * and OnStartRequest. This has to be stored permanently on
     * initialization because it sometimes can't be
     * AddRef/Release'd off-main-thread.
     */
    init(observer: nsIRequestObserverType, context: nsISupportsType): void;
}

/**
 * Protocol handler interface for the resource:// protocol
 */
declare interface nsIResProtocolHandlerType extends nsISubstitutingProtocolHandlerType {
    /**
     *
     */
    allowContentToAccess(url: nsIURIType): boolean;
}

/**
 *
 */
declare interface nsIResumableChannelType extends nsISupportsType {
    /**
     * Prepare this channel for resuming. The request will not start until
     * asyncOpen or open is called. Calling resumeAt after open or asyncOpen
     * has been called has undefined behaviour.
     *
     * @param startPos the starting offset, in bytes, to use to download
     * @param entityID information about the file, to match before obtaining
     * the file. Pass an empty string to use anything.
     *
     * During OnStartRequest, this channel will have a status of
     * NS_ERROR_NOT_RESUMABLE if the file cannot be resumed, eg because the
     * server doesn't support this. This error may occur even if startPos
     * is 0, so that the front end can warn the user.
     * Similarly, the status of this channel during OnStartRequest may be
     * NS_ERROR_ENTITY_CHANGED, which indicates that the entity has changed,
     * as indicated by a changed entityID.
     * In both of these cases, no OnDataAvailable will be called, and
     * OnStopRequest will immediately follow with the same status code.
     */
    resumeAt(startPos: unsigned_long_long, entityID: ACString): void;
    /**
     * The entity id for this URI. Available after OnStartRequest.
     * @throw NS_ERROR_NOT_RESUMABLE if this load is not resumable.
     */
    readonly entityID: ACString;
}

/**
 * Represents a task which can be dispatched to a thread for execution.
 */
declare interface nsIRunnableType extends nsISupportsType {
    /**
     * The function implementing the task to be run.
     */
    run(): void;
}

/**
 *
 */
declare interface nsIRunnablePriorityType extends nsISupportsType {
    /**
     *
     */
    readonly priority: unsigned_long;
}

/**
 *
 */
declare interface nsIRunnableIPCMessageTypeType extends nsISupportsType {
    /**
     *
     */
    readonly type: unsigned_long;
}

/**
 *
 */
declare interface nsISDBCallbackType extends nsISupportsType {
    /**
     *
     */
    onComplete(aRequest: nsISDBRequestType): void;
}

/**
 *
 */
declare interface nsISDBCloseCallbackType extends nsISupportsType {
    /**
     *
     */
    onClose(aConnection: nsISDBConnectionType): void;
}

/**
 *
 */
declare interface nsISDBConnectionType extends nsISupportsType {
    /**
     *
     */
    init(aPrincipal: nsIPrincipalType, aPersistenceType: ACString): void;
    /**
     *
     */
    open(aName: AString): nsISDBRequest;
    /**
     *
     */
    seek(offset: unsigned_long_long): nsISDBRequest;
    /**
     *
     */
    read(size: unsigned_long_long): nsISDBRequest;
    /**
     *
     */
    write(value: jsval): nsISDBRequest;
    /**
     *
     */
    close(): nsISDBRequest;
    /**
     *
     */
    closeCallback: nsISDBCloseCallback;
}

/**
 *
 */
declare interface nsISDBRequestType extends nsISupportsType {
    /**
     *
     */
    readonly result: nsIVariant;
    /**
     *
     */
    readonly resultCode: nsresult;
    /**
     *
     */
    callback: nsISDBCallback;
}

/**
 *
 */
declare interface nsISDBResultType extends nsISupportsType {
    /**
     *
     */
    getAsArrayBuffer(): jsval;
}

/**
 *
 */
declare interface nsISHEntryType extends nsISupportsType {
    /**
     * The URI of the current entry.
     */
    URI: nsIURI;
    /**
     * The original URI of the current entry. If an entry is the result of a
     * redirect this attribute holds the original URI.
     */
    originalURI: nsIURI;
    /**
     * URL as stored from nsILoadInfo.resultPrincipalURI.  See nsILoadInfo
     * for more details.
     */
    resultPrincipalURI: nsIURI;
    /**
     * If non-null, the URI as it was before query stripping was performed.
     */
    unstrippedURI: nsIURI;
    /**
     * This flag remembers whether channel has LOAD_REPLACE set.
     */
    loadReplace: boolean;
    /**
     * The title of the current entry.
     */
    title: AString;
    /**
     * The name of the browsing context.
     */
    name: AString;
    /**
     * Was the entry created as a result of a subframe navigation?
     * - Will be 'false' when a frameset page is visited for the first time.
     * - Will be 'true' for all history entries created as a result of a
     * subframe navigation.
     */
    isSubFrame: boolean;
    /**
     * Whether the user interacted with the page while this entry was active.
     * This includes interactions with subframe documents associated with
     * child entries that are rooted at this entry.
     * This field will only be set on top-level entries.
     */
    hasUserInteraction: boolean;
    /**
     * Whether the load that created this entry was triggered by user activation.
     * (e.g.: The user clicked a link)
     * Remembering this flag enables replaying the sec-fetch-* headers.
     */
    hasUserActivation: boolean;
    /**
     * Referrer Info
     */
    referrerInfo: nsIReferrerInfo;
    /**
     * Content viewer, for fast restoration of presentation
     */
    contentViewer: nsIContentViewer;
    /**
     *
     */
    readonly isInBFCache: boolean;
    /**
     * Whether the content viewer is marked "sticky"
     */
    sticky: boolean;
    /**
     * Saved state of the global window object
     */
    windowState: nsISupports;
    /**
     * Saved refresh URI list for the content viewer
     */
    refreshURIList: nsIMutableArray;
    /**
     * Post Data for the document
     */
    postData: nsIInputStream;
    /**
     *
     */
    readonly hasPostData: boolean;
    /**
     * LayoutHistoryState for scroll position and form values
     */
    layoutHistoryState: nsILayoutHistoryState;
    /**
     * parent of this entry
     */
    parent: nsISHEntry;
    /**
     * The loadType for this entry. This is typically loadHistory except
     * when reload is pressed, it has the appropriate reload flag
     */
    loadType: unsigned_long;
    /**
     * An ID to help identify this entry from others during
     * subframe navigation
     */
    ID: unsigned_long;
    /**
     * The cache key for the entry
     */
    cacheKey: unsigned_long;
    /**
     * Should the layoutHistoryState be saved?
     */
    saveLayoutStateFlag: boolean;
    /**
     * attribute to indicate the content-type of the document that this
     * is a session history entry for
     */
    contentType: ACString;
    /**
     * If we created this SHEntry via history.pushState or modified it via
     * history.replaceState, and if we changed the SHEntry's URI via the
     * push/replaceState call, and if the SHEntry's new URI differs from its
     * old URI by more than just the hash, then we set this field to true.
     *
     * Additionally, if this SHEntry was created by calling pushState from a
     * SHEntry whose URI was modified, this SHEntry's URIWasModified field is
     * true.
     */
    URIWasModified: boolean;
    /**
     * Get the principal, if any, that was associated with the channel
     * that the document that was loaded to create this history entry
     * came from.
     */
    triggeringPrincipal: nsIPrincipal;
    /**
     * Get the principal, if any, that is used when the inherit flag
     * is set.
     */
    principalToInherit: nsIPrincipal;
    /**
     * Get the storage principal, if any, that is used when the inherit flag is
     * set.
     */
    partitionedPrincipalToInherit: nsIPrincipal;
    /**
     * Get the csp, if any, that was used for this document load. That
     * is not the CSP that was applied to subresource loads within the
     * document, but the CSP that was applied to this document load.
     */
    csp: nsIContentSecurityPolicy;
    /**
     * Get/set data associated with this history state via a pushState() call,
     * serialized using structured clone.
     */
    stateData: nsIStructuredCloneContainer;
    /**
     * The history ID of the docshell.
     */
    docshellID: nsIDRef;
    /**
     * True if this SHEntry corresponds to a document created by a srcdoc
     * iframe. Set when a value is assigned to srcdocData.
     */
    readonly isSrcdocEntry: boolean;
    /**
     * Contents of the srcdoc attribute in a srcdoc iframe to be loaded instead
     * of the URI.  Similar to a Data URI, this information is needed to
     * recreate the document at a later stage.
     * Setting this sets isSrcdocEntry to true
     */
    srcdocData: AString;
    /**
     * When isSrcdocEntry is true, this contains the baseURI of the srcdoc
     * document for use in situations where it cannot otherwise be determined,
     * for example with view-source.
     */
    baseURI: nsIURI;
    /**
     * Sets/gets the current scroll restoration state,
     * if true == "manual", false == "auto".
     */
    scrollRestorationIsManual: boolean;
    /**
     * Flag to indicate that the history entry was originally loaded in the
     * current process. This flag does not survive a browser process switch.
     */
    readonly loadedInThisProcess: boolean;
    /**
     * The session history it belongs to. This is set only on the root entries.
     */
    shistory: nsISHistory;
    /**
     * A number that is assigned by the sHistory when the entry is activated
     */
    lastTouched: unsigned_long;
    /**
     * The current number of nsISHEntries which are immediate children of this
     * SHEntry.
     */
    readonly childCount: long;
    /**
     * When an entry is serving is within nsISHistory's array of entries, this
     * property specifies if it should persist. If not it will be replaced by
     * new additions to the list.
     */
    persist: boolean;
    /**
     * Set/Get the visual viewport scroll position if session history is
     * changed through anchor navigation or pushState.
     */
    setScrollPosition(x: long, y: long): void;
    /**
     *
     */
    getScrollPosition(x: long, y: long): void;
    /**
     * Initialises `layoutHistoryState` if it doesn't already exist
     * and returns a reference to it.
     */
    initLayoutHistoryState(): nsILayoutHistoryState;
    /**
     *
     */
    clone(): nsISHEntry;
    /**
     * Returns true if any of the child entries returns true
     * when isDynamicallyAdded is called on it.
     */
    hasDynamicallyAddedChild(): boolean;
    /**
     * Adopt aEntry's BFCacheEntry, so now both this and aEntry point to
     * aEntry's BFCacheEntry.
     */
    adoptBFCacheEntry(aEntry: nsISHEntryType): void;
    /**
     * Create a new BFCache entry and drop our reference to our old one. This
     * call unlinks this SHEntry from any other SHEntries for its document.
     */
    abandonBFCacheEntry(): void;
    /**
     * Does this SHEntry correspond to the same document as aEntry? This is
     * true iff the two SHEntries have the same BFCacheEntry. So in particular,
     * sharesDocumentWith(aEntry) is guaranteed to return true if it's
     * preceded by a call to adoptBFCacheEntry(aEntry).
     */
    sharesDocumentWith(aEntry: nsISHEntryType): boolean;
    /**
     * Sets an SHEntry to reflect that it is a history type load. This is the
     * equivalent to doing
     *
     * shEntry.loadType = 4;
     *
     * in js, but is easier to maintain and less opaque.
     */
    setLoadTypeAsHistory(): void;
    /**
     * Add a new child SHEntry. If offset is -1 adds to the end of the list.
     */
    AddChild(aChild: nsISHEntryType, aOffset: long, aUseRemoteSubframes: bool): void;
    /**
     * Get child at an index.
     */
    GetChildAt(aIndex: long): nsISHEntry;
    /**
     * If this entry has no dynamically added child, get the child SHEntry
     * at the given offset. The loadtype of the returned entry is set
     * to its parent's loadtype.
     */
    GetChildSHEntryIfHasNoDynamicallyAddedChild(aChildOffset: long, aChild: nsISHEntryType): void;
    /**
     * Remove all children of this entry and call abandonBFCacheEntry.
     */
    ClearEntry(): void;
    /**
     *
     */
    readonly bfcacheID: unsigned_long_long;
    /**
     * Sync up the docshell and session history trees for subframe navigation.
     *
     * @param aEntry                    new entry
     * @param aTopBC                    top BC corresponding to the root ancestor
     * of the docshell that called this method
     * @param aIgnoreBC                 current BC
     */
    SyncTreesForSubframeNavigation(aEntry: nsISHEntryType, aTopBC: BrowsingContext, aIgnoreBC: BrowsingContext): void;
    /**
     * If browser.history.collectWireframes is true, this will get populated
     * with a Wireframe upon document navigation / pushState. This will only
     * be set for nsISHEntry's accessed in the parent process with
     * sessionHistoryInParent enabled. See Document.webidl for more details on
     * what a Wireframe is.
     */
    wireframe: jsval;
}

/**
 * An interface to the primary properties of the Session History
 * component. In an embedded browser environment, the nsIWebBrowser
 * object creates an instance of session history for each open window.
 * A handle to the session history object can be obtained from
 * nsIWebNavigation. In a non-embedded situation, the  owner of the
 * session history component must create a instance of it and set
 * it in the nsIWebNavigation object.
 * This interface is accessible from javascript.
 */
declare interface nsISHistoryType extends nsISupportsType {
    /**
     * A readonly property of the interface that returns
     * the number of toplevel documents currently available
     * in session history.
     */
    readonly count: long;
    /**
     * The index of the current document in session history. Not infallible
     * because setting can fail if the assigned value is out of range.
     */
    index: long;
    /**
     * A readonly property of the interface that returns
     * the index of the last document that started to load and
     * didn't finished yet. When document finishes the loading
     * value -1 is returned.
     */
    readonly requestedIndex: long;
    /**
     * Get the history entry at a given index. Returns non-null on success.
     *
     * @param index             The index value whose entry is requested.
     * The oldest entry is located at index == 0.
     * @return                  The found entry; never null.
     */
    getEntryAtIndex(aIndex: long): nsISHEntry;
    /**
     * Called to purge older documents from history.
     * Documents can be removed from session history for various
     * reasons. For example to  control memory usage of the browser, to
     * prevent users from loading documents from history, to erase evidence of
     * prior page loads etc...
     *
     * @param numEntries        The number of toplevel documents to be
     * purged from history. During purge operation,
     * the latest documents are maintained and older
     * 'numEntries' documents are removed from history.
     * @throws                  `NS_SUCCESS_LOSS_OF_INSIGNIFICANT_DATA`
     * Purge was vetod.
     * @throws                  `NS_ERROR_FAILURE` numEntries is
     * invalid or out of bounds with the size of history.
     */
    purgeHistory(aNumEntries: long): void;
    /**
     * Called to register a listener for the session history component.
     * Listeners are notified when pages are loaded or purged from history.
     *
     * @param aListener         Listener object to be notified for all
     * page loads that initiate in session history.
     *
     * @note                    A listener object must implement
     * nsISHistoryListener and nsSupportsWeakReference
     *
     * @see nsISHistoryListener
     * @see nsSupportsWeakReference
     */
    addSHistoryListener(aListener: nsISHistoryListenerType): void;
    /**
     * Called to remove a listener for the session history component.
     * Listeners are notified when pages are loaded from history.
     *
     * @param aListener         Listener object to be removed from
     * session history.
     *
     * @note                    A listener object must implement
     * nsISHistoryListener and nsSupportsWeakReference
     * @see nsISHistoryListener
     * @see nsSupportsWeakReference
     */
    removeSHistoryListener(aListener: nsISHistoryListenerType): void;
    /**
     *
     */
    reloadCurrentEntry(): void;
    /**
     * Add a new Entry to the History List.
     *
     * @param aEntry            The entry to add.
     * @param aPersist          If true this specifies that the entry should
     * persist in the list. If false, this means that
     * when new entries are added this element will not
     * appear in the session history list.
     */
    addEntry(aEntry: nsISHEntryType, aPersist: boolean): void;
    /**
     * Update the index maintained by sessionHistory
     */
    updateIndex(): void;
    /**
     * Replace the nsISHEntry at a particular index
     *
     * @param aIndex            The index at which the entry should be replaced.
     * @param aReplaceEntry     The replacement entry for the index.
     */
    replaceEntry(aIndex: long, aReplaceEntry: nsISHEntryType): void;
    /**
     * Notifies all registered session history listeners about an impending
     * reload.
     *
     * @return                  Whether the operation can proceed.
     */
    notifyOnHistoryReload(): boolean;
    /**
     * Evict content viewers which don't lie in the "safe" range around aIndex.
     * In practice, this should leave us with no more than gHistoryMaxViewers
     * viewers associated with this SHistory object.
     *
     * Also make sure that the total number of content viewers in all windows is
     * not greater than our global max; if it is, evict viewers as appropriate.
     *
     * @param aIndex           The index around which the "safe" range is
     * centered.  In general, if you just navigated the
     * history, aIndex should be the index history was
     * navigated to.
     */
    evictOutOfRangeContentViewers(aIndex: long): void;
    /**
     * Evict all the content viewers in this session history
     */
    evictAllContentViewers(): void;
    /**
     *
     */
    EnsureCorrectEntryAtCurrIndex(aEntry: nsISHEntryType): void;
    /**
     *
     */
    EvictContentViewersOrReplaceEntry(aNewSHEntry: nsISHEntryType, aReplace: bool): void;
    /**
     *
     */
    createEntry(): nsISHEntry;
}

/**
 * nsISHistoryListener defines the interface one can implement to receive
 * notifications about activities in session history and (for reloads) to be
 * able to cancel them.
 *
 * A session history listener will be notified when pages are added, removed
 * and loaded from session history. In the case of reloads, it can prevent them
 * from happening by returning false from the corresponding callback method.
 *
 * A session history listener can be registered on a particular nsISHistory
 * instance via the nsISHistory::addSHistoryListener() method.
 *
 * Listener methods should not alter the session history. Things are likely to
 * go haywire if they do.
 */
declare interface nsISHistoryListenerType extends nsISupportsType {
    /**
     * Called when a new document is added to session history. New documents are
     * added to session history by docshell when new pages are loaded in a frame
     * or content area, for example via nsIWebNavigation::loadURI()
     *
     * @param aNewURI     The URI of the document to be added to session history.
     * @param aOldIndex   The index of the current history item before the
     * operation.
     */
    OnHistoryNewEntry(aNewURI: nsIURIType, aOldIndex: long): void;
    /**
     * Called before the current document is reloaded, for example due to a
     * nsIWebNavigation::reload() call.
     */
    OnHistoryReload(): boolean;
    /**
     * Called before navigating to a session history entry by index, for example,
     * when nsIWebNavigation::gotoIndex() is called.
     */
    OnHistoryGotoIndex(): void;
    /**
     * Called before entries are removed from the start of session history.
     * Entries can be removed from session history for various reasons, for
     * example to control the memory usage of the browser, to prevent users from
     * loading documents from history, to erase evidence of prior page loads, etc.
     *
     * To purge documents from session history call nsISHistory::PurgeHistory().
     *
     * @param aNumEntries  The number of entries being removed.
     */
    OnHistoryPurge(aNumEntries: long): void;
    /**
     * Called before entries are removed from the end of session history. This
     * occurs when navigating to a new page while on a previous session entry.
     *
     * @param aNumEntries  The number of entries being removed.
     */
    OnHistoryTruncate(aNumEntries: long): void;
    /**
     * Called before an entry is replaced in the session history. Entries are
     * replaced when navigating away from non-persistent history entries (such as
     * about pages) and when history.replaceState is called.
     */
    OnHistoryReplaceEntry(): void;
    /**
     * Called whenever a content viewer is evicted. A content viewer is evicted
     * whenever a bfcache entry has timed out or the number of total content
     * viewers has exceeded the global max. This is used for testing only.
     *
     * @param aNumEvicted - number of content viewers evicted
     */
    OnContentViewerEvicted(aNumEvicted: unsigned_long): void;
}

/**
 * This interface provides a mechanism to control an output stream
 * that takes care not to overwrite an existing target until it is known
 * that all writes to the destination succeeded.
 *
 * An object that supports this interface is intended to also support
 * nsIOutputStream.
 *
 * For example, a file output stream that supports this interface writes to
 * a temporary file, and moves it over the original file when |finish| is
 * called only if the stream can be successfully closed and all writes
 * succeeded.  If |finish| is called but something went wrong during
 * writing, it will delete the temporary file and not touch the original.
 * If the stream is closed by calling |close| directly, or the stream
 * goes away, the original file will not be overwritten, and the temporary
 * file will be deleted.
 *
 * Currently, this interface is implemented only for file output streams.
 */
declare interface nsISafeOutputStreamType extends nsISupportsType {
    /**
     * Call this method to close the stream and cause the original target
     * to be overwritten. Note: if any call to |write| failed to write out
     * all of the data given to it, then calling this method will |close| the
     * stream and return failure. Further, if closing the stream fails, this
     * method will return failure. The original target will be overwritten only
     * if all calls to |write| succeeded and the stream was successfully closed.
     */
    finish(): void;
}

/**
 *
 */
declare interface nsIScreenType extends nsISupportsType {
    /**
     * These report screen dimensions in (screen-specific) device pixels
     */
    GetRect(left: long, top: long, width: long, height: long): void;
    /**
     *
     */
    GetAvailRect(left: long, top: long, width: long, height: long): void;
    /**
     * And these report in desktop pixels
     */
    GetRectDisplayPix(left: long, top: long, width: long, height: long): void;
    /**
     *
     */
    GetAvailRectDisplayPix(left: long, top: long, width: long, height: long): void;
    /**
     *
     */
    readonly pixelDepth: long;
    /**
     *
     */
    readonly colorDepth: long;
    /**
     * ScreenColorGamut is native type, which cannot be declared [infallible].
     */
    readonly colorGamut: ScreenColorGamut;
    /**
     * The number of device pixels per desktop pixel for this screen (for
     * hidpi configurations where there may be multiple device pixels per
     * desktop px and/or per CSS px).
     *
     * This seems poorly named (something like devicePixelsPerDesktopPixel
     * would be more accurate/explicit), but given that it is exposed to
     * front-end code and may also be used by add-ons, it's probably not
     * worth the disruption of changing it.
     *
     * Returns 1.0 if HiDPI mode is disabled or unsupported, or if the
     * host OS uses device pixels as its desktop pixel units (e.g. Windows 7 or
     * GTK/X11). Per-monitor DPI is available in Windows 8.1+, GTK/Wayland or
     * macOS.
     */
    readonly contentsScaleFactor: double;
    /**
     * The default number of device pixels per unscaled CSS pixel for this
     * screen. This is probably what contentsScaleFactor originally meant
     * to be, prior to confusion between CSS pixels and desktop pixel units.
     */
    readonly defaultCSSScaleFactor: double;
    /**
     * The DPI of the screen.
     */
    readonly dpi: float;
    /**
     * The target screen refresh rate, in Hz, or 0 if unknown
     */
    readonly refreshRate: long;
    /**
     *
     */
    readonly isPseudoDisplay: boolean;
}

/**
 *
 */
declare interface nsIScreenManagerType extends nsISupportsType {
    /**
     *
     */
    screenForRect(left: long, top: long, width: long, height: long): nsIScreen;
    /**
     *
     */
    readonly primaryScreen: nsIScreen;
    /**
     *
     */
    readonly totalScreenPixels: int64_t;
}

/**
 * An interface representing a channel which will have to execute some sort of
 * program provided via its URI to compute the data it should return.
 *
 * If a channel implements this interface, the execution of the program in
 * question will be restricted in the following ways:
 *
 * - If the channel does not have an owner principal, the program will not be
 * executed at all, no matter what.  This is necessary because in this
 * circumstance we have no way to tell whether script execution is allowed at
 * all for the originating security context of this channel.
 * - If the channel has an owner principal, how it is executed is controlled by
 * this interface.  However if the owner principal does not subsume the
 * principal of the environment in which the program is to be executed the
 * execution will be forced to happen in a sandbox.
 */
declare interface nsIScriptChannelType extends nsISupportsType {
    /**
     * Whether and how the program represented by this channel is to be executed.
     * The default value if this property has never been set on this channel MUST
     * be either EXECUTE_IN_SANDBOX or NO_EXECUTION.
     *
     * @throws NS_ERROR_INVALID_ARG when set to an unrecognized value.
     */
    executionPolicy: unsigned_long;
    /**
     * Control whether the program should be executed synchronosly when
     * the channel's AsyncOpen method is called or whether it should be
     * executed asynchronously.  In both cases, any data that the
     * channel returns will be returned asynchronously; the only thing
     * this property affects is when the program executes.
     *
     * The default value of this property is TRUE.
     *
     * Setting this property after asyncOpen has been called on the
     * channel has no effect.
     */
    executeAsync: boolean;
    /**
     * Check whether this script channel is a document load.  This is
     * needed because script channels can lie about their
     * LOAD_DOCUMENT_URI flag until they have run the script.
     */
    readonly isDocumentLoad: boolean;
}

/**
 *
 */
declare interface nsIScriptErrorNoteType extends nsISupportsType {
    /**
     *
     */
    readonly errorMessage: AString;
    /**
     *
     */
    readonly sourceName: AString;
    /**
     * Unique identifier within the process for the script source this note is
     * associated with, or zero.
     */
    readonly sourceId: uint32_t;
    /**
     *
     */
    readonly lineNumber: uint32_t;
    /**
     *
     */
    readonly columnNumber: uint32_t;
    /**
     *
     */
    toString(): AUTF8String;
}

/**
 *
 */
declare interface nsIScriptErrorType extends nsIConsoleMessageType {
    /**
     * The error message without any context/line number information.
     *
     * @note nsIConsoleMessage.message will return the error formatted
     * with file/line information.
     */
    readonly errorMessage: AString;
    /**
     *
     */
    readonly sourceName: AString;
    /**
     *
     */
    readonly sourceLine: AString;
    /**
     * Unique identifier within the process for the script source this error is
     * associated with, or zero.
     */
    readonly sourceId: uint32_t;
    /**
     *
     */
    readonly lineNumber: uint32_t;
    /**
     *
     */
    readonly columnNumber: uint32_t;
    /**
     *
     */
    readonly flags: uint32_t;
    /**
     * Categories I know about -
     * XUL javascript
     * content javascript (both of these from nsDocShell, currently)
     * system javascript (errors in JS components and other system JS)
     */
    readonly category: string;
    /**
     * Get the window id this was initialized with.  Zero will be
     * returned if init() was used instead of initWithWindowID().
     */
    readonly outerWindowID: unsigned_long_long;
    /**
     * Get the inner window id this was initialized with.  Zero will be
     * returned if init() was used instead of initWithWindowID().
     */
    readonly innerWindowID: unsigned_long_long;
    /**
     *
     */
    readonly isFromPrivateWindow: boolean;
    /**
     *
     */
    readonly isFromChromeContext: boolean;
    /**
     *
     */
    readonly isPromiseRejection: boolean;
    /**
     *
     */
    exception: jsval;
    /**
     *
     */
    readonly hasException: boolean;
    /**
     *
     */
    stack: jsval;
    /**
     * If |stack| is an object, then stackGlobal must be a global object that's
     * same-compartment with |stack|. This can be used to enter the correct
     * realm when working with the stack object. We can't use the object itself
     * because it might be a cross-compartment wrapper and CCWs are not
     * associated with a single realm/global.
     */
    readonly stackGlobal: jsval;
    /**
     * The name of a template string associated with the error message.  See
     * js/public/friend/ErrorNumbers.msg.
     */
    errorMessageName: AString;
    /**
     *
     */
    readonly notes: nsIArray;
    /**
     * If the ScriptError is a CSS parser error, this value will contain the
     * CSS selectors of the CSS ruleset where the error occured.
     */
    cssSelectors: AString;
    /**
     *
     */
    init(message: AString, sourceName: AString, sourceLine: AString, lineNumber: uint32_t, columnNumber: uint32_t, flags: uint32_t, category: ACString, fromPrivateWindow: bool, fromChromeContext: bool): void;
    /**
     * This should be called instead of nsIScriptError.init to
     * initialize with a window id.  The window id should be for the
     * inner window associated with this error.
     *
     * This function will check whether sourceName is a uri and sanitize it if
     * needed. If you know the source name is sanitized already, use
     * initWithSanitizedSource.
     * A "sanitized" source name means that passwords are not shown. It will
     * use the sensitiveInfoHiddenSpec function of nsIURI interface, that is
     * replacing paswords with ***
     * (e.g. https://USERNAME:****@example.com/some/path).
     */
    initWithWindowID(message: AString, sourceName: AString, sourceLine: AString, lineNumber: uint32_t, columnNumber: uint32_t, flags: uint32_t, category: ACString, innerWindowID: unsigned_long_long, fromChromeContext: bool): void;
    /**
     * This is the same function as initWithWindowID, but it expects an already
     * sanitized sourceName.
     * Please use it only if sourceName string is already sanitized.
     */
    initWithSanitizedSource(message: AString, sourceName: AString, sourceLine: AString, lineNumber: uint32_t, columnNumber: uint32_t, flags: uint32_t, category: ACString, innerWindowID: unsigned_long_long, fromChromeContext: bool): void;
    /**
     * This is the same function as initWithWindowID with an uri as a source parameter.
     */
    initWithSourceURI(message: AString, sourceURI: nsIURIType, sourceLine: AString, lineNumber: uint32_t, columnNumber: uint32_t, flags: uint32_t, category: ACString, innerWindowID: unsigned_long_long, fromChromeContext: bool): void;
    /**
     * Initialize the script source ID in a new error.
     */
    initSourceId(sourceId: uint32_t): void;
}

/**
 *
 */
declare interface nsIScriptLoaderObserverType extends nsISupportsType {
    /**
     * The script is available for evaluation. For inline scripts, this
     * method will be called synchronously. For externally loaded scripts,
     * this method will be called when the load completes.
     *
     * @param aResult A result code representing the result of loading
     * a script. If this is a failure code, script evaluation
     * will not occur.
     * @param aElement The element being processed.
     * @param aIsInline Is this an inline classic script (as opposed to an
     * externally loaded classic script or module script)?
     * @param aURI What is the URI of the script (the document URI if
     * it is inline).
     * @param aLineNo At what line does the script appear (generally 1
     * if it is a loaded script).
     */
    scriptAvailable(aResult: nsresult, aElement: nsIScriptElementType, aIsInlineClassicScript: boolean, aURI: nsIURIType, aLineNo: uint32_t): void;
    /**
     * The script has been evaluated.
     *
     * @param aResult A result code representing the success or failure of
     * the script evaluation.
     * @param aElement The element being processed.
     * @param aIsInline Is this an inline script or externally loaded?
     */
    scriptEvaluated(aResult: nsresult, aElement: nsIScriptElementType, aIsInline: boolean): void;
}

/**
 *
 */
declare interface nsIScriptSecurityManagerType extends nsISupportsType {
    /**
     * Check that content with principal aPrincipal can load "uri".
     *
     * Will return error code NS_ERROR_DOM_BAD_URI if the load request
     * should be denied.
     *
     * @param aPrincipal the principal identifying the actor causing the load
     * @param uri the URI that is being loaded
     * @param flags the permission set, see above
     * @param innerWindowID the window ID for error reporting.  If this is 0
     * (which happens automatically if it's not passed from JS), errors
     * will only appear in the browser console, not window-associated
     * consoles like the web console.
     */
    checkLoadURIWithPrincipalXPCOM(aPrincipal: nsIPrincipalType, uri: nsIURIType, flags: unsigned_long, innerWindowID: unsigned_long_long): void;
    /**
     * Same as the above, but when called from JS, raises exceptions with more
     * useful messages, including both the tested URI and the principal string.
     */
    checkLoadURIWithPrincipal(aPrincipal: nsIPrincipalType, uri: nsIURIType, flags: unsigned_long, innerWindowID: unsigned_long_long): void;
    /**
     * Similar to checkLoadURIWithPrincipal but there are two differences:
     *
     * 1) The URI is a string, not a URI object.
     * 2) This function assumes that the URI may still be subject to fixup (and
     * hence will check whether fixed-up versions of the URI are allowed to
     * load as well); if any of the versions of this URI is not allowed, this
     * function will return error code NS_ERROR_DOM_BAD_URI.
     */
    checkLoadURIStrWithPrincipalXPCOM(aPrincipal: nsIPrincipalType, uri: AUTF8String, flags: unsigned_long): void;
    /**
     * Same as the above, but when called from JS, raises exceptions with more
     * useful messages, including both the tested URI and the principal string.
     */
    checkLoadURIStrWithPrincipal(aPrincipal: nsIPrincipalType, uri: AUTF8String, flags: unsigned_long): void;
    /**
     * Returns true if the URI is from a domain that is allow-listed through
     * prefs to be allowed to use file:// URIs.
     * @param aUri the URI to be tested
     */
    inFileURIAllowlist(aUri: nsIURIType): bool;
    /**
     * Return the all-powerful system principal.
     */
    getSystemPrincipal(): nsIPrincipal;
    /**
     * Returns a principal that has the OriginAttributes of the load context.
     * @param loadContext to get the OriginAttributes from.
     */
    getLoadContextContentPrincipal(uri: nsIURIType, loadContext: nsILoadContextType): nsIPrincipal;
    /**
     * Returns a principal that has the OriginAttributes of the docshell.
     * @param docShell to get the OriginAttributes from.
     */
    getDocShellContentPrincipal(uri: nsIURIType, docShell: nsIDocShellType): nsIPrincipal;
    /**
     * If this is a content principal, return a copy with different
     * origin attributes.
     */
    principalWithOA(principal: nsIPrincipalType, originAttributes: jsval): nsIPrincipal;
    /**
     * Returns a principal whose origin is composed of |uri| and |originAttributes|.
     * See nsIPrincipal.idl for a description of origin attributes, and
     * ChromeUtils.webidl for a list of origin attributes and their defaults.
     */
    createContentPrincipal(uri: nsIURIType, originAttributes: jsval): nsIPrincipal;
    /**
     * Returns a principal whose origin is the one we pass in.
     * See nsIPrincipal.idl for a description of origin attributes, and
     * ChromeUtils.webidl for a list of origin attributes and their defaults.
     */
    createContentPrincipalFromOrigin(origin: ACString): nsIPrincipal;
    /**
     * Takes a principal and returns a string representation of it or a nullptr if it can't be serialized.
     * Example output: `{"1": {"0": "https://mozilla.com", "2": "^privateBrowsingId=1"}}`
     */
    principalToJSON(principal: nsIPrincipalType): ACString;
    /**
     * Takes a string of the following format:
     * `{"1": {"0": "https://mozilla.com", "2": "^privateBrowsingId=1"}}`
     * and turns it into a principal or a nullptr on error.
     */
    JSONToPrincipal(json: ACString): nsIPrincipal;
    /**
     * Returns a unique nonce principal with |originAttributes|.
     * See nsIPrincipal.idl for a description of origin attributes, and
     * ChromeUtils.webidl for a list of origin attributes and their defaults.
     */
    createNullPrincipal(originAttributes: jsval): nsIPrincipal;
    /**
     * Returns OK if aSourceURI and target have the same "origin"
     * (scheme, host, and port).
     * ReportError flag suppresses error reports for functions that
     * don't need reporting.
     * FromPrivateWindow indicates whether the error occurs in a private
     * window or not.
     */
    checkSameOriginURI(aSourceURI: nsIURIType, aTargetURI: nsIURIType, reportError: boolean, fromPrivateWindow: boolean): void;
    /**
     * Get the principal for the given channel.  This will typically be the
     * channel owner if there is one, and the content principal for the
     * channel's URI otherwise.  aChannel must not be null.
     */
    getChannelResultPrincipal(aChannel: nsIChannelType): nsIPrincipal;
    /**
     * Get the storage principal for the given channel.  This is basically the
     * same of getChannelResultPrincipal() execept for trackers, where we
     * return a principal with a different OriginAttributes.
     */
    getChannelResultStoragePrincipal(aChannel: nsIChannelType): nsIPrincipal;
    /**
     * This method returns 2 principals from a nsIChannel:
     * - aPrincipal is the regular principal.
     * - aPartitionedPrincipal is aPrincipal plus an isolation key in its
     * originAttributes.
     * See more in StoragePrincipalHelper.h
     */
    getChannelResultPrincipals(aChannel: nsIChannelType, aPrincipal: nsIPrincipalType, aPartitionedPrincipal: nsIPrincipalType): void;
    /**
     * Get the content principal for the channel's URI.
     * aChannel must not be null.
     */
    getChannelURIPrincipal(aChannel: nsIChannelType): nsIPrincipal;
    /**
     * Per-domain controls to enable and disable script. This system is designed
     * to be used by at most one consumer, and enforces this with its semantics.
     *
     * Initially, domainPolicyActive is false. When activateDomainPolicy() is
     * invoked, domainPolicyActive becomes true, and subsequent calls to
     * activateDomainPolicy() will fail until deactivate() is invoked on the
     * nsIDomainPolicy returned from activateDomainPolicy(). At this point,
     * domainPolicyActive becomes false again, and a new consumer may acquire
     * control of the system by invoking activateDomainPolicy().
     */
    activateDomainPolicy(): nsIDomainPolicy;
    /**
     *
     */
    readonly domainPolicyActive: boolean;
    /**
     * Query mechanism for the above policy.
     *
     * If domainPolicyEnabled is false, this simply returns the current value
     * of javascript.enabled. Otherwise, it returns the same value, but taking
     * the various blocklist/allowlist exceptions into account.
     */
    policyAllowsScript(aDomain: nsIURIType): bool;
}

/**
 * nsIScriptableBase64Encoder efficiently encodes the contents
 * of a nsIInputStream to a Base64 string.  This avoids the need
 * to read the entire stream into a buffer, and only then do the
 * Base64 encoding.
 *
 * If you already have a buffer full of data, you should use
 * btoa instead!
 */
declare interface nsIScriptableBase64EncoderType extends nsISupportsType {
    /**
     * These methods take an nsIInputStream and return a narrow or wide
     * string with the contents of the nsIInputStream base64 encoded.
     *
     * The stream passed in must support ReadSegments and must not be
     * a non-blocking stream that will return NS_BASE_STREAM_WOULD_BLOCK.
     * If either of these restrictions are violated we will abort.
     */
    encodeToCString(stream: nsIInputStreamType, length: unsigned_long): ACString;
    /**
     *
     */
    encodeToString(stream: nsIInputStreamType, length: unsigned_long): AString;
}

/**
 * nsIScriptableContentIterator is designed to testing concrete classes of
 * ContentIteratorBase.
 */
declare interface nsIScriptableContentIteratorType extends nsISupportsType {
    /**
     * You need to call initWith*() first.  Then, the instance of this interface
     * decides the type of iterator with its aType argument.  You can call
     * initWith*() multiple times, but you need to keep setting same type as
     * previous call.  If you set different type, these method with throw an
     * exception.
     */
    initWithRootNode(aType: nsIScriptableContentIterator_IteratorTypeType, aRoot: Node): void;
    /**
     *
     */
    initWithRange(aType: nsIScriptableContentIterator_IteratorTypeType, aRange: Range): void;
    /**
     *
     */
    initWithPositions(aType: nsIScriptableContentIterator_IteratorTypeType, aStartContainer: Node, aStartOffset: unsigned_long, aEndContainer: Node, aEndOffset: unsigned_long): void;
    /**
     *
     */
    first(): void;
    /**
     *
     */
    last(): void;
    /**
     *
     */
    next(): void;
    /**
     *
     */
    prev(): void;
    /**
     *
     */
    readonly currentNode: Node;
    /**
     *
     */
    readonly isDone: bool;
    /**
     *
     */
    positionAt(aNode: Node): void;
}

/**
 * nsIScriptableInputStream provides scriptable access to an nsIInputStream
 * instance.
 */
declare interface nsIScriptableInputStreamType extends nsISupportsType {
    /**
     * Closes the stream.
     */
    close(): void;
    /**
     * Wrap the given nsIInputStream with this nsIScriptableInputStream.
     *
     * @param aInputStream parameter providing the stream to wrap
     */
    init(aInputStream: nsIInputStreamType): void;
    /**
     * Return the number of bytes currently available in the stream
     *
     * @return the number of bytes
     *
     * @throws NS_BASE_STREAM_CLOSED if called after the stream has been closed
     */
    available(): unsigned_long_long;
    /**
     * Read data from the stream.
     *
     * WARNING: If the data contains a null byte, then this method will return
     * a truncated string.
     *
     * @param aCount the maximum number of bytes to read
     *
     * @return the data, which will be an empty string if the stream is at EOF.
     *
     * @throws NS_BASE_STREAM_CLOSED if called after the stream has been closed
     * @throws NS_ERROR_NOT_INITIALIZED if init was not called
     */
    read(aCount: unsigned_long): string;
    /**
     * Read data from the stream, including NULL bytes.
     *
     * @param aCount the maximum number of bytes to read.
     *
     * @return the data from the stream, which will be an empty string if EOF
     * has been reached.
     *
     * @throws NS_BASE_STREAM_WOULD_BLOCK if reading from the input stream
     * would block the calling thread (non-blocking mode only).
     * @throws NS_ERROR_FAILURE if there are not enough bytes available to read
     * aCount amount of data.
     */
    readBytes(aCount: unsigned_long): ACString;
}

/**
 * In new code, please use the WebIDL TextDecoder and TextEncoder
 * instead. They represent bytes as Uint8Array (or as view to such
 * array), which is the current best practice for representing bytes
 * in JavaScript.
 *
 * This interface converts between UTF-16 in JavaScript strings
 * and bytes transported as the unsigned value of each byte
 * transported in a code unit of the same numeric value in
 * a JavaScript string.
 *
 * @created         8/Jun/2000
 * @author          Makoto Kato [m_kato@ga2.so-net.ne.jp]
 */
declare interface nsIScriptableUnicodeConverterType extends nsISupportsType {
    /**
     * Converts the data from Unicode to one Charset.
     * Returns the converted string. After converting, Finish should be called
     * and its return value appended to this return value.
     */
    ConvertFromUnicode(aSrc: AString): ACString;
    /**
     * Returns the terminator string.
     * Should be called after ConvertFromUnicode() and appended to that
     * function's return value.
     */
    Finish(): ACString;
    /**
     * Converts the data from one Charset to Unicode.
     */
    ConvertToUnicode(aSrc: ACString): AString;
    /**
     * Current character set.
     *
     * @throw NS_ERROR_UCONV_NOCONV
     * The requested charset is not supported.
     */
    charset: ACString;
    /**
     * Meaningless
     */
    isInternal: boolean;
}

/**
 *
 */
declare interface nsISearchSubmissionType extends nsISupportsType {
    /**
     * The POST data associated with a search submission, wrapped in a MIME
     * input stream. May be null.
     */
    readonly postData: nsIInputStream;
    /**
     * The URI to submit a search to.
     */
    readonly uri: nsIURI;
}

/**
 *
 */
declare interface nsISearchEngineType extends nsISupportsType {
    /**
     * Gets a nsISearchSubmission object that contains information about what to
     * send to the search engine, including the URI and postData, if applicable.
     *
     * @param searchTerms
     * The search term(s) for the submission.
     *
     * @param responseType [optional]
     * The MIME type that we'd like to receive in response
     * to this submission.  If null, will default to "text/html".
     *
     * @param purpose [optional]
     * A string that indicates the context of the search request. This may then
     * be used to provide different submission data depending on the context.
     *
     * @returns nsISearchSubmission
     * The submission data. If no appropriate submission can be determined for
     * the request type, this may be null.
     */
    getSubmission(searchTerms: AString, responseType: AString, purpose: AString): nsISearchSubmission;
    /**
     * Returns the search term of a possible search result URI if and only if:
     * - The URI has the same scheme, host, and path as the engine.
     * - All query parameters of the URI have a matching name and value in the engine.
     * - An exception to the equality check is the engine's termsParameterName
     * value, which contains a placeholder, i.e. {searchTerms}.
     * - If an engine has query parameters with "null" values, they will be ignored.
     *
     * @param  uri
     * A URI that may or may not be from a search result matching the engine.
     *
     * @returns A string representing the termsParameterName value of the URI,
     * or an empty string if the URI isn't matched to the engine.
     */
    searchTermFromResult(uri: nsIURIType): AString;
    /**
     * Returns the name of the parameter used for the search terms for a submission
     * URL of type `SearchUtils.URL_TYPE.SEARCH`.
     *
     * @returns A string which is the name of the parameter, or empty string
     * if no parameter cannot be found or is not supported (e.g. POST).
     */
    readonly searchUrlQueryParamName: AString;
    /**
     * Returns the public suffix for the submission URL of type
     * `SearchUtils.URL_TYPE.SEARCH`.
     *
     * @returns A string which is a known public suffix, or empty string
     * if one cannot be found.
     */
    readonly searchUrlPublicSuffix: AString;
    /**
     * Determines whether the engine can return responses in the given
     * MIME type.  Returns true if the engine spec has a URL with the
     * given responseType, false otherwise.
     *
     * @param responseType
     * The MIME type to check for
     */
    supportsResponseType(responseType: AString): boolean;
    /**
     * Returns a string with the URL to an engine's icon matching both width and
     * height. Returns null if icon with specified dimensions is not found.
     *
     * @param width
     * Width of the requested icon.
     * @param height
     * Height of the requested icon.
     */
    getIconURLBySize(width: long, height: long): AString;
    /**
     * Gets an array of all available icons. Each entry is an object with
     * width, height and url properties. width and height are numeric and
     * represent the icon's dimensions. url is a string with the URL for
     * the icon.
     */
    getIcons(): jsval;
    /**
     * Opens a speculative connection to the engine's search URI
     * (and suggest URI, if different) to reduce request latency
     *
     * @param  options
     * An object that must contain the following fields:
     * {window} the content window for the window performing the search
     * {originAttributes} the originAttributes for performing the search
     *
     * @throws NS_ERROR_INVALID_ARG if options is omitted or lacks required
     * elemeents
     */
    speculativeConnect(options: jsval): void;
    /**
     * An optional shortcut alias for the engine.
     * When not an empty string, this is a unique identifier.
     */
    alias: AString;
    /**
     * A text description describing the engine.
     */
    readonly description: AString;
    /**
     * Whether the engine should be hidden from the user.
     */
    hidden: boolean;
    /**
     * Whether the associated one off button should be hidden from the user.
     */
    hideOneOffButton: boolean;
    /**
     * A nsIURI corresponding to the engine's icon, stored locally. May be null.
     */
    readonly iconURI: nsIURI;
    /**
     * The display name of the search engine. This is a unique identifier.
     */
    readonly name: AString;
    /**
     * The display of the search engine id. This is a unique identifier.
     */
    readonly id: AString;
    /**
     * The searchForm URL points to the engine's organic search page. This should
     * not contain neither search term parameters nor partner codes, but may
     * contain parameters which set the engine in the correct way.
     *
     * This URL is typically the prePath and filePath of the search submission URI,
     * but may vary for different engines. For example, some engines may use a
     * different domain, e.g. https://sub.example.com for the search URI but
     * https://example.org/ for the organic search page.
     */
    readonly searchForm: AString;
    /**
     * A boolean to indicate if we should send an attribution request to Mozilla's
     * server.
     */
    readonly sendAttributionRequest: boolean;
    /**
     * The identifier to use for this engine when submitting to telemetry.
     */
    readonly telemetryId: AString;
    /**
     * An optional unique identifier for this search engine within the context of
     * the distribution, as provided by the distributing entity.
     */
    readonly identifier: AString;
    /**
     * Whether or not this engine is provided by the application, e.g. it is
     * in the list of configured search engines.
     */
    readonly isAppProvided: boolean;
    /**
     * Whether or not this engine is an in-memory only search engine.
     * These engines are typically application provided or policy engines,
     * where they are loaded every time on SearchService initialization
     * using the policy JSON or the extension manifest. Minimal details of the
     * in-memory engines are saved to disk, but they are never loaded
     * from the user's saved settings file.
     */
    readonly inMemory: boolean;
    /**
     * Whether or not this engine is a "general" search engine, e.g. is it for
     * generally searching the web, or does it have a specific purpose like
     * shopping.
     */
    readonly isGeneralPurposeEngine: boolean;
    /**
     * The domain from which search results are returned for this engine.
     *
     * @return the domain of the the search URL.
     */
    readonly searchUrlDomain: AString;
}

/**
 *
 */
declare interface nsISearchParseSubmissionResultType extends nsISupportsType {
    /**
     * The search engine associated with the URL passed in to
     * nsISearchEngine::parseSubmissionURL, or null if the URL does not represent
     * a search submission.
     */
    readonly engine: nsISearchEngine;
    /**
     * String containing the sought terms.  This can be an empty string in case no
     * terms were specified or the URL does not represent a search submission.
     */
    readonly terms: AString;
    /**
     * The name of the query parameter used by `engine` for queries. E.g. "q".
     */
    readonly termsParameterName: AString;
}

/**
 *
 */
declare interface nsISearchServiceType extends nsISupportsType {
    /**
     * Start asynchronous initialization.
     *
     * The promise is resolved once initialization is complete, which may be
     * immediately, if initialization has already been completed by some previous
     * call to this method.
     * This method should only be called when you need or want to wait for the
     * full initialization of the search service.
     */
    init(): Promise;
    /**
     * Determine whether initialization has been completed.
     *
     * Clients of the service can use this attribute to quickly determine whether
     * initialization is complete, and decide to trigger some immediate treatment,
     * to launch asynchronous initialization or to bailout.
     *
     * Note that this attribute does not indicate that initialization has succeeded.
     *
     * @return |true| if the search service is now initialized, |false| if
     * initialization has not been triggered yet.
     */
    readonly isInitialized: bool;
    /**
     * Determine whether initialization has been completed successfully.
     */
    readonly hasSuccessfullyInitialized: bool;
    /**
     * Runs background checks; Designed to be run on idle.
     */
    runBackgroundChecks(): Promise;
    /**
     * Resets the default engine to its app default engine value.
     */
    resetToAppDefaultEngine(): Promise;
    /**
     * Adds a new Open Search engine from the file at the supplied URI.
     *
     * @param engineURL
     * The URL to the search engine's description file.
     *
     * @param iconURL
     * A URL string to an icon file to be used as the search engine's
     * icon. This value may be overridden by an icon specified in the
     * engine description file.
     *
     * @throws NS_ERROR_FAILURE if the description file cannot be successfully
     * loaded.
     */
    addOpenSearchEngine(engineURL: AString, iconURL: AString): Promise;
    /**
     * Adds a new search engine defined by the user.
     *
     * @param name
     * The name of the engine.
     * @param url
     * The url of the engine with %s denoting where to
     * replace the search term.
     * @param alias [optional]
     * The alias to refer to the engine.
     */
    addUserEngine(name: AString, url: AString, alias: AString): Promise;
    /**
     * Adds search providers to the search service.  If the search
     * service is configured to load multiple locales for the extension,
     * it may load more than one search engine. If called directly
     * ensure the extension has been initialised.
     *
     * @param extension
     * The extension to load from.
     * @returns Promise that resolves when finished.
     */
    addEnginesFromExtension(extension: jsval): Promise;
    /**
     * Un-hides all engines in the set of engines returned by getAppProvidedEngines.
     */
    restoreDefaultEngines(): void;
    /**
     * Returns an engine with the specified alias.
     *
     * @param   alias
     * The search engine's alias.
     * @returns The corresponding nsISearchEngine object, or null if it doesn't
     * exist.
     */
    getEngineByAlias(alias: AString): Promise;
    /**
     * Returns an engine with the specified name.
     *
     * @param   aEngineName
     * The name of the engine.
     * @returns The corresponding nsISearchEngine object, or null if it doesn't
     * exist.
     */
    getEngineByName(aEngineName: AString): nsISearchEngine;
    /**
     * Returns an engine with the specified Id.
     *
     * @param   aEngineId
     * The Id of the engine.
     * @returns The corresponding nsISearchEngine object, or null if it doesn't
     * exist.
     */
    getEngineById(aEngineId: AString): nsISearchEngine;
    /**
     * Returns an array of all installed search engines.
     * The array is sorted either to the user requirements or the default order.
     *
     * @returns an array of nsISearchEngine objects.
     */
    getEngines(): Promise;
    /**
     * Returns an array of all installed search engines whose hidden attribute is
     * false.
     * The array is sorted either to the user requirements or the default order.
     *
     * @returns an array of nsISearchEngine objects.
     */
    getVisibleEngines(): Promise;
    /**
     * Returns an array of all default search engines. This includes all loaded
     * engines that aren't in the user's profile directory.
     * The array is sorted to the default order.
     *
     * @returns an array of nsISearchEngine objects.
     */
    getAppProvidedEngines(): Promise;
    /**
     * Returns an array of search engines installed by a given extension.
     *
     * @returns an array of nsISearchEngine objects.
     */
    getEnginesByExtensionID(extensionID: AString): Promise;
    /**
     * Moves a visible search engine.
     *
     * @param  engine
     * The engine to move.
     * @param  newIndex
     * The engine's new index in the set of visible engines.
     *
     * @throws NS_ERROR_FAILURE if newIndex is out of bounds, or if engine is
     * hidden.
     */
    moveEngine(engine: nsISearchEngineType, newIndex: long): Promise;
    /**
     * Removes the search engine. If the search engine is installed in a global
     * location, this will just hide the engine. If the engine is in the user's
     * profile directory, it will be removed from disk.
     *
     * @param  engine
     * The engine to remove.
     */
    removeEngine(engine: nsISearchEngineType): Promise;
    /**
     * Notify nsSearchService that an extension has been removed. Removes any
     * engines that are associated with that extension.
     *
     * @param  id
     * The id of the extension.
     */
    removeWebExtensionEngine(id: AString): Promise;
    /**
     * The Application Default Engine object that is the default for this region,
     * ignoring changes the user may have subsequently made.
     */
    readonly appDefaultEngine: nsISearchEngine;
    /**
     * The Application Default Engine object that is the default for this region when in
     * private browsing mode, ignoring changes the user may have subsequently made.
     */
    readonly appPrivateDefaultEngine: nsISearchEngine;
    /**
     * The currently active search engine.
     * Unless the application doesn't ship any search plugin, this should never
     * be null. If the currently active engine is removed, this attribute will
     * fallback first to the application default engine if it's not hidden, then to
     * the first visible engine, and as a last resort it will unhide the app
     * default engine.
     */
    defaultEngine: nsISearchEngine;
    /**
     *
     */
    getDefault(): Promise;
    /**
     *
     */
    setDefault(engine: nsISearchEngineType, changeSource: unsigned_short): Promise;
    /**
     * The currently active search engine for private browsing mode.
     * @see defaultEngine.
     */
    defaultPrivateEngine: nsISearchEngine;
    /**
     *
     */
    getDefaultPrivate(): Promise;
    /**
     *
     */
    setDefaultPrivate(engine: nsISearchEngineType, changeSource: unsigned_short): Promise;
    /**
     * Whether to display the "Search in Private Window" result in the urlbar.
     */
    readonly separatePrivateDefaultUrlbarResultEnabled: boolean;
    /**
     * Allows the add-on manager to discover if a WebExtension based search engine
     * may change the default to an application provided search engine.
     * If that WebExtension is on the allow list, then it will override the
     * built-in engine's urls and parameters.
     *
     * @param extension
     * The extension to load from.
     * @returns An object with two booleans:
     * - canChangeToAppProvided: indicates if the WebExtension engine may
     * set the named engine as default e.g. it is application provided.
     * - canInstallEngine: indicates if the WebExtension engine may be
     * installed, e.g. it is not an app-provided engine.
     */
    maybeSetAndOverrideDefault(extension: jsval): Promise;
    /**
     * Gets a representation of the default engine in an anonymized JSON
     * string suitable for recording in the Telemetry environment.
     *
     * @return {object} result
     * contains anonymized info about the default engine(s).
     * @return {string} result.defaultSearchEngine
     * contains the telemetry id of the default engine.
     * @return {object} result.defaultSearchEngineData
     * contains information about the default engine:
     * name, loadPath, original submissionURL
     * @return {string} [result.defaultPrivateSearchEngine]
     * only returned if the preference for having a separate engine in private
     * mode is turned on.
     * contains the telemetry id of the default engine for private browsing mode.
     * @return {object} [result.defaultPrivateSearchEngineData]
     * only returned if the preference for having a separate engine in private
     * mode is turned on.
     * contains information about the default engine for private browsing mode:
     * name, loadPath, original submissionURL
     */
    getDefaultEngineInfo(): jsval;
    /**
     * Determines if the provided URL represents results from a search engine, and
     * provides details about the match.
     *
     * The lookup mechanism checks whether the domain name and path of the
     * provided HTTP or HTTPS URL matches one of the known values for the visible
     * search engines.  The match does not depend on which of the schemes is used.
     * The expected URI parameter for the search terms must exist in the query
     * string, but other parameters are ignored.
     *
     * @param url
     * String containing the URL to parse, for example
     * "https://www.google.com/search?q=terms".
     */
    parseSubmissionURL(url: AString): nsISearchParseSubmissionResult;
}

/**
 * nsISecCheckWrapChannel
 * Describes an XPCOM component used to wrap channels for performing
 * security checks. Channels wrapped inside this class can use
 * this interface to query the wrapped inner channel.
 */
declare interface nsISecCheckWrapChannelType extends nsISupportsType {
    /**
     * Returns the wrapped channel inside this class.
     */
    readonly innerChannel: nsIChannel;
}

/**
 *
 */
declare interface nsISecretDecoderRingType extends nsISupportsType {
    /**
     * Encrypt to Base64 output.
     * Note that the input must basically be a byte array (i.e. the code points
     * must be within the range [0, 255]). Hence, using this method directly to
     * encrypt passwords (or any text, really) won't work as expected.
     * Instead, use something like nsIScriptableUnicodeConverter to first convert
     * the desired password or text to UTF-8, then encrypt that. Remember to
     * convert back when calling decryptString().
     *
     * @param text The text to encrypt.
     * @return The encrypted text, encoded as Base64.
     */
    encryptString(text: ACString): ACString;
    /**
     * Run encryptString on multiple strings, asynchronously. This will allow you
     * to not jank the browser if you need to encrypt a large number of strings
     * all at once. This method accepts an array of wstrings which it will convert
     * to UTF-8 internally before encrypting.
     *
     * @param plaintexts the strings to encrypt.
     * @return A promise for the list of encrypted strings, encoded as Base64.
     */
    asyncEncryptStrings(plaintexts: invalid): Promise;
    /**
     * Decrypt Base64 input.
     * See the encryptString() documentation - this method has basically the same
     * limitations.
     *
     * @param encryptedBase64Text Encrypted input text, encoded as Base64.
     * @return The decoded text.
     */
    decryptString(encryptedBase64Text: ACString): ACString;
    /**
     * Run decryptString on multiple strings, asynchronously. This will allow you
     * to not jank the browser if you need to decrypt a large number of strings
     * all at once.
     *
     * @param encryptedStrings the strings to decrypt, encoded as Base64.
     * @return A promise that resolves with the list of decrypted strings in Unicode.
     */
    asyncDecryptStrings(encryptedStrings: invalid): Promise;
    /**
     * Prompt the user to change the password on the SDR key.
     */
    changePassword(): void;
    /**
     * Logout of the security device that protects the SDR key.
     */
    logout(): void;
    /**
     * Logout of the security device that protects the SDR key and tear
     * down authenticated objects.
     */
    logoutAndTeardown(): void;
}

/**
 *
 */
declare interface nsISecureBrowserUIType extends nsISupportsType {
    /**
     *
     */
    readonly state: unsigned_long;
    /**
     *
     */
    readonly isSecureContext: bool;
    /**
     *
     */
    readonly secInfo: nsITransportSecurityInfo;
}

/**
 * Holds localization message tag and message category
 * for security related console messages.
 */
declare interface nsISecurityConsoleMessageType extends nsISupportsType {
    /**
     *
     */
    tag: AString;
    /**
     *
     */
    category: AString;
}

/**
 *
 */
declare interface nsISecurityUITelemetryType extends nsISupportsType {
}

/**
 *
 */
declare interface nsISeekableStreamType extends nsITellableStreamType {
    /**
     * seek
     *
     * This method moves the stream offset of the steam implementing this
     * interface.
     *
     * @param whence specifies how to interpret the 'offset' parameter in
     * setting the stream offset associated with the implementing
     * stream.
     *
     * @param offset specifies a value, in bytes, that is used in conjunction
     * with the 'whence' parameter to set the stream offset of the
     * implementing stream.  A negative value causes seeking in
     * the reverse direction.
     *
     * @throws NS_BASE_STREAM_CLOSED if called on a closed stream.
     */
    seek(whence: long, offset: long_long): void;
    /**
     * setEOF
     *
     * This method truncates the stream at the current offset.
     *
     * @throws NS_BASE_STREAM_CLOSED if called on a closed stream.
     */
    setEOF(): void;
}

/**
 *
 */
declare interface nsISelectionControllerType extends nsISelectionDisplayType {
    /**
     * SetDisplaySelection will set the display mode for the selection. OFF,ON,DISABLED
     */
    setDisplaySelection(toggle: short): void;
    /**
     * GetDisplaySelection will get the display mode for the selection. OFF,ON,DISABLED
     */
    getDisplaySelection(): short;
    /**
     * GetSelection will return the selection that the presentation
     * shell may implement.
     *
     * @param aType This will hold the type of selection.  This value must be one
     * of RawSelectionType values.
     * @param _return will hold the return value
     */
    getSelection(type: short): Selection;
    /**
     * ScrollSelectionIntoView scrolls a region of the selection,
     * so that it is visible in the scrolled view.
     *
     * @param aType the selection to scroll into view.  This value must be one
     * of RawSelectionType values.
     * @param aRegion the region inside the selection to scroll into view. //SelectionRegion
     * @param aFlags the scroll flags.  Valid bits include:
     * SCROLL_SYNCHRONOUS: when set, scrolls the selection into view
     * before returning. If not set, posts a request which is processed
     * at some point after the method returns.
     * SCROLL_FIRST_ANCESTOR_ONLY: if set, only the first ancestor will be scrolled
     * into view.
     * SCROLL_OVERFLOW_HIDDEN: if set, scrolls even if the overflow is specified
     * as hidden.
     * SCROLL_FOR_CARET_MOVE: set to indicate whether scrolling is in response
     * to the caret being moved. Does not affect behavior (used for telemetry
     * purposes only).
     *
     * Note that if isSynchronous is true, then this might flush the pending
     * reflow. It's dangerous for some objects. See bug 418470 comment 12.
     */
    scrollSelectionIntoView(type: short, region: short, flags: short): void;
    /**
     * RepaintSelection repaints the selection specified by aType.
     *
     * @param aType specifies the selection to repaint.
     */
    repaintSelection(type: short): void;
    /**
     * Set the caret as enabled or disabled. An enabled caret will
     * draw or blink when made visible. A disabled caret will never show up.
     * Can be called any time.
     * @param aEnable PR_TRUE to enable caret.  PR_FALSE to disable.
     * @return always NS_OK
     */
    setCaretEnabled(enabled: boolean): void;
    /**
     * Set the caret readonly or not. An readonly caret will
     * draw but not blink when made visible.
     * @param aReadOnly PR_TRUE to enable caret.  PR_FALSE to disable.
     * @return always NS_OK
     */
    setCaretReadOnly(readOnly: boolean): void;
    /**
     * Gets the current state of the caret.
     * @param aEnabled  [OUT] set to the current caret state, as set by SetCaretEnabled
     * @return   if aOutEnabled==null, returns NS_ERROR_INVALID_ARG
     * else NS_OK
     */
    getCaretEnabled(): boolean;
    /**
     * This is true if the caret is enabled, visible, and currently blinking.
     * This is still true when the caret is enabled, visible, but in its "off"
     * blink cycle.
     */
    readonly caretVisible: boolean;
    /**
     * Show the caret even in selections. By default the caret is hidden unless the
     * selection is collapsed. Use this function to show the caret even in selections.
     * @param aVisibility PR_TRUE to show the caret in selections.  PR_FALSE to hide.
     * @return always NS_OK
     */
    setCaretVisibilityDuringSelection(visibility: boolean): void;
    /**
     * CharacterMove will move the selection one character forward/backward in the document.
     * this will also have the effect of collapsing the selection if the aExtend = PR_FALSE
     * the "point" of selection that is extended is considered the "focus" point.
     * or the last point adjusted by the selection.
     * @param aForward forward or backward if PR_FALSE
     * @param aExtend  should it collapse the selection of extend it?
     */
    characterMove(forward: boolean, extend: boolean): void;
    /**
     * PhysicalMove will move the selection one "unit" in a given direction
     * within the document.
     * this will also have the effect of collapsing the selection if the aExtend = PR_FALSE
     * the "point" of selection that is extended is considered the "focus" point.
     * or the last point adjusted by the selection.
     * @param aDirection
     * @param aAmount    character/line; word/lineBoundary
     * @param aExtend    should it collapse the selection of extend it?
     */
    physicalMove(direction: short, amount: short, extend: boolean): void;
    /**
     * WordMove will move the selection one word forward/backward in the document.
     * this will also have the effect of collapsing the selection if the aExtend = PR_FALSE
     * the "point" of selection that is extended is considered the "focus" point.
     * or the last point adjusted by the selection.
     * @param aForward forward or backward if PR_FALSE
     * @param aExtend  should it collapse the selection of extend it?
     */
    wordMove(forward: boolean, extend: boolean): void;
    /**
     * LineMove will move the selection one line forward/backward in the document.
     * this will also have the effect of collapsing the selection if the aExtend = PR_FALSE
     * the "point" of selection that is extended is considered the "focus" point.
     * or the last point adjusted by the selection.
     * @param aForward forward or backward if PR_FALSE
     * @param aExtend  should it collapse the selection of extend it?
     */
    lineMove(forward: boolean, extend: boolean): void;
    /**
     * IntraLineMove will move the selection to the front of the line or end of the line
     * in the document.
     * this will also have the effect of collapsing the selection if the aExtend = PR_FALSE
     * the "point" of selection that is extended is considered the "focus" point.
     * or the last point adjusted by the selection.
     * @param aForward forward or backward if PR_FALSE
     * @param aExtend  should it collapse the selection of extend it?
     */
    intraLineMove(forward: boolean, extend: boolean): void;
    /**
     * PageMove will move the selection one page forward/backward in the document.
     * this will also have the effect of collapsing the selection if the aExtend = PR_FALSE
     * the "point" of selection that is extended is considered the "focus" point.
     * or the last point adjusted by the selection.
     * @param aForward forward or backward if PR_FALSE
     * @param aExtend  should it collapse the selection of extend it?
     */
    pageMove(forward: boolean, extend: boolean): void;
    /**
     * CompleteScroll will move page view to the top or bottom of the document
     * @param aForward forward or backward if PR_FALSE
     */
    completeScroll(forward: boolean): void;
    /**
     * CompleteMove will move page view to the top or bottom of the document
     * this will also have the effect of collapsing the selection if the aExtend = PR_FALSE
     * the "point" of selection that is extended is considered the "focus" point.
     * or the last point adjusted by the selection.
     * @param aForward forward or backward if PR_FALSE
     * @param aExtend  should it collapse the selection of extend it?
     */
    completeMove(forward: boolean, extend: boolean): void;
    /**
     * ScrollPage will scroll the page without affecting the selection.
     * @param aForward scroll forward or backwards in selection
     */
    scrollPage(forward: boolean): void;
    /**
     * ScrollLine will scroll line up or down dependent on the boolean
     * @param aForward scroll forward or backwards in selection
     */
    scrollLine(forward: boolean): void;
    /**
     * ScrollCharacter will scroll right or left dependent on the boolean
     * @param aRight if true will scroll right. if not will scroll left.
     */
    scrollCharacter(right: boolean): void;
}

/**
 *
 */
declare interface nsISelectionDisplayType extends nsISupportsType {
    /**
     * SetSelectionFlags used to set whether you want to see HRULES/IMAGES with border.
     * also used to tell if the presshell is an editor right now. this should change
     *
     * @param aToggle -either DISPLAY_(TEXT,IMAGES,FRAMES,ALL)
     * This will tell the rendering engine to draw the different
     * selection types.
     */
    setSelectionFlags(toggle: short): void;
    /**
     * GetSelectionFlags used to get whether you want to see HRULES/IMAGES with border.
     * also used to tell if the presshell is an editor right now. this should change
     *
     * @param short *aReturn - This will be filled with DISPLAY_(TEXT,IMAGE,FRAMES,ALL)
     * bit flags.
     */
    getSelectionFlags(): short;
}

/**
 *
 */
declare interface nsISelectionListenerType extends nsISupportsType {
    /**
     *
     */
    notifySelectionChanged(doc: Document, sel: Selection, reason: short, amount: long): void;
}

/**
 *
 */
declare interface nsISensitiveInfoHiddenURIType extends nsISupportsType {
    /**
     * Returns the spec attribute with sensitive information hidden. This will
     * only affect uri with password. The password part of uri will be
     * transformed into "****".
     */
    getSensitiveInfoHiddenSpec(): AUTF8String;
}

/**
 * A serial event target is an event dispatching interface like
 * nsIEventTarget. Runnables dispatched to an nsISerialEventTarget are required
 * to execute serially. That is, two different runnables dispatched to the
 * target should never be allowed to execute simultaneously. One exception to
 * this rule is nested event loops. If a runnable spins a nested event loop,
 * causing another runnable dispatched to the target to run, the target may
 * still be considered "serial".
 *
 * Examples:
 * - nsIThread is a serial event target.
 * - Thread pools are not serial event targets.
 * - However, one can "convert" a thread pool into an nsISerialEventTarget
 * by putting a TaskQueue in front of it.
 */
declare interface nsISerialEventTargetType extends nsIEventTargetType {
}

/**
 *
 */
declare interface nsISerializableType extends nsISupportsType {
    /**
     * Initialize the object implementing nsISerializable, which must have
     * been freshly constructed via CreateInstance.  All data members that
     * can't be set to default values must have been serialized by write,
     * and should be read from aInputStream in the same order by this method.
     */
    read(aInputStream: nsIObjectInputStreamType): void;
    /**
     * Serialize the object implementing nsISerializable to aOutputStream, by
     * writing each data member that must be recovered later to reconstitute
     * a working replica of this object, in a canonical member and byte order,
     * to aOutputStream.
     *
     * NB: a class that implements nsISerializable *must* also implement
     * nsIClassInfo, in particular nsIClassInfo::GetClassID.
     */
    write(aOutputStream: nsIObjectOutputStreamType): void;
}

/**
 *
 */
declare interface nsISerializationHelperType extends nsISupportsType {
    /**
     * Serialize the object to a base64 string. This string can be later passed
     * as an input to deserializeObject method.
     */
    serializeToString(serializable: nsISerializableType): ACString;
    /**
     * Takes base64 encoded string that cointains serialization of a single
     * object. Most commonly, input is result of previous call to
     * serializeToString.
     */
    deserializeObject(input: ACString): nsISupports;
}

/**
 * nsIServerSocket
 *
 * An interface to a server socket that can accept incoming connections.
 */
declare interface nsIServerSocketType extends nsISupportsType {
    /**
     * @}
     *
     * init
     *
     * This method initializes a server socket.
     *
     * @param aPort
     * The port of the server socket.  Pass -1 to indicate no preference,
     * and a port will be selected automatically.
     * @param aLoopbackOnly
     * If true, the server socket will only respond to connections on the
     * local loopback interface.  Otherwise, it will accept connections
     * from any interface.  To specify a particular network interface,
     * use initWithAddress.
     * @param aBackLog
     * The maximum length the queue of pending connections may grow to.
     * This parameter may be silently limited by the operating system.
     * Pass -1 to use the default value.
     */
    init(aPort: long, aLoopbackOnly: boolean, aBackLog: long): void;
    /**
     * the same as init(), but initializes an IPv6 server socket
     */
    initIPv6(aPort: long, aLoopbackOnly: boolean, aBackLog: long): void;
    /**
     * Similar to init(), but initializes a server socket that supports
     * both IPv4 and IPv6.
     */
    initDualStack(aPort: long, aBackLog: long): void;
    /**
     * initSpecialConnection
     *
     * This method initializes a server socket and offers the ability to have
     * that socket not get terminated if Gecko is set offline.
     *
     * @param aPort
     * The port of the server socket.  Pass -1 to indicate no preference,
     * and a port will be selected automatically.
     * @param aFlags
     * Flags for the socket.
     * @param aBackLog
     * The maximum length the queue of pending connections may grow to.
     * This parameter may be silently limited by the operating system.
     * Pass -1 to use the default value.
     */
    initSpecialConnection(aPort: long, aFlags: nsServerSocketFlag, aBackLog: long): void;
    /**
     * initWithFilename
     *
     * This method initializes a Unix domain or "local" server socket. Such
     * a socket has a name in the filesystem, like an ordinary file. To
     * connect, a client supplies the socket's filename, and the usual
     * permission checks on socket apply.
     *
     * This makes Unix domain sockets useful for communication between the
     * programs being run by a specific user on a single machine: the
     * operating system takes care of authentication, and the user's home
     * directory or profile directory provide natural per-user rendezvous
     * points.
     *
     * Since Unix domain sockets are always local to the machine, they are
     * not affected by the nsIIOService's 'offline' flag.
     *
     * The system-level socket API may impose restrictions on the length of
     * the filename that are stricter than those of the underlying
     * filesystem. If the file name is too long, this returns
     * NS_ERROR_FILE_NAME_TOO_LONG.
     *
     * All components of the path prefix of |aPath| must name directories;
     * otherwise, this returns NS_ERROR_FILE_NOT_DIRECTORY.
     *
     * This call requires execute permission on all directories containing
     * the one in which the socket is to be created, and write and execute
     * permission on the directory itself. Otherwise, this returns
     * NS_ERROR_CONNECTION_REFUSED.
     *
     * This call creates the socket's directory entry. There must not be
     * any existing entry with the given name. If there is, this returns
     * NS_ERROR_SOCKET_ADDRESS_IN_USE.
     *
     * On systems that don't support Unix domain sockets at all, this
     * returns NS_ERROR_SOCKET_ADDRESS_NOT_SUPPORTED.
     *
     * @param aPath nsIFile
     * The file name at which the socket should be created.
     *
     * @param aPermissions unsigned long
     * Unix-style permission bits to be applied to the new socket.
     *
     * Note about permissions: Linux's unix(7) man page claims that some
     * BSD-derived systems ignore permissions on UNIX-domain sockets;
     * NetBSD's bind(2) man page agrees, but says it does check now (dated
     * 2005). POSIX has required 'connect' to fail if write permission on
     * the socket itself is not granted since 2003 (Issue 6). NetBSD says
     * that the permissions on the containing directory (execute) have
     * always applied, so creating sockets in appropriately protected
     * directories should be secure on both old and new systems.
     */
    initWithFilename(aPath: nsIFileType, aPermissions: unsigned_long, aBacklog: long): void;
    /**
     * initWithAbstractAddress
     *
     * This mehtod is a flavor of initWithFilename method. This initializes
     * a UNIX domain socket that uses abstract socket address.
     * This socket type is only supported on Linux and Android.
     *
     * On systems that don't support this type's UNIX domain sockets at all,
     * this returns NS_ERROR_SOCKET_ADDRESS_NOT_SUPPORTED.
     *
     * @param aName
     * The abstract socket address which the socket should be created.
     * @param aBacklog
     * The maximum length the queue of pending connections may grow to.
     */
    initWithAbstractAddress(aName: AUTF8String, aBacklog: long): void;
    /**
     * close
     *
     * This method closes a server socket.  This does not affect already
     * connected client sockets (i.e., the nsISocketTransport instances
     * created from this server socket).  This will cause the onStopListening
     * event to asynchronously fire with a status of NS_BINDING_ABORTED.
     */
    close(): void;
    /**
     * asyncListen
     *
     * This method puts the server socket in the listening state.  It will
     * asynchronously listen for and accept client connections.  The listener
     * will be notified once for each client connection that is accepted.  The
     * listener's onSocketAccepted method will be called on the same thread
     * that called asyncListen (the calling thread must have a nsIEventTarget).
     *
     * The listener will be passed a reference to an already connected socket
     * transport (nsISocketTransport).  See below for more details.
     *
     * @param aListener
     * The listener to be notified when client connections are accepted.
     */
    asyncListen(aListener: nsIServerSocketListenerType): void;
    /**
     * Returns the port of this server socket.
     */
    readonly port: long;
}

/**
 * nsIServerSocketListener
 *
 * This interface is notified whenever a server socket accepts a new connection.
 * The transport is in the connected state, and read/write streams can be opened
 * using the normal nsITransport API.  The address of the client can be found by
 * calling the nsISocketTransport::GetAddress method or by inspecting
 * nsISocketTransport::GetHost, which returns a string representation of the
 * client's IP address (NOTE: this may be an IPv4 or IPv6 string literal).
 */
declare interface nsIServerSocketListenerType extends nsISupportsType {
    /**
     * onSocketAccepted
     *
     * This method is called when a client connection is accepted.
     *
     * @param aServ
     * The server socket.
     * @param aTransport
     * The connected socket transport.
     */
    onSocketAccepted(aServ: nsIServerSocketType, aTransport: nsISocketTransportType): void;
    /**
     * onStopListening
     *
     * This method is called when the listening socket stops for some reason.
     * The server socket is effectively dead after this notification.
     *
     * @param aServ
     * The server socket.
     * @param aStatus
     * The reason why the server socket stopped listening.  If the
     * server socket was manually closed, then this value will be
     * NS_BINDING_ABORTED.
     */
    onStopListening(aServ: nsIServerSocketType, aStatus: nsresult): void;
}

/**
 * The nsIServiceManager manager interface provides a means to obtain
 * global services in an application. The service manager depends on the
 * repository to find and instantiate factories to obtain services.
 *
 * Users of the service manager must first obtain a pointer to the global
 * service manager by calling NS_GetServiceManager. After that,
 * they can request specific services by calling GetService. When they are
 * finished they can NS_RELEASE() the service as usual.
 *
 * A user of a service may keep references to particular services indefinitely
 * and only must call Release when it shuts down.
 */
declare interface nsIServiceManagerType extends nsISupportsType {
    /**
     * getServiceByContractID
     *
     * Returns the instance that implements aClass or aContractID and the
     * interface aIID.  This may result in the instance being created.
     *
     * @param aClass or aContractID : aClass or aContractID of object
     * instance requested
     * @param aIID : IID of interface requested
     * @param result : resulting service
     */
    getService(aClass: nsCIDRef, aIID: nsIIDRefType, result: nsQIResult): void;
    /**
     *
     */
    getServiceByContractID(aContractID: string, aIID: nsIIDRefType, result: nsQIResult): void;
    /**
     * isServiceInstantiated
     *
     * isServiceInstantiated will return a true if the service has already
     * been created, or false otherwise. Throws if the service does not
     * implement the given IID.
     *
     * @param aClass or aContractID : aClass or aContractID of object
     * instance requested
     * @param aIID : IID of interface requested
     * @throws NS_NOINTERFACE if the IID given isn't supported by the object
     */
    isServiceInstantiated(aClass: nsCIDRef, aIID: nsIIDRefType): boolean;
    /**
     *
     */
    isServiceInstantiatedByContractID(aContractID: string, aIID: nsIIDRefType): boolean;
}

/**
 *
 */
declare interface nsIServiceWorkerUnregisterCallbackType extends nsISupportsType {
    /**
     *
     */
    unregisterSucceeded(aState: bool): void;
    /**
     *
     */
    unregisterFailed(): void;
}

/**
 *
 */
declare interface nsIServiceWorkerInfoType extends nsISupportsType {
    /**
     *
     */
    readonly id: AString;
    /**
     *
     */
    readonly scriptSpec: AString;
    /**
     *
     */
    readonly cacheName: AString;
    /**
     *
     */
    readonly state: unsigned_short;
    /**
     *
     */
    readonly debugger: nsIWorkerDebugger;
    /**
     *
     */
    readonly handlesFetchEvents: bool;
    /**
     *
     */
    readonly installedTime: PRTime;
    /**
     *
     */
    readonly activatedTime: PRTime;
    /**
     *
     */
    readonly redundantTime: PRTime;
    /**
     *
     */
    readonly navigationFaultCount: unsigned_long;
    /**
     *
     */
    testingInjectCancellation: nsresult;
    /**
     *
     */
    attachDebugger(): void;
    /**
     *
     */
    detachDebugger(): void;
}

/**
 *
 */
declare interface nsIServiceWorkerRegistrationInfoListenerType extends nsISupportsType {
    /**
     *
     */
    onChange(): void;
}

/**
 *
 */
declare interface nsIServiceWorkerRegistrationInfoType extends nsISupportsType {
    /**
     *
     */
    readonly principal: nsIPrincipal;
    /**
     *
     */
    readonly unregistered: boolean;
    /**
     *
     */
    readonly scope: AString;
    /**
     *
     */
    readonly scriptSpec: AString;
    /**
     *
     */
    readonly updateViaCache: unsigned_short;
    /**
     *
     */
    readonly lastUpdateTime: PRTime;
    /**
     *
     */
    readonly evaluatingWorker: nsIServiceWorkerInfo;
    /**
     *
     */
    readonly installingWorker: nsIServiceWorkerInfo;
    /**
     *
     */
    readonly waitingWorker: nsIServiceWorkerInfo;
    /**
     *
     */
    readonly activeWorker: nsIServiceWorkerInfo;
    /**
     *
     */
    readonly quotaUsageCheckCount: long;
    /**
     *
     */
    getWorkerByID(aID: unsigned_long_long): nsIServiceWorkerInfo;
    /**
     *
     */
    addListener(listener: nsIServiceWorkerRegistrationInfoListenerType): void;
    /**
     *
     */
    removeListener(listener: nsIServiceWorkerRegistrationInfoListenerType): void;
    /**
     *
     */
    forceShutdown(): void;
}

/**
 *
 */
declare interface nsIServiceWorkerManagerListenerType extends nsISupportsType {
    /**
     *
     */
    onRegister(aInfo: nsIServiceWorkerRegistrationInfoType): void;
    /**
     *
     */
    onUnregister(aInfo: nsIServiceWorkerRegistrationInfoType): void;
    /**
     * Called by ServiceWorker bypass mitigations when checking whether an
     * origin's quota usage is sufficiently full that we need to clear the origin
     * (and possibly group's) data as part of our mitigation.
     * This notification is provided primarily for testing code that needs to wait
     * for this check to happen but has no other mechanism for knowing it's
     * completed. Probably not relevant to devtools.
     */
    onQuotaUsageCheckFinish(aInfo: nsIServiceWorkerRegistrationInfoType): void;
}

/**
 *
 */
declare interface nsIServiceWorkerManagerType extends nsISupportsType {
    /**
     * A testing helper that is meant to only be used in xpcshell-test to test behaviors
     * that would need a browser restart to re-initialize the ServiceWorkerManager from
     * the service worker registration dumped on disk (the one listed in the serviceworker.txt
     * file part of the Firefox profile directory).
     *
     * NOTE: this test helper does
     * - fail if "dom.serviceWorkers.testing.enabled" is not set to true
     * - fail if there are controlled clients (the test case is responsible of making sure that
     * there is none when this method is being called)
     * - shutdown and clear all service worker registrations (but without removing them from
     * the registration stored in serviceworker.txt)
     * - force reload the registration data stored in serviceworker.txt (but the test case using
     * this helper is responsible to be sure that the registrations have been already written
     * on disk)
     */
    reloadRegistrationsForTest(): void;
    /**
     * A testing helper that registers a service worker for testing purpose (e.g. used to test
     * a remote worker that has to spawn a new process to be launched).
     * This method can only be used when "dom.serviceWorkers.testing.enabled" is true and
     * it doesn't support all the registration options (e.g. updateViaCache is set automatically
     * to "imports").
     */
    registerForTest(aPrincipal: nsIPrincipalType, aScope: AString, aScriptURL: AString): Promise;
    /**
     * Register an extension background service worker for a given
     * extension principal and return a promise that resolves to the
     * nsIServiceWorkerRegistrationInfo (or rejects if there was one
     * already registered).
     */
    registerForAddonPrincipal(aPrincipal: nsIPrincipalType): Promise;
    /**
     * Get an extension background service worker registration for a
     * given extension principal, return an nsIServiceWorkerRegistrationInfo
     * if one exists (or null if no registration has been found).
     */
    getRegistrationForAddonPrincipal(aPrincipal: nsIPrincipalType, regInfo: nsIServiceWorkerRegistrationInfoType): void;
    /**
     * Wake up the extension background service worker given its extension base url,
     * for an API event identified by the namespace and event name strings.
     *
     * Returns a Promise which is resolved to true if a listener has been subscribed
     * during the synchronous worker script execution for the expected WebExtensions
     * API event.
     *
     * NOTE: ExtensionBrowser and ExtensionEventManager interfaces are keeping track
     * of these listeners. These are WebExtensions API event listeners and they do not
     * involve any functional events at all.
     */
    wakeForExtensionAPIEvent(aExtensionBaseURL: AString, aAPINamespace: AString, aAPIEventName: AString): Promise;
    /**
     * Unregister an existing ServiceWorker registration for `aScope`.
     * It keeps aCallback alive until the operation is concluded.
     */
    unregister(aPrincipal: nsIPrincipalType, aCallback: nsIServiceWorkerUnregisterCallbackType, aScope: AString): void;
    /**
     *
     */
    getRegistrationByPrincipal(aPrincipal: nsIPrincipalType, aScope: AString): nsIServiceWorkerRegistrationInfo;
    /**
     *
     */
    StartControlling(aClientInfo: const_ClientInfoRef, aServiceWorker: const_ServiceWorkerDescriptorRef): bool;
    /**
     *
     */
    getScopeForUrl(aPrincipal: nsIPrincipalType, aPath: AString): AString;
    /**
     *
     */
    getAllRegistrations(): nsIArray;
    /**
     *
     */
    removeRegistrationsByOriginAttributes(aOriginAttributes: AString): void;
    /**
     *
     */
    propagateUnregister(aPrincipal: nsIPrincipalType, aCallback: nsIServiceWorkerUnregisterCallbackType, aScope: AString): void;
    /**
     *
     */
    sendNotificationClickEvent(aOriginSuffix: ACString, scope: ACString, aID: AString, aTitle: AString, aDir: AString, aLang: AString, aBody: AString, aTag: AString, aIcon: AString, aData: AString, aBehavior: AString): void;
    /**
     *
     */
    sendNotificationCloseEvent(aOriginSuffix: ACString, scope: ACString, aID: AString, aTitle: AString, aDir: AString, aLang: AString, aBody: AString, aTag: AString, aIcon: AString, aData: AString, aBehavior: AString): void;
    /**
     *
     */
    sendPushEvent(aOriginAttributes: ACString, aScope: ACString, aDataBytes: invalid): void;
    /**
     *
     */
    sendPushSubscriptionChangeEvent(aOriginAttributes: ACString, scope: ACString): void;
    /**
     *
     */
    addListener(aListener: nsIServiceWorkerManagerListenerType): void;
    /**
     *
     */
    removeListener(aListener: nsIServiceWorkerManagerListenerType): void;
}

/**
 *
 */
declare interface nsISessionStorageServiceType extends nsISupportsType {
    /**
     * Removes all storages stored for the given principal.
     *
     * @param aPrincipal
     * A principal for the origin whose storages are to be cleared.
     */
    clearStoragesForOrigin(aPrincipal: nsIPrincipalType): void;
}

/**
 *
 */
declare interface nsISessionStoreRestoreDataType extends nsISupportsType {
    /**
     *
     */
    url: AUTF8String;
    /**
     *
     */
    innerHTML: AString;
    /**
     *
     */
    scroll: ACString;
    /**
     *
     */
    addTextField(aIsXPath: boolean, aIdOrXPath: AString, aValue: AString): void;
    /**
     *
     */
    addCheckbox(aIsXPath: boolean, aIdOrXPath: AString, aValue: boolean): void;
    /**
     *
     */
    addFileList(aIsXPath: boolean, aIdOrXPath: AString, aType: AString, aFileList: invalid): void;
    /**
     *
     */
    addSingleSelect(aIsXPath: boolean, aIdOrXPath: AString, aSelectedIndex: unsigned_long, aValue: AString): void;
    /**
     *
     */
    addMultipleSelect(aIsXPath: boolean, aIdOrXPath: AString, aValues: invalid): void;
    /**
     *
     */
    addCustomElement(aIsXPath: boolean, aIdOrXPath: AString, aValue: jsval, aState: jsval): void;
    /**
     *
     */
    addChild(aChild: nsISessionStoreRestoreDataType, aIndex: unsigned_long): void;
}

/**
 *
 */
declare interface nsISharePickerType extends nsISupportsType {
    /**
     * Initialize the share picker widget.
     * @param nsIDOMWindow openerWindow.
     */
    init(openerWindow: mozIDOMWindowProxy): void;
    /**
     * Returns the parent window this was initialized with.
     */
    readonly openerWindow: mozIDOMWindowProxy;
    /**
     * XPCOM Analog of navigator.share() as per:
     * https://w3c.github.io/web-share/#share-method
     */
    share(title: AUTF8String, text: AUTF8String, url: nsIURIType): Promise;
}

/**
 *
 */
declare interface nsISharingHandlerAppType extends nsIHandlerAppType {
    /**
     *
     */
    share(data: AString, title: AString): void;
}

/**
 *
 */
declare interface nsIShellServiceType extends nsISupportsType {
    /**
     * Determines whether or not Firefox is the "Default Browser."
     * This is simply whether or not Firefox is registered to handle
     * http links.
     *
     * @param aForAllTypes  true if the check should be made for HTTP and HTML.
     * false if the check should be made for HTTP only.
     * This parameter may be ignored on some platforms.
     */
    isDefaultBrowser(aForAllTypes: boolean): boolean;
    /**
     * Registers Firefox as the "Default Browser."
     *
     * @param aClaimAllTypes Register Firefox as the handler for
     * additional protocols (chrome etc)
     * and web documents (.html, .xhtml etc).
     * @param aForAllUsers   Whether or not Firefox should attempt
     * to become the default browser for all
     * users on a multi-user system.
     */
    setDefaultBrowser(aClaimAllTypes: boolean, aForAllUsers: boolean): void;
    /**
     * Sets the desktop background image using either the HTML <IMG>
     * element supplied or the background image of the element supplied.
     *
     * @param aImageElement Either a HTML <IMG> element or an element with
     * a background image from which to source the
     * background image.
     * @param aPosition     How to place the image on the desktop
     * @param aImageName    The image name. Equivalent to the leaf name of the
     * location.href.
     */
    setDesktopBackground(aElement: Element, aPosition: long, aImageName: ACString): void;
    /**
     * The desktop background color, visible when no background image is
     * used, or if the background image is centered and does not fill the
     * entire screen. A rgb value, where (r << 16 | g << 8 | b)
     */
    desktopBackgroundColor: unsigned_long;
}

/**
 * A wrapper for an nsISimpleEnumerator instance which implements the
 * JavaScript iteration protocol.
 */
declare interface nsIJSEnumeratorType extends nsISupportsType {
    /**
     *
     */
    iterator(): nsIJSEnumerator;
    /**
     *
     */
    next(): jsval;
}

/**
 *
 */
declare interface nsISimpleEnumeratorBaseType extends nsISupportsType {
    /**
     * Returns a JavaScript iterator for all remaining entries in the enumerator.
     * Each entry is typically queried to the appropriate interface for the
     * enumerator.
     */
    iterator(): nsIJSEnumerator;
    /**
     * Returns JavaScript iterator for all remaining entries in the enumerator.
     * Each entry is queried only to the supplied interface. If any element
     * fails to query to that interface, the error is propagated to the caller.
     */
    entries(aIface: nsIIDRefType): nsIJSEnumerator;
}

/**
 *
 */
declare interface nsISimpleEnumeratorType extends nsISimpleEnumeratorBaseType {
    /**
     * Called to determine whether or not the enumerator has
     * any elements that can be returned via getNext(). This method
     * is generally used to determine whether or not to initiate or
     * continue iteration over the enumerator, though it can be
     * called without subsequent getNext() calls. Does not affect
     * internal state of enumerator.
     *
     * @see getNext()
     * @return true if there are remaining elements in the enumerator.
     * false if there are no more elements in the enumerator.
     */
    hasMoreElements(): boolean;
    /**
     * Called to retrieve the next element in the enumerator. The "next"
     * element is the first element upon the first call. Must be
     * pre-ceeded by a call to hasMoreElements() which returns PR_TRUE.
     * This method is generally called within a loop to iterate over
     * the elements in the enumerator.
     *
     * @see hasMoreElements()
     * @throws NS_ERROR_FAILURE if there are no more elements
     * to enumerate.
     * @return the next element in the enumeration.
     */
    getNext(): nsISupports;
}

/**
 * A simple stream listener can be used with AsyncRead to supply data to
 * a output stream.
 */
declare interface nsISimpleStreamListenerType extends nsIStreamListenerType {
    /**
     * Initialize the simple stream listener.
     *
     * @param aSink data will be read from the channel to this output stream.
     * Must implement writeFrom.
     * @param aObserver optional stream observer (can be NULL)
     */
    init(aSink: nsIOutputStreamType, aObserver: nsIRequestObserverType): void;
}

/**
 *
 */
declare interface nsISimpleURIMutatorType extends nsISupportsType {
    /**
     * Same behaviour as nsIURISetSpec.setSpec() but filters whitespace.
     */
    setSpecAndFilterWhitespace(aSpec: AUTF8String): nsIURIMutator;
}

/**
 *
 */
declare interface nsISiteSecurityServiceType extends nsISupportsType {
    /**
     *
     */
    processHeader(aSourceURI: nsIURIType, aHeader: ACString, aOriginAttributes: jsval, aMaxAge: unsigned_long_long, aIncludeSubdomains: boolean, aFailureResult: uint32_t): void;
    /**
     * Resets HSTS state a host, including the includeSubdomains state that
     * would affect subdomains. This essentially removes the state for the
     * domain tree rooted at this host. If any preloaded information is present
     * for that host, that information will then be used instead of any other
     * previously existing state.
     *
     * @param aURI    the URI of the target host
     * @param aOriginAttributes the origin attributes that isolate this origin,
     * (note that this implementation does not isolate
     * by userContextId because of the risk of man-in-
     * the-middle attacks before trust-on-second-use
     * happens).
     * @param aScope  The scope of state to reset. See ResetStateBy. Defaults
     * to ExactDomain.
     */
    resetState(aURI: nsIURIType, aOriginAttributes: jsval, aScope: nsISiteSecurityService_ResetStateByType): void;
    /**
     *
     */
    isSecureURI(aURI: nsIURIType, aOriginAttributes: jsval): boolean;
    /**
     * Removes all non-preloaded HSTS state by resetting to factory-original
     * settings.
     */
    clearAll(): void;
}

/**
 *
 */
declare interface nsISlowScriptDebugCallbackType extends nsISupportsType {
    /**
     *
     */
    handleSlowScriptDebug(aWindow: nsIDOMWindowType): void;
}

/**
 *
 */
declare interface nsISlowScriptDebuggerStartupCallbackType extends nsISupportsType {
    /**
     *
     */
    finishDebuggerStartup(): void;
}

/**
 *
 */
declare interface nsISlowScriptDebugRemoteCallbackType extends nsISupportsType {
    /**
     *
     */
    handleSlowScriptDebug(aBrowser: EventTarget, aCallback: nsISlowScriptDebuggerStartupCallbackType): void;
}

/**
 *
 */
declare interface nsISlowScriptDebugType extends nsISupportsType {
    /**
     *
     */
    activationHandler: nsISlowScriptDebugCallback;
    /**
     *
     */
    remoteActivationHandler: nsISlowScriptDebugRemoteCallback;
}

/**
 * Filters are created and run on the parent, and filter all packets, both
 * ingoing and outgoing. The child must specify the name of a recognized filter
 * in order to create a socket.
 */
declare interface nsISocketFilterType extends nsISupportsType {
    /**
     *
     */
    filterPacket(remote_addr: NetAddrPtr, data: uint8_t[], len: unsigned_long, direction: long): bool;
}

/**
 * Factory of a specified filter.
 */
declare interface nsISocketFilterHandlerType extends nsISupportsType {
    /**
     *
     */
    newFilter(): nsISocketFilter;
}

/**
 * nsISocketProvider
 */
declare interface nsISocketProviderType extends nsISupportsType {
}

/**
 * nsISocketProviderService
 *
 * Provides a mapping between a socket type and its associated socket provider
 * instance.  One could also use the service manager directly.
 */
declare interface nsISocketProviderServiceType extends nsISupportsType {
    /**
     *
     */
    getSocketProvider(socketType: string): nsISocketProvider;
}

/**
 * nsISocketTransport
 *
 * NOTE: Connection setup is triggered by opening an input or output stream,
 * it does not start on its own. Completion of the connection setup is
 * indicated by a STATUS_CONNECTED_TO notification to the event sink (if set).
 *
 * NOTE: This is a free-threaded interface, meaning that the methods on
 * this interface may be called from any thread.
 */
declare interface nsISocketTransportType extends nsITransportType {
    /**
     * Get the peer's host for the underlying socket connection.
     * For Unix domain sockets, this is a pathname, or the empty string for
     * unnamed and abstract socket addresses.
     */
    readonly host: AUTF8String;
    /**
     * Get the port for the underlying socket connection.
     * For Unix domain sockets, this is zero.
     */
    readonly port: long;
    /**
     * The origin attributes are used to create sockets.  The first party domain
     * will eventually be used to isolate OCSP cache and is only non-empty when
     * "privacy.firstparty.isolate" is enabled.  Setting this is the only way to
     * carry origin attributes down to NSPR layers which are final consumers.
     * It must be set before the socket transport is built.
     */
    originAttributes: jsval;
    /**
     * Returns a scriptable version of getPeerAddr. This attribute is defined
     * only once a connection has been established.
     */
    getScriptablePeerAddr(): nsINetAddr;
    /**
     * Returns a scriptable version of getSelfAddr. This attribute is defined
     * only once a connection has been established.
     */
    getScriptableSelfAddr(): nsINetAddr;
    /**
     * TLS socket control object. This attribute is only available once the
     * socket is connected.
     */
    readonly tlsSocketControl: nsITLSSocketControl;
    /**
     * Security notification callbacks passed to the secure socket provider
     * via nsITLSSocketControl at socket creation time.
     *
     * NOTE: this attribute cannot be changed once a stream has been opened.
     */
    securityCallbacks: nsIInterfaceRequestor;
    /**
     * Test if this socket transport is (still) connected.
     */
    isAlive(): boolean;
    /**
     * Socket timeouts in seconds.  To specify no timeout, pass UINT32_MAX
     * as aValue to setTimeout.  The implementation may truncate timeout values
     * to a smaller range of values (e.g., 0 to 0xFFFF).
     */
    getTimeout(aType: unsigned_long): unsigned_long;
    /**
     *
     */
    setTimeout(aType: unsigned_long, aValue: unsigned_long): void;
    /**
     * Sets the SO_LINGER option with the specified values for the l_onoff and
     * l_linger parameters. This applies PR_SockOpt_Linger before PR_Close and
     * can be used with a timeout of zero to send an RST packet when closing.
     */
    setLinger(aPolarity: boolean, aTimeout: short): void;
    /**
     * True to set addr and port reuse socket options.
     */
    setReuseAddrPort(reuseAddrPort: bool): void;
    /**
     * connectionFlags is a bitmask that can be used to modify underlying
     * behavior of the socket connection. See the flags below.
     */
    connectionFlags: unsigned_long;
    /**
     * An opaque flags for non-standard behavior of the TLS system.
     * It is unlikely this will need to be set outside of telemetry studies
     * relating to the TLS implementation.
     */
    tlsFlags: unsigned_long;
    /**
     * Socket QoS/ToS markings. Valid values are IPTOS_DSCP_AFxx or
     * IPTOS_CLASS_CSx (or IPTOS_DSCP_EF, but currently no supported
     * services require expedited-forwarding).
     * Not setting this value will leave the socket with the default
     * ToS value, which on most systems if IPTOS_CLASS_CS0 (formerly
     * IPTOS_PREC_ROUTINE).
     */
    QoSBits: octet;
    /**
     * TCP send and receive buffer sizes. A value of 0 means OS level
     * auto-tuning is in effect.
     */
    recvBufferSize: unsigned_long;
    /**
     *
     */
    sendBufferSize: unsigned_long;
    /**
     * TCP keepalive configuration (support varies by platform).
     * Note that the attribute as well as the setter can only accessed
     * in the socket thread.
     */
    keepaliveEnabled: boolean;
    /**
     *
     */
    setKeepaliveVals(keepaliveIdleTime: long, keepaliveRetryInterval: long): void;
    /**
     * If true, this socket transport has found out the prefered family
     * according it's connection flags could not be used to establish
     * connections any more.  Hence, the preference should be reset.
     */
    readonly resetIPFamilyPreference: boolean;
    /**
     * This attribute holds information whether echConfig has been used.
     * The value is set after PR_Connect is called.
     */
    readonly echConfigUsed: boolean;
    /**
     * Called to set the echConfig to the securityInfo object.
     */
    setEchConfig(echConfig: ACString): void;
    /**
     * IP address resolved using TRR.
     */
    resolvedByTRR(): bool;
    /**
     * Returns the effectiveTRRMode used for the DNS resolution.
     */
    readonly effectiveTRRMode: nsIRequest_TRRMode;
    /**
     * Returns the TRR skip reason used for the DNS resolution.
     */
    readonly trrSkipReason: nsITRRSkipReason_value;
    /**
     * If DNS is performed externally, this flag informs the caller that it may
     * retry connecting with a different DNS configuration (e.g. different IP
     * family preference). The flag is set only if a network error is encounder,
     * e.g. NS_ERROR_CONNECTION_REFUSED, NS_ERROR_RESET, etc.
     */
    readonly retryDnsIfPossible: boolean;
    /**
     * Return the current status of the socket.
     */
    readonly status: nsresult;
}

/**
 *
 */
declare interface nsISTSShutdownObserverType extends nsISupportsType {
    /**
     * Observe will be called when the SocketTransportService is shutting down,
     * before threads are stopped.
     */
    observe(): void;
}

/**
 *
 */
declare interface nsISocketTransportServiceType extends nsISupportsType {
    /**
     * Creates a transport for a specified host and port.
     *
     * @param aSocketTypes
     * array of socket type strings.  Empty array if using default
     * socket type.
     * @param aHost
     * specifies the target hostname or IP address literal of the peer
     * for this socket.
     * @param aPort
     * specifies the target port of the peer for this socket.
     * @param aProxyInfo
     * specifies the transport-layer proxy type to use.  null if no
     * proxy.  used for communicating information about proxies like
     * SOCKS (which are transparent to upper protocols).
     * @param aDnsRecord
     * the dns record to be used for the connection
     *
     * @see nsIProxiedProtocolHandler
     * @see nsIProtocolProxyService::GetProxyInfo
     *
     * NOTE: this function can be called from any thread
     */
    createTransport(aSocketTypes: invalid, aHost: AUTF8String, aPort: long, aProxyInfo: nsIProxyInfoType, dnsRecord: nsIDNSRecordType): nsISocketTransport;
    /**
     * Create a transport built on a Unix domain socket, connecting to the
     * given filename.
     *
     * Since Unix domain sockets are always local to the machine, they are
     * not affected by the nsIIOService's 'offline' flag.
     *
     * On systems that don't support Unix domain sockets at all, this
     * returns NS_ERROR_SOCKET_ADDRESS_NOT_SUPPORTED.
     *
     * The system-level socket API may impose restrictions on the length of
     * the filename that are stricter than those of the underlying
     * filesystem. If the file name is too long, this returns
     * NS_ERROR_FILE_NAME_TOO_LONG.
     *
     * The |aPath| parameter must specify an existing directory entry.
     * Otherwise, this returns NS_ERROR_FILE_NOT_FOUND.
     *
     * The program must have search permission on all components of the
     * path prefix of |aPath|, and read and write permission on |aPath|
     * itself. Without such permission, this returns
     * NS_ERROR_CONNECTION_REFUSED.
     *
     * The |aPath| parameter must refer to a unix-domain socket. Otherwise,
     * this returns NS_ERROR_CONNECTION_REFUSED. (POSIX specifies
     * ECONNREFUSED when "the target address was not listening for
     * connections", and this is what Linux returns.)
     *
     * @param aPath
     * The file name of the Unix domain socket to which we should
     * connect.
     */
    createUnixDomainTransport(aPath: nsIFileType): nsISocketTransport;
    /**
     * Create a transport built on a Unix domain socket that uses abstract
     * address name.
     *
     * If abstract socket address isn't supported on System, this returns
     * NS_ERROR_SOCKET_ADDRESS_NOT_SUPPORTED.
     *
     * @param aName
     * The name of abstract socket adress of the Unix domain socket to
     * which we should connect.
     */
    createUnixDomainAbstractAddressTransport(aName: ACString): nsISocketTransport;
}

/**
 *
 */
declare interface nsIRoutedSocketTransportServiceType extends nsISocketTransportServiceType {
    /**
     *
     */
    createRoutedTransport(aSocketTypes: invalid, aHost: AUTF8String, aPort: long, aHostRoute: AUTF8String, aPortRoute: long, aProxyInfo: nsIProxyInfoType, aDnsRecord: nsIDNSRecordType): nsISocketTransport;
}

/**
 *
 */
declare interface nsISoundType extends nsISupportsType {
    /**
     *
     */
    play(aURL: nsIURLType): void;
    /**
     *
     */
    beep(): void;
    /**
     * Not strictly necessary, but avoids delay before first sound.
     * The various methods on nsISound call Init() if they need to.
     */
    init(): void;
    /**
     *
     */
    playEventSound(aEventId: unsigned_long): void;
}

/**
 *
 */
declare interface nsISpeculativeConnectType extends nsISupportsType {
    /**
     * Called as a hint to indicate a new transaction for the URI is likely coming
     * soon. The implementer may use this information to start a TCP
     * and/or SSL level handshake for that resource immediately so that it is
     * ready and/or progressed when the transaction is actually submitted.
     *
     * No obligation is taken on by the implementer, nor is the submitter obligated
     * to actually open the new channel.
     *
     * @param aURI the URI of the hinted transaction
     * @param aPrincipal the principal that will be used for opening the
     * channel of the hinted transaction.
     * @param aCallbacks any security callbacks for use with SSL for interfaces.
     * May be null.
     * @param aAnonymous indicates if this is an anonymous connection.
     */
    speculativeConnect(aURI: nsIURIType, aPrincipal: nsIPrincipalType, aCallbacks: nsIInterfaceRequestorType, aAnonymous: boolean): void;
    /**
     * This method is similar to speculativeConnect, but it use
     * the partition key of the originAttributes directly to create the
     * connection.
     */
    speculativeConnectWithOriginAttributes(aURI: nsIURIType, originAttributes: jsval, aCallbacks: nsIInterfaceRequestorType, aAnonymous: boolean): void;
    /**
     *
     */
    speculativeConnectWithOriginAttributesNative(aURI: nsIURIType, originAttributes: OriginAttributes, aCallbacks: nsIInterfaceRequestorType, aAnonymous: boolean): void;
}

/**
 * This is used to override the default values for various values (documented
 * inline) to determine whether or not to actually make a speculative
 * connection.
 */
declare interface nsISpeculativeConnectionOverriderType extends nsISupportsType {
    /**
     * Used to determine the maximum number of unused speculative connections
     * we will have open for a host at any one time
     */
    readonly parallelSpeculativeConnectLimit: unsigned_long;
    /**
     * Used to determine if we will ignore the existence of any currently idle
     * connections when we decide whether or not to make a speculative
     * connection.
     */
    readonly ignoreIdle: boolean;
    /**
     * Used by the Predictor to gather telemetry data on speculative connection
     * usage.
     */
    readonly isFromPredictor: boolean;
    /**
     * by default speculative connections are not made to RFC 1918 addresses
     */
    readonly allow1918: boolean;
}

/**
 *
 */
declare interface nsISpeechGrammarCompilationCallbackType extends nsISupportsType {
    /**
     *
     */
    grammarCompilationEnd(grammarObject: SpeechGrammarPtr, success: boolean): void;
}

/**
 *
 */
declare interface nsISpeechRecognitionServiceType extends nsISupportsType {
    /**
     *
     */
    initialize(aSpeechRecognition: SpeechRecognitionWeakPtr): void;
    /**
     *
     */
    processAudioSegment(aAudioSegment: AudioSegmentPtr, aSampleRate: long): void;
    /**
     *
     */
    validateAndSetGrammarList(aSpeechGrammar: SpeechGrammarPtr, aCallback: nsISpeechGrammarCompilationCallbackType): void;
    /**
     *
     */
    soundEnd(): void;
    /**
     *
     */
    abort(): void;
}

/**
 * A callback is implemented by the service.
 */
declare interface nsISpeechTaskCallbackType extends nsISupportsType {
    /**
     * The user or application has paused the speech.
     */
    onPause(): void;
    /**
     * The user or application has resumed the speech.
     */
    onResume(): void;
    /**
     * The user or application has canceled the speech.
     */
    onCancel(): void;
    /**
     * The user or application has changed the volume of this speech.
     */
    onVolumeChanged(aVolume: float): void;
}

/**
 * A task is associated with a single utterance. It is provided by the browser
 * to the service in the speak() method.
 */
declare interface nsISpeechTaskType extends nsISupportsType {
    /**
     * Prepare browser for speech.
     *
     * @param aCallback callback object for mid-speech operations.
     */
    setup(aCallback: nsISpeechTaskCallbackType): void;
    /**
     * Dispatch start event.
     */
    dispatchStart(): void;
    /**
     * Dispatch end event.
     *
     * @param aElapsedTime time in seconds since speech has started.
     * @param aCharIndex   offset of spoken characters.
     */
    dispatchEnd(aElapsedTime: float, aCharIndex: unsigned_long): void;
    /**
     * Dispatch pause event.
     *
     * @param aElapsedTime time in seconds since speech has started.
     * @param aCharIndex   offset of spoken characters.
     */
    dispatchPause(aElapsedTime: float, aCharIndex: unsigned_long): void;
    /**
     * Dispatch resume event.
     *
     * @param aElapsedTime time in seconds since speech has started.
     * @param aCharIndex   offset of spoken characters.
     */
    dispatchResume(aElapsedTime: float, aCharIndex: unsigned_long): void;
    /**
     * Dispatch error event.
     *
     * @param aElapsedTime time in seconds since speech has started.
     * @param aCharIndex   offset of spoken characters.
     */
    dispatchError(aElapsedTime: float, aCharIndex: unsigned_long): void;
    /**
     * Dispatch boundary event.
     *
     * @param aName        name of boundary, 'word' or 'sentence'
     * @param aElapsedTime time in seconds since speech has started.
     * @param aCharIndex   offset of spoken characters.
     * @param aCharLength  length of text in boundary event to be spoken.
     */
    dispatchBoundary(aName: AString, aElapsedTime: float, aCharIndex: unsigned_long, aCharLength: unsigned_long): void;
    /**
     * Dispatch mark event.
     *
     * @param aName        mark identifier.
     * @param aElapsedTime time in seconds since speech has started.
     * @param aCharIndex   offset of spoken characters.
     */
    dispatchMark(aName: AString, aElapsedTime: float, aCharIndex: unsigned_long): void;
}

/**
 * The main interface of a speech synthesis service.
 *
 * A service is responsible for outputting audio.
 * The service dispatches events, starting with dispatchStart() and ending with
 * dispatchEnd or dispatchError().
 * A service must also respond with the currect actions and events in response
 * to implemented callback methods.
 */
declare interface nsISpeechServiceType extends nsISupportsType {
    /**
     * Speak the given text using the voice identified byu the given uri. See
     * W3C Speech API spec for information about pitch and rate.
     * https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html#utterance-attributes
     *
     * @param aText   text to utter.
     * @param aUri    unique voice identifier.
     * @param aVolume volume to speak voice in. Only relevant for indirect audio.
     * @param aRate   rate to speak voice in.
     * @param aPitch  pitch to speak voice in.
     * @param aTask  task instance for utterance, used for sending events or audio
     * data back to browser.
     */
    speak(aText: AString, aUri: AString, aVolume: float, aRate: float, aPitch: float, aTask: nsISpeechTaskType): void;
}

/**
 * Platform-independent interface to platform native menu objects.
 */
declare interface nsIStandaloneNativeMenuType extends nsISupportsType {
    /**
     * Initialize the native menu using given XUL DOM element.
     *
     * @param aDOMElement A XUL DOM element of tag type |menu| or |menupopup|.
     */
    init(aElement: Element): void;
    /**
     * This method must be called before the menu is opened and displayed to the
     * user. It allows the platform code to update the menu and also determine
     * whether the menu should even be shown.
     *
     * @return true if the menu can be shown, false if it should not be shown
     */
    menuWillOpen(): boolean;
    /**
     * Activate the native menu item specified by |anIndexString|. This method
     * is intended to be used by the test suite.
     *
     * @param anIndexString string containing a list of indices separated by
     * pipe ('|') characters
     */
    activateNativeMenuItemAt(anIndexString: AString): void;
    /**
     * Force an update of the native menu item specified by |anIndexString|. This
     * method is intended to be used by the test suite.
     *
     * @param anIndexString string containing a list of indices separated by
     * pipe ('|') characters
     */
    forceUpdateNativeMenuAt(anIndexString: AString): void;
    /**
     * Print information about the menu structure to stdout. Only used for
     * debugging.
     */
    dump(): void;
}

/**
 * nsIStandardURL defines the interface to an URL with the standard
 * file path format common to protocols like http, ftp, and file.
 * It supports initialization from a relative path and provides
 * some customization on how URLs are normalized.
 */
declare interface nsIStandardURLType extends nsISupportsType {
}

/**
 *
 */
declare interface nsIStandardURLMutatorType extends nsISupportsType {
    /**
     * Initialize a standard URL.
     *
     * @param aUrlType       - one of the URLTYPE_ flags listed above.
     * @param aDefaultPort   - if the port parsed from the URL string matches
     * this port, then the port will be removed from the
     * canonical form of the URL.
     * @param aSpec          - URL string.
     * @param aOriginCharset - the charset from which this URI string
     * originated.  this corresponds to the charset
     * that should be used when communicating this
     * URI to an origin server, for example.  if
     * null, then provide aBaseURI implements this
     * interface, the origin charset of aBaseURI will
     * be assumed, otherwise defaulting to UTF-8 (i.e.,
     * no charset transformation from aSpec).
     * @param aBaseURI       - if null, aSpec must specify an absolute URI.
     * otherwise, aSpec will be resolved relative
     * to aBaseURI.
     */
    init(aUrlType: unsigned_long, aDefaultPort: long, aSpec: AUTF8String, aOriginCharset: string, aBaseURI: nsIURIType): nsIURIMutator;
    /**
     * Set the default port.
     *
     * Note: If this object is already using its default port (i.e. if it has
     * mPort == -1), then it will now implicitly be using the new default port.
     *
     * @param aNewDefaultPort - if the URI has (or is later given) a port that
     * matches this default, then we won't include a
     * port number in the canonical form of the URL.
     */
    setDefaultPort(aNewDefaultPort: long): nsIURIMutator;
}

/**
 * NOTE: this interface is completely undesigned, not stable and likely to change
 */
declare interface nsIStartupCacheInfoType extends nsISupportsType {
    /**
     * Returns true if the startup cache will not load from the cache from disk.
     * This can happen if the cache file is corrupt or has been invalidated.
     */
    readonly IgnoreDiskCache: boolean;
    /**
     * Returns true if during initialization of the startup cache an existing
     * cache file was found on disk. This does NOT indicate if the file loaded
     * successfully.
     */
    readonly FoundDiskCacheOnInit: boolean;
    /**
     * Returns true once the current cache file as been written to disk at least
     * once. If the cache was loaded from disk and never changed this may never
     * be set to true.
     */
    readonly WroteToDiskCache: boolean;
    /**
     * The full path and filename of the startup cache file that will be stored on
     * disk.
     */
    readonly DiskCachePath: AString;
}

/**
 * nsIStorageActivityService is a service that can be used to know which
 * origins have been active in a time range. This information can be used to
 * implement "Clear Recent History" or similar features.
 *
 * If you are implementing a new Storage component, you should use
 * QuotaManager. But if you don't do it, remember to call
 * StorageActivityService methods in order to inform this service about
 * 'writing' operations executed by origins.
 */
declare interface nsIStorageActivityServiceType extends nsISupportsType {
    /**
     *
     */
    getActiveOrigins(from: PRTime, to: PRTime): nsIArray;
    /**
     *
     */
    moveOriginInTime(origin: nsIPrincipalType, when: PRTime): void;
    /**
     *
     */
    testOnlyReset(): void;
}

/**
 * The nsIStorageStream interface maintains an internal data buffer that can be
 * filled using a single output stream.  One or more independent input streams
 * can be created to read the data from the buffer non-destructively.
 */
declare interface nsIStorageStreamType extends nsISupportsType {
    /**
     * Initialize the stream, setting up the amount of space that will be
     * allocated for the stream's backing-store.
     *
     * @param segmentSize
     * Size of each segment. Must be a power of two.
     * @param maxSize
     * Maximum total size of this stream. length will always be less
     * than or equal to this value. Passing UINT32_MAX is safe.
     */
    init(segmentSize: uint32_t, maxSize: uint32_t): void;
    /**
     * Get a reference to the one and only output stream for this instance.
     * The zero-based startPosition argument is used is used to set the initial
     * write cursor position.  The startPosition cannot be set larger than the
     * current buffer length.  Calling this method has the side-effect of
     * truncating the internal buffer to startPosition bytes.
     */
    getOutputStream(startPosition: int32_t): nsIOutputStream;
    /**
     * Create a new input stream to read data (written by the singleton output
     * stream) from the internal buffer.  Multiple, independent input streams
     * can be created.
     */
    newInputStream(startPosition: int32_t): nsIInputStream;
    /**
     * The length attribute indicates the total number of bytes stored in the
     * nsIStorageStream internal buffer, regardless of any consumption by input
     * streams.  Assigning to the length field can be used to truncate the
     * buffer data, but can not be used when either the instance's output
     * stream is in use.
     *
     * @See #writeInProgress
     */
    length: uint32_t;
    /**
     * True, when output stream has not yet been Close'ed
     */
    readonly writeInProgress: boolean;
}

/**
 * An interface for access to a buffering stream implementation's underlying
 * memory buffer.
 *
 * Stream implementations that QueryInterface to nsIStreamBufferAccess must
 * ensure that all buffers are aligned on the most restrictive type size for
 * the current architecture (e.g., sizeof(double) for RISCy CPUs).  malloc(3)
 * satisfies this requirement.
 */
declare interface nsIStreamBufferAccessType extends nsISupportsType {
    /**
     * Disable and enable buffering on the stream implementing this interface.
     * DisableBuffering flushes an output stream's buffer, and invalidates an
     * input stream's buffer.
     */
    disableBuffering(): void;
    /**
     *
     */
    enableBuffering(): void;
    /**
     * The underlying, unbuffered input or output stream.
     */
    readonly unbufferedStream: nsISupports;
}

/**
 * nsIStreamConverter provides an interface to implement when you have code
 * that converts data from one type to another.
 *
 * Suppose you had code that converted plain text into HTML. You could implement
 * this interface to allow everyone else to use your conversion logic using a
 * standard api.
 *
 *
 * **STREAM CONVERTER USERS**
 *
 * There are currently two ways to use a stream converter:
 *
 * -  **SYNCHRONOUS** Stream to Stream
 * You can supply the service with a stream of type X
 * and it will convert it to your desired output type and return
 * a converted (blocking) stream to you.
 *
 * -  **ASYNCHRONOUS** nsIStreamListener to nsIStreamListener
 * You can supply data directly to the converter by calling it's
 * nsIStreamListener::OnDataAvailable() method. It will then
 * convert that data from type X to your desired output type and
 * return converted data to you via the nsIStreamListener you passed
 * in by calling its OnDataAvailable() method.
 *
 *
 *
 *
 * **STREAM CONVERTER SUPPLIERS**
 *
 * Registering a stream converter:
 * Stream converter registration is a two step process. First of all the stream
 * converter implementation must register itself with the component manager using
 * a contractid in the format below. Second, the stream converter must add the contractid
 * to the registry.
 *
 * Stream converter contractid format (the stream converter root key is defined in this
 * file):
 *
 * `@mozilla.org/streamconv;1?from=FROM_MIME_TYPE&to=TO_MIME_TYPE`
 *
 * @author Jud Valeski
 * @see nsIStreamConverterService
 */
declare interface nsIStreamConverterType extends nsIStreamListenerType {
    /**
     * **SYNCRONOUS VERSION**
     * Converts a stream of one type, to a stream of another type.
     *
     * Use this method when you have a stream you want to convert.
     *
     * @param aFromStream   The stream representing the original/raw data.
     * @param aFromType     The MIME type of aFromStream.
     * @param aToType       The MIME type of the returned stream.
     * @param aCtxt         Either an opaque context, or a converter specific context
     * (implementation specific).
     * @return              The converted stream. NOTE: The returned stream may not
     * already be converted. An efficient stream converter
     * implementation will converter data on demand rather than
     * buffering the converted data until it is used.
     */
    convert(aFromStream: nsIInputStreamType, aFromType: string, aToType: string, aCtxt: nsISupportsType): nsIInputStream;
    /**
     * **ASYNCRONOUS VERSION**
     * Converts data arriving via the converter's nsIStreamListener::OnDataAvailable()
     * method from one type to another, pushing the converted data out to the caller
     * via aListener::OnDataAvailable().
     *
     * Use this method when you want to proxy (and convert) nsIStreamListener callbacks
     * asynchronously.
     *
     * @param aFromType     The MIME type of the original/raw data.
     * @param aToType       The MIME type of the converted data.
     * @param aListener     The listener who receives the converted data.
     * @param aCtxt         Either an opaque context, or a converter specific context
     * (implementation specific).
     */
    asyncConvertData(aFromType: string, aToType: string, aListener: nsIStreamListenerType, aCtxt: nsISupportsType): void;
    /**
     * Returns the content type that the stream listener passed to asyncConvertData will
     * see on the channel if the conversion is being done from aFromType to * .
     *
     * @param aFromType     The type of the content prior to conversion.
     * @param aChannel      The channel that we'd like to convert. May be null.
     *
     * @throws if the converter does not support conversion to * /* or if it doesn't know
     * the type in advance.
     */
    getConvertedType(aFromType: ACString, aChannel: nsIChannelType): ACString;
}

/**
 * The nsIStreamConverterService is a higher level stream converter factory
 * responsible for locating and creating stream converters
 * (nsIStreamConverter).
 *
 * This service retrieves an interface that can convert data from a particular
 * MIME type, to a particular MIME type. It is responsible for any intermediary
 * conversion required in order to get from X to Z, assuming direct conversion
 * is not possible.
 *
 * @author Jud Valeski
 * @see nsIStreamConverter
 */
declare interface nsIStreamConverterServiceType extends nsISupportsType {
    /**
     * Tests whether conversion between the two specified types is possible.
     * This is cheaper than calling convert()/asyncConvertData(); it is not
     * necessary to call this function before calling one of those, though.
     */
    canConvert(aFromType: string, aToType: string): boolean;
    /**
     * Returns the content type that will be returned from a converter
     * created with aFromType and  * .
     * Can fail if no converters support this conversion, or if the
     * output type isn't known in advance.
     */
    convertedType(aFromType: ACString, aChannel: nsIChannelType): ACString;
    /**
     * **SYNCHRONOUS VERSION**
     * Converts a stream of one type, to a stream of another type.
     *
     * Use this method when you have a stream you want to convert.
     *
     * @param aFromStream   The stream representing the original/raw data.
     * @param aFromType     The MIME type of aFromStream.
     * @param aToType       The MIME type of the returned stream.
     * @param aContext      Either an opaque context, or a converter specific
     * context (implementation specific).
     * @return              The converted stream. NOTE: The returned stream
     * may not already be converted. An efficient stream
     * converter implementation will convert data on
     * demand rather than buffering the converted data
     * until it is used.
     */
    convert(aFromStream: nsIInputStreamType, aFromType: string, aToType: string, aContext: nsISupportsType): nsIInputStream;
    /**
     * **ASYNCHRONOUS VERSION**
     * Retrieves a nsIStreamListener that receives the original/raw data via its
     * nsIStreamListener::OnDataAvailable() callback, then converts and pushes
     * the data to aListener.
     *
     * Use this method when you want to proxy (and convert) nsIStreamListener
     * callbacks asynchronously.
     *
     * @param aFromType     The MIME type of the original/raw data.
     * @param aToType       The MIME type of the converted data.
     * @param aListener     The listener that receives the converted data.
     * @param aCtxt         Either an opaque context, or a converter specific
     * context (implementation specific).
     * @return              A nsIStreamListener that receives data via its
     * OnDataAvailable() method.
     */
    asyncConvertData(aFromType: string, aToType: string, aListener: nsIStreamListenerType, aContext: nsISupportsType): nsIStreamListener;
}

/**
 * nsIStreamListener
 */
declare interface nsIStreamListenerType extends nsIRequestObserverType {
    /**
     * Called when the next chunk of data (corresponding to the request) may
     * be read without blocking the calling thread.  The onDataAvailable impl
     * must read exactly |aCount| bytes of data before returning.
     *
     * @param aRequest request corresponding to the source of the data
     * @param aInputStream input stream containing the data chunk
     * @param aOffset
     * Number of bytes that were sent in previous onDataAvailable calls
     * for this request. In other words, the sum of all previous count
     * parameters.
     * @param aCount number of bytes available in the stream
     *
     * NOTE: The aInputStream parameter must implement readSegments.
     *
     * An exception thrown from onDataAvailable has the side-effect of
     * causing the request to be canceled.
     */
    onDataAvailable(aRequest: nsIRequestType, aInputStream: nsIInputStreamType, aOffset: unsigned_long_long, aCount: unsigned_long): void;
}

/**
 * As data "flows" into a stream listener tee, it is copied to the output stream
 * and then forwarded to the real listener.
 */
declare interface nsIStreamListenerTeeType extends nsIStreamListenerType {
    /**
     * Initalize the tee.
     *
     * @param listener
     * the original listener the tee will propagate onStartRequest,
     * onDataAvailable and onStopRequest notifications to, exceptions from
     * the listener will be propagated back to the channel
     * @param sink
     * the stream the data coming from the channel will be written to,
     * should be blocking
     * @param requestObserver
     * optional parameter, listener that gets only onStartRequest and
     * onStopRequest notifications; exceptions threw within this optional
     * observer are also propagated to the channel, but exceptions from
     * the original listener (listener parameter) are privileged
     */
    init(listener: nsIStreamListenerType, sink: nsIOutputStreamType, requestObserver: nsIRequestObserverType): void;
    /**
     * Initalize the tee like above, but with the extra parameter to make it
     * possible to copy the output asynchronously
     * @param anEventTarget
     * if set, this event-target is used to copy data to the output stream,
     * giving an asynchronous tee
     */
    initAsync(listener: nsIStreamListenerType, eventTarget: nsIEventTargetType, sink: nsIOutputStreamType, requestObserver: nsIRequestObserverType): void;
}

/**
 *
 */
declare interface nsIStreamLoaderObserverType extends nsISupportsType {
    /**
     * Called when the entire stream has been loaded.
     *
     * @param loader the stream loader that loaded the stream.
     * @param ctxt the context parameter of the underlying channel
     * @param status the status of the underlying channel
     * @param resultLength the length of the data loaded
     * @param result the data
     *
     * This method will always be called asynchronously by the
     * nsIStreamLoader involved, on the thread that called the
     * loader's init() method.
     *
     * If the observer wants to take over responsibility for the
     * data buffer (result), it returns NS_SUCCESS_ADOPTED_DATA
     * in place of NS_OK as its success code. The loader will then
     * "forget" about the data and not free() it after
     * onStreamComplete() returns; observer must call free()
     * when the data is no longer required.
     */
    onStreamComplete(loader: nsIStreamLoaderType, ctxt: nsISupportsType, status: nsresult, resultLength: unsigned_long, result: octet[]): void;
}

/**
 * Asynchronously loads a channel into a memory buffer.
 *
 * To use this interface, first call init() with a nsIStreamLoaderObserver
 * that will be notified when the data has been loaded. Then call asyncOpen()
 * on the channel with the nsIStreamLoader as the listener. The context
 * argument in the asyncOpen() call will be passed to the onStreamComplete()
 * callback.
 *
 * XXX define behaviour for sizes >4 GB
 */
declare interface nsIStreamLoaderType extends nsIStreamListenerType {
    /**
     * Initialize this stream loader, and start loading the data.
     *
     * @param aStreamObserver
     * An observer that will be notified when the data is complete.
     * @param aRequestObserver
     * An optional observer that will be notified when the request
     * has started or stopped.
     */
    init(aStreamObserver: nsIStreamLoaderObserverType, aRequestObserver: nsIRequestObserverType): void;
    /**
     * Gets the number of bytes read so far.
     */
    readonly numBytesRead: unsigned_long;
    /**
     * Gets the request that loaded this file.
     * null after the request has finished loading.
     */
    readonly request: nsIRequest;
}

/**
 * This service read/writes a stream on a background thread.
 *
 * Note: instead of using this interface, probably you want to use
 * NS_MakeAsyncNonBlockingInputStream.
 *
 * Use this service to transform any blocking stream (e.g., file stream)
 * into a fully asynchronous stream that can be read/written without
 * blocking the main thread.
 */
declare interface nsIStreamTransportServiceType extends nsISupportsType {
    /**
     * CreateInputTransport
     *
     * @param aStream
     * The input stream that will be read on a background thread.
     * This stream must implement "blocking" stream semantics.
     * @param aCloseWhenDone
     * Specify this flag to have the input stream closed once its
     * contents have been completely read.
     *
     * @return nsITransport instance.
     */
    createInputTransport(aStream: nsIInputStreamType, aCloseWhenDone: boolean): nsITransport;
    /**
     *
     */
    InputAvailable(aStream: nsIInputStreamType, aCallback: nsIInputAvailableCallbackType): void;
}

/**
 *
 */
declare interface nsIInputAvailableCallbackType extends nsISupportsType {
    /**
     *
     */
    onInputAvailableComplete(available: unsigned_long_long, available_return_code: nsresult): void;
}

/**
 *
 */
declare interface nsIStringBundleType extends nsISupportsType {
    /**
     *
     */
    GetStringFromID(aID: long): AString;
    /**
     *
     */
    GetStringFromName(aName: AUTF8String): AString;
    /**
     *
     */
    formatStringFromID(aID: long, params: invalid): AString;
    /**
     *
     */
    formatStringFromName(aName: AUTF8String, params: invalid): AString;
    /**
     * Implements nsISimpleEnumerator, replaces nsIEnumerator
     */
    getSimpleEnumeration(): nsISimpleEnumerator;
    /**
     *
     */
    asyncPreload(): void;
    /**
     *
     */
    SizeOfIncludingThis(aMallocSizeOf: MallocSizeOf): size_t;
    /**
     *
     */
    SizeOfIncludingThisIfUnshared(aMallocSizeOf: MallocSizeOf): size_t;
}

/**
 *
 */
declare interface nsIStringBundleServiceType extends nsISupportsType {
    /**
     *
     */
    createBundle(aURLSpec: string): nsIStringBundle;
    /**
     * Formats a message string from a status code and status arguments.
     * @param aStatus - The status code. This is mapped into a string ID and
     * used in the string lookup process.
     * @param aStatusArg - The status message argument(s). Multiple arguments
     * can be separated by newline ('\n') characters.
     * @return the formatted message
     */
    formatStatusMessage(aStatus: nsresult, aStatusArg: wstring): AString;
    /**
     * flushes the string bundle cache - useful when the locale changes or
     * when we need to get some extra memory back
     *
     * at some point, we might want to make this flush all the bundles,
     * because any bundles that are floating around when the locale changes
     * will suddenly contain bad data
     */
    flushBundles(): void;
    /**
     *
     */
    sizeOfIncludingThis(aMallocSizeOf: MallocSizeOf): size_t;
    /**
     *
     */
    sendContentBundles(aContentParent: ContentParent): void;
    /**
     *
     */
    registerContentBundle(aBundleURL: ACString, aMapFile: FileDescriptor, aMapSize: size_t): void;
}

/**
 * Base class for C++-implemented string iterators. JS implementors need not
 * be queryable to it.
 */
declare interface nsIStringEnumeratorBaseType extends nsISupportsType {
    /**
     *
     */
    iterator(): nsIJSEnumerator;
}

/**
 *
 */
declare interface nsIStringEnumeratorType extends nsIStringEnumeratorBaseType {
    /**
     *
     */
    hasMore(): boolean;
    /**
     *
     */
    getNext(): AString;
}

/**
 *
 */
declare interface nsIUTF8StringEnumeratorType extends nsIStringEnumeratorBaseType {
    /**
     *
     */
    hasMore(): boolean;
    /**
     *
     */
    getNext(): AUTF8String;
}

/**
 * nsIStringInputStream
 *
 * Provides scriptable and specialized C++-only methods for initializing a
 * nsIInputStream implementation with a simple character array.
 */
declare interface nsIStringInputStreamType extends nsIInputStreamType {
    /**
     * SetData - assign data to the input stream (copied on assignment).
     *
     * @param data    - stream data
     * @param dataLen - stream data length (-1 if length should be computed)
     *
     * NOTE: C++ code should consider using AdoptData or ShareData to avoid
     * making an extra copy of the stream data.
     *
     * NOTE: For JS callers, the given data must not contain null characters
     * (other than a null terminator) because a null character in the middle of
     * the data string will be seen as a terminator when the data is converted
     * from a JS string to a C++ character array.
     */
    setData(data: string, dataLen: long): void;
    /**
     * SetUTF8Data - encode input data to UTF-8 and assign it to the input
     * stream.
     *
     * @param data    - stream data
     *
     * NOTE: This method is meant to be used by JS callers,
     */
    setUTF8Data(data: AUTF8String): void;
}

/**
 * This interface acts as a container for an object serialized using the
 * structured clone algorithm.
 *
 * You can copy an object into an nsIStructuredCloneContainer using
 * initFromJSVal or initFromBase64.  It's an error to initialize an
 * nsIStructuredCloneContainer more than once.
 *
 * Once you've initialized the container, you can get a copy of the object it
 * stores by calling deserializeToVariant.  You can also get a base-64-encoded
 * string containing a copy of the container's serialized data, using
 * getDataAsBase64.
 */
declare interface nsIStructuredCloneContainerType extends nsISupportsType {
    /**
     * Initialize this structured clone container from a base-64-encoded byte
     * stream, stored in aData.  aFormatVersion should be the version of the
     * structured clone algorithm which was used to generate aData.
     */
    initFromBase64(aData: AString, aFormatVersion: unsigned_long): void;
    /**
     * Deserializes this structured clone container returning it as a jsval.
     * Can be called on main and worker threads.
     */
    deserializeToJsval(): jsval;
    /**
     * Get this structured clone container's data as a base-64-encoded string.
     */
    getDataAsBase64(): AString;
    /**
     * Get the size in bytes of this container's serialized data.
     */
    readonly serializedNBytes: unsigned_long_long;
    /**
     * Get the version of the structured clone algorithm which was used to
     * generate this container's serialized buffer.
     */
    readonly formatVersion: unsigned_long;
}

/**
 * nsISFVBareItem is a building block for Item header value (nsISFVItem) and Parameters (nsISFVParams).
 * It can be of type BOOL, STRING, DECIMAL, INTEGER, TOKEN, BYTE_SEQUENCE.
 * Each type is represented by its own interface which is used to create
 * a bare item of that type.
 */
declare interface nsISFVBareItemType extends nsISupportsType {
    /**
     * Returns value associated with type of bare item.
     * Used to identify type of bare item without querying for interface
     * (like nsISFVString, etc).
     */
    readonly type: long;
}

/**
 *
 */
declare interface nsISFVIntegerType extends nsISFVBareItemType {
    /**
     *
     */
    value: long_long;
}

/**
 *
 */
declare interface nsISFVStringType extends nsISFVBareItemType {
    /**
     *
     */
    value: ACString;
}

/**
 *
 */
declare interface nsISFVBoolType extends nsISFVBareItemType {
    /**
     *
     */
    value: boolean;
}

/**
 *
 */
declare interface nsISFVDecimalType extends nsISFVBareItemType {
    /**
     *
     */
    value: double;
}

/**
 *
 */
declare interface nsISFVTokenType extends nsISFVBareItemType {
    /**
     *
     */
    value: ACString;
}

/**
 *
 */
declare interface nsISFVByteSeqType extends nsISFVBareItemType {
    /**
     *
     */
    value: ACString;
}

/**
 * nsISFVParams represents parameters, key-value pairs of ACString and nsISFVBareItem,
 * which parametrize Item type header or InnerList type withing List type header.
 */
declare interface nsISFVParamsType extends nsISupportsType {
    /**
     * Return value (nsISFVBareItem) stored for key, if it is present
     *
     * @throws NS_ERROR_UNEXPECTED if the key does not exist in parameters.
     */
    get(key: ACString): nsISFVBareItem;
    /**
     * Insert a new key-value pair.
     * If an equivalent key already exists: the key remains and retains in its place in the order,
     * its corresponding value is updated with the new value.
     *
     * @throws NS_ERROR_UNEXPECTED if supplied item does not implement nsISFVBareItem interface.
     */
    set(key: ACString, item: nsISFVBareItemType): void;
    /**
     * Remove the key-value pair equivalent to key.
     *
     * @throws NS_ERROR_UNEXPECTED upon attempt to delete  key that does not exist in parameters.
     */
    delete(key: ACString): void;
}

/**
 * nsISFVParametrizable is implemented for types that
 * can be parametrized with nsISFVParams
 */
declare interface nsISFVParametrizableType extends nsISupportsType {
    /**
     *
     */
    readonly params: nsISFVParams;
}

/**
 * nsISFVItemOrInnerList represents member in nsISFVList
 * or member-value in nsISFVDictionary.
 * nsISFVItemOrInnerList is implemented for
 * nsISFVItem or nsISFVInnerList, both of which are used
 * to create nsISFVList and nsISFVDictionary.
 */
declare interface nsISFVItemOrInnerListType extends nsISFVParametrizableType {
}

/**
 * nsISFVSerialize indicates that object can be serialized into ACString.
 */
declare interface nsISFVSerializeType extends nsISupportsType {
    /**
     *
     */
    serialize(): ACString;
}

/**
 * nsISFVItem represents Item structured header value.
 */
declare interface nsISFVItemType extends nsISFVItemOrInnerListType {
    /**
     *
     */
    readonly value: nsISFVBareItem;
    /**
     *
     */
    serialize(): ACString;
}

/**
 * nsISFVInnerList can be used as a member of nsISFVList
 * or a member-value of nsISFVDictionary.
 */
declare interface nsISFVInnerListType extends nsISFVItemOrInnerListType {
}

/**
 * nsISFVList represents List structured header value.
 */
declare interface nsISFVListType extends nsISFVSerializeType {
    /**
     * In case when header value is split across lines, it's possible
     * this method parses supplied line and merges it with members of existing object.
     */
    parseMore(header: ACString): void;
}

/**
 * nsISFVDictionary represents nsISFVDictionary structured header value.
 */
declare interface nsISFVDictionaryType extends nsISFVSerializeType {
    /**
     * Return value (nsISFVItemOrInnerList) stored for key, if it is present.
     * QueryInterface can be used on a value to get more specific type.
     *
     * @throws NS_ERROR_UNEXPECTED if the key does not exist in parameters.
     */
    get(key: ACString): nsISFVItemOrInnerList;
    /**
     * Insert a new key-value pair.
     * If an equivalent key already exists: the key remains and retains in its place in the order,
     * its corresponding value is updated with the new value.
     *
     * @throws NS_ERROR_UNEXPECTED if supplied item does not implement nsISFVItemOrInnerList interface.
     */
    set(key: ACString, member_value: nsISFVItemOrInnerListType): void;
    /**
     * Remove the key-value pair equivalent to key.
     *
     * @throws NS_ERROR_UNEXPECTED upon attempt to delete  key that does not exist in parameters.
     */
    delete(key: ACString): void;
    /**
     * In case when header value is split across lines, it's possible
     * this method parses supplied line and merges it with members of existing object.
     */
    parseMore(header: ACString): void;
}

/**
 * nsISFVService provides a set of functions for working with HTTP header value as an object.
 * It exposes functions for creating object from string containing header value,
 * as well as individual components for manual structured header object creation.
 */
declare interface nsISFVServiceType extends nsISupportsType {
    /**
     * Parses provided string into Dictionary header value (nsISFVDictionary).
     *
     * @throws NS_ERROR_FAILURE if parsing fails.
     */
    parseDictionary(header: ACString): nsISFVDictionary;
    /**
     * Parses provided string into List header value (nsISFVList).
     *
     * @throws NS_ERROR_FAILURE if parsing fails.
     */
    parseList(header: ACString): nsISFVList;
    /**
     * Parses provided string into Item header value (nsISFVItem).
     *
     * @throws NS_ERROR_FAILURE if parsing fails.
     */
    parseItem(header: ACString): nsISFVItem;
    /**
     * The following functions create bare item of specific type.
     */
    newInteger(value: long_long): nsISFVInteger;
    /**
     *
     */
    newBool(value: bool): nsISFVBool;
    /**
     *
     */
    newDecimal(value: double): nsISFVDecimal;
    /**
     *
     */
    newString(value: ACString): nsISFVString;
    /**
     *
     */
    newByteSequence(value: ACString): nsISFVByteSeq;
    /**
     *
     */
    newToken(value: ACString): nsISFVToken;
    /**
     * Creates nsISFVParams with no parameters. In other words, it's an empty map byt default.
     */
    newParameters(): nsISFVParams;
    /**
     * Creates nsISFVInnerList from nsISFVItem array and nsISFVParams.
     */
    newInnerList(items: invalid, params: nsISFVParamsType): nsISFVInnerList;
    /**
     * Creates nsISFVItem, which represents Item header value, from nsISFVBareItem and associated nsISFVParams.
     */
    newItem(value: nsISFVBareItemType, params: nsISFVParamsType): nsISFVItem;
    /**
     * Creates nsISFVList, which represents List header value, from array of nsISFVItemOrInnerList.
     * nsISFVItemOrInnerList represens either Item (nsISFVItem) or Inner List (nsISFVInnerList).
     */
    newList(members: invalid): nsISFVList;
    /**
     * Creates nsISFVDictionary representing Dictionary header value. It is empty by default.
     */
    newDictionary(): nsISFVDictionary;
}

/**
 * nsIStyleSheetService allows extensions or embeddors to add to the
 * built-in list of user or agent style sheets.
 */
declare interface nsIStyleSheetServiceType extends nsISupportsType {
    /**
     * Synchronously loads a style sheet from |sheetURI| and adds it to the list
     * of user or agent style sheets.
     *
     * A user sheet loaded via this API will come before userContent.css and
     * userChrome.css in the cascade (so the rules in it will have lower
     * precedence than rules in those sheets).
     *
     * An agent sheet loaded via this API will come after ua.css in the cascade
     * (so the rules in it will have higher precedence than rules in ua.css).
     *
     * The relative ordering of two user or two agent sheets loaded via
     * this API is undefined.
     *
     * Sheets added via this API take effect on all documents, including
     * already-loaded ones, immediately.
     */
    loadAndRegisterSheet(sheetURI: nsIURIType, type: unsigned_long): void;
    /**
     * Returns true if a style sheet at |sheetURI| has previously been
     * added to the list of style sheets specified by |type|.
     */
    sheetRegistered(sheetURI: nsIURIType, type: unsigned_long): boolean;
    /**
     * Synchronously loads a style sheet from |sheetURI| and returns the
     * new style sheet object. Can be used with nsIDOMWindowUtils.addSheet.
     */
    preloadSheet(sheetURI: nsIURIType, type: unsigned_long): nsIPreloadedStyleSheet;
    /**
     * Asynchronously loads a style sheet from |sheetURI| and returns a Promise
     * which resolves to the new style sheet object, which can be used with
     * nsIDOMWindowUtils.addSheet, when it has completed loading.
     */
    preloadSheetAsync(sheetURI: nsIURIType, type: unsigned_long): jsval;
    /**
     * Remove the style sheet at |sheetURI| from the list of style sheets
     * specified by |type|.  The removal takes effect immediately, even for
     * already-loaded documents.
     */
    unregisterSheet(sheetURI: nsIURIType, type: unsigned_long): void;
}

/**
 * Protocol handler superinterface for a protocol which performs substitutions
 * from URIs of its scheme to URIs of another scheme.
 */
declare interface nsISubstitutingProtocolHandlerType extends nsIProtocolHandlerType {
    /**
     * Sets the substitution for the root key:
     * resource://root/path ==> baseURI.resolve(path)
     *
     * A null baseURI removes the specified substitution.
     *
     * The root key will be converted to lower-case to conform to
     * case-insensitive URI hostname matching behavior.
     */
    setSubstitution(root: ACString, baseURI: nsIURIType): void;
    /**
     * Same as setSubstitution, but with specific flags.
     */
    setSubstitutionWithFlags(root: ACString, baseURI: nsIURIType, flags: uint32_t): void;
    /**
     * Gets the substitution for the root key.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if none exists.
     */
    getSubstitution(root: ACString): nsIURI;
    /**
     * Returns TRUE if the substitution exists and FALSE otherwise.
     */
    hasSubstitution(root: ACString): boolean;
    /**
     * Utility function to resolve a substituted URI.  A resolved URI is not
     * guaranteed to reference a resource that exists (ie. opening a channel to
     * the resolved URI may fail).
     *
     * @throws NS_ERROR_NOT_AVAILABLE if resURI.host() is an unknown root key.
     */
    resolveURI(resURI: nsIURIType): AUTF8String;
}

/**
 * Basic component object model interface. Objects which implement
 * this interface support runtime interface discovery (QueryInterface)
 * and a reference counted memory model (AddRef/Release). This is
 * modelled after the win32 IUnknown API.
 *
 * Historically, nsISupports needed to be binary compatible with COM's
 * IUnknown, so the IID of nsISupports is the same as it. That is no
 * longer a goal, and hopefully nobody depends on it. We may break
 * this compatibility at any time.
 */
declare interface nsISupportsType {
    /**
     * A run time mechanism for interface discovery.
     * @param aIID [in] A requested interface IID
     * @param aInstancePtr [out] A pointer to an interface pointer to
     * receive the result.
     * @return **NS_OK** if the interface is supported by the associated
     * instance, **NS_NOINTERFACE** if it is not.
     *
     * aInstancePtr must not be null.
     */
    QueryInterface(aIID: nsIIDRefType, aInstancePtr: nsQIResult): void;
}

/**
 * ...
 */
declare interface nsIOutputIteratorType extends nsISupportsType {
    /**
     * Put |anElementToPut| into the underlying container or sequence at the position currently pointed to by this iterator.
     * The iterator and the underlying container or sequence cooperate to |Release()|
     * the replaced element, if any and if necessary, and to |AddRef()| the new element.
     *
     * The result is undefined if this iterator currently points outside the
     * useful range of the underlying container or sequence.
     *
     * @param anElementToPut the element to place into the underlying container or sequence
     */
    putElement(anElementToPut: nsISupportsType): void;
    /**
     * Advance this iterator to the next position in the underlying container or sequence.
     */
    stepForward(): void;
}

/**
 * ...
 */
declare interface nsIInputIteratorType extends nsISupportsType {
    /**
     * Retrieve (and |AddRef()|) the element this iterator currently points to.
     *
     * The result is undefined if this iterator currently points outside the
     * useful range of the underlying container or sequence.
     *
     * @result a new reference to the element this iterator currently points to (if any)
     */
    getElement(): nsISupports;
    /**
     * Advance this iterator to the next position in the underlying container or sequence.
     */
    stepForward(): void;
    /**
     * Test if |anotherIterator| points to the same position in the underlying container or sequence.
     *
     * The result is undefined if |anotherIterator| was not created by or for the same underlying container or sequence.
     *
     * @param anotherIterator another iterator to compare against, created by or for the same underlying container or sequence
     * @result true if |anotherIterator| points to the same position in the underlying container or sequence
     */
    isEqualTo(anotherIterator: nsISupportsType): boolean;
    /**
     * Create a new iterator pointing to the same position in the underlying container or sequence to which this iterator currently points.
     * The returned iterator is suitable for use in a subsequent call to |isEqualTo()| against this iterator.
     *
     * @result a new iterator pointing at the same position in the same underlying container or sequence as this iterator
     */
    clone(): nsISupports;
}

/**
 * ...
 */
declare interface nsIForwardIteratorType extends nsISupportsType {
    /**
     * Retrieve (and |AddRef()|) the element this iterator currently points to.
     *
     * The result is undefined if this iterator currently points outside the
     * useful range of the underlying container or sequence.
     *
     * @result a new reference to the element this iterator currently points to (if any)
     */
    getElement(): nsISupports;
    /**
     * Put |anElementToPut| into the underlying container or sequence at the position currently pointed to by this iterator.
     * The iterator and the underlying container or sequence cooperate to |Release()|
     * the replaced element, if any and if necessary, and to |AddRef()| the new element.
     *
     * The result is undefined if this iterator currently points outside the
     * useful range of the underlying container or sequence.
     *
     * @param anElementToPut the element to place into the underlying container or sequence
     */
    putElement(anElementToPut: nsISupportsType): void;
    /**
     * Advance this iterator to the next position in the underlying container or sequence.
     */
    stepForward(): void;
    /**
     * Test if |anotherIterator| points to the same position in the underlying container or sequence.
     *
     * The result is undefined if |anotherIterator| was not created by or for the same underlying container or sequence.
     *
     * @param anotherIterator another iterator to compare against, created by or for the same underlying container or sequence
     * @result true if |anotherIterator| points to the same position in the underlying container or sequence
     */
    isEqualTo(anotherIterator: nsISupportsType): boolean;
    /**
     * Create a new iterator pointing to the same position in the underlying container or sequence to which this iterator currently points.
     * The returned iterator is suitable for use in a subsequent call to |isEqualTo()| against this iterator.
     *
     * @result a new iterator pointing at the same position in the same underlying container or sequence as this iterator
     */
    clone(): nsISupports;
}

/**
 * ...
 */
declare interface nsIBidirectionalIteratorType extends nsISupportsType {
    /**
     * Retrieve (and |AddRef()|) the element this iterator currently points to.
     *
     * The result is undefined if this iterator currently points outside the
     * useful range of the underlying container or sequence.
     *
     * @result a new reference to the element this iterator currently points to (if any)
     */
    getElement(): nsISupports;
    /**
     * Put |anElementToPut| into the underlying container or sequence at the position currently pointed to by this iterator.
     * The iterator and the underlying container or sequence cooperate to |Release()|
     * the replaced element, if any and if necessary, and to |AddRef()| the new element.
     *
     * The result is undefined if this iterator currently points outside the
     * useful range of the underlying container or sequence.
     *
     * @param anElementToPut the element to place into the underlying container or sequence
     */
    putElement(anElementToPut: nsISupportsType): void;
    /**
     * Advance this iterator to the next position in the underlying container or sequence.
     */
    stepForward(): void;
    /**
     * Move this iterator to the previous position in the underlying container or sequence.
     */
    stepBackward(): void;
    /**
     * Test if |anotherIterator| points to the same position in the underlying container or sequence.
     *
     * The result is undefined if |anotherIterator| was not created by or for the same underlying container or sequence.
     *
     * @param anotherIterator another iterator to compare against, created by or for the same underlying container or sequence
     * @result true if |anotherIterator| points to the same position in the underlying container or sequence
     */
    isEqualTo(anotherIterator: nsISupportsType): boolean;
    /**
     * Create a new iterator pointing to the same position in the underlying container or sequence to which this iterator currently points.
     * The returned iterator is suitable for use in a subsequent call to |isEqualTo()| against this iterator.
     *
     * @result a new iterator pointing at the same position in the same underlying container or sequence as this iterator
     */
    clone(): nsISupports;
}

/**
 * ...
 */
declare interface nsIRandomAccessIteratorType extends nsISupportsType {
    /**
     * Retrieve (and |AddRef()|) the element this iterator currently points to.
     *
     * The result is undefined if this iterator currently points outside the
     * useful range of the underlying container or sequence.
     *
     * @result a new reference to the element this iterator currently points to (if any)
     */
    getElement(): nsISupports;
    /**
     * Retrieve (and |AddRef()|) an element at some offset from where this iterator currently points.
     * The offset may be negative.  |getElementAt(0)| is equivalent to |getElement()|.
     *
     * The result is undefined if this iterator currently points outside the
     * useful range of the underlying container or sequence.
     *
     * @param anOffset a |0|-based offset from the position to which this iterator currently points
     * @result a new reference to the indicated element (if any)
     */
    getElementAt(anOffset: int32_t): nsISupports;
    /**
     * Put |anElementToPut| into the underlying container or sequence at the position currently pointed to by this iterator.
     * The iterator and the underlying container or sequence cooperate to |Release()|
     * the replaced element, if any and if necessary, and to |AddRef()| the new element.
     *
     * The result is undefined if this iterator currently points outside the
     * useful range of the underlying container or sequence.
     *
     * @param anElementToPut the element to place into the underlying container or sequence
     */
    putElement(anElementToPut: nsISupportsType): void;
    /**
     * Put |anElementToPut| into the underlying container or sequence at the position |anOffset| away from that currently pointed to by this iterator.
     * The iterator and the underlying container or sequence cooperate to |Release()|
     * the replaced element, if any and if necessary, and to |AddRef()| the new element.
     * |putElementAt(0, obj)| is equivalent to |putElement(obj)|.
     *
     * The result is undefined if this iterator currently points outside the
     * useful range of the underlying container or sequence.
     *
     * @param anOffset a |0|-based offset from the position to which this iterator currently points
     * @param anElementToPut the element to place into the underlying container or sequence
     */
    putElementAt(anOffset: int32_t, anElementToPut: nsISupportsType): void;
    /**
     * Advance this iterator to the next position in the underlying container or sequence.
     */
    stepForward(): void;
    /**
     * Move this iterator by |anOffset| positions in the underlying container or sequence.
     * |anOffset| may be negative.  |stepForwardBy(1)| is equivalent to |stepForward()|.
     * |stepForwardBy(0)| is a no-op.
     *
     * @param anOffset a |0|-based offset from the position to which this iterator currently points
     */
    stepForwardBy(anOffset: int32_t): void;
    /**
     * Move this iterator to the previous position in the underlying container or sequence.
     */
    stepBackward(): void;
    /**
     * Move this iterator backwards by |anOffset| positions in the underlying container or sequence.
     * |anOffset| may be negative.  |stepBackwardBy(1)| is equivalent to |stepBackward()|.
     * |stepBackwardBy(n)| is equivalent to |stepForwardBy(-n)|.  |stepBackwardBy(0)| is a no-op.
     *
     * @param anOffset a |0|-based offset from the position to which this iterator currently points
     */
    stepBackwardBy(anOffset: int32_t): void;
    /**
     * Test if |anotherIterator| points to the same position in the underlying container or sequence.
     *
     * The result is undefined if |anotherIterator| was not created by or for the same underlying container or sequence.
     *
     * @param anotherIterator another iterator to compare against, created by or for the same underlying container or sequence
     * @result true if |anotherIterator| points to the same position in the underlying container or sequence
     */
    isEqualTo(anotherIterator: nsISupportsType): boolean;
    /**
     * Create a new iterator pointing to the same position in the underlying container or sequence to which this iterator currently points.
     * The returned iterator is suitable for use in a subsequent call to |isEqualTo()| against this iterator.
     *
     * @result a new iterator pointing at the same position in the same underlying container or sequence as this iterator
     */
    clone(): nsISupports;
}

/**
 * Primitive base interface.
 *
 * These first three are pointer types and do data copying
 * using the nsIMemory. Be careful!
 */
declare interface nsISupportsPrimitiveType extends nsISupportsType {
    /**
     *
     */
    readonly type: unsigned_short;
}

/**
 * Scriptable storage for nsID structures
 */
declare interface nsISupportsIDType extends nsISupportsPrimitiveType {
    /**
     *
     */
    data: nsIDPtr;
    /**
     *
     */
    toString(): string;
}

/**
 * Scriptable storage for ASCII strings
 */
declare interface nsISupportsCStringType extends nsISupportsPrimitiveType {
    /**
     *
     */
    data: ACString;
    /**
     *
     */
    toString(): string;
}

/**
 * Scriptable storage for Unicode strings
 */
declare interface nsISupportsStringType extends nsISupportsPrimitiveType {
    /**
     *
     */
    data: AString;
    /**
     *
     */
    toString(): wstring;
}

/**
 * Scriptable storage for booleans
 */
declare interface nsISupportsPRBoolType extends nsISupportsPrimitiveType {
    /**
     *
     */
    data: boolean;
    /**
     *
     */
    toString(): string;
}

/**
 * Scriptable storage for 8-bit integers
 */
declare interface nsISupportsPRUint8Type extends nsISupportsPrimitiveType {
    /**
     *
     */
    data: uint8_t;
    /**
     *
     */
    toString(): string;
}

/**
 * Scriptable storage for unsigned 16-bit integers
 */
declare interface nsISupportsPRUint16Type extends nsISupportsPrimitiveType {
    /**
     *
     */
    data: uint16_t;
    /**
     *
     */
    toString(): string;
}

/**
 * Scriptable storage for unsigned 32-bit integers
 */
declare interface nsISupportsPRUint32Type extends nsISupportsPrimitiveType {
    /**
     *
     */
    data: uint32_t;
    /**
     *
     */
    toString(): string;
}

/**
 * Scriptable storage for 64-bit integers
 */
declare interface nsISupportsPRUint64Type extends nsISupportsPrimitiveType {
    /**
     *
     */
    data: uint64_t;
    /**
     *
     */
    toString(): string;
}

/**
 * Scriptable storage for NSPR date/time values
 */
declare interface nsISupportsPRTimeType extends nsISupportsPrimitiveType {
    /**
     *
     */
    data: PRTime;
    /**
     *
     */
    toString(): string;
}

/**
 * Scriptable storage for single character values
 * (often used to store an ASCII character)
 */
declare interface nsISupportsCharType extends nsISupportsPrimitiveType {
    /**
     *
     */
    data: char;
    /**
     *
     */
    toString(): string;
}

/**
 * Scriptable storage for 16-bit integers
 */
declare interface nsISupportsPRInt16Type extends nsISupportsPrimitiveType {
    /**
     *
     */
    data: int16_t;
    /**
     *
     */
    toString(): string;
}

/**
 * Scriptable storage for 32-bit integers
 */
declare interface nsISupportsPRInt32Type extends nsISupportsPrimitiveType {
    /**
     *
     */
    data: int32_t;
    /**
     *
     */
    toString(): string;
}

/**
 * Scriptable storage for 64-bit integers
 */
declare interface nsISupportsPRInt64Type extends nsISupportsPrimitiveType {
    /**
     *
     */
    data: int64_t;
    /**
     *
     */
    toString(): string;
}

/**
 * Scriptable storage for floating point numbers
 */
declare interface nsISupportsFloatType extends nsISupportsPrimitiveType {
    /**
     *
     */
    data: float;
    /**
     *
     */
    toString(): string;
}

/**
 * Scriptable storage for doubles
 */
declare interface nsISupportsDoubleType extends nsISupportsPrimitiveType {
    /**
     *
     */
    data: double;
    /**
     *
     */
    toString(): string;
}

/**
 * Scriptable storage for other XPCOM objects
 */
declare interface nsISupportsInterfacePointerType extends nsISupportsPrimitiveType {
    /**
     *
     */
    data: nsISupports;
    /**
     *
     */
    dataIID: nsIDPtr;
    /**
     *
     */
    toString(): string;
}

/**
 * This interface exposes the general notion of a scheduled object with a
 * integral priority value.  Following UNIX conventions, smaller (and possibly
 * negative) values have higher priority.
 *
 * This interface does not strictly define what happens when the priority of an
 * object is changed.  An implementation of this interface is free to define
 * the side-effects of changing the priority of an object.  In some cases,
 * changing the priority of an object may be disallowed (resulting in an
 * exception being thrown) or may simply be ignored.
 */
declare interface nsISupportsPriorityType extends nsISupportsType {
    /**
     * This attribute may be modified to change the priority of this object.  The
     * implementation of this interface is free to truncate a given priority
     * value to whatever limits are appropriate.  Typically, this attribute is
     * initialized to PRIORITY_NORMAL, but implementations may choose to assign a
     * different initial value.
     */
    priority: long;
    /**
     * This method adjusts the priority attribute by a given delta.  It helps
     * reduce the amount of coding required to increment or decrement the value
     * of the priority attribute.
     */
    adjustPriority(delta: long): void;
}

/**
 *
 */
declare interface nsISyncStreamListenerType extends nsIStreamListenerType {
    /**
     * Returns an input stream that when read will fetch data delivered to the
     * sync stream listener.  The nsIInputStream implementation will wait for
     * OnDataAvailable events before returning from Read.
     *
     * NOTE: Reading from the returned nsIInputStream may spin the current
     * thread's event queue, which could result in any event being processed.
     */
    readonly inputStream: nsIInputStream;
}

/**
 *
 */
declare interface nsISynthVoiceRegistryType extends nsISupportsType {
    /**
     * Register a speech synthesis voice.
     *
     * @param aService          the service that provides this voice.
     * @param aUri              a unique identifier for this voice.
     * @param aName             human-readable name for this voice.
     * @param aLang             a BCP 47 language tag.
     * @param aLocalService     true if service does not require network.
     * @param aQueuesUtterances true if voice only speaks one utterance at a time
     */
    addVoice(aService: nsISpeechServiceType, aUri: AString, aName: AString, aLang: AString, aLocalService: boolean, aQueuesUtterances: boolean): void;
    /**
     * Remove a speech synthesis voice.
     *
     * @param aService the service that was used to add the voice.
     * @param aUri     a unique identifier of an existing voice.
     */
    removeVoice(aService: nsISpeechServiceType, aUri: AString): void;
    /**
     * Notify content of voice availability changes. This allows content
     * to be notified of voice catalog changes in real time.
     */
    notifyVoicesChanged(): void;
    /**
     * Notify chrome code of an error when starting speech synthesis service
     */
    notifyVoicesError(aError: AString): void;
    /**
     * Set a voice as default.
     *
     * @param aUri       a unique identifier of an existing voice.
     * @param aIsDefault true if this voice should be toggled as default.
     */
    setDefaultVoice(aUri: AString, aIsDefault: boolean): void;
    /**
     *
     */
    readonly voiceCount: uint32_t;
    /**
     *
     */
    getVoice(aIndex: uint32_t): AString;
    /**
     *
     */
    isDefaultVoice(aUri: AString): bool;
    /**
     *
     */
    isLocalVoice(aUri: AString): bool;
    /**
     *
     */
    getVoiceLang(aUri: AString): AString;
    /**
     *
     */
    getVoiceName(aUri: AString): AString;
}

/**
 *
 */
declare interface nsISystemInfoType extends nsISupportsType {
    /**
     * Asynchronously get info about what types of disks we're using for the
     * profile and binary.
     * Note: only implemented on Windows, will return null elsewhere.
     */
    readonly diskInfo: Promise;
    /**
     * Asynchronously get CountryCode info.
     * Note: only implemented on macOS and Windows, will return null elsewhere.
     */
    readonly countryCode: Promise;
    /**
     * Asynchronously gets OS info on the system's install year.
     * Note: only implemented on Windows, will return null elsewhere.
     */
    readonly osInfo: Promise;
    /**
     * Asynchronously gets process info that indicates if the process is running
     * under Wow64 and WowARM64.
     * Note: only implemented on Windows, will return null elsewhere.
     */
    readonly processInfo: Promise;
}

/**
 * This interface allows the proxy code to use platform-specific proxy
 * settings when the proxy preference is set to "automatic discovery". This service
 * acts like a PAC parser to netwerk, but it will actually read the system settings and
 * either return the proper proxy data from the autoconfig URL specified in the system proxy,
 * or generate proxy data based on the system's manual proxy settings.
 */
declare interface nsISystemProxySettingsType extends nsISupportsType {
    /**
     * Whether or not it is appropriate to execute getProxyForURI off the main thread.
     * If that method can block (e.g. for WPAD as windows does) then it must be
     * not mainThreadOnly to avoid creating main thread jank. The main thread only option is
     * provided for implementations that do not block but use other main thread only
     * functions such as dbus.
     */
    readonly mainThreadOnly: bool;
    /**
     * If non-empty, use this PAC file. If empty, call getProxyForURI instead.
     */
    readonly PACURI: AUTF8String;
    /**
     * See ProxyAutoConfig::getProxyForURI; this function behaves similarly except
     * a more relaxed return string is allowed that includes full urls instead of just
     * host:port syntax. e.g. "PROXY http://www.foo.com:8080" instead of
     * "PROXY www.foo.com:8080"
     */
    getProxyForURI(testSpec: AUTF8String, testScheme: AUTF8String, testHost: AUTF8String, testPort: int32_t): AUTF8String;
}

/**
 * Allow applications to interface with the Mac OS X system status bar.
 */
declare interface nsISystemStatusBarType extends nsISupportsType {
    /**
     * Add an item to the system status bar. Each item can only be present once,
     * subsequent addItem calls with the same element will be ignored.
     * The system status bar holds a strong reference to the added XUL menu
     * element and the item will stay in the status bar until it is removed via
     * a call to removeItem, or until the process shuts down.
     * @param aDOMMenuElement A XUL menu element that contains a XUL menupopup
     * with regular menu content. The menu's icon is put
     * into the system status bar; clicking it will open
     * a menu with the contents of the menupopup.
     * The menu label is not shown.
     */
    addItem(aMenuElement: Element): void;
    /**
     * Remove a previously-added item from the menu bar. Calling this with an
     * element that has not been added before will be silently ignored.
     * @param aDOMMenuElement The XUL menu element that you called addItem with.
     */
    removeItem(aMenuElement: Element): void;
}

/**
 * This interface is implemented in TCPSocket.cpp as an internal interface
 * for use in cross-process socket implementation.
 * Needed to account for multiple possible types that can be provided to
 * the socket callbacks as arguments.
 */
declare interface nsITCPSocketCallbackType extends nsISupportsType {
    /**
     *
     */
    fireErrorEvent(name: AString, type: AString, errorCode: nsresult): void;
    /**
     *
     */
    fireDataStringEvent(type: AString, data: ACString): void;
    /**
     *
     */
    fireDataArrayEvent(type: AString, data: nsUint8TArrayRef): void;
    /**
     *
     */
    fireEvent(type: AString): void;
    /**
     *
     */
    updateReadyState(readystate: unsigned_long): void;
    /**
     *
     */
    updateBufferedAmount(bufferedAmount: uint32_t, trackingNumber: uint32_t): void;
}

/**
 *
 */
declare interface nsITLSServerSocketType extends nsIServerSocketType {
    /**
     * serverCert
     *
     * The server's certificate that is presented to the client during the TLS
     * handshake.  This is required to be set before calling |asyncListen|.
     */
    serverCert: nsIX509Cert;
    /**
     * setSessionTickets
     *
     * Whether the server should support session tickets.  Defaults to true.  This
     * should be set before calling |asyncListen| if you wish to change the
     * default.
     */
    setSessionTickets(aSessionTickets: boolean): void;
    /**
     * setRequestClientCertificate
     *
     * Whether the server should request and/or require a client auth certificate
     * from the client.  Defaults to REQUEST_NEVER.  See the possible options
     * above.  This should be set before calling |asyncListen| if you wish to
     * change the default.
     */
    setRequestClientCertificate(aRequestClientCert: unsigned_long): void;
    /**
     * setVersionRange
     *
     * The server's TLS versions that is used by the TLS handshake.
     * This is required to be set before calling |asyncListen|.
     *
     * aMinVersion and aMaxVersion is a TLS version value from
     * |nsITLSClientStatus| constants.
     */
    setVersionRange(aMinVersion: unsigned_short, aMaxVersion: unsigned_short): void;
}

/**
 * Security summary for a given TLS client connection being handled by a
 * |nsITLSServerSocket| server.
 *
 * This is accessible through the security info object on the transport, which
 * will be an instance of |nsITLSServerConnectionInfo| (see below).
 *
 * The values of these attributes are available once the |onHandshakeDone|
 * method of the security observer has been called (see
 * |nsITLSServerSecurityObserver| below).
 */
declare interface nsITLSClientStatusType extends nsISupportsType {
    /**
     * peerCert
     *
     * The client's certificate, if one was requested via |requestCertificate|
     * above and supplied by the client.
     */
    readonly peerCert: nsIX509Cert;
    /**
     * tlsVersionUsed
     *
     * The version of TLS used by the connection.  See values above.
     */
    readonly tlsVersionUsed: short;
    /**
     * cipherName
     *
     * Name of the cipher suite used, such as
     * "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256".
     * See security/nss/lib/ssl/sslinfo.c for the possible values.
     */
    readonly cipherName: ACString;
    /**
     * keyLength
     *
     * The "effective" key size of the symmetric key in bits.
     */
    readonly keyLength: unsigned_long;
    /**
     * macLength
     *
     * The size of the MAC in bits.
     */
    readonly macLength: unsigned_long;
}

/**
 * Connection info for a given TLS client connection being handled by a
 * |nsITLSServerSocket| server.  This object is thread-safe.
 *
 * This is exposed as the security info object on the transport, so it can be
 * accessed via |transport.securityInfo|.
 *
 * This interface is available by the time the |onSocketAttached| is called,
 * which is the first time the TLS server consumer is notified of a new client.
 */
declare interface nsITLSServerConnectionInfoType extends nsISupportsType {
    /**
     * setSecurityObserver
     *
     * Set the security observer to be notified when the TLS handshake has
     * completed.
     */
    setSecurityObserver(observer: nsITLSServerSecurityObserverType): void;
    /**
     * serverSocket
     *
     * The nsITLSServerSocket instance that accepted this client connection.
     */
    readonly serverSocket: nsITLSServerSocket;
    /**
     * status
     *
     * Security summary for this TLS client connection.  Note that the values of
     * this interface are not available until the TLS handshake has completed.
     * See |nsITLSClientStatus| above for more details.
     */
    readonly status: nsITLSClientStatus;
}

/**
 *
 */
declare interface nsITLSServerSecurityObserverType extends nsISupportsType {
    /**
     * onHandsakeDone
     *
     * This method is called once the TLS handshake is completed.  This takes
     * place after |onSocketAccepted| has been called, which typically opens the
     * streams to keep things moving along. It's important to be aware that the
     * handshake has not completed at the point that |onSocketAccepted| is called,
     * so no security verification can be done until this method is called.
     */
    onHandshakeDone(aServer: nsITLSServerSocketType, aStatus: nsITLSClientStatusType): void;
}

/**
 *
 */
declare interface nsITLSSocketControlType extends nsISupportsType {
    /**
     *
     */
    proxyStartSSL(): void;
    /**
     *
     */
    StartTLS(): void;
    /**
     * For 0RTT we need to know the alpn protocol selected for the last tls
     * session. This function will return a value if applicable or an error
     * NS_ERROR_NOT_AVAILABLE.
     */
    getAlpnEarlySelection(): ACString;
    /**
     * If 0RTT handshake was applied and some data has been sent, as soon as
     * the handshake finishes this attribute will be set to appropriate value.
     */
    readonly earlyDataAccepted: bool;
    /**
     * When 0RTT is performed, PR_Write will not drive the handshake forward.
     * It must be forced by calling this function.
     */
    driveHandshake(): void;
    /**
     * Determine if a potential SSL connection to hostname:port with
     * a desired NPN negotiated protocol of npnProtocol can use the socket
     * associated with this object instead of making a new one. And if so, combine
     * them.
     */
    joinConnection(npnProtocol: ACString, hostname: ACString, port: long): boolean;
    /**
     * just like JoinConnection() except do not mark a successful test as joined.
     */
    testJoinConnection(npnProtocol: ACString, hostname: ACString, port: long): boolean;
    /**
     * Determine if existing connection should be trusted to convey information about
     * a hostname.
     */
    isAcceptableForHost(hostname: ACString): boolean;
    /**
     * The Key Exchange Algorithm is used when determining whether or
     * not HTTP/2 can be used.
     *
     * After a handshake is complete it can be read from KEAUsed.
     * The values correspond to the SSLKEAType enum in NSS or the
     * KEY_EXCHANGE_UNKNOWN constant defined below.
     *
     * KEAKeyBits is the size/security-level used for the KEA.
     */
    readonly KEAUsed: short;
    /**
     *
     */
    readonly KEAKeyBits: unsigned_long;
    /**
     * The original flags from the socket provider.
     */
    readonly providerFlags: uint32_t;
    /**
     *
     */
    readonly SSLVersionUsed: short;
    /**
     *
     */
    readonly SSLVersionOffered: short;
    /**
     *
     */
    readonly MACAlgorithmUsed: short;
    /**
     * If set to true before the server requests a client cert
     * no cert will be sent.
     */
    denyClientCert: boolean;
    /**
     * True iff a client cert has been sent to the server - i.e. this
     * socket has been client-cert authenticated.
     */
    readonly clientCertSent: boolean;
    /**
     * failedVerification is true if any enforced certificate checks have failed.
     * Connections that have not yet tried to verify, or are using acceptable
     * exceptions will all return false.
     */
    readonly failedVerification: boolean;
    /**
     * esniTxt is a string that consists of the concatenated _esni. TXT records.
     * This is a base64 encoded ESNIKeys structure.
     */
    esniTxt: ACString;
    /**
     * echConfig is defined for conveying the ECH configuration.
     * This is encoded in base64.
     */
    echConfig: ACString;
    /**
     * The echConfig that should be used to retry for the connection setup.
     */
    readonly retryEchConfig: ACString;
    /**
     * The id used to uniquely identify the connection to the peer.
     */
    readonly peerId: ACString;
    /**
     * The securityInfo of the TLS handshake.
     */
    readonly securityInfo: nsITransportSecurityInfo;
    /**
     * Asynchronously obtain the securityInfo of the TLS handshake. Resolves
     * with an nsITransportSecurityInfo. This should probably only be used in
     * tests, where JS running on the main thread cannot access any of the
     * other fields of nsITLSSocketControl.
     */
    asyncGetSecurityInfo(): Promise;
    /**
     * Claim a speculative connection.
     */
    claim(): void;
    /**
     * The top-level outer content window ID (called "browserId" in networking
     * code) associated with this connection, if any (otherwise, 0). Useful for
     * associating this connection with a browser tab in order to show UI (e.g.
     * the client authentication certificate selection dialog).
     */
    browserId: uint64_t;
}

/**
 *
 */
declare interface nsITRRSkipReasonType extends nsISupportsType {
}

/**
 *
 */
declare interface nsITXTToHTMLConvType extends nsIStreamConverterType {
    /**
     * @param text: Title to set for the HTML document.  Only applicable if
     * preFormatHTML(true) is called.
     * @result      The given title will be used to form an HTML document
     * from the plain text document.
     */
    setTitle(text: wstring): void;
    /**
     * @param value: true to use an HTML header and footer on the document,
     * false to omit it.
     * @result       The document will use a header and footer if value is
     * true.
     */
    preFormatHTML(value: boolean): void;
}

/**
 *
 */
declare interface nsITableEditorType extends nsISupportsType {
    /**
     * insertTableCell() inserts <td> elements before or after a cell element
     * containing first selection range.  I.e., if the cell spans columns and
     * aInsertPosition is true, new columns will be inserted after the
     * right-most column which contains the cell.  Note that this simply
     * inserts <td> elements, i.e., colspan and rowspan around the cell
     * containing selection are not modified.  So, for example, adding a cell
     * to rectangular table changes non-rectangular table.  And if a cell
     * containing selection is at left of row-spanning cell, it may be moved to
     * right side of the row-spanning cell after inserting some cell elements
     * before it.  Similarly, colspan won't be adjusted for keeping table
     * rectangle.
     * If first selection range is not in table cell element, this does nothing
     * without exception.
     *
     * @param aNumberOfCellssToInsert     Number of cells to insert.
     * @param aInsertAfterSelectedCell    true if new cells should be inserted
     * before current cell.  Otherwise, will
     * be inserted after the cell.
     */
    insertTableCell(aNumberOfColumnsToInsert: long, aInsertAfterSelectedCell: boolean): void;
    /**
     * insertTableColumn() inserts columns before or after a cell element
     * containing first selection range.  I.e., if the cell spans columns and
     * aInsertAfterSelectedCell is tre, new columns will be inserted after the
     * right-most column which contains the cell.  If first selection range is
     * not in table cell element, this does nothing without exception.
     *
     * @param aNumberOfColumnsToInsert    Number of columns to insert.
     * @param aInsertAfterSelectedCell    true if new columns will be inserted
     * before current cell.  Otherwise, will
     * be inserted after the cell.
     */
    insertTableColumn(aNumberOfColumnsToInsert: long, aInsertAfterSelectedCell: boolean): void;
    /**
     * insertTableRow() inserts <tr> elements before or after a <td> element
     * containing first selection range.  I.e., if the cell spans rows and
     * aInsertAfterSelectedCell is true, new rows will be inserted after the
     * bottom-most row which contains the cell.  If first selection range is
     * not in table cell element, this does nothing without exception.
     *
     * @param aNumberOfRowsToInsert       Number of rows to insert.
     * @param aInsertAfterSelectedCell    true if new rows will be inserted
     * before current cell.  Otherwise, will
     * be inserted after the cell.
     */
    insertTableRow(aNumberOfRowsToInsert: long, aInsertAfterSelectedCell: boolean): void;
    /**
     * Delete table methods
     * Delete starting at the selected cell or the
     * cell (or table) enclosing the selection anchor
     * The selection is collapsed and is left in the
     * cell at the same row,col location as
     * the previous selection anchor, if possible,
     * else in the closest neighboring cell
     *
     * @param aNumber    Number of items to insert/delete
     */
    deleteTable(): void;
    /**
     * deleteTableCellContents() removes any contents in cell elements.  If two
     * or more cell elements are selected, this removes all selected cells'
     * contents.  Otherwise, this removes contents of a cell which contains
     * first selection range.  This does nothing without exception if selection
     * is not in cell element.
     */
    deleteTableCellContents(): void;
    /**
     * deleteTableCell() removes table cell elements.  If two or more cell
     * elements are selected, this removes all selected cell elements.
     * Otherwise, this removes some cell elements starting from selected cell
     * element or a cell containing first selection range.  When this removes
     * last cell element in <tr> or <table>, this removes the <tr> or the
     * <table> too.  Note that when removing a cell causes number of its row
     * becomes less than the others, this method does NOT fill the place with
     * rowspan nor colspan.  This does nothing without exception if selection is
     * not in cell element.
     *
     * @param aNumberOfCellsToDelete  Number of cells to remove.  This is ignored
     * if 2 or more cells are selected.
     */
    deleteTableCell(aNumberOfCellsToDelete: long): void;
    /**
     * deleteTableColumn() removes cell elements which belong to same columns
     * of selected cell elements.
     * If only one cell element is selected or first selection range is
     * in a cell, removes cell elements which belong to same column.
     * If 2 or more cell elements are selected, removes cell elements which
     * belong to any of all selected columns.  In this case,
     * aNumberOfColumnsToDelete is ignored.
     * If there is no selection ranges, throws exception.
     * If selection is not in a cell element, just does nothing without
     * throwing exception.
     * WARNING: This does not remove <col> nor <colgroup> elements.
     *
     * @param aNumberOfColumnsToDelete    Number of columns to remove.  This is
     * ignored if 2 ore more cells are
     * selected.
     */
    deleteTableColumn(aNumberOfColumnsToDelete: long): void;
    /**
     * deleteTableRow() removes <tr> elements.
     * If only one cell element is selected or first selection range is
     * in a cell, removes <tr> elements starting from a <tr> element
     * containing the selected cell or first selection range.
     * If 2 or more cell elements are selected, all <tr> elements
     * which contains selected cell(s).  In this case, aNumberOfRowsToDelete
     * is ignored.
     * If there is no selection ranges, throws exception.
     * If selection is not in a cell element, just does nothing without
     * throwing exception.
     *
     * @param aNumberOfRowsToDelete   Number of rows to remove.  This is ignored
     * if 2 or more cells are selected.
     */
    deleteTableRow(aNumberOfRowsToDelete: long): void;
    /**
     * Table Selection methods
     * Selecting a row or column actually
     * selects all cells (not TR in the case of rows)
     */
    selectTableCell(): void;
    /**
     *
     */
    selectTableRow(): void;
    /**
     *
     */
    selectTableColumn(): void;
    /**
     *
     */
    selectTable(): void;
    /**
     *
     */
    selectAllTableCells(): void;
    /**
     * Create a new TD or TH element, the opposite type of the supplied aSourceCell
     * 1. Copy all attributes from aSourceCell to the new cell
     * 2. Move all contents of aSourceCell to the new cell
     * 3. Replace aSourceCell in the table with the new cell
     *
     * @param aSourceCell   The cell to be replaced
     * @return              The new cell that replaces aSourceCell
     */
    switchTableCellHeaderType(aSourceCell: Element): Element;
    /**
     * Merges contents of all selected cells
     * for selected cells that are adjacent,
     * this will result in a larger cell with appropriate
     * rowspan and colspan, and original cells are deleted
     * The resulting cell is in the location of the
     * cell at the upper-left corner of the adjacent
     * block of selected cells
     *
     * @param aMergeNonContiguousContents:
     * If true:
     * Non-contiguous cells are not deleted,
     * but their contents are still moved
     * to the upper-left cell
     * If false: contiguous cells are ignored
     *
     * If there are no selected cells,
     * and selection or caret is in a cell,
     * that cell and the one to the right
     * are merged
     */
    joinTableCells(aMergeNonContiguousContents: boolean): void;
    /**
     * Split a cell that has rowspan and/or colspan > 0
     * into cells such that all new cells have
     * rowspan = 1 and colspan = 1
     * All of the contents are not touched --
     * they will appear to be in the upper-left cell
     */
    splitTableCell(): void;
    /**
     * Scan through all rows and add cells as needed so
     * all locations in the cellmap are occupied.
     * Used after inserting single cells or pasting
     * a collection of cells that extend past the
     * previous size of the table
     * If aTable is null, it uses table enclosing the selection anchor
     * This doesn't doesn't change the selection,
     * thus it can be used to fixup all tables
     * in a page independent of the selection
     */
    normalizeTable(aTable: Element): void;
    /**
     * getCellIndexes() computes row index and column index of a table cell.
     * Note that this depends on layout information.  Therefore, all pending
     * layout should've been flushed before calling this.
     *
     * @param aCellElement        If not null, this computes indexes of the cell.
     * If null, this computes indexes of a cell which
     * contains anchor of Selection.
     * @param aRowIndex           Must be an object, whose .value will be set
     * to row index of the cell.  0 is the first row.
     * If rowspan is set to 2 or more, the start
     * row index is used.
     * @param aColumnIndex        Must be an object, whose .value will be set
     * to column index of the cell.  0 is the first
     * column.  If colspan is set to 2 or more, the
     * start column index is used.
     */
    getCellIndexes(aCellElement: Element, aRowIndex: long, aColumnIndex: long): void;
    /**
     * getTableSize() computes number of rows and columns.
     * Note that this depends on layout information.  Therefore, all pending
     * layout should've been flushed before calling this.
     *
     * @param aTableOrElementInTable  If a <table> element, this computes number
     * of rows and columns of it.
     * If another element and in a <table>, this
     * computes number of rows and columns of
     * the nearest ancestor <table> element.
     * If element is not in <table> element,
     * throwing an exception.
     * If null, this looks for nearest ancestor
     * <table> element containing anchor of
     * Selection.  If found, computes the number
     * of rows and columns of the <table>.
     * Otherwise, throwing an exception.
     * @param aRowCount               Number of *actual* row count.
     * I.e., rowspan does NOT increase this value.
     * @param aColumnCount            Number of column count.
     * I.e., if colspan is specified with bigger
     * number than actual, the value is used
     * as this.
     */
    getTableSize(aTableOrElementInTable: Element, aRowCount: long, aColCount: long): void;
    /**
     * getCellAt() returns a <td> or <th> element in a <table> if there is a
     * cell at the indexes.
     *
     * @param aTableElement       If not null, must be a <table> element.
     * If null, looks for the nearest ancestor <table>
     * to look for a cell.
     * @param aRowIndex           Row index of the cell.
     * @param aColumnIndex        Column index of the cell.
     * @return                    Returns a <td> or <th> element if there is.
     * Otherwise, returns null without throwing
     * exception.
     * If aTableElement is not null and not a <table>
     * element, throwing an exception.
     * If aTableElement is null and anchor of Selection
     * is not in any <table> element, throwing an
     * exception.
     */
    getCellAt(aTableElement: Element, aRowIndex: long, aColumnIndex: long): Element;
    /**
     * Get cell element and its various information from <table> element and
     * indexes in it.  If aTableElement is null, this looks for an ancestor
     * <table> element of anchor of Selection.  If there is no <table> element
     * at that point, this throws exception.  Note that this requires layout
     * information.  So, you need to flush the layout after changing the DOM
     * tree.
     * If there is no cell element at the indexes, this throws exception.
     * XXX Perhaps, this is wrong behavior, this should return null without
     * exception since the caller cannot distinguish whether the exception
     * is caused by "not found" or other unexpected situation.
     *
     * @param aTableElement       A <table> element.  If this is null, this
     * uses ancestor of anchor of Selection.
     * @param aRowIndex           Row index in aTableElement.  Starting from 0.
     * @param aColumnIndex        Column index in aTableElement.  Starting from
     * 0.
     * @param aCellElement        [OUT] The cell element at the indexes.
     * @param aStartRowIndex      [OUT] First row index which contains
     * aCellElement.  E.g., if the cell's rowspan is
     * not 1, this returns its first row index.
     * I.e., this can be smaller than aRowIndex.
     * @param aStartColumnIndex   [OUT] First column index which contains the
     * aCellElement.  E.g., if the cell's colspan is
     * larger than 1, this returns its first column
     * index.  I.e., this can be smaller than
     * aColumIndex.
     * @param aRowSpan            [OUT] rowspan attribute value in most cases.
     * If the specified value is invalid, this
     * returns 1.  Only when the document is written
     * in HTML5 or later, this can be 0.
     * @param aColSpan            [OUT] colspan attribute value in most cases.
     * If the specified value is invalid, this
     * returns 1.
     * @param aEffectiveRowSpan   [OUT] Effective rowspan value at aRowIndex.
     * This is same as:
     * aRowSpan - (aRowIndex - aStartRowIndex)
     * @param aEffectiveColSpan   [OUT] Effective colspan value at aColumnIndex.
     * This is same as:
     * aColSpan - (aColumnIndex - aStartColumnIndex)
     * @param aIsSelected         [OUT] Returns true if aCellElement or its
     * <tr> or <table> element is selected.
     * Otherwise, e.g., aCellElement just contains
     * selection range, returns false.
     */
    getCellDataAt(aTableElement: Element, aRowIndex: long, aColumnIndex: long, aCellElement: Element, aStartRowIndex: long, aStartColumnIndex: long, aRowSpan: long, aColSpan: long, aEffectiveRowSpan: long, aEffectiveColSpan: long, aIsSelected: boolean): void;
    /**
     * getFirstRow() returns first <tr> element in a <table> element.
     *
     * @param aTableOrElementInTable  If a <table> element, returns its first
     * <tr> element.
     * If another element, looks for nearest
     * ancestor <table> element first.  Then,
     * return its first <tr> element.
     * @return                        <tr> element in the <table> element.
     * If <table> element is not found, this
     * throws an exception.
     * If there is a <table> element but it
     * does not have <tr> elements, returns
     * null without throwing exception.
     * Note that this may return anonymous <tr>
     * element if <table> has one or more cells
     * but <tr> element is not in the source.
     */
    getFirstRow(aTableElement: Element): Element;
    /**
     * Preferred direction to search for neighboring cell
     * when trying to locate a cell to place caret in after
     * a table editing action.
     * Used for aDirection param in SetSelectionAfterTableEdit
     *
     * getSelectedOrParentTableElement() returns a <td>, <th>, <tr> or <table>.
     * If first selection range selects a <td> or <th>, returns it.  aTagName
     * is set to "td" even if the result is a <th> and aCount is set to
     * Selection.rangeCount.
     * If first selection range does not select <td> nor <th>, but selection
     * anchor refers <table>, returns it.  aTagName is set to "table" and
     * aCount is set to 1.
     * If first selection range does not select <td> nor <th>, but selection
     * anchor refers <tr>, returns it.  aTagName is set to "tr" and aCount is
     * set to 1.
     * If first selection range does not select <td> nor <th>, but selection
     * anchor refers <td> (not include <th>!), returns it.  aTagName is set to
     * "td" and aCount is set to 0.
     * Otherwise, if container of selection anchor is in a <td> or <th>,
     * returns it.  aTagName is set to "td" but aCount is set to 0.
     * Otherwise, returns null, aTagName is set to empty string and aCount is
     * set to 0.  I.e., does not throw exception even if a cell is not found.
     * NOTE: Calling this resets internal counter of getFirstSelectedCell()
     * and getNextSelectedCell().  I.e., getNextSelectedCell() will
     * return second selected cell element.
     */
    getSelectedOrParentTableElement(aTagName: AString, aCount: long): Element;
    /**
     * Generally used after GetSelectedOrParentTableElement
     * to test if selected cells are complete rows or columns
     *
     * @param aElement           Any table or cell element or any element
     * inside a table
     * Used to get enclosing table.
     * If null, selection's anchorNode is used
     *
     * @return
     * 0                        aCellElement was not a cell
     * (returned result = NS_ERROR_FAILURE)
     * TableSelectionMode::Cell     There are 1 or more cells selected but
     * complete rows or columns are not selected
     * TableSelectionMode::Row      All cells are in 1 or more rows
     * and in each row, all cells selected
     * Note: This is the value if all rows
     * (thus all cells) are selected
     * TableSelectionMode::Column   All cells are in 1 or more columns
     * and in each column, all cells are selected
     */
    getSelectedCellsType(aElement: Element): uint32_t;
    /**
     * getFirstSelectedCellInTable() returns a cell element, its row index and
     * its column index if first range of Selection selects a cell.  Note that
     * that "selects a cell" means that the range container is a <tr> element
     * and endOffset is startOffset + 1.  So, even if first range of Selection
     * is in a cell element, this treats the range does not select a cell.
     * NOTE: Calling this resets internal counter of getFirstSelectedCell()
     * and getNextSelectedCell().  I.e., getNextSelectedCell() will
     * return second selected cell element.
     *
     * @param aRowIndex    [OUT} Returns row index of the found cell.  If not
     * found, returns 0.
     * @param aColumnIndex [OUT] Returns column index of the found cell.  If
     * not found, returns 0.
     * @return             The cell element which is selected by the first
     * range of Selection.  Even if this is not found,
     * this returns null, not throwing exception.
     */
    getFirstSelectedCellInTable(aRowIndex: long, aColIndex: long): Element;
}

/**
 *
 */
declare interface nsITaggingServiceType extends nsISupportsType {
    /**
     * Tags a URL with the given set of tags. Current tags set for the URL
     * persist. Tags in aTags which are already set for the given URL are
     * ignored.
     *
     * @param aURI
     * the URL to tag.
     * @param aTags
     * Array of tags to set for the given URL.  Each element within the
     * array can be either a tag name (non-empty string) or a concrete
     * itemId of a tag container.
     * @param [optional] aSource
     * A change source constant from nsINavBookmarksService::SOURCE_*.
     * Defaults to SOURCE_DEFAULT if omitted.
     */
    tagURI(aURI: nsIURIType, aTags: nsIVariantType, aSource: unsigned_short): void;
    /**
     * Removes tags from a URL. Tags from aTags which are not set for the
     * given URL are ignored.
     *
     * @param aURI
     * the URL to un-tag.
     * @param aTags
     * Array of tags to unset.  Pass null to remove all tags from the given
     * url.  Each element within the array can be either a tag name
     * (non-empty string) or a concrete itemId of a tag container.
     * @param [optional] aSource
     * A change source constant from nsINavBookmarksService::SOURCE_*.
     * Defaults to SOURCE_DEFAULT if omitted.
     */
    untagURI(aURI: nsIURIType, aTags: nsIVariantType, aSource: unsigned_short): void;
}

/**
 * Starting in Windows 7, applications can display an overlay on the icon in
 * the taskbar. This class wraps around the native functionality to do this.
 */
declare interface nsITaskbarOverlayIconControllerType extends nsISupportsType {
    /**
     * Sets the overlay icon and its corresponding alt text.
     *
     * @param statusIcon The handle to the overlay icon. The icon will be scaled
     * to the small icon size (16x16 at 96 dpi). Can be null, in
     * which case if the taskbar button represents a single window
     * the icon is removed.
     * @param statusDescription The alt text version of the information
     * conveyed by the overlay, for accessibility
     * purposes.
     *
     * @note The behavior for window groups is managed by Windows.
     * - If an overlay icon is set for any window in a window group and another
     * overlay icon is already applied to the corresponding taskbar button, that
     * existing overlay is replaced.
     * - If null is passed in to replace the overlay currently being displayed,
     * and if a previous overlay set for a different window in the group is
     * still available, then that previous overlay is displayed.
     */
    setOverlayIcon(statusIcon: imgIContainer, statusDescription: AString): void;
}

/**
 * nsITaskbarPreview
 *
 * Common interface for both window and tab taskbar previews. This interface
 * cannot be instantiated directly.
 */
declare interface nsITaskbarPreviewType extends nsISupportsType {
    /**
     * The controller for this preview. A controller is required to provide
     * the behavior and appearance of the taskbar previews. It is responsible for
     * determining the size and contents of the preview, which buttons are
     * displayed and how the application responds to user actions on the preview.
     *
     * Neither preview makes full use of the controller. See the documentation
     * for nsITaskbarWindowPreview and nsITaskbarTabPreview for details on which
     * controller methods are used.
     *
     * The controller is not allowed to be null.
     *
     * @see nsITaskbarPreviewController
     */
    controller: nsITaskbarPreviewController;
    /**
     * The tooltip displayed above the preview when the user hovers over it
     *
     * Default: an empty string
     */
    tooltip: AString;
    /**
     * Whether or not the preview is visible.
     *
     * Changing this option is expensive for tab previews since toggling this
     * option will destroy/create the proxy window and its registration with the
     * taskbar. If any step of that fails, an exception will be thrown.
     *
     * For window previews, this operation is very cheap.
     *
     * Default: false
     */
    visible: boolean;
    /**
     * Gets/sets whether or not the preview is marked active (selected) in the
     * taskbar.
     */
    active: boolean;
    /**
     * Invalidates the taskbar's cached image of this preview, forcing a redraw
     * if necessary
     */
    invalidate(): void;
}

/**
 * nsITaskbarPreviewButton
 *
 * Provides access to a window preview's toolbar button's properties.
 */
declare interface nsITaskbarPreviewButtonType extends nsISupportsType {
    /**
     * The button's tooltip.
     *
     * Default: an empty string
     */
    tooltip: AString;
    /**
     * True if the array of previews should be dismissed when this button is clicked.
     *
     * Default: false
     */
    dismissOnClick: boolean;
    /**
     * True if the taskbar should draw a border around this button's image.
     *
     * Default: true
     */
    hasBorder: boolean;
    /**
     * True if the button is disabled. This is not the same as visible.
     *
     * Default: false
     */
    disabled: boolean;
    /**
     * The icon used for the button.
     *
     * Default: null
     */
    image: imgIContainer;
    /**
     * True if the button is shown. Buttons that are invisible do not
     * participate in the layout of buttons underneath the preview.
     *
     * Default: false
     */
    visible: boolean;
}

/**
 * nsITaskbarPreviewCallback
 *
 * Provides an interface for async image result callbacks. See
 * nsITaskbarPreviewController request apis below.
 */
declare interface nsITaskbarPreviewCallbackType extends nsISupportsType {
    /**
     *
     */
    done(aCanvas: nsISupportsType, aDrawBorder: boolean): void;
}

/**
 * nsITaskbarPreviewController
 *
 * nsITaskbarPreviewController provides the behavior for the taskbar previews.
 * Its methods and properties are used by nsITaskbarPreview. Clients are
 * intended to provide their own implementation of this interface. Depending on
 * the interface the controller is attached to, only certain methods/attributes
 * are required to be implemented.
 */
declare interface nsITaskbarPreviewControllerType extends nsISupportsType {
    /**
     * The width of the preview image. This value is allowed to change at any
     * time. See requestPreview for more information.
     */
    readonly width: unsigned_long;
    /**
     * The height of the preview image. This value is allowed to change at any
     * time.  See requestPreview for more information.
     */
    readonly height: unsigned_long;
    /**
     * The aspect ratio of the thumbnail - this does not need to match the ratio
     * of the preview. This value is allowed to change at any time. See
     * requestThumbnail for more information.
     */
    readonly thumbnailAspectRatio: float;
    /**
     * Invoked by nsITaskbarPreview when it needs to render the preview.
     *
     * @param aCallback Async callback the controller should invoke once
     * the thumbnail is rendered. aCallback receives as its only parameter
     * a canvas containing the preview image.
     */
    requestPreview(aCallback: nsITaskbarPreviewCallbackType): void;
    /**
     * Note: it is guaranteed that width/height == thumbnailAspectRatio
     * (modulo rounding errors)
     *
     * Also note that the context is not attached to a canvas element.
     *
     * @param aCallback Async callback the controller should invoke once
     * the thumbnail is rendered. aCallback receives as its only parameter
     * a canvas containing the thumbnail image. Canvas dimensions should
     * match the requested width or height otherwise setting the thumbnail
     * will fail.
     * @param width The width of the requested thumbnail
     * @param height The height of the requested thumbnail
     */
    requestThumbnail(aCallback: nsITaskbarPreviewCallbackType, width: unsigned_long, height: unsigned_long): void;
    /**
     * Invoked when the user presses the close button on the tab preview.
     */
    onClose(): void;
    /**
     * Invoked when the user clicks on the tab preview.
     *
     * @return true if the top level window corresponding to the preview should
     * be activated, false if activation is not accepted.
     */
    onActivate(): boolean;
    /**
     * Invoked when one of the buttons on the window preview's toolbar is pressed.
     *
     * @param button The button that was pressed. This can be compared with the
     * buttons returned by nsITaskbarWindowPreview.getButton.
     */
    onClick(button: nsITaskbarPreviewButtonType): void;
}

/**
 * Starting in Windows 7, applications can display a progress notification in
 * the taskbar. This class wraps around the native functionality to do this.
 */
declare interface nsITaskbarProgressType extends nsISupportsType {
    /**
     * Sets the taskbar progress state and value for this window. The currentValue
     * and maxValue parameters are optional and should be supplied when |state|
     * is one of STATE_NORMAL, STATE_ERROR or STATE_PAUSED.
     *
     * @throws NS_ERROR_INVALID_ARG if state is STATE_NO_PROGRESS or
     * STATE_INDETERMINATE, and either currentValue or maxValue is not 0.
     * @throws NS_ERROR_ILLEGAL_VALUE if currentValue is greater than maxValue.
     */
    setProgressState(state: nsTaskbarProgressState, currentValue: unsigned_long_long, maxValue: unsigned_long_long): void;
}

/**
 * nsITaskbarTabPreview
 *
 * This interface controls tab preview-specific behavior. Creating an
 * nsITaskbarTabPreview for a window will hide that window's
 * nsITaskbarWindowPreview in the taskbar - the native API performs this
 * unconditionally. When there are no more tab previews for a window, the
 * nsITaskbarWindowPreview will automatically become visible again.
 *
 * An application may have as many tab previews per window as memory allows.
 */
declare interface nsITaskbarTabPreviewType extends nsITaskbarPreviewType {
    /**
     * The title displayed above the thumbnail
     *
     * Default: an empty string
     */
    title: AString;
    /**
     * The icon displayed next to the title in the preview
     *
     * Default: null
     */
    icon: imgIContainer;
    /**
     * Rearranges the preview relative to another tab preview from the same window
     * @param aNext The preview to the right of this one. A value of null
     * indicates that the preview is the rightmost one.
     */
    move(aNext: nsITaskbarTabPreviewType): void;
    /**
     * Used internally to grab the handle to the proxy window.
     */
    GetHWND(): nativeWindow;
    /**
     * Used internally to ensure that the taskbar knows about this preview. If a
     * preview is not registered, then the API call to set its sibling (via move)
     * will silently fail.
     *
     * This method is only invoked when it is safe to make taskbar API calls.
     */
    EnsureRegistration(): void;
}

/**
 * nsITaskbarWindowPreview
 *
 * This interface represents the preview for a window in the taskbar. By
 * default, Windows implements much of the behavior for applications by
 * default. The primary purpose of this interface is to allow Gecko
 * applications to take control over parts of the preview. Some parts are not
 * controlled through this interface: the title and icon of the preview match
 * the title and icon of the window always.
 *
 * By default, Windows takes care of drawing the thumbnail and preview for the
 * application however if enableCustomDrawing is set to true, then the
 * controller will start to receive requestPreview and requestThumbnail calls
 * as well as reads on the thumbnailAspectRatio, width and height properties.
 *
 * By default, nsITaskbarWindowPreviews are visible. When made invisible, the
 * window disappears from the list of windows in the taskbar for the
 * application.
 *
 * If the window has any visible nsITaskbarTabPreviews, then the
 * nsITaskbarWindowPreview for the corresponding window is automatically
 * hidden. This is not reflected in the visible property. Note that other parts
 * of the system (such as alt-tab) may still request thumbnails and/or previews
 * through the nsITaskbarWindowPreview's controller.
 *
 * nsITaskbarWindowPreview will never invoke the controller's onClose or
 * onActivate methods since handling them may conflict with other internal
 * Gecko state and there is existing infrastructure in place to allow clients
 * to handle those events
 *
 * Window previews may have a toolbar with up to 7 buttons. See
 * nsITaskbarPreviewButton for more information about button properties.
 */
declare interface nsITaskbarWindowPreviewType extends nsITaskbarPreviewType {
    /**
     * Gets the nth button for the preview image. By default, all of the buttons
     * are invisible.
     *
     * @see nsITaskbarPreviewButton
     *
     * @param index The index into the button array. Must be >= 0 and <
     * MAX_TOOLBAR_BUTTONS.
     */
    getButton(index: unsigned_long): nsITaskbarPreviewButton;
    /**
     * Enables/disables custom drawing of thumbnails and previews
     *
     * Default value: false
     */
    enableCustomDrawing: boolean;
}

/**
 *
 */
declare interface nsIFetchTelemetryDataCallbackType extends nsISupportsType {
    /**
     *
     */
    complete(): void;
}

/**
 *
 */
declare interface nsITelemetryType extends nsISupportsType {
    /**
     * Serializes the histogram labels for categorical hitograms.
     * The returned structure looks like:
     * { "histogram1": [ "histogram1_label1", "histogram1_label2", ...],
     * "histogram2": [ "histogram2_label1", "histogram2_label2", ...]
     * ...
     * }
     *
     * Note that this function should only be used in tests and about:telemetry.
     */
    getCategoricalLabels(): jsval;
    /**
     * Serializes the histograms from the given store to a JSON-style object.
     * The returned structure looks like:
     * { "process": { "name1": histogramData1, "name2": histogramData2 }, ... }
     *
     * Each histogram is represented in a packed format and has the following properties:
     * bucket_count - Number of buckets of this histogram
     * histogram_type - HISTOGRAM_EXPONENTIAL, HISTOGRAM_LINEAR, HISTOGRAM_BOOLEAN,
     * HISTOGRAM_FLAG, HISTOGRAM_COUNT, or HISTOGRAM_CATEGORICAL
     * sum - sum of the bucket contents
     * range - A 2-item array of minimum and maximum bucket size
     * values - Map from bucket to the bucket's count
     *
     * @param aStoreName The name of the store to snapshot.
     * Defaults to "main".
     * Custom stores are available when probes have them defined.
     * See the `record_into_store` attribute on histograms.
     * @see https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/histograms.html#record-into-store
     * @param aClearStore Whether to clear out the histograms in the named store after snapshotting.
     * Defaults to false.
     * @param aFilterTest If true, `TELEMETRY_TEST_` histograms will be filtered out.
     * Filtered histograms are still cleared if `aClearStore` is true.
     * Defaults to false.
     */
    getSnapshotForHistograms(aStoreName: ACString, aClearStore: boolean, aFilterTest: boolean): jsval;
    /**
     * Serializes the keyed histograms from the given store to a JSON-style object.
     * The returned structure looks like:
     * { "process": { "name1": { "key_1": histogramData1, "key_2": histogramData2 }, ...}, ... }
     *
     * @param aStoreName The name of the store to snapshot.
     * Defaults to "main".
     * Custom stores are available when probes have them defined.
     * See the `record_into_store` attribute on histograms.
     * @see https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/histograms.html#record-into-store
     * @param aClearStore Whether to clear out the keyed histograms in the named store after snapshotting.
     * Defaults to false.
     * @param aFilterTest If true, `TELEMETRY_TEST_` histograms will be filtered out.
     * Filtered histograms are still cleared if `aClearStore` is true.
     * Defaults to false.
     */
    getSnapshotForKeyedHistograms(aStoreName: ACString, aClearStore: boolean, aFilterTest: boolean): jsval;
    /**
     * Serializes the scalars from the given store to a JSON-style object.
     * The returned structure looks like:
     * { "process": { "category1.probe": 1,"category1.other_probe": false, ... }, ... }.
     *
     * @param aStoreName The name of the store to snapshot.
     * Defaults to "main".
     * Custom stores are available when probes have them defined.
     * See the `record_into_store` attribute on scalars.
     * @see https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/scalars.html#optional-fields
     * @param aClearStore Whether to clear out the scalars in the named store after snapshotting.
     * Defaults to false.
     * @param aFilterTest If true, `telemetry.test` scalars will be filtered out.
     * Filtered scalars are still cleared if `aClearStore` is true.
     * Defaults to false.
     */
    getSnapshotForScalars(aStoreName: ACString, aClearStore: boolean, aFilterTest: boolean): jsval;
    /**
     * Serializes the keyed scalars from the given store to a JSON-style object.
     * The returned structure looks like:
     * { "process": { "category1.probe": { "key_1": 2, "key_2": 1, ... }, ... }, ... }
     *
     * @param aStoreName The name of the store to snapshot.
     * Defaults to "main".
     * Custom stores are available when probes have them defined.
     * See the `record_into_store` attribute on scalars.
     * @see https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/scalars.html#optional-fields
     * @param aClearStore Whether to clear out the keyed scalars in the named store after snapshotting.
     * Defaults to false.
     * @param aFilterTest If true, `telemetry.test` scalars will be filtered out.
     * Filtered scalars are still cleared if `aClearStore` is true.
     * Defaults to false.
     */
    getSnapshotForKeyedScalars(aStoreName: ACString, aClearStore: boolean, aFilterTest: boolean): jsval;
    /**
     * The amount of time, in milliseconds, that the last session took
     * to shutdown.  Reads as 0 to indicate failure.
     */
    readonly lastShutdownDuration: uint32_t;
    /**
     * The number of failed profile lock attempts that have occurred prior to
     * successfully locking the profile
     */
    readonly failedProfileLockCount: uint32_t;
    /**
     * An object containing information about slow SQL statements.
     *
     * {
     * mainThread: { "sqlString1": [<hit count>, <total time>], "sqlString2": [...], ... },
     * otherThreads: { "sqlString3": [<hit count>, <total time>], "sqlString4": [...], ... }
     * }
     *
     * where:
     * mainThread: Slow statements that executed on the main thread
     * otherThreads: Slow statements that executed on a non-main thread
     * sqlString - String of the offending statement (see note)
     * hit count - The number of times this statement required longer than the threshold time to execute
     * total time - The sum of all execution times above the threshold time for this statement
     *
     * Note that dynamic SQL strings and SQL strings executed against addon DBs could contain private information.
     * This property represents such SQL as aggregate database-level stats and the sqlString contains the database
     * filename instead.
     */
    readonly slowSQL: jsval;
    /**
     * See slowSQL above.
     *
     * An object containing full strings of every slow SQL statement if toolkit.telemetry.debugSlowSql = true
     * The returned SQL strings may contain private information and should not be reported to Telemetry.
     */
    readonly debugSlowSQL: jsval;
    /**
     * An array of untrusted module load events. Each element describes one or
     * more modules that were loaded, contextual information at the time of the
     * event (including stack trace), and flags describing the module's
     * trustworthiness.
     *
     * @param aFlags   Combination (bitwise OR) of the flags specified above.
     * Defaults to 0.
     */
    getUntrustedModuleLoadEvents(aFlags: unsigned_long): Promise;
    /**
     * Whether the untrusted module load events are ready for processing.
     * Calling getUntrustedModuleLoadEvents() before this attribute is true
     * will result in an empty array.
     */
    readonly areUntrustedModuleLoadEventsReady: boolean;
    /**
     * Asynchronously get an array of the modules loaded in the process.
     *
     * The data has the following structure:
     *
     * [
     * {
     * "name": <string>, // Name of the module file (e.g. xul.dll)
     * "version": <string>, // Version of the module
     * "debugName": <string>, // ID of the debug information file
     * "debugID": <string>, // Name of the debug information file
     * "certSubject": <string>, // Name of the organization that signed the binary (Optional, only defined when present)
     * },
     * ...
     * ]
     *
     * @return A promise that resolves to an array of modules or rejects with
     * NS_ERROR_FAILURE on failure.
     * @throws NS_ERROR_NOT_IMPLEMENTED if the Gecko profiler is not enabled.
     */
    getLoadedModules(): Promise;
    /**
     * An object with two fields: memoryMap and stacks.
     * * memoryMap is a list of loaded libraries.
     * * stacks is a list of stacks. Each stack is a list of pairs of the form
     * [moduleIndex, offset]. The moduleIndex is an index into the memoryMap and
     * offset is an offset in the library at memoryMap[moduleIndex].
     * This format is used to make it easier to send the stacks to the
     * symbolication server.
     */
    readonly lateWrites: jsval;
    /**
     * Create and return a histogram registered in TelemetryHistograms.h.
     *
     * @param id - unique identifier from TelemetryHistograms.h
     * The returned object has the following functions:
     * add(value) - Adds a sample of `value` to the histogram.
     * `value` may be a categorical histogram's label as a string,
     * a boolean histogram's value as a boolean,
     * or a number that fits inside a uint32_t.
     * snapshot([optional] {store}) - Returns a snapshot of the histogram with the same data fields
     * as in getSnapshotForHistograms().
     * Defaults to the "main" store.
     * clear([optional] {store}) - Zeros out the histogram's buckets and sum.
     * Defaults to the "main" store.
     * Note: This is intended to be only used in tests.
     */
    getHistogramById(id: ACString): jsval;
    /**
     * Create and return a histogram registered in TelemetryHistograms.h.
     *
     * @param id - unique identifier from TelemetryHistograms.h
     * The returned object has the following functions:
     * add(string key, [optional] value) - Adds a sample of `value` to the histogram for that key.
     * If no histogram for that key exists yet, it is created.
     * `value` may be a categorical histogram's label as a string,
     * a boolean histogram's value as a boolean,
     * or a number that fits inside a uint32_t.
     * snapshot([optional] {store}) - Returns the snapshots of all the registered keys in the form
     * {key1: snapshot1, key2: snapshot2, ...} in the specified store.
     * Defaults to the "main" store.
     * keys([optional] {store}) - Returns an array with the string keys of the currently registered
     * histograms in the given store.
     * Defaults to "main".
     * clear([optional] {store}) - Clears the registered histograms from this.
     * Defaults to the "main" store.
     * Note: This is intended to be only used in tests.
     */
    getKeyedHistogramById(id: ACString): jsval;
    /**
     * A flag indicating if Telemetry can record base data (FHR data). This is true if the
     * FHR data reporting service or self-support are enabled.
     *
     * In the unlikely event that adding a new base probe is needed, please check the data
     * collection wiki at https://wiki.mozilla.org/Firefox/Data_Collection and talk to the
     * Telemetry team.
     */
    canRecordBase: boolean;
    /**
     * A flag indicating if Telemetry is allowed to record extended data. Returns false if
     * the user hasn't opted into "extended Telemetry" on the Release channel, when the
     * user has explicitly opted out of Telemetry on Nightly/Aurora/Beta or if manually
     * set to false during tests.
     *
     * Set this to false in tests to disable gathering of extended telemetry statistics.
     */
    canRecordExtended: boolean;
    /**
     * A flag indicating whether Telemetry is recording release data, which is a
     * smallish subset of our usage data that we're prepared to handle from our
     * largish release population.
     *
     * This is true most of the time.
     *
     * This will always return true in the case of a non-content child process.
     * Only values returned on the parent process are valid.
     *
     * This does not indicate whether Telemetry will send any data. That is
     * governed by user preference and other mechanisms.
     *
     * You may use this to determine if it's okay to record your data.
     */
    readonly canRecordReleaseData: boolean;
    /**
     * A flag indicating whether Telemetry is recording prerelease data, which is
     * a largish amount of usage data that we're prepared to handle from our
     * smallish pre-release population.
     *
     * This is true on pre-release branches of Firefox.
     *
     * This does not indicate whether Telemetry will send any data. That is
     * governed by user preference and other mechanisms.
     *
     * You may use this to determine if it's okay to record your data.
     */
    readonly canRecordPrereleaseData: boolean;
    /**
     * A flag indicating whether Telemetry can submit official results (for base or extended
     * data). This is true on official, non-debug builds with built in support for Mozilla
     * Telemetry reporting.
     *
     * This will always return true in the case of a non-content child process.
     * Only values returned on the parent process are valid.
     */
    readonly isOfficialTelemetry: boolean;
    /**
     * Enable/disable recording for this histogram at runtime.
     * Recording is enabled by default, unless listed at kRecordingInitiallyDisabledIDs[].
     * Name must be a valid Histogram identifier, otherwise an assertion will be triggered.
     *
     * @param id - unique identifier from histograms.json
     * @param enabled - whether or not to enable recording from now on.
     */
    setHistogramRecordingEnabled(id: ACString, enabled: boolean): void;
    /**
     * Read data from the previous run. After the callback is called, the last
     * shutdown time is available in lastShutdownDuration and any late
     * writes in lateWrites.
     */
    asyncFetchTelemetryData(aCallback: nsIFetchTelemetryDataCallbackType): void;
    /**
     * Get statistics of file IO reports, null, if not recorded.
     *
     * The statistics are returned as an object whose propoerties are the names
     * of the files that have been accessed and whose corresponding values are
     * arrays of size three, representing startup, normal, and shutdown stages.
     * Each stage's entry is either null or an array with the layout
     * [total_time, #creates, #reads, #writes, #fsyncs, #stats]
     */
    readonly fileIOReports: jsval;
    /**
     * Return the number of milliseconds since process start using monotonic
     * timestamps (unaffected by system clock changes). On Windows, this includes
     * the period of time the device was suspended. On Linux and macOS, this does
     * not include the period of time the device was suspneded.
     */
    msSinceProcessStart(): double;
    /**
     * Return the number of milliseconds since process start using monotonic
     * timestamps (unaffected by system clock changes), including the periods of
     * time the device was suspended.
     * @throws NS_ERROR_NOT_AVAILABLE if unavailable.
     */
    msSinceProcessStartIncludingSuspend(): double;
    /**
     * Return the number of milliseconds since process start using monotonic
     * timestamps (unaffected by system clock changes), excluding the periods of
     * time the device was suspended.
     * @throws NS_ERROR_NOT_AVAILABLE if unavailable.
     */
    msSinceProcessStartExcludingSuspend(): double;
    /**
     * Time since the system wide epoch. This is not a monotonic timer but
     * can be used across process boundaries.
     */
    msSystemNow(): double;
    /**
     * Adds the value to the given scalar.
     *
     * @param aName The scalar name.
     * @param aValue The numeric value to add to the scalar. Only unsigned integers supported.
     */
    scalarAdd(aName: ACString, aValue: jsval): void;
    /**
     * Sets the scalar to the given value.
     *
     * @param aName The scalar name.
     * @param aValue The value to set the scalar to. If the type of aValue doesn't match the
     * type of the scalar, the function will fail. For scalar string types, the this
     * is truncated to 50 characters.
     */
    scalarSet(aName: ACString, aValue: jsval): void;
    /**
     * Sets the scalar to the maximum of the current and the passed value.
     *
     * @param aName The scalar name.
     * @param aValue The numeric value to set the scalar to. Only unsigned integers supported.
     */
    scalarSetMaximum(aName: ACString, aValue: jsval): void;
    /**
     * Adds the value to the given keyed scalar.
     *
     * @param aName The scalar name.
     * @param aKey The key name.
     * @param aValue The numeric value to add to the scalar. Only unsigned integers supported.
     */
    keyedScalarAdd(aName: ACString, aKey: AString, aValue: jsval): void;
    /**
     * Sets the keyed scalar to the given value.
     *
     * @param aName The scalar name.
     * @param aKey The key name.
     * @param aValue The value to set the scalar to. If the type of aValue doesn't match the
     * type of the scalar, the function will fail.
     */
    keyedScalarSet(aName: ACString, aKey: AString, aValue: jsval): void;
    /**
     * Sets the keyed scalar to the maximum of the current and the passed value.
     *
     * @param aName The scalar name.
     * @param aKey The key name.
     * @param aValue The numeric value to set the scalar to. Only unsigned integers supported.
     */
    keyedScalarSetMaximum(aName: ACString, aKey: AString, aValue: jsval): void;
    /**
     * Resets all the stored scalars. This is intended to be only used in tests.
     */
    clearScalars(): void;
    /**
     * Immediately sends any Telemetry batched on this process to the parent
     * process. This is intended only to be used on process shutdown.
     */
    flushBatchedChildTelemetry(): void;
    /**
     * Record an event in Telemetry.
     *
     * @param aCategory The category name.
     * @param aMethod The method name.
     * @param aObject The object name.
     * @param aValue An optional string value to record.
     * @param aExtra An optional object of the form (string -> string).
     * It should only contain registered extra keys.
     *
     * @throws NS_ERROR_INVALID_ARG When trying to record an unknown event.
     */
    recordEvent(aCategory: ACString, aMethod: ACString, aObject: ACString, aValue: jsval, extra: jsval): void;
    /**
     * Enable recording of events in a category.
     * Events default to recording disabled. This allows to toggle recording for all events
     * in the specified category.
     *
     * @param aCategory The category name.
     * @param aEnabled Whether recording is enabled for events in that category.
     */
    setEventRecordingEnabled(aCategory: ACString, aEnabled: boolean): void;
    /**
     * Serializes the recorded events to a JSON-appropriate array and optionally resets them.
     * The returned structure looks like this:
     * [
     * // [timestamp, category, method, object, stringValue, extraValues]
     * [43245, "category1", "method1", "object1", "string value", null],
     * [43258, "category1", "method2", "object1", null, {"key1": "string value"}],
     * ...
     * ]
     *
     * @param aDataset DATASET_ALL_CHANNELS or DATASET_PRERELEASE_CHANNELS.
     * @param [aClear=false] Whether to clear out the flushed events after snapshotting.
     * @param aEventLimit How many events per process to limit the snapshot to contain, all if unspecified.
     * Even if aClear, the leftover event records are not cleared.
     */
    snapshotEvents(aDataset: uint32_t, aClear: boolean?, aEventLimit: uint32_t): jsval;
    /**
     * Register new events to record them from addons. This allows registering multiple
     * events for a category. They will be valid only for the current Firefox session.
     * Note that events shipping in Firefox should be registered in Events.yaml.
     *
     * @param aCategory The unique category the events are registered in.
     * @param aEventData An object that contains registration data for 1-N events of the form:
     * {
     * "categoryName": {
     * "methods": ["test1"],
     * "objects": ["object1"],
     * "record_on_release": false,
     * "extra_keys": ["key1", "key2"], // optional
     * "expired": false // optional, defaults to false.
     * },
     * ...
     * }
     * @param aEventData.<name>.methods List of methods for this event entry.
     * @param aEventData.<name>.objects List of objects for this event entry.
     * @param aEventData.<name>.extra_keys Optional, list of allowed extra keys for this event entry.
     * @param aEventData.<name>.record_on_release Optional, whether to record this data on release.
     * Defaults to false.
     * @param aEventData.<name>.expired Optional, whether this event entry is expired. This allows
     * recording it without error, but it will be discarded. Defaults to false.
     */
    registerEvents(aCategory: ACString, aEventData: jsval): void;
    /**
     * Parent process only. Register dynamic builtin events. The parameters
     * have the same meaning as the usual |registerEvents| function.
     *
     * This function is only meant to be used to support the "artifact build"/
     * "build faster" developers by allowing to add new events without rebuilding
     * the C++ components including the headers files.
     */
    registerBuiltinEvents(aCategory: ACString, aEventData: jsval): void;
    /**
     * Parent process only. Register new scalars to record them from addons. This
     * allows registering multiple scalars for a category. They will be valid only for
     * the current Firefox session.
     * Note that scalars shipping in Firefox should be registered in Scalars.yaml.
     *
     * @param aCategoryName The unique category the scalars are registered in.
     * @param aScalarData An object that contains registration data for multiple scalars in the form:
     * {
     * "sample_scalar": {
     * "kind": Ci.nsITelemetry.SCALAR_TYPE_COUNT,
     * "keyed": true, //optional, defaults to false
     * "record_on_release: true, // optional, defaults to false
     * "expired": false // optional, defaults to false.
     * },
     * ...
     * }
     * @param aScalarData.<name>.kind One of the scalar types defined in this file (SCALAR_TYPE_*)
     * @param aScalarData.<name>.keyed Optional, whether this is a keyed scalar or not. Defaults to false.
     * @param aScalarData.<name>.record_on_release Optional, whether to record this data on release.
     * Defaults to false.
     * @param aScalarData.<name>.expired Optional, whether this scalar entry is expired. This allows
     * recording it without error, but it will be discarded. Defaults to false.
     */
    registerScalars(aCategoryName: ACString, aScalarData: jsval): void;
    /**
     * Parent process only. Register dynamic builtin scalars. The parameters
     * have the same meaning as the usual |registerScalars| function.
     *
     * This function is only meant to be used to support the "artifact build"/
     * "build faster" developers by allowing to add new scalars without rebuilding
     * the C++ components including the headers files.
     */
    registerBuiltinScalars(aCategoryName: ACString, aScalarData: jsval): void;
    /**
     * Resets all the stored events. This is intended to be only used in tests.
     * Events recorded but not yet flushed to the parent process storage won't be cleared.
     * Override the pref. `toolkit.telemetry.ipcBatchTimeout` to reduce the time to flush events.
     */
    clearEvents(): void;
    /**
     * Get a list of all registered stores.
     *
     * The list is deduplicated, but unordered.
     */
    getAllStores(): jsval;
    /**
     * Does early, cheap initialization for native telemetry data providers.
     * Currently, this includes only MemoryTelemetry.
     */
    earlyInit(): void;
    /**
     * Does late, expensive initialization for native telemetry data providers.
     * Currently, this includes only MemoryTelemetry.
     *
     * This should only be called after startup has completed and the event loop
     * is idle.
     */
    delayedInit(): void;
    /**
     * Shuts down native telemetry providers. Currently, this includes only
     * MemoryTelemetry.
     */
    shutdown(): void;
    /**
     * Gathers telemetry data for memory usage and records it to the data store.
     * Returns a promise which resolves when asynchronous data collection has
     * completed and all data has been recorded.
     */
    gatherMemory(): Promise;
}

/**
 *
 */
declare interface nsITellableStreamType extends nsISupportsType {
    /**
     * tell
     *
     * This method reports the current offset, in bytes, from the start of the
     * stream.
     *
     * @throws NS_BASE_STREAM_CLOSED if called on a closed stream.
     */
    tell(): long_long;
}

/**
 * An nsITextInputProcessor instance is associated with a top level widget which
 * handles native IME.  It's associated by calling beginInputTransaction() or
 * beginInputTransactionForTests().  While an instance has composition, nobody
 * can steal the rights to make composition on the top level widget.  In other
 * words, if another instance is composing on a top level widget, either
 * beginInputTransaction() or beginInputTransactionForTests() returns false
 * (i.e., not throws an exception).
 *
 * NOTE: See nsITextInputProcessorCallback.idl for examples of |callback| in
 * following examples,
 *
 * Example #1 JS-IME can start composition like this:
 *
 * var TIP = Components.classes["@mozilla.org/text-input-processor;1"].
 * createInstance(Components.interfaces.nsITextInputProcessor);
 * if (!TIP.beginInputTransaction(window, callback)) {
 * return; // You failed to get the rights to make composition
 * }
 * // Create a keyboard event if the following compositionc change is caused
 * // by a key event.
 * var keyEvent =
 * new KeyboardEvent("", { key: "foo", code: "bar", keyCode: buzz });
 * // Set new composition string first
 * TIP.setPendingCompositionString("some-words-are-inputted");
 * // Set clause information.
 * TIP.appendClauseToPendingComposition(23, TIP.ATTR_RAW_CLAUSE);
 * // Set caret position, this is optional.
 * TIP.setCaretInPendingComposition(23);
 * // Flush the pending composition
 * if (!TIP.flushPendingComposition(keyEvent)) {
 * // If it returns false, it fails to start composition.
 * return;
 * }
 *
 * Example #2 JS-IME can separate composition string to two or more clauses:
 *
 * // Create a keyboard event if the following compositionc change is caused
 * // by a key event.
 * var keyEvent =
 * new KeyboardEvent("", { key: "foo", code: "bar", keyCode: buzz });
 * // First, set composition string again
 * TIP.setPendingCompositionString("some-words-are-inputted");
 * // Then, if "are" is selected to convert, there are 3 clauses:
 * TIP.appendClauseToPendingComposition(11, TIP.ATTR_CONVERTED_CLAUSE);
 * TIP.appendClauseToPendingComposition(3,  TIP.ATTR_SELECTED_CLAUSE);
 * TIP.appendClauseToPendingComposition(9,  TIP.ATTR_CONVERTED_CLAUSE);
 * // Show caret at the beginning of the selected clause
 * TIP.setCaretInPendingComposition(11);
 * // Flush the pending composition.  Note that if there is a composition,
 * // flushPendingComposition() won't return false.
 * TIP.flushPendingComposition(keyEvent);
 *
 * Example #3 JS-IME can commit composition with specific string with this:
 *
 * // Create a keyboard event if the following compositionc change is caused
 * // by a key event.
 * var keyEvent1 =
 * new KeyboardEvent("", { key: "foo", code: "bar", keyCode: buzz });
 * // First, there is a composition.
 * TIP.setPendingCompositionString("some-words-directly-inputted");
 * TIP.appendClauseToPendingComposition(28, TIP.ATTR_RAW_CLAUSE);
 * TIP.flushPendingComposition(keyEvent1);
 * // Create a keyboard event if the following commit composition is caused
 * // by a key event.
 * var keyEvent2 =
 * new KeyboardEvent("", { key: "foo", code: "bar", keyCode: buzz });
 * // This is useful when user selects a commit string from candidate list UI
 * // which is provided by JS-IME.
 * TIP.commitCompositionWith("selected-words-from-candidate-list", keyEvent2);
 *
 * Example #4 JS-IME can commit composition with the last composition string
 * without specifying commit string:
 *
 * // Create a keyboard event if the following compositionc change is caused
 * // by a key event.
 * var keyEvent1 =
 * new KeyboardEvent("", { key: "foo", code: "bar", keyCode: buzz });
 * // First, there is a composition.
 * TIP.setPendingCompositionString("some-words-will-be-commited");
 * TIP.appendClauseToPendingComposition(27, TIP.ATTR_RAW_CLAUSE);
 * TIP.flushPendingComposition(keyEvent1);
 * // Create a keyboard event if the following commit is caused by a key
 * // event.
 * var keyEvent2 =
 * new KeyboardEvent("", { key: "Enter", code: "Enter",
 * keyCode: KeyboardEvent.DOM_VK_RETURN });
 * // This is useful when user just type Enter key.
 * TIP.commitComposition(keyEvent2);
 *
 * Example #5 JS-IME can cancel composition with this:
 *
 * // Create a keyboard event if the following composition change is caused
 * // by a key event.
 * var keyEvent1 =
 * new KeyboardEvent("", { key: "foo", code: "bar", keyCode: buzz });
 * // First, there is a composition.
 * TIP.setPendingCompositionString("some-words-will-be-canceled");
 * TIP.appendClauseToPendingComposition(27, TIP.ATTR_RAW_CLAUSE);
 * TIP.flushPendingComposition(keyEvent1);
 * // Create a keyboard event if the following canceling composition is
 * // caused by a key event.
 * var keyEvent2 =
 * new KeyboardEvent("", { key: "Escape", code: "Escape",
 * keyCode: KeyboardEvent.DOM_VK_ESCAPE });
 * // This is useful when user doesn't want to commit the composition.
 * // FYI: This is same as TIP.commitCompositionWith("") for now.
 * TIP.cancelComposition(keyEvent2);
 *
 * Example #6 JS-IME can insert text only with commitCompositionWith():
 *
 * // Create a keyboard event if the following inserting text is caused by a
 * // key event.
 * var keyEvent1 =
 * new KeyboardEvent("", { key: "foo", code: "bar", keyCode: buzz });
 * if (!TIP.beginInputTransaction(window, callback)) {
 * return; // You failed to get the rights to make composition
 * }
 * TIP.commitCompositionWith("Some words", keyEvent1);
 *
 * Example #7 JS-IME can start composition explicitly:
 *
 * if (!TIP.beginInputTransaction(window, callback)) {
 * return; // You failed to get the rights to make composition
 * }
 * // Create a keyboard event if the following starting composition is caused
 * // by a key event.
 * var keyEvent1 =
 * new KeyboardEvent("", { key: "foo", code: "bar", keyCode: buzz });
 * // If JS-IME don't want to show composing string in the focused editor,
 * // JS-IME can dispatch only compositionstart event with this.
 * if (!TIP.startComposition(keyEvent1)) {
 * // Failed to start composition.
 * return;
 * }
 * // And when user selects a result from UI of JS-IME, commit with it.
 * // Then, the key event should be null.
 * TIP.commitCompositionWith("selected-words");
 *
 * Example #8 JS-IME or JS-Keyboard should dispatch key events even during
 * composition (non-printable key case):
 *
 * if (!TIP.beginInputTransaction(window, callback)) {
 * return; // You failed to get the rights to dispatch key events
 * }
 *
 * // You don't need to specify .keyCode value if it's non-printable key
 * // because it can be computed from .key value.
 * // If you specify non-zero value to .keyCode, it'll be used.
 * var keyEvent = new KeyboardEvent("", { code: "Enter", key: "Enter" });
 * if (TIP.keydown(keyEvent)) {
 * // Handle its default action
 * }
 *
 * // Even if keydown event was consumed, keyup event should be dispatched.
 * if (TIP.keyup(keyEvent)) {
 * // Handle its default action
 * }
 *
 * Example #9 JS-IME or JS-Keyboard should dispatch key events even during
 * composition (printable key case):
 *
 * if (!TIP.beginInputTransaction(window, callback)) {
 * return; // You failed to get the rights to dispatch key events
 * }
 *
 * // You need to specify .keyCode value if it's printable key.
 * // The rules of .keyCode value is documented in MDN:
 * //   https://developer.mozilla.org/docs/Web/API/KeyboardEvent.keyCode
 * //
 * //   #1 If the key location is DOM_KEY_LOCATION_NUMPAD and NumLock is
 * //      active, you should specify DOM_VK_NUMPAD[0-9], DOM_VK_MULTIPLY,
 * //      DOM_VK_ADD, DOM_VK_SEPARATOR, DOM_VK_SUBTRACT, DOM_VK_DECIMAL or
 * //      DOM_VK_DIVIDE.
 * //   #2 If the key is Spacebar, use DOM_VK_SPACE.
 * //
 * //   Following rules are printable keys in DOM_KEY_LOCATION_STANDARD.
 * //   .keyCode value for a key shouldn't be changed by modifier states:
 * //     #1 If the key can input [0-9] with any modifier state (except
 * //        NumLock state), the value should be DOM_VK_[0-9].
 * //     #2 Otherwise, and if the key inputs an ASCII alphabet with no
 * //        active modifiers, use DOM_VK_[A-Z].
 * //     #3 Otherwise, and if the key inputs an ASCII alphabet with no
 * //        active modifiers except Shift key state, use DOM_VK_[A-Z] for
 * //        the shifted character.  E.g., if a key causes non-alphabet
 * //        character such as "@" or a Unicode character without Shift key
 * //        but "a" is inputted when Shift key is pressed, the proper
 * //        keyCode is DOM_VK_A.
 * //     #4 Otherwise, and if the key inputs another ASCII character with
 * //        no modifier states, use a proper value for the character.  E.g.,
 * //        if the key inputs "*" without Shift key state, it should be
 * //        DOM_VK_ASTERISK.
 * //     #5 Otherwise, and if the key inputs another ASCII character with
 * //        Shift key state, use a proper value for the character.  E.g.,
 * //        if a key causes a Unicode character without Shift key but "&"
 * //        is inputted when Shift key is pressed, the proper keyCode is
 * //        DOM_VK_AMPERSAND.
 * //     See above document for the other cases.
 * //
 * // NOTE: If the software keyboard is 10-key like simple phone,
 * //       We don't have common rules to decide its .keyCode value.
 * //       Above rules should be used when the JS-Keyboard emulates PC
 * //       keyboard.
 * // .key value should be inputting character by the key with current
 * // modifier state.
 * // .code value should be empty string if the JS-Keyboard isn't emulating
 * // physical keyboard.  Otherwise, use same value with physical keyboard's
 * // same key.
 * var keyEvent = new KeyboardEvent("", { code: "KeyA", key: "a",
 * keyCode: KeyboardEvent.DOM_VK_A });
 * if (TIP.keydown(keyEvent)) {
 * // Handle its default action
 * }
 *
 * // Even if keydown event was consumed, keyup event should be dispatched.
 * if (TIP.keyup(keyEvent)) {
 * // Handle its default action
 * }
 *
 * Example #10 JS-Keyboard doesn't need to initialize modifier states at
 * calling either keydown() or keyup().
 *
 * // Neither beginInputTransaction() nor beginInputTransactionForTests()
 * // resets modifier state.
 * if (!TIP.beginInputTransaction(window, callback)) {
 * return; // You failed to get the rights to dispatch key events
 * }
 *
 * var leftShift = new KeyboardEvent("", { code: "ShiftLeft", key: "Shift" });
 *
 * // This causes following key events will be shifted automatically.
 * TIP.keydown(leftShift);
 *
 * var rightShift =
 * new KeyboardEvent("", { code: "ShiftRight", key: "Shift" });
 *
 * TIP.keydown(rightShift);
 *
 * // keyup of one of shift key doesn't cause inactivating "Shift" state.
 * TIP.keyup(rightShift);
 *
 * // This causes inactivating "Shift" state completely.
 * TIP.keyup(leftShift);
 */
declare interface nsITextInputProcessorType extends nsISupportsType {
    /**
     * Returns true if this instance was dispatched compositionstart but hasn't
     * dispatched compositionend yet.
     */
    readonly hasComposition: boolean;
    /**
     * When you create an instance, you must call beginInputTransaction() first
     * except when you created the instance for automated tests.
     *
     * @param aWindow         A DOM window.  The instance will look for a top
     * level widget from this.
     * @param aCallback       Callback interface which handles requests to
     * IME and notifications to IME.  This must not be
     * null.
     * @return                If somebody uses internal text input service for a
     * composition, this returns false.  Otherwise, returns
     * true.  I.e., only your TIP can create composition
     * when this returns true.  If this returns false,
     * your TIP should wait next chance.
     */
    beginInputTransaction(aWindow: mozIDOMWindow, aCallback: nsITextInputProcessorCallbackType): boolean;
    /**
     * When you create an instance for automated test, you must call
     * beginInputTransaction(), first.  See beginInputTransaction() for more
     * detail of this.
     * Note that aCallback can be null.  If it's null, nsITextInputProcessor
     * implementation will handle them automatically.
     */
    beginInputTransactionForTests(aWindow: mozIDOMWindow, aCallback: nsITextInputProcessorCallbackType): boolean;
    /**
     * startComposition() dispatches compositionstart event explicitly.
     * IME does NOT need to call this typically since compositionstart event
     * is automatically dispatched by sendPendingComposition() if
     * compositionstart event hasn't been dispatched yet.  If this is called
     * when compositionstart has already been dispatched, this throws an
     * exception.
     *
     * @param aKeyboardEvent  Key event which causes starting composition.
     * If its type value is "keydown", this method
     * dispatches only keydown event first.  Otherwise,
     * dispatches keydown first and keyup at last.
     * key value and keyCode values of keydown event
     * are set to "Process" and DOM_VK_PROCESSKEY
     * automatically.  You can prevent this behavior
     * with KEY_DONT_MARK_KEYDOWN_AS_PROCESSED.
     * @param aKeyFlags       See KEY_* constants.
     * @return                Returns true if composition starts normally.
     * Otherwise, returns false because it might be
     * canceled by the web application.
     */
    startComposition(aKeyboardEvent: Event, aKeyFlags: unsigned_long): boolean;
    /**
     * Set new composition string.  Pending composition will be flushed by
     * a call of flushPendingComposition().  However, if the new composition
     * string isn't empty, you need to call appendClauseToPendingComposition() to
     * fill all characters of aString with one or more clauses before flushing.
     * Note that if you need to commit or cancel composition, use
     * commitComposition(), commitCompositionWith() or cancelComposition().
     */
    setPendingCompositionString(aString: AString): void;
    /**
     * Append a clause to the pending composition.
     *
     * If you need to fill the pending composition string with a clause, you
     * should call this once.  For example:
     * appendClauseToPendingComposition(compositionString.length,
     * ATTR_RAW_CLAUSE);
     * is enough.  If you need to separate the pending composition string to
     * multiple clauses, you need to call this multiple times. For example,
     * if your pending composition string has three clauses and the second clause
     * is being converted:
     * appendClauseToPendingComposition(firstClauseLength,
     * ATTR_CONVERTED_CLAUSE);
     * appendClauseToPendingComposition(secondClauseLength,
     * ATTR_SELECTED_CLAUSE);
     * appendClauseToPendingComposition(thirdClauseLength,
     * ATTR_CONVERTED_CLAUSE);
     * Note that if sum of aLength mismatches length of the pending composition
     * string, flushPendingComposition() will throw an exception.  I.e.,
     * |firstClauseLength + secondClauseLength + thirdClauseLength| must be
     * same as the length of pending composition string.
     *
     * TODO: Should be able to specify custom clause style.
     *
     * @param aLength         Length of the clause.
     * @param aAttribute      One of ATTR_* constants.
     */
    appendClauseToPendingComposition(aLength: unsigned_long, aAttribute: unsigned_long): void;
    /**
     * Set caret offset in the pending composition string.  If you don't need to
     * show a caret, you don't need to call this.
     *
     * @param aOffset         Caret offset in the pending composition string.
     * This must be between 0 and length of the pending
     * composition string.
     */
    setCaretInPendingComposition(aOffset: unsigned_long): void;
    /**
     * flushPendingComposition() must be called after
     * setPendingCompositionString() and appendClauseToPendingComposition()
     * (setCaretInPendingComposition() is optional) are called.
     *
     * Note that compositionstart will be automatically dispatched if this is
     * called when there is no composition.
     *
     * Note that if sum of lengths of appended clauses are not same as composition
     * string or caret offset is larger than the composition string length, this
     * throws an exception.
     *
     * @param aKeyboardEvent  Key event which causes the composition string.
     * If its type value is "keydown", this method
     * dispatches only keydown event first.  Otherwise,
     * dispatches keydown first and keyup at last.
     * key value and keyCode values of keydown event
     * are set to "Process" and DOM_VK_PROCESSKEY
     * automatically.  You can prevent this behavior
     * with KEY_DONT_MARK_KEYDOWN_AS_PROCESSED.
     * @param aKeyFlags       See KEY_* constants.
     * @return                Returns true if there is a composition already or
     * starting composition automatically.
     * Otherwise, i.e., if it cannot start composition
     * automatically, e.g., canceled by web apps, returns
     * false.
     */
    flushPendingComposition(aKeyboardEvent: Event, aKeyFlags: unsigned_long): boolean;
    /**
     * commitComposition() will commit composition with the last composition
     * string.  If there is no composition, this will throw an exception.
     *
     * @param aKeyboardEvent  Key event which causes the commit composition.
     * If its type value is "keydown", this method
     * dispatches only keydown event first.  Otherwise,
     * dispatches keydown first and keyup at last.
     * key value and keyCode values of keydown event
     * are set to "Process" and DOM_VK_PROCESSKEY
     * automatically.  You can prevent this behavior
     * with KEY_DONT_MARK_KEYDOWN_AS_PROCESSED.
     * @param aKeyFlags       See KEY_* constants.
     */
    commitComposition(aKeyboardEvent: Event, aKeyFlags: unsigned_long): void;
    /**
     * commitCompositionWith() will commit composition with the specific string.
     * If there is no composition, this will start composition and commit it
     * with the specified string.
     *
     * @param aCommitString   The string to be committed.
     * @param aKeyboardEvent  Key event which causes the commit composition.
     * If its type value is "keydown", this method
     * dispatches only keydown event first.  Otherwise,
     * dispatches keydown first and keyup at last.
     * key value and keyCode values of keydown event
     * are set to "Process" and DOM_VK_PROCESSKEY
     * automatically.  You can prevent this behavior
     * with KEY_DONT_MARK_KEYDOWN_AS_PROCESSED.
     * @param aKeyFlags       See KEY_* constants.
     * @return                Returns true if there is a composition already or
     * starting composition automatically.
     * Otherwise, i.e., if it cannot start composition
     * automatically, e.g., canceled by web apps, returns
     * false.
     */
    commitCompositionWith(aCommitString: AString, aKeyboardEvent: Event, aKeyFlags: unsigned_long): boolean;
    /**
     * cancelComposition() will cancel composition.  This is for now the same as
     * calling commitComposition("").  However, in the future, this might work
     * better.  If your IME needs to cancel composition, use this instead of
     * commitComposition().
     *
     * Note that if you tries to cancel composition when there is no composition,
     * this throws an exception.
     *
     * @param aKeyboardEvent  Key event which causes the canceling composition.
     * If its type value is "keydown", this method
     * dispatches only keydown event first.  Otherwise,
     * dispatches keydown first and keyup at last.
     * key value and keyCode values of keydown event
     * are set to "Process" and DOM_VK_PROCESSKEY
     * automatically.  You can prevent this behavior
     * with KEY_DONT_MARK_KEYDOWN_AS_PROCESSED.
     * @param aKeyFlags       See KEY_* constants.
     */
    cancelComposition(aKeyboardEvent: Event, aKeyFlags: unsigned_long): void;
    /**
     * keydown() may dispatch a keydown event and some keypress events if
     * preceding keydown event isn't consumed and they are necessary.
     * Note that even if this is called during composition, key events may not
     * be dispatched.  In this case, this returns false.
     *
     * You should initialize at least .key value and .code value of the event.
     * Additionally, if you try to emulate a printable key, .keyCode value should
     * be specified if there is proper key value.  See the comment of above
     * example how to decide .keyCode value of a printable key.  On the other
     * hand, .keyCode value is automatically computed when you try to emulate
     * non-printable key.  However, if you try to emulate physical keyboard of
     * desktop platform, you need to specify proper value explicitly because
     * the mapping table of this API isn't enough to emulate the behavior of
     * Gecko for desktop platforms.
     *
     * NOTE: Even if this has composition, JS-Keyboard should call keydown() and
     * keyup().  Although, with the default preferences and normal
     * conditions, DOM key events won't be fired during composition.
     * However, they MAY be dispatched for some reasons, e.g., the web
     * content listens only key events, or if the standard DOM event spec
     * will be changed in the future.
     *
     * @param aKeyboardEvent  Must be a keyboard event which should be dispatched
     * as a keydown event and keypress events.
     * #1 Note that you don't need to set charCode value
     * because it's computed from its key value.
     * #2 If code value is set properly and location value
     * isn't specified (i.e., 0), the location value will
     * be guessed from the code value.
     * #3 Non-defined code names are not allowed. If your
     * key isn't registered, file a bug. If your key isn't
     * defined by any standards, use "" (empty string).
     * #4 .keyCode is guessed from .key value if the key
     * name is registered and .keyCode isn't initialized.
     * #5 modifier key states, e.g., .shiftKey, are
     * ignored.  Instead, modifier states are managed by
     * each instance and set automatically.
     * @param aKeyFlags       Special flags.  The values can be some of KEY_*
     * constants.
     * @return                KEYEVENT_NOT_CONSUMED, if the keydown event nor
     * the following keypress event(s) are consumed.
     * KEYDOWN_IS_CONSUMED, if the keydown event is
     * consumed. No keypress event will be dispatched in
     * this case.
     * KEYPRESS_IS_CONSUMED, if the keypress event(s) is
     * consumed when dispatched.
     * Note that keypress event is always consumed by
     * native code for the printable keys (indicating the
     * default action has been taken).
     */
    keydown(aKeyboardEvent: Event, aKeyFlags: unsigned_long): unsigned_long;
    /**
     * Similar to keydown(), but this dispatches only a keyup event.
     */
    keyup(aKeyboardEvent: Event, aKeyFlags: unsigned_long): boolean;
    /**
     * getModifierState() returns modifier state managed by this instance.
     *
     * @param aModifier       One of modifier key names.  This doesn't support
     * virtual modifiers like "Accel".
     * @return                true if the modifier key is active.  Otherwise,
     * false.
     */
    getModifierState(aModifierKey: AString): boolean;
    /**
     * shareModifierStateOf() makes the instance shares modifier state of
     * another instance.  When this is called, the instance refers the modifier
     * state of another instance.  After that, changes to either this and the
     * other instance's modifier state is synchronized.
     *
     * @param aOther          Another instance which will be referred by the
     * instance.  If this is null, the instance restarts
     * to manage modifier state independently.
     */
    shareModifierStateOf(aOther: nsITextInputProcessorType): void;
    /**
     * Helper method to get usual |.code| value of non-printable keys.
     *
     * @param aKeyValue       A predefined key value such as "Enter".
     * If this is not a proper non-printable key value
     * or a proper key value but not in usual keyboard of
     * the platform, this returns empty string.
     * @param aLocation       The |.location| value.  This is important if
     * the key may be in different location.
     * E.g., Left vs. Right or Standard vs. Numpad.
     * If this is undefined or null, it'll be treated
     * as Standard or Left.
     * @return                One of a code value of well-known key on usual
     * keyboard on the platform, or empty string.
     */
    computeCodeValueOfNonPrintableKey(aKeyValue: AString, aLocation: jsval): AString;
    /**
     * Helper method to guess |.code| value of a printable key which is in usual
     * keyboard of the platform and when active keyboard layout is US-English.
     * Note that this is not aware of option key mapping on macOS.
     *
     * @param aKeyValue          The key value. Must be a character which can
     * be inputted with US-English keyboard layout.
     * @param aLocation          The location of the key.  This is important
     * to distinguish whether the key is in Standard
     * or Numpad. If this is undefined or null, will
     * be treated as Standard.
     * @return                   Returns empty string if there is no proper key.
     */
    guessCodeValueOfPrintableKeyInUSEnglishKeyboardLayout(aKeyValue: AString, aLocation: jsval): AString;
    /**
     * Helper method to guess |.keyCode| value of a printable key which is in
     * usual keyboard of the platform and when active keyboard layout is
     * US-English.
     * Note that this is not aware of option key mapping on macOS.
     *
     * @param aKeyValue          The key value.  Must be a character which can
     * be inputted with US-English keyboard layout.
     * @param aLocation          The location of the key.  This is important
     * to distinguish whether the key is in Standard
     * our Numpad.  If this is undefined or null,
     * will be treated as Standard.
     * @return                   Returns 0 if there is no proper key to input
     * aKeyValue with US-English keyboard layout.
     */
    guessKeyCodeValueOfPrintableKeyInUSEnglishKeyboardLayout(aKeyValue: AString, aLocation: jsval): unsigned_long;
}

/**
 * nsITextInputProcessorNotification stores the type of notification to IME and
 * its detail.  See each explanation of attribute for the detail.
 */
declare interface nsITextInputProcessorNotificationType extends nsISupportsType {
    /**
     * type attribute represents what's notified or requested.  Value must be
     * one of following values:
     *
     * "request-to-commit"  (required to be handled)
     * This is requested when Gecko believes that active composition should be
     * committed.  nsITextInputProcessorCallback::onNotify() has to handle this
     * notification.
     *
     * "request-to-cancel" (required to be handled)
     * This is requested when Gecko believes that active composition should be
     * canceled.  I.e., composition should be committed with empty string.
     * nsITextInputProcessorCallback::onNotify() has to handle this
     * notification.
     *
     * "notify-end-input-transaction" (optional)
     * This is notified when the callback is detached from
     * nsITextInputProcessor.  I.e., the TextInputProcessor lost the rights
     * to input text and needs to call .beginInputTransaction() before next
     * input.
     *
     * "notify-focus" (optional)
     * This is notified when an editable editor gets focus and Gecko starts
     * to observe changes in the content. E.g., selection changes.
     * IME shouldn't change DOM tree, focus nor something when this is notified.
     *
     * "notify-blur" (optional)
     * This is notified when an editable editor loses focus and Gecko stops
     * observing the changes in the content.
     *
     * "notify-text-change" (optional)
     * This is notified when text in the focused editor is modified.
     * Some attributes below are available to retrieve the detail.
     * IME shouldn't change DOM tree, focus nor something when this is notified.
     * Note that when there is no chance to notify you of some text changes
     * safely, this represents all changes as a change.
     *
     * "notify-selection-change" (optional)
     * This is notified when selection in the focused editor is changed.
     * Some attributes below are available to retrieve the detail.
     * IME shouldn't change DOM tree, focus nor something when this is notified.
     * Note that when there was no chance to notify you of this safely, this
     * represents the latest selection change.
     *
     * "notify-position-change" (optional)
     * This is notified when layout is changed in the editor or the window
     * is moved.
     * IME shouldn't change DOM tree, focus nor something when this is notified.
     * Note that when there was no chance to notify you of this safely, this
     * represents the latest layout change.
     */
    readonly type: ACString;
    /**
     * This attribute has a vaild value when type is "notify-selection-change".
     * This is true if selection has a range.  Otherwise, i.e., there is no
     * range such as after calling Selection.removeAllRanges, this is false.
     */
    readonly hasRange: bool;
    /**
     * Be careful, line breakers in the editor are treated as native line
     * breakers.  I.e., on Windows, a line breaker is "\r\n" (CRLF).  On the
     * others, it is "\n" (LF).  If you want TextInputProcessor to treat line
     * breakers on Windows as XP line breakers (LF), please file a bug with
     * the reason why you need the behavior.
     * This attribute has a valid value when type is "notify-text-change", or
     * is "notify-selection-change" and hasRange is true.
     * This is offset of the start of modified text range if type is
     * "notify-text-change".  Or offset of start of selection if type is
     * "notify-selection-change".
     */
    readonly offset: unsigned_long;
    /**
     * This attribute has a valid value when type is "notify-selection-change"
     * and hasRange is true.
     * This is selected text.  I.e., the length is selected length and
     * it's empty if the selection is collapsed.
     */
    readonly text: AString;
    /**
     * This attribute has a valid value when type is "notify-selection-change".
     * This is set to true when the selection is collapsed or no range.
     * Otherwise, false.
     */
    readonly collapsed: boolean;
    /**
     * This attribute has a valid value when type is "notify-selection-change"
     * and hasRange is true.
     * This is selected length.  I.e., if this is 0, collapsed is set to true.
     */
    readonly length: uint32_t;
    /**
     * This attribute has a valid value when type is "notify-selection-change"
     * and hasRange is true.
     * When selection is created from latter point to former point, this is
     * set to true.  Otherwise, false.
     * I.e., if this is true, offset + length is the anchor of selection.
     */
    readonly reversed: boolean;
    /**
     * This attribute has a valid value when type is "notify-selection-change".
     * This indicates the start of the selection's writing mode.
     * The value can be "horizontal-tb", "vertical-rl" or "vertical-lr".
     */
    readonly writingMode: ACString;
    /**
     * This attribute has a valid value when type is "notify-selection-change".
     * If the selection change was caused by composition, this is set to true.
     * Otherwise, false.
     */
    readonly causedByComposition: boolean;
    /**
     * This attribute has a valid value when type is "notify-selection-change".
     * If the selection change was caused by selection event, this is set to true.
     * Otherwise, false.
     */
    readonly causedBySelectionEvent: boolean;
    /**
     * This attribute has a valid value when type is "notify-selection-change".
     * If the selection change occurred during composition, this is set to true.
     * Otherwise, false.
     */
    readonly occurredDuringComposition: boolean;
    /**
     * This attribute has a valid value when type is "notify-text-change".
     * This is removed text length by the change(s).  If this is empty, new text
     * was just inserted.  Otherwise, the text is replaced with new text.
     */
    readonly removedLength: unsigned_long;
    /**
     * This attribute has a valid value when type is "notify-text-change".
     * This is added text length by the change(s).  If this is empty, old text
     * was just deleted.  Otherwise, the text replaces the old text.
     */
    readonly addedLength: unsigned_long;
    /**
     * This attribute has a valid value when type is "notify-text-change".
     * If the text change(s) was caused only by composition, this is set to true.
     * Otherwise, false.  I.e., if one of text changes are caused by JS or
     * modifying without composition, this is set to false.
     */
    readonly causedOnlyByComposition: boolean;
    /**
     * This attribute has a valid value when type is "notify-text-change".
     * If at least one text change not caused by composition occurred during
     * composition, this is set to true.  Otherwise, false.
     * Note that this is set to false when new change is caused by neither
     * composition nor occurred during composition because it's outdated for
     * new composition.
     * In other words, when text changes not caused by composition occurred
     * during composition and it may cause committing composition, this is
     * set to true.
     */
    readonly includingChangesDuringComposition: boolean;
    /**
     * This attribute has a valid value when type is "notify-text-change".
     * If at least one text change occurred when there was no composition, this
     * is set to true.  Otherwise, false.
     */
    readonly includingChangesWithoutComposition: boolean;
}

/**
 * nsITextInputProcessorCallback is a callback interface for JS to implement
 * IME.  IME implemented by JS can implement onNotify() function and must send
 * it to nsITextInputProcessor at initializing.  Then, onNotify() will be
 * called with nsITextInputProcessorNotification instance.
 * The reason why onNotify() uses string simply is that if we will support
 * other notifications such as text changes and selection changes, we need to
 * notify IME of some other information.  Then, only changing
 * nsITextInputProcessorNotification interface is better for compatibility.
 */
declare interface nsITextInputProcessorCallbackType extends nsISupportsType {
    /**
     * When Gecko notifies IME of something or requests something to IME,
     * this is called.
     *
     * @param aTextInputProcessor Reference to the nsITextInputProcessor service
     * which is the original receiver of the request
     * or notification.
     * @param aNotification       Stores type of notifications and additional
     * information.
     * @return                    Return true if it succeeded or does nothing.
     * Otherwise, return false.
     *
     * Example #1 The simplest implementation of nsITextInputProcessorCallback is:
     *
     * function simpleCallback(aTIP, aNotification)
     * {
     * try {
     * switch (aNotification.type) {
     * case "request-to-commit":
     * aTIP.commitComposition();
     * break;
     * case "request-to-cancel":
     * aTIP.cancelComposition();
     * break;
     * }
     * } catch (e) {
     * return false;
     * }
     * return true;
     * }
     *
     * var TIP = Components.classes["@mozilla.org/text-input-processor;1"].
     * createInstance(Components.interfaces.nsITextInputProcessor);
     * if (!TIP.init(window, simpleCallback)) {
     * return;
     * }
     */
    onNotify(aTextInputProcessor: nsITextInputProcessorType, aNotification: nsITextInputProcessorNotificationType): boolean;
}

/**
 *
 */
declare interface nsITextToSubURIType extends nsISupportsType {
    /**
     *
     */
    ConvertAndEscape(charset: ACString, text: AString): ACString;
    /**
     *
     */
    UnEscapeAndConvert(charset: ACString, text: ACString): AString;
    /**
     * Unescapes the given URI fragment (for UI purpose only)
     * Note:
     *
     * -  escaping back the result (unescaped string) is not guaranteed to
     * give the original escaped string
     * -  The URI fragment (escaped) is assumed to be in UTF-8 and converted
     * to AString (UTF-16)
     * -  In case of successful conversion any resulting character listed
     * in netwerk/dns/IDNCharacterBlocklist.inc (except space) is escaped
     * -  Always succeeeds (callers don't need to do error checking)
     *
     *
     * @param aURIFragment the URI (or URI fragment) to unescape
     * @param aDontEscape whether to escape IDN blocklisted characters
     * @return Unescaped aURIFragment  converted to unicode
     */
    unEscapeURIForUI(aURIFragment: AUTF8String, aDontEscape: boolean): AString;
    /**
     * Unescapes only non ASCII characters in the given URI fragment
     * note: this method assumes the URI as UTF-8 and fallbacks to the given
     * charset if the charset is an ASCII superset
     *
     * @param aCharset the charset to convert from
     * @param aURIFragment the URI (or URI fragment) to unescape
     * @return Unescaped aURIFragment  converted to unicode
     * @throws NS_ERROR_UCONV_NOCONV when there is no decoder for aCharset
     * or NS_ERROR_UDEC_ILLEGALINPUT in case of conversion failure
     */
    unEscapeNonAsciiURI(aCharset: ACString, aURIFragment: AUTF8String): AString;
}

/**
 * This interface provides a high-level abstraction for an operating system
 * thread.
 *
 * Threads have a built-in event queue, and a thread is an event target that
 * can receive nsIRunnable objects (events) to be processed on the thread.
 *
 * See nsIThreadManager for the API used to create and locate threads.
 */
declare interface nsIThreadType extends nsISerialEventTargetType {
    /**
     * @returns
     * The NSPR thread object corresponding to this nsIThread.
     */
    readonly PRThread: PRThread;
    /**
     * @returns
     * Whether or not this thread may call into JS. Used in the profiler
     * to avoid some unnecessary locking.
     */
    CanInvokeJS: boolean;
    /**
     * Shutdown the thread.  This method prevents further dispatch of events to
     * the thread, and it causes any pending events to run to completion before
     * the thread joins (see PR_JoinThread) with the current thread.  During this
     * method call, events for the current thread may be processed.
     *
     * This method MAY NOT be executed from the thread itself.  Instead, it is
     * meant to be executed from another thread (usually the thread that created
     * this thread or the main application thread).  When this function returns,
     * the thread will be shutdown, and it will no longer be possible to dispatch
     * events to the thread.
     *
     * @throws NS_ERROR_UNEXPECTED
     * Indicates that this method was erroneously called when this thread was
     * the current thread, that this thread was not created with a call to
     * nsIThreadManager::NewThread, or if this method was called more than once
     * on the thread object.
     */
    shutdown(): void;
    /**
     * This method may be called to determine if there are any events ready to be
     * processed.  It may only be called when this thread is the current thread.
     *
     * Because events may be added to this thread by another thread, a "false"
     * result does not mean that this thread has no pending events.  It only
     * means that there were no pending events when this method was called.
     *
     * @returns
     * A boolean value that if "true" indicates that this thread has one or
     * more pending events.
     *
     * @throws NS_ERROR_UNEXPECTED
     * Indicates that this method was erroneously called when this thread was
     * not the current thread.
     */
    hasPendingEvents(): boolean;
    /**
     * Similar to above, but checks only possible high priority queue.
     */
    hasPendingHighPriorityEvents(): boolean;
    /**
     * Process the next event.  If there are no pending events, then this method
     * may wait -- depending on the value of the mayWait parameter -- until an
     * event is dispatched to this thread.  This method is re-entrant but may
     * only be called if this thread is the current thread.
     *
     * @param mayWait
     * A boolean parameter that if "true" indicates that the method may block
     * the calling thread to wait for a pending event.
     *
     * @returns
     * A boolean value that if "true" indicates that an event was processed.
     *
     * @throws NS_ERROR_UNEXPECTED
     * Indicates that this method was erroneously called when this thread was
     * not the current thread.
     */
    processNextEvent(mayWait: boolean): boolean;
    /**
     * Shutdown the thread asynchronously.  This method immediately prevents
     * further dispatch of events to the thread, and it causes any pending events
     * to run to completion before this thread joins with the current thread.
     *
     * UNLIKE shutdown() this does not process events on the current thread.
     * Instead it merely ensures that the current thread continues running until
     * this thread has shut down.
     *
     * This method MAY NOT be executed from the thread itself.  Instead, it is
     * meant to be executed from another thread (usually the thread that created
     * this thread or the main application thread).  When this function returns,
     * the thread will continue running until it exhausts its event queue.
     *
     * @throws NS_ERROR_UNEXPECTED
     * Indicates that this method was erroneously called when this thread was
     * the current thread, that this thread was not created with a call to
     * nsIThreadManager::NewNamedThread, or that this method was called more
     * than once on the thread object.
     */
    asyncShutdown(): void;
    /**
     * Like `asyncShutdown`, but also returns a nsIThreadShutdown instance to
     * allow observing and controlling the thread's async shutdown progress.
     */
    beginShutdown(): nsIThreadShutdown;
    /**
     * This is set to the end of the last 50+ms event that was executed on
     * this thread (for MainThread only).  Otherwise returns a null TimeStamp.
     */
    readonly lastLongTaskEnd: TimeStamp;
    /**
     *
     */
    readonly lastLongNonIdleTaskEnd: TimeStamp;
}

/**
 * The XPCOM thread object implements this interface, which allows a consumer
 * to observe dispatch activity on the thread.
 */
declare interface nsIThreadInternalType extends nsIThreadType {
    /**
     * Get/set the current thread observer (may be null).  This attribute may be
     * read from any thread, but must only be set on the thread corresponding to
     * this thread object.  The observer will be released on the thread
     * corresponding to this thread object after all other events have been
     * processed during a call to Shutdown.
     */
    observer: nsIThreadObserver;
    /**
     * Add an observer that will *only* receive onProcessNextEvent,
     * beforeProcessNextEvent. and afterProcessNextEvent callbacks. Always called
     * on the target thread, and the implementation does not have to be
     * threadsafe. Order of callbacks is not guaranteed (i.e.
     * afterProcessNextEvent may be called first depending on whether or not the
     * observer is added in a nested loop). Holds a strong ref.
     */
    addObserver(observer: nsIThreadObserverType): void;
    /**
     * Remove an observer added via the addObserver call. Once removed the
     * observer will never be called again by the thread.
     */
    removeObserver(observer: nsIThreadObserverType): void;
}

/**
 * This interface provides the observer with hooks to implement a layered
 * event queue.  For example, it is possible to overlay processing events
 * for a GUI toolkit on top of the events for a thread:
 *
 * var NativeQueue;
 * Observer = {
 * onDispatchedEvent() {
 * NativeQueue.signal();
 * }
 * onProcessNextEvent(thread, mayWait) {
 * if (NativeQueue.hasNextEvent())
 * NativeQueue.processNextEvent();
 * while (mayWait && !thread.hasPendingEvent()) {
 * NativeQueue.wait();
 * NativeQueue.processNextEvent();
 * }
 * }
 * };
 *
 * NOTE: The implementation of this interface must be threadsafe.
 *
 * NOTE: It is valid to change the thread's observer during a call to an
 * observer method.
 *
 * NOTE: Will be split into two interfaces soon: one for onProcessNextEvent and
 * afterProcessNextEvent, then another that inherits the first and adds
 * onDispatchedEvent.
 */
declare interface nsIThreadObserverType extends nsISupportsType {
    /**
     * This method is called after an event has been dispatched to the thread.
     * This method may be called from any thread.
     */
    onDispatchedEvent(): void;
    /**
     * This method is called when nsIThread::ProcessNextEvent is called.  It does
     * not guarantee that an event is actually going to be processed.  This method
     * is only called on the target thread.
     *
     * @param thread
     * The thread being asked to process another event.
     * @param mayWait
     * Indicates whether or not the method is allowed to block the calling
     * thread.  For example, this parameter is false during thread shutdown.
     */
    onProcessNextEvent(thread: nsIThreadInternalType, mayWait: boolean): void;
    /**
     * This method is called (from nsIThread::ProcessNextEvent) after an event
     * is processed.  It does not guarantee that an event was actually processed
     * (depends on the value of |eventWasProcessed|.  This method is only called
     * on the target thread.  DO NOT EVER RUN SCRIPT FROM THIS CALLBACK!!!
     *
     * @param thread
     * The thread that processed another event.
     * @param eventWasProcessed
     * Indicates whether an event was actually processed. May be false if the
     * |mayWait| flag was false when calling nsIThread::ProcessNextEvent().
     */
    afterProcessNextEvent(thread: nsIThreadInternalType, eventWasProcessed: bool): void;
}

/**
 *
 */
declare interface nsINestedEventLoopConditionType extends nsISupportsType {
    /**
     * Returns true if the current nested event loop should stop spinning.
     */
    isDone(): bool;
}

/**
 * An interface for creating and locating nsIThread instances.
 */
declare interface nsIThreadManagerType extends nsISupportsType {
    /**
     * Get the main thread.
     */
    readonly mainThread: nsIThread;
    /**
     * Get the current thread.  If the calling thread does not already have a
     * nsIThread associated with it, then a new nsIThread will be created and
     * associated with the current PRThread.
     */
    readonly currentThread: nsIThread;
    /**
     * This queues a runnable to the main thread. It's a shortcut for JS callers
     * to be used instead of
     * .mainThread.dispatch(runnable, Ci.nsIEventTarget.DISPATCH_NORMAL);
     * or
     * .currentThread.dispatch(runnable, Ci.nsIEventTarget.DISPATCH_NORMAL);
     * C++ callers should instead use NS_DispatchToMainThread.
     */
    dispatchToMainThread(event: nsIRunnableType, priority: uint32_t): void;
    /**
     * Similar to dispatchToMainThread, but wraps the event with extra
     * runnable that allocates nsAutoMicroTask.
     */
    dispatchToMainThreadWithMicroTask(event: nsIRunnableType, priority: uint32_t): void;
    /**
     * This queues a runnable to the main thread's idle queue.
     *
     * @param event
     * The event to dispatch.
     * @param timeout
     * The time in milliseconds until this event should be moved from the idle
     * queue to the regular queue if it hasn't been executed by then.  If not
     * passed or a zero value is specified, the event will never be moved to
     * the regular queue.
     */
    idleDispatchToMainThread(event: nsIRunnableType, timeout: uint32_t): void;
    /**
     * A helper method to dispatch a task through nsIDirectTaskDispatcher to the
     * current thread.
     */
    dispatchDirectTaskToCurrentThread(event: nsIRunnableType): void;
    /**
     * Enter a nested event loop on the current thread, waiting on, and
     * processing events until condition.isDone() returns true.
     *
     * If condition.isDone() throws, this function will throw as well.
     *
     * C++ code should not use this function, instead preferring
     * mozilla::SpinEventLoopUntil.
     */
    spinEventLoopUntil(aVeryGoodReasonToDoThis: ACString, condition: nsINestedEventLoopConditionType): void;
    /**
     * Similar to the previous method, but the spinning of the event loop
     * terminates when the quit application shutting down starts.
     *
     * C++ code should not use this function, instead preferring
     * mozilla::SpinEventLoopUntil.
     */
    spinEventLoopUntilOrQuit(aVeryGoodReasonToDoThis: ACString, condition: nsINestedEventLoopConditionType): void;
    /**
     * Spin the current thread's event loop until there are no more pending
     * events.  This could be done with spinEventLoopUntil, but that would
     * require access to the current thread from JavaScript, which we are
     * moving away from.
     */
    spinEventLoopUntilEmpty(): void;
    /**
     * Return the EventTarget for the main thread.
     */
    readonly mainThreadEventTarget: nsIEventTarget;
}

/**
 *
 */
declare interface nsIThreadPoolListenerType extends nsISupportsType {
    /**
     * Called when a new thread is created by the thread pool. The notification
     * happens on the newly-created thread.
     */
    onThreadCreated(): void;
    /**
     * Called when a thread is about to be destroyed by the thread pool. The
     * notification happens on the thread that is about to be destroyed.
     */
    onThreadShuttingDown(): void;
}

/**
 * An interface to a thread pool.  A thread pool creates a limited number of
 * anonymous (unnamed) worker threads.  An event dispatched to the thread pool
 * will be run on the next available worker thread.
 */
declare interface nsIThreadPoolType extends nsIEventTargetType {
    /**
     * Shutdown the thread pool.  This method may not be executed from any thread
     * in the thread pool.  Instead, it is meant to be executed from another
     * thread (usually the thread that created this thread pool).  When this
     * function returns, the thread pool and all of its threads will be shutdown,
     * and it will no longer be possible to dispatch tasks to the thread pool.
     *
     * As a side effect, events on the current thread will be processed.
     */
    shutdown(): void;
    /**
     * Get/set the maximum number of threads allowed at one time in this pool.
     */
    threadLimit: unsigned_long;
    /**
     * Get/set the maximum number of idle threads kept alive.
     */
    idleThreadLimit: unsigned_long;
    /**
     * Get/set the amount of time in milliseconds before an idle thread is
     * destroyed.
     */
    idleThreadTimeout: unsigned_long;
    /**
     * If set to true the idle timeout will be calculated as idleThreadTimeout
     * divideded by the number of idle threads at the moment.  This may help
     * save memory allocations but still keep reasonable amount of idle threads.
     * Default is false, use |idleThreadTimeout| for all threads.
     */
    idleThreadTimeoutRegressive: boolean;
    /**
     * Get/set the number of bytes reserved for the stack of all threads in
     * the pool. By default this is nsIThreadManager::DEFAULT_STACK_SIZE.
     */
    threadStackSize: unsigned_long;
    /**
     * An optional listener that will be notified when a thread is created or
     * destroyed in the course of the thread pool's operation.
     *
     * A listener will only receive notifications about threads created after the
     * listener is set so it is recommended that the consumer set the listener
     * before dispatching the first event. A listener that receives an
     * onThreadCreated() notification is guaranteed to always receive the
     * corresponding onThreadShuttingDown() notification.
     *
     * The thread pool takes ownership of the listener and releases it when the
     * shutdown() method is called. Threads created after the listener is set will
     * also take ownership of the listener so that the listener will be kept alive
     * long enough to receive the guaranteed onThreadShuttingDown() notification.
     */
    listener: nsIThreadPoolListener;
    /**
     * Set the label for threads in the pool. All threads will be named
     * "<aName> #<n>", where <n> is a serial number.
     */
    setName(aName: ACString): void;
}

/**
 * nsIThreadRetargetableRequest
 *
 * Should be implemented by requests that support retargeting delivery of
 * data off the main thread.
 */
declare interface nsIThreadRetargetableRequestType extends nsISupportsType {
    /**
     * Called to retarget delivery of OnDataAvailable to another thread. Should
     * only be called before AsyncOpen for nsIWebsocketChannels, or during
     * OnStartRequest for nsIChannels.
     * Note: For nsIChannels, OnStartRequest and OnStopRequest will still be
     * delivered on the main thread.
     *
     * @param aNewTarget New event target, e.g. thread or threadpool.
     *
     * Note: no return value is given. If the retargeting cannot be handled,
     * normal delivery to the main thread will continue. As such, listeners
     * should be ready to deal with OnDataAvailable on either the main thread or
     * the new target thread.
     */
    retargetDeliveryTo(aNewTarget: nsISerialEventTargetType): void;
    /**
     * Returns the event target where OnDataAvailable events will be dispatched.
     *
     * This is only valid after OnStartRequest has been called. Any time before
     * that point, the value may be changed by `retargetDeliveryTo` calls.
     */
    readonly deliveryTarget: nsISerialEventTarget;
}

/**
 * nsIThreadRetargetableStreamListener
 *
 * To be used by classes which implement nsIStreamListener and whose
 * OnDataAvailable callback may be retargeted for delivery off the main thread.
 */
declare interface nsIThreadRetargetableStreamListenerType extends nsISupportsType {
    /**
     * Checks this listener and any next listeners it may have to verify that
     * they can receive OnDataAvailable off the main thread. It is the
     * responsibility of the implementing class to decide on the criteria to
     * determine if retargeted delivery of these methods is possible, but it must
     * check any and all nsIStreamListener objects that might be called in the
     * listener chain.
     *
     * An exception should be thrown if a listener in the chain does not
     * support retargeted delivery, i.e. if the next listener does not implement
     * nsIThreadRetargetableStreamListener, or a call to its checkListenerChain()
     * fails.
     */
    checkListenerChain(): void;
}

/**
 * Handle for the ongoing shutdown progress of a given thread which can be used
 * to observe and interrupt async shutdown progress. Methods on this interface
 * may generally only be used on the thread which called
 * `nsIThread::beginShutdown`.
 */
declare interface nsIThreadShutdownType extends nsISupportsType {
    /**
     * Register a runnable to be executed when the thread has completed shutdown,
     * or shutdown has been cancelled due to `stopWaitingAndLeakThread()`.
     *
     * If the thread has already completed or cancelled shutdown, the runnable
     * may be executed synchronously.
     *
     * May only be called on the thread which invoked `nsIThread::beginShutdown`.
     */
    onCompletion(aEvent: nsIRunnableType): void;
    /**
     * Check if the target thread has completed shutdown.
     *
     * May only be accessed on the thread which called `nsIThread::beginShutdown`.
     */
    readonly completed: boolean;
    /**
     * Give up on waiting for the shutting down thread to exit. Calling this
     * method will allow the thread to continue running, no longer block shutdown,
     * and the thread will never be joined or have its resources reclaimed.
     *
     * Completion callbacks attached to this `nsIThreadShutdown` may be executed
     * during this call.
     *
     * This method should NOT be called except in exceptional circumstances during
     * shutdown, as it will cause resources for the shutting down thread to be
     * leaked.
     *
     * May only be called on the thread which called `nsIThread::beginShutdown`
     *
     * @throws NS_ERROR_NOT_AVAILABLE
     * Indicates that the target thread has already stopped running and a
     * request to be joined is already being dispatched to the waiting thread.
     */
    stopWaitingAndLeakThread(): void;
}

/**
 * An instance of this interface can be used to throttle the uploads
 * of a group of associated channels.
 */
declare interface nsIInputChannelThrottleQueueType extends nsISupportsType {
    /**
     * Initialize this object with the mean and maximum bytes per
     * second that will be allowed.  Neither value may be zero, and
     * the maximum must not be less than the mean.
     *
     * @param aMeanBytesPerSecond
     * Mean number of bytes per second.
     * @param aMaxBytesPerSecond
     * Maximum number of bytes per second.
     */
    init(aMeanBytesPerSecond: unsigned_long, aMaxBytesPerSecond: unsigned_long): void;
    /**
     * Internal use only. Get the values set by init method.
     */
    readonly meanBytesPerSecond: unsigned_long;
    /**
     *
     */
    readonly maxBytesPerSecond: unsigned_long;
    /**
     * Return the number of bytes that are available to the caller in
     * this time slice.
     *
     * @param aRemaining
     * The number of bytes available to be processed
     * @return the number of bytes allowed to be processed during this
     * time slice; this will never be greater than aRemaining.
     */
    available(aRemaining: unsigned_long): unsigned_long;
    /**
     * Record a successful read.
     *
     * @param aBytesRead
     * The number of bytes actually read.
     */
    recordRead(aBytesRead: unsigned_long): void;
    /**
     * Return the number of bytes allowed through this queue.  This is
     * the sum of all the values passed to recordRead.  This method is
     * primarily useful for testing.
     */
    bytesProcessed(): unsigned_long_long;
    /**
     * Wrap the given input stream in a new input stream which
     * throttles the incoming data.
     *
     * @param aInputStream the input stream to wrap
     * @return a new input stream that throttles the data.
     */
    wrapStream(aInputStream: nsIInputStreamType): nsIAsyncInputStream;
}

/**
 * A throttled input channel can be managed by an
 * nsIInputChannelThrottleQueue to limit how much data is sent during
 * a given time slice.
 */
declare interface nsIThrottledInputChannelType extends nsISupportsType {
    /**
     * The queue that manages this channel.  Multiple channels can
     * share a single queue.  A null value means that no throttling
     * will be done.
     */
    throttleQueue: nsIInputChannelThrottleQueue;
}

/**
 *
 */
declare interface nsIServerTimingType extends nsISupportsType {
    /**
     *
     */
    readonly name: ACString;
    /**
     *
     */
    readonly duration: double;
    /**
     *
     */
    readonly description: ACString;
}

/**
 *
 */
declare interface nsITimedChannelType extends nsISupportsType {
    /**
     *
     */
    timingEnabled: boolean;
    /**
     *
     */
    redirectCount: uint8_t;
    /**
     *
     */
    internalRedirectCount: uint8_t;
    /**
     *
     */
    channelCreation: TimeStamp;
    /**
     *
     */
    asyncOpen: TimeStamp;
    /**
     *
     */
    launchServiceWorkerStart: TimeStamp;
    /**
     *
     */
    launchServiceWorkerEnd: TimeStamp;
    /**
     *
     */
    dispatchFetchEventStart: TimeStamp;
    /**
     *
     */
    dispatchFetchEventEnd: TimeStamp;
    /**
     *
     */
    handleFetchEventStart: TimeStamp;
    /**
     *
     */
    handleFetchEventEnd: TimeStamp;
    /**
     *
     */
    readonly domainLookupStart: TimeStamp;
    /**
     *
     */
    readonly domainLookupEnd: TimeStamp;
    /**
     *
     */
    readonly connectStart: TimeStamp;
    /**
     *
     */
    readonly tcpConnectEnd: TimeStamp;
    /**
     *
     */
    readonly secureConnectionStart: TimeStamp;
    /**
     *
     */
    readonly connectEnd: TimeStamp;
    /**
     *
     */
    readonly requestStart: TimeStamp;
    /**
     *
     */
    readonly responseStart: TimeStamp;
    /**
     *
     */
    readonly responseEnd: TimeStamp;
    /**
     *
     */
    redirectStart: TimeStamp;
    /**
     *
     */
    redirectEnd: TimeStamp;
    /**
     *
     */
    initiatorType: AString;
    /**
     *
     */
    allRedirectsSameOrigin: boolean;
    /**
     *
     */
    allRedirectsPassTimingAllowCheck: boolean;
    /**
     *
     */
    readonly cacheReadStart: TimeStamp;
    /**
     *
     */
    readonly cacheReadEnd: TimeStamp;
    /**
     *
     */
    readonly transactionPending: TimeStamp;
    /**
     *
     */
    readonly channelCreationTime: PRTime;
    /**
     *
     */
    readonly asyncOpenTime: PRTime;
    /**
     *
     */
    readonly launchServiceWorkerStartTime: PRTime;
    /**
     *
     */
    readonly launchServiceWorkerEndTime: PRTime;
    /**
     *
     */
    readonly dispatchFetchEventStartTime: PRTime;
    /**
     *
     */
    readonly dispatchFetchEventEndTime: PRTime;
    /**
     *
     */
    readonly handleFetchEventStartTime: PRTime;
    /**
     *
     */
    readonly handleFetchEventEndTime: PRTime;
    /**
     *
     */
    readonly domainLookupStartTime: PRTime;
    /**
     *
     */
    readonly domainLookupEndTime: PRTime;
    /**
     *
     */
    readonly connectStartTime: PRTime;
    /**
     *
     */
    readonly tcpConnectEndTime: PRTime;
    /**
     *
     */
    readonly secureConnectionStartTime: PRTime;
    /**
     *
     */
    readonly connectEndTime: PRTime;
    /**
     *
     */
    readonly requestStartTime: PRTime;
    /**
     *
     */
    readonly responseStartTime: PRTime;
    /**
     *
     */
    readonly responseEndTime: PRTime;
    /**
     *
     */
    readonly cacheReadStartTime: PRTime;
    /**
     *
     */
    readonly cacheReadEndTime: PRTime;
    /**
     *
     */
    readonly redirectStartTime: PRTime;
    /**
     *
     */
    readonly redirectEndTime: PRTime;
    /**
     *
     */
    readonly transactionPendingTime: PRTime;
    /**
     *
     */
    reportResourceTiming: boolean;
    /**
     *
     */
    readonly serverTiming: nsIArray;
    /**
     *
     */
    getNativeServerTiming(): nsServerTimingArrayRef;
}

/**
 *
 */
declare interface nsITimerCallbackType extends nsISupportsType {
    /**
     * @param aTimer the timer which has expired
     */
    notify(timer: nsITimerType): void;
}

/**
 * nsITimer instances must be initialized by calling one of the "init" methods
 * documented below.  You may also re-initialize (using one of the init()
 * methods) an existing instance to avoid the overhead of destroying and
 * creating a timer.  It is not necessary to cancel the timer in that case.
 *
 * By default a timer will fire on the thread that created it.  Set the .target
 * attribute to fire on a different thread.  Once you have set a timer's .target
 * and called one of its init functions, any further interactions with the timer
 * (calling cancel(), changing member fields, etc) should only be done by the
 * target thread, or races may occur with bad results like timers firing after
 * they've been canceled, and/or not firing after re-initiatization.
 */
declare interface nsITimerType extends nsISupportsType {
    /**
     * Initialize a timer that will fire after the said delay.
     * A user must keep a reference to this timer till it is
     * is no longer needed or has been cancelled.
     *
     * @param aObserver   the callback object that observes the
     * ``timer-callback'' topic with the subject being
     * the timer itself when the timer fires:
     *
     * observe(nsISupports aSubject, => nsITimer
     * string aTopic,        => ``timer-callback''
     * wstring data          =>  null
     *
     * @param aDelayInMs  delay in milliseconds for timer to fire
     * @param aType       timer type per TYPE* consts defined above
     */
    init(aObserver: nsIObserverType, aDelayInMs: unsigned_long, aType: unsigned_long): void;
    /**
     * Initialize a timer to fire after the given millisecond interval.
     * This version takes a callback object.
     *
     * @param aFunc       nsITimerCallback interface to call when timer expires
     * @param aDelayInMs  The millisecond interval
     * @param aType       Timer type per TYPE* consts defined above
     */
    initWithCallback(aCallback: nsITimerCallbackType, aDelayInMs: unsigned_long, aType: unsigned_long): void;
    /**
     * Cancel the timer.  This method works on all types, not just on repeating
     * timers -- you might want to cancel a TYPE_ONE_SHOT timer, and even reuse
     * it by re-initializing it (to avoid object destruction and creation costs
     * by conserving one timer instance).
     */
    cancel(): void;
    /**
     * The millisecond delay of the timeout.
     *
     * NOTE: Re-setting the delay on a one-shot timer that has already fired
     * doesn't restart the timer. Call one of the init() methods to restart
     * a one-shot timer.
     */
    delay: unsigned_long;
    /**
     * The timer type - one of the above TYPE_* constants.
     */
    type: unsigned_long;
    /**
     * The opaque pointer pass to initWithFuncCallback.
     */
    readonly closure: voidPtr;
    /**
     * The nsITimerCallback object passed to initWithCallback.
     */
    readonly callback: nsITimerCallback;
    /**
     * The nsIEventTarget where the callback will be dispatched. Note that this
     * target may only be set before the call to one of the init methods above.
     *
     * By default the target is the thread that created the timer.
     */
    target: nsIEventTarget;
    /**
     *
     */
    readonly name: ACString;
    /**
     * The number of microseconds this nsITimer implementation can possibly
     * fire early.
     */
    readonly allowedEarlyFiringMicroseconds: unsigned_long;
    /**
     *
     */
    sizeOfIncludingThis(aMallocSizeOf: MallocSizeOf): size_t;
}

/**
 *
 */
declare interface nsITimerManagerType extends nsISupportsType {
}

/**
 *
 */
declare interface nsITlsHandshakeCallbackListenerType extends nsISupportsType {
}

/**
 *
 */
declare interface nsITokenDialogsType extends nsISupportsType {
    /**
     * Displays notification dialog to the user that they are expected to
     * authenticate to the token using its "protected authentication path" feature.
     */
    displayProtectedAuth(ctx: nsIInterfaceRequestorType, runnable: nsIProtectedAuthThreadType): void;
}

/**
 * This is the interface for setting and changing password
 * on a PKCS11 token.
 */
declare interface nsITokenPasswordDialogsType extends nsISupportsType {
    /**
     * Brings up a dialog to set the password on a token.
     *
     * @param ctx A user interface context.
     * @param token {nsIPK11Token} The token.
     * @return true if the user canceled the dialog, false otherwise.
     */
    setPassword(ctx: nsIInterfaceRequestorType, token: nsIPK11TokenType): boolean;
}

/**
 *
 */
declare interface nsIToolkitChromeRegistryType extends nsIXULChromeRegistryType {
    /**
     * Get a list of locales available for the specified package.
     */
    getLocalesForPackage(aPackage: AUTF8String): nsIUTF8StringEnumerator;
}

/**
 * Hold on to a profile lock. Once you release the last reference to this
 * interface, the profile lock is released.
 */
declare interface nsIProfileLockType extends nsISupportsType {
    /**
     * The main profile directory.
     */
    readonly directory: nsIFile;
    /**
     * A directory corresponding to the main profile directory that exists for
     * the purpose of storing data on the local filesystem, including cache
     * files or other data files that may not represent critical user data.
     * (e.g., this directory may not be included as part of a backup scheme.)
     *
     * In some cases, this directory may just be the main profile directory.
     */
    readonly localDirectory: nsIFile;
    /**
     * The timestamp of an existing profile lock at lock time.
     */
    readonly replacedLockTime: PRTime;
    /**
     * Unlock the profile.
     */
    unlock(): void;
}

/**
 * A interface representing a profile.
 * @note THIS INTERFACE SHOULD BE IMPLEMENTED BY THE TOOLKIT CODE ONLY! DON'T
 * EVEN THINK ABOUT IMPLEMENTING THIS IN JAVASCRIPT!
 */
declare interface nsIToolkitProfileType extends nsISupportsType {
    /**
     * The location of the profile directory.
     */
    readonly rootDir: nsIFile;
    /**
     * The location of the profile local directory, which may be the same as
     * the root directory.  See nsIProfileLock::localDirectory.
     */
    readonly localDir: nsIFile;
    /**
     * The name of the profile.
     */
    name: AUTF8String;
    /**
     * Removes the profile from the registry of profiles.
     *
     * @param removeFiles
     * Indicates whether or not the profile directory should be
     * removed in addition.
     */
    remove(removeFiles: boolean): void;
    /**
     * Removes the profile from the registry of profiles.
     * The profile directory is removed in the stream transport thread.
     *
     * @param removeFiles
     * Indicates whether or not the profile directory should be
     * removed in addition.
     */
    removeInBackground(removeFiles: boolean): void;
    /**
     * Lock this profile using platform-specific locking methods.
     *
     * @param lockFile If locking fails, this may return a lockFile object
     * which can be used in platform-specific ways to
     * determine which process has the file locked. Null
     * may be passed.
     * @return An interface which holds a profile lock as long as you reference
     * it.
     * @throws NS_ERROR_FILE_ACCESS_DENIED if the profile was already locked.
     */
    lock(aUnlocker: nsIProfileUnlockerType): nsIProfileLock;
}

/**
 *
 */
declare interface nsIToolkitProfileServiceType extends nsISupportsType {
    /**
     * Tests whether the profile lists on disk have changed since they were
     * loaded. When this is true attempts to flush changes to disk will fail.
     */
    readonly isListOutdated: boolean;
    /**
     *
     */
    startWithLastProfile: boolean;
    /**
     *
     */
    readonly profiles: nsISimpleEnumerator;
    /**
     * The profile currently in use if it is a named profile. This will return
     * null if the current profile path doesn't match a profile in the database.
     */
    readonly currentProfile: nsIToolkitProfile;
    /**
     * The default profile for this build.
     * On startup this is the profile selected unless overridden by command line
     * arguments or environment variables. Setting this will change the profile
     * used by default the next time the application is started.
     * Attempting to change the default may throw an exception on builds that do
     * not support changing the default profile, such as developer edition.
     */
    defaultProfile: nsIToolkitProfile;
    /**
     * Selects or creates a profile to use based on the profiles database, any
     * environment variables and any command line arguments. Will not create
     * a profile if aIsResetting is true. The profile is selected based on this
     * order of preference:
     * * Environment variables (set when restarting the application).
     * * --profile command line argument.
     * * --createprofile command line argument (this also causes the app to exit).
     * * -p command line argument.
     * * A new profile created if this is the first run of the application.
     * * The default profile.
     * aRootDir and aLocalDir are set to the data and local directories for the
     * profile data. If a profile from the database was selected it will be
     * returned in aProfile.
     * This returns true if a new profile was created.
     * This method is primarily for testing. It can be called only once.
     */
    selectStartupProfile(aArgv: invalid, aIsResetting: boolean, aUpdateChannel: AUTF8String, aLegacyInstallHash: AUTF8String, aRootDir: nsIFileType, aLocalDir: nsIFileType, aProfile: nsIToolkitProfileType): bool;
    /**
     * Get a profile by name. This is mainly for use by the -P
     * commandline flag.
     *
     * @param aName The profile name to find.
     */
    getProfileByName(aName: AUTF8String): nsIToolkitProfile;
    /**
     * Create a new profile.
     *
     * The profile temporary directory will be chosen based on where the
     * profile directory is located.
     *
     * If a profile with the given name already exists it will be returned
     * instead of creating a new profile.
     *
     * @param aRootDir
     * The profile directory. May be null, in which case a suitable
     * default will be chosen based on the profile name.
     * @param aName
     * The profile name.
     */
    createProfile(aRootDir: nsIFileType, aName: AUTF8String): nsIToolkitProfile;
    /**
     * Create a new profile with a unique name.
     *
     * As above however the name given will be altered to make it a unique
     * profile name.
     *
     * @param aRootDir
     * The profile directory. May be null, in which case a suitable
     * default will be chosen based on the profile name.
     * @param aNamePrefix
     * The prefix to use for the profile name. If unused this will be
     * used as the profile name otherwise additional characters will be
     * added to make the name unique.
     */
    createUniqueProfile(aRootDir: nsIFileType, aNamePrefix: AUTF8String): nsIToolkitProfile;
    /**
     * Returns the number of profiles.
     * @return the number of profiles.
     */
    readonly profileCount: unsigned_long;
    /**
     * Flush the profiles list file. This will fail with
     * NS_ERROR_DATABASE_CHANGED if the files on disk have changed since the
     * profiles were loaded.
     */
    flush(): void;
}

/**
 *
 */
declare interface nsIToolkitShellServiceType extends nsISupportsType {
    /**
     * Determines whether or not this application is the default for the operating
     * system. It is up to the application to determine how to answer this
     * question but it would typically involve checking if it is registered as the
     * default handler for web protocols and/or file types.
     */
    isDefaultApplication(): boolean;
}

/**
 * An optional interface for embedding clients wishing to receive
 * notifications for when a tooltip should be displayed or removed.
 * The embedder implements this interface on the web browser chrome
 * object associated with the window that notifications are required
 * for.
 *
 * @see nsITooltipTextProvider
 */
declare interface nsITooltipListenerType extends nsISupportsType {
    /**
     * Called when a tooltip should be displayed.
     *
     * @param aXCoords The tooltip left edge X coordinate.
     * @param aYCoords The tooltip top edge Y coordinate.
     * @param aTipText The text to display in the tooltip, typically obtained
     * from the TITLE attribute of the node (or containing parent)
     * over which the pointer has been positioned.
     * @param aTipDir  The direction (ltr or rtl) in which to display the text
     *
     * @note
     * Coordinates are specified in device pixels, relative to the top-left
     * corner of the browser area.
     *
     * @return `NS_OK` if the tooltip was displayed.
     */
    onShowTooltip(aXCoords: long, aYCoords: long, aTipText: AString, aTipDir: AString): void;
    /**
     * Called when the tooltip should be hidden, either because the pointer
     * has moved or the tooltip has timed out.
     */
    onHideTooltip(): void;
}

/**
 * An interface implemented by a tooltip text provider service. This
 * service is called to discover what tooltip text is associated
 * with the node that the pointer is positioned over.
 *
 * Embedders may implement and register their own tooltip text provider
 * service if they wish to provide different tooltip text.
 *
 * The default service returns the text stored in the TITLE
 * attribute of the node or a containing parent.
 *
 * @note
 * The tooltip text provider service is registered with the contract
 * defined in NS_TOOLTIPTEXTPROVIDER_CONTRACTID.
 *
 * @see nsITooltipListener
 * @see nsIComponentManager
 * @see Node
 */
declare interface nsITooltipTextProviderType extends nsISupportsType {
    /**
     * Called to obtain the tooltip text for a node.
     *
     * @arg aNode      The node to obtain the text from.
     * @arg aText      The tooltip text.
     * @arg aDirection The text direction (ltr or rtl) to use
     *
     * @return `PR_TRUE` if tooltip text is associated
     * with the node and was returned in the aText argument;
     * `PR_FALSE` otherwise.
     */
    getNodeText(aNode: Node, aText: wstring, aDirection: wstring): boolean;
}

/**
 * Back-to-frontend communication for the Touch Bar
 */
declare interface nsITouchBarHelperType extends nsISupportsType {
    /**
     * Returns the active browser's URL.
     */
    readonly activeUrl: AString;
    /**
     * Return the active browser's page title.
     */
    readonly activeTitle: AString;
    /**
     * Return true if the Urlbar has focus.
     */
    readonly isUrlbarFocused: boolean;
    /**
     * Toggles Urlbar focus.
     */
    toggleFocusUrlbar(): void;
    /**
     * Unfocuses the Urlbar.
     */
    unfocusUrlbar(): void;
    /**
     * Returns all available Touch Bar Inputs in an nsIArray
     * of nsITouchBarInput objects.
     */
    allItems: nsIArray;
    /**
     * The context in which this nsITouchBarHelper exists. Required to create
     * an imgLoader to load our SVG icons.
     */
    readonly document: Document;
    /**
     * Returns the requested TouchBarInput.
     * Exposed for testing.
     */
    getTouchBarInput(aInputName: string): nsITouchBarInput;
    /**
     * Inserts a search restriction string in the Urlbar.
     * Exposed for testing.
     */
    insertRestrictionInUrlbar(aToken: string): void;
}

/**
 *
 */
declare interface nsITouchBarInputCallbackType extends nsISupportsType {
    /**
     *
     */
    onCommand(): void;
}

/**
 * Implements an input to be registered on the Mac Touch Bar.
 */
declare interface nsITouchBarInputType extends nsISupportsType {
    /**
     *
     */
    readonly key: AString;
    /**
     * The lookup key for the button's localized text title.
     */
    title: AString;
    /**
     * The URI of an icon file.
     */
    image: nsIURI;
    /**
     * The type of the input.
     * Takes one of:
     * `button`:
     * A standard button.
     * If an image is available, only the image is displayed.
     * `mainButton`:
     * An extra-wide button. Displays both the image and title.
     * `scrubber`:
     * A Scrubber element. Not yet implemented, except in the case of Apple's
     * pre-built Share scrubber.
     * `popover`:
     * An element that displays a new instance of nsTouchBar when tapped.
     * The elements in the new Touch Bar should be defined in the
     * input's `children` property.
     * `label`:
     * A text label.
     * `scrollView`:
     * Contains several buttons, defined in the input's `children` property.
     * The user can scroll through the buttons.
     */
    type: AString;
    /**
     * A callback function to be invoked when an element is touched.
     */
    callback: nsITouchBarInputCallback;
    /**
     * A hexadecimal uint32_t specifying the input's
     * background color. If omitted, the default background color is used.
     */
    color: uint32_t;
    /**
     * If `true`, the Touch Bar input is greyed out and inoperable.
     */
    disabled: boolean;
    /**
     * An array containing an input's children.
     * Available for  type = ("scrollView" || "popover").
     */
    children: nsIArray;
}

/**
 * Front-to-backend communication to keep Touch Bar updated
 */
declare interface nsITouchBarUpdaterType extends nsISupportsType {
    /**
     * Updates an array of nsITouchBarInputs in the specified window.
     */
    updateTouchBarInputs(aWindow: nsIBaseWindowType, aInputs: invalid): void;
    /**
     * Enter the native Touch Bar customization window.
     */
    enterCustomizeMode(): void;
    /**
     * Checks if the user is using a Touch Bar-compatible Mac.
     */
    isTouchBarInitialized(): boolean;
    /**
     * Sets whether the Touch Bar is initialized.
     * NOTE: This method is for internal unit tests only! Normally, the system
     * sets this value after a Touch Bar is initialized on compatible Macs.
     */
    setTouchBarInitialized(aIsInitialized: boolean): void;
    /**
     * If aShowing is true, aPopover is shown. Otherwise, it is hidden.
     */
    showPopover(aWindow: nsIBaseWindowType, aPopover: nsITouchBarInputType, aShowing: boolean): void;
}

/**
 * A channel implementing this interface allows one to intercept its data by
 * inserting intermediate stream listeners.
 */
declare interface nsITraceableChannelType extends nsISupportsType {
    /**
     * Replace the channel's listener with a new one, and return the listener
     * the channel used to have. The new listener intercepts OnStartRequest,
     * OnDataAvailable and OnStopRequest calls and must pass them to
     * the original listener after examination. If multiple callers replace
     * the channel's listener, a chain of listeners is created.
     * The caller of setNewListener has no way to control at which place
     * in the chain its listener is placed.
     *
     * @param aMustApplyContentConversion Pass true if the new listener requires
     * content conversion to already be applied by the channel.
     *
     * Note: The caller of setNewListener must not delay passing
     * OnStartRequest to the original listener.
     *
     * Note2: A channel may restrict when the listener can be replaced.
     * It is not recommended to allow listener replacement after OnStartRequest
     * has been called.
     */
    setNewListener(aListener: nsIStreamListenerType, aMustApplyContentConversion: boolean): nsIStreamListener;
}

/**
 *
 */
declare interface nsITrackingDBServiceType extends nsISupportsType {
    /**
     * Record entries from a content blocking log in the tracking database.
     * This function is typically called at the end of the document lifecycle,
     * since calling it multiple times results in multiple new entries.
     *
     * @param data    a json string containing the content blocking log.
     */
    recordContentBlockingLog(data: ACString): void;
    /**
     * Save new events in the content blocking database
     * @param data    a json string containing the content blocking log.
     */
    saveEvents(data: AString): Promise;
    /**
     * Clear all content blocking database entries.
     */
    clearAll(): Promise;
    /**
     * Clear all content blocking database entries added since the specified time.
     * @param since   a unix timestamp representing the number of milliseconds from
     * Jan 1, 1970 00:00:00 UTC.
     */
    clearSince(since: int64_t): Promise;
    /**
     * Fetch events from the content blocking database
     * @param dateFrom   a unix timestamp.
     * @param dateTo     a unix timestamp.
     */
    getEventsByDateRange(dateFrom: int64_t, dateTo: int64_t): Promise;
    /**
     * Return a count of all tracking events.
     */
    sumAllEvents(): Promise;
    /**
     * Return the earliest recorded date.
     */
    getEarliestRecordedDate(): Promise;
}

/**
 * The nsITransaction interface.
 *
 *
 * This interface is implemented by an object that needs to
 * execute some behavior that must be tracked by the transaction manager.
 */
declare interface nsITransactionType extends nsISupportsType {
    /**
     * Executes the transaction.
     */
    doTransaction(): void;
    /**
     * Restores the state to what it was before the transaction was executed.
     */
    undoTransaction(): void;
    /**
     * Executes the transaction again. Can only be called on a transaction that
     * was previously undone.
     *
     *
     * In most cases, the redoTransaction() method will actually call the
     * doTransaction() method to execute the transaction again.
     */
    redoTransaction(): void;
    /**
     * The transaction's transient state. This attribute is checked by
     * the transaction manager after the transaction's Execute() method is called.
     * If the transient state is false, a reference to the transaction is
     * held by the transaction manager so that the transactions' undoTransaction()
     * and redoTransaction() methods can be called. If the transient state is
     * true, the transaction manager returns immediately after the transaction's
     * doTransaction() method is called, no references to the transaction are
     * maintained. Transient transactions cannot be undone or redone by the
     * transaction manager.
     */
    readonly isTransient: boolean;
    /**
     * Attempts to merge a transaction into "this" transaction. Both transactions
     * must be in their undo state, doTransaction() methods already called. The
     * transaction manager calls this method to coalesce a new transaction with
     * the transaction on the top of the undo stack.
     * This method returns a boolean value that indicates the merge result.
     * A true value indicates that the transactions were merged successfully,
     * a false value if the merge was not possible or failed. If true,
     * the transaction manager will Release() the new transacton instead of
     * pushing it on the undo stack.
     * @param aTransaction the previously executed transaction to merge.
     */
    merge(aTransaction: nsITransactionType): boolean;
}

/**
 * The nsITransactionManager interface.
 *
 *
 * This interface is implemented by an object that wants to
 * manage/track transactions.
 */
declare interface nsITransactionManagerType extends nsISupportsType {
    /**
     * Calls a transaction's doTransaction() method, then pushes it on the
     * undo stack.
     *
     *
     * This method calls the transaction's AddRef() method.
     * The transaction's Release() method will be called when the undo or redo
     * stack is pruned or when the transaction manager is destroyed.
     * @param aTransaction the transaction to do.
     */
    doTransaction(aTransaction: nsITransactionType): void;
    /**
     * Pops the topmost transaction on the undo stack, calls its
     * undoTransaction() method, then pushes it on the redo stack.
     */
    undoTransaction(): void;
    /**
     * Pops the topmost transaction on the redo stack, calls its
     * redoTransaction() method, then pushes it on the undo stack.
     */
    redoTransaction(): void;
    /**
     * Clears the undo and redo stacks.
     */
    clear(): void;
    /**
     * Clears the undo stack only.
     */
    clearUndoStack(): void;
    /**
     * Clears the redo stack only.
     */
    clearRedoStack(): void;
    /**
     * Turns on the transaction manager's batch mode, forcing all transactions
     * executed by the transaction manager's doTransaction() method to be
     * aggregated together until EndBatch() is called.  This mode allows an
     * application to execute and group together several independent transactions
     * so they can be undone with a single call to undoTransaction().
     * @param aData An arbitrary nsISupports object that is associated with the
     * batch. Can be retrieved from the undo or redo stacks.
     */
    beginBatch(aData: nsISupportsType): void;
    /**
     * Turns off the transaction manager's batch mode.
     * @param aAllowEmpty If true, a batch containing no children will be
     * pushed onto the undo stack. Otherwise, ending a batch with no
     * children will result in no transactions being pushed on the undo stack.
     */
    endBatch(aAllowEmpty: boolean): void;
    /**
     * The number of items on the undo stack.
     */
    readonly numberOfUndoItems: long;
    /**
     * The number of items on the redo stack.
     */
    readonly numberOfRedoItems: long;
    /**
     * Sets the maximum number of transaction items the transaction manager will
     * maintain at any time. This is commonly referred to as the number of levels
     * of undo.
     * @param aMaxCount A value of -1 means no limit. A value of zero means the
     * transaction manager will execute each transaction, then immediately release
     * all references it has to the transaction without pushing it on the undo
     * stack. A value greater than zero indicates the max number of transactions
     * that can exist at any time on both the undo and redo stacks. This method
     * will prune the necessary number of transactions on the undo and redo
     * stacks if the value specified is less than the number of items that exist
     * on both the undo and redo stacks.
     */
    maxTransactionCount: long;
    /**
     * Combines the transaction at the top of the undo stack (if any) with the
     * preceding undo transaction (if any) into a batch transaction. Thus,
     * a call to undoTransaction() will undo both transactions.
     */
    batchTopUndo(): void;
    /**
     * Removes the transaction at the top of the undo stack (if any) without
     * transacting.
     */
    removeTopUndo(): void;
    /**
     * Returns an AddRef'd pointer to the transaction at the top of the
     * undo stack. Callers should be aware that this method could return
     * return a null in some implementations if there is a batch at the top
     * of the undo stack.
     */
    peekUndoStack(): nsITransaction;
    /**
     * Returns an AddRef'd pointer to the transaction at the top of the
     * redo stack. Callers should be aware that this method could return
     * return a null in some implementations if there is a batch at the top
     * of the redo stack.
     */
    peekRedoStack(): nsITransaction;
}

/**
 *
 */
declare interface nsITransferType extends nsIWebProgressListener2Type {
    /**
     * Initializes the transfer with certain properties.  This function must
     * be called prior to accessing any properties on this interface.
     *
     * @param aSource The source URI of the transfer. Must not be null.
     *
     * @param aSourceOriginalURI The original URI of the transfer in case
     * aSource is a blob URL. Can be null.
     *
     * @param aTarget The target URI of the transfer. Must not be null.
     *
     * @param aDisplayName The user-readable description of the transfer.
     * Can be empty.
     *
     * @param aMIMEInfo The MIME info associated with the target,
     * including MIME type and helper app when appropriate.
     * This parameter is optional.
     *
     * @param startTime Time when the download started (ie, when the first
     * response from the server was received)
     * XXX presumably wbp and exthandler do this differently
     *
     * @param aTempFile The location of a temporary file; i.e. a file in which
     * the received data will be stored, but which is not
     * equal to the target file. (will be moved to the real
     * target by the caller, when the download is finished)
     * May be null.
     *
     * @param aCancelable An object that can be used to abort the download.
     * Must not be null.
     * Implementations are expected to hold a strong
     * reference to this object until the download is
     * finished, at which point they should release the
     * reference.
     *
     * @param aIsPrivate Used to determine the privacy status of the new transfer.
     * If true, indicates that the transfer was initiated from
     * a source that desires privacy.
     *
     * @param aDownloadClassification Indicates wheter the download is unwanted,
     * should be considered dangerous or insecure.
     *
     * @param aReferrerInfo The Referrer this download is started with
     *
     * @param aOpenDownloadsListOnStart true (default) - Open downloads panel.
     * false - Only show an icon indicator.
     * This parameter is optional.
     */
    init(aSource: nsIURIType, aSourceOriginalURI: nsIURIType, aTarget: nsIURIType, aDisplayName: AString, aMIMEInfo: nsIMIMEInfoType, startTime: PRTime, aTempFile: nsIFileType, aCancelable: nsICancelableType, aIsPrivate: boolean, aDownloadClassification: long, aReferrerInfo: nsIReferrerInfoType, aOpenDownloadsListOnStart: boolean): void;
    /**
     * Same as init, but allows for passing the browsingContext
     * which will allow for opening the download with the same
     * userContextId and auth header.
     *
     * @param aBrowsingContext BrowsingContext of the initiating document.
     *
     * @param aHandleInternally Set to true if the download should be opened within
     * the browser.
     * @param aHttpChannel Channel of the initiating document.
     */
    initWithBrowsingContext(aSource: nsIURIType, aTarget: nsIURIType, aDisplayName: AString, aMIMEInfo: nsIMIMEInfoType, startTime: PRTime, aTempFile: nsIFileType, aCancelable: nsICancelableType, aIsPrivate: boolean, aDownloadClassification: long, aReferrerInfo: nsIReferrerInfoType, aOpenDownloadsListOnStart: boolean, aBrowsingContext: BrowsingContext, aHandleInternally: boolean, aHttpChannel: nsIHttpChannelType): void;
    /**
     * Used to notify the transfer object of the hash of the downloaded file.
     * Must be called on the main thread, only after the download has finished
     * successfully.
     * @param aHash The SHA-256 hash in raw bytes of the downloaded file.
     */
    setSha256Hash(aHash: ACString): void;
    /**
     * Used to notify the transfer object of the signature of the downloaded
     * file.  Must be called on the main thread, only after the download has
     * finished successfully.
     * @param aSignatureInfo The Array of Array of Array of bytes
     * certificates of the downloaded file.
     */
    setSignatureInfo(aSignatureInfo: invalid): void;
    /**
     * Used to notify the transfer object of the redirects associated with the
     * channel that terminated in the downloaded file.  Must be called on the
     * main thread, only after the download has finished successfully.
     * @param aRedirects The nsIArray of nsIPrincipal of redirected URIs
     * associated with the downloaded file.
     */
    setRedirects(aRedirects: nsIArrayType): void;
}

/**
 *
 */
declare interface nsIFlavorDataProviderType extends nsISupportsType {
    /**
     * Retrieve the data from this data provider.
     *
     * @param  aTransferable (in parameter) the transferable we're being called for.
     * @param  aFlavor (in parameter) the flavor of data to retrieve
     * @param  aData the data. Some variant of class in nsISupportsPrimitives.idl
     */
    getFlavorData(aTransferable: nsITransferableType, aFlavor: string, aData: nsISupportsType): void;
}

/**
 *
 */
declare interface nsITransferableType extends nsISupportsType {
    /**
     * Initializes a transferable object.  This should be called on all
     * transferable objects.  Failure to do so will result in fatal assertions in
     * debug builds.
     *
     * The load context is used to track whether the transferable is storing privacy-
     * sensitive information.
     *
     * To get the appropriate load context in Javascript callers, one needs to get
     * to the document that the transferable corresponds to, and then get the load
     * context from the document like this:
     *
     * var loadContext = doc.defaultView.docShell
     * .QueryInterface(Ci.nsILoadContext);
     *
     * In C++ callers, if you have the corresponding document, you can just call
     * Document::GetLoadContext to get to the load context object.
     *
     * @param aContext the load context associated with the transferable object.
     * This can be set to null if a load context is not available.
     */
    init(aContext: nsILoadContextType): void;
    /**
     * Given a flavor retrieve the data.
     *
     * @param  aFlavor (in parameter) the flavor of data to retrieve
     * @param  aData the data. Some variant of class in nsISupportsPrimitives.idl
     */
    getTransferData(aFlavor: string, aData: nsISupportsType): void;
    /**
     * Returns the first flavor which has data.
     *
     * @param  aFlavor (out parameter) the flavor of data that was retrieved
     * @param  aData the data. Some variant of class in nsISupportsPrimitives.idl
     */
    getAnyTransferData(aFlavor: ACString, aData: nsISupportsType): void;
    /**
     * Sets the data in the transferable with the specified flavor. The transferable
     * will maintain its own copy the data, so it is not necessary to do that beforehand.
     *
     * @param  aFlavor the flavor of data that is being set
     * @param  aData the data, either some variant of class in nsISupportsPrimitives.idl,
     * an nsIFile, or an nsIFlavorDataProvider (see above)
     */
    setTransferData(aFlavor: string, aData: nsISupportsType): void;
    /**
     * Add the data flavor, indicating that this transferable
     * can receive this type of flavor
     *
     * @param  aDataFlavor a new data flavor to handle
     */
    addDataFlavor(aDataFlavor: string): void;
    /**
     * Removes the data flavor matching the given one (string compare) and the data
     * that goes along with it.
     *
     * @param  aDataFlavor a data flavor to remove
     */
    removeDataFlavor(aDataFlavor: string): void;
    /**
     *
     */
    converter: nsIFormatConverter;
    /**
     * Use of the SetIsPrivateData() method generated by isPrivateData attribute should
     * be avoided as much as possible because the value set may not reflect the status
     * of the context in which the transferable was created.
     */
    isPrivateData: boolean;
    /**
     * The principal of the source dom node this transferable was
     * created from and the contentPolicyType for the transferable.
     * Note, currently only used on Windows for network principal and
     * contentPolicyType information in clipboard and drag operations.
     */
    requestingPrincipal: nsIPrincipal;
    /**
     *
     */
    contentPolicyType: nsContentPolicyType;
    /**
     * The cookieJarSettings of the source dom node this transferable was created
     * from.
     */
    cookieJarSettings: nsICookieJarSettings;
    /**
     * Used for initializing the referrer when downloading a file promise.
     */
    referrerInfo: nsIReferrerInfo;
}

/**
 * nsITransport
 *
 * This interface provides a common way of accessing i/o streams connected
 * to some resource.  This interface does not in any way specify the resource.
 * It provides methods to open blocking or non-blocking, buffered or unbuffered
 * streams to the resource.  The name "transport" is meant to connote the
 * inherent data transfer implied by this interface (i.e., data is being
 * transfered in some fashion via the streams exposed by this interface).
 *
 * A transport can have an event sink associated with it.  The event sink
 * receives transport-specific events as the transfer is occuring.  For a
 * socket transport, these events can include status about the connection.
 * See nsISocketTransport for more info about socket transport specifics.
 */
declare interface nsITransportType extends nsISupportsType {
    /**
     * Open an input stream on this transport.
     *
     * Flags have the following meaning:
     *
     * OPEN_BLOCKING
     * If specified, then the resulting stream will have blocking stream
     * semantics.  This means that if the stream has no data and is not
     * closed, then reading from it will block the calling thread until
     * at least one byte is available or until the stream is closed.
     * If this flag is NOT specified, then the stream has non-blocking
     * stream semantics.  This means that if the stream has no data and is
     * not closed, then reading from it returns NS_BASE_STREAM_WOULD_BLOCK.
     * In addition, in non-blocking mode, the stream is guaranteed to
     * support nsIAsyncInputStream.  This interface allows the consumer of
     * the stream to be notified when the stream can again be read.
     *
     * OPEN_UNBUFFERED
     * If specified, the resulting stream may not support ReadSegments.
     * ReadSegments is only gauranteed to be implemented when this flag is
     * NOT specified.
     *
     * @param aFlags
     * optional transport specific flags.
     * @param aSegmentSize
     * if OPEN_UNBUFFERED is not set, then this parameter specifies the
     * size of each buffer segment (pass 0 to use default value).
     * @param aSegmentCount
     * if OPEN_UNBUFFERED is not set, then this parameter specifies the
     * maximum number of buffer segments (pass 0 to use default value).
     */
    openInputStream(aFlags: unsigned_long, aSegmentSize: unsigned_long, aSegmentCount: unsigned_long): nsIInputStream;
    /**
     * Open an output stream on this transport.
     *
     * Flags have the following meaning:
     *
     * OPEN_BLOCKING
     * If specified, then the resulting stream will have blocking stream
     * semantics.  This means that if the stream is full and is not closed,
     * then writing to it will block the calling thread until ALL of the
     * data can be written or until the stream is closed.  If this flag is
     * NOT specified, then the stream has non-blocking stream semantics.
     * This means that if the stream is full and is not closed, then writing
     * to it returns NS_BASE_STREAM_WOULD_BLOCK.  In addition, in non-
     * blocking mode, the stream is guaranteed to support
     * nsIAsyncOutputStream.  This interface allows the consumer of the
     * stream to be notified when the stream can again accept more data.
     *
     * OPEN_UNBUFFERED
     * If specified, the resulting stream may not support WriteSegments and
     * WriteFrom.  WriteSegments and WriteFrom are only guaranteed to be
     * implemented when this flag is NOT specified.
     *
     * @param aFlags
     * optional transport specific flags.
     * @param aSegmentSize
     * if OPEN_UNBUFFERED is not set, then this parameter specifies the
     * size of each buffer segment (pass 0 to use default value).
     * @param aSegmentCount
     * if OPEN_UNBUFFERED is not set, then this parameter specifies the
     * maximum number of buffer segments (pass 0 to use default value).
     */
    openOutputStream(aFlags: unsigned_long, aSegmentSize: unsigned_long, aSegmentCount: unsigned_long): nsIOutputStream;
    /**
     * Close the transport and any open streams.
     *
     * @param aReason
     * the reason for closing the stream.
     */
    close(aReason: nsresult): void;
    /**
     * Set the transport event sink.
     *
     * @param aSink
     * receives transport layer notifications
     * @param aEventTarget
     * indicates the event target to which the notifications should
     * be delivered.  if NULL, then the notifications may occur on
     * any thread.
     */
    setEventSink(aSink: nsITransportEventSinkType, aEventTarget: nsIEventTargetType): void;
}

/**
 *
 */
declare interface nsITransportEventSinkType extends nsISupportsType {
    /**
     * Transport status notification.
     *
     * @param aTransport
     * the transport sending this status notification.
     * @param aStatus
     * the transport status. See nsISocketTransport for socket specific
     * status codes and more comments.
     * @param aProgress
     * the amount of data either read or written depending on the value
     * of the status code.  this value is relative to aProgressMax.
     * @param aProgressMax
     * the maximum amount of data that will be read or written.  if
     * unknown, -1 will be passed.
     */
    onTransportStatus(aTransport: nsITransportType, aStatus: nsresult, aProgress: long_long, aProgressMax: long_long): void;
}

/**
 * An interface which can be used to asynchronously request a nsITransport
 * together with the input and output streams that go together with it.
 */
declare interface nsITransportProviderType extends nsISupportsType {
    /**
     *
     */
    setListener(listener: nsIHttpUpgradeListenerType): void;
}

/**
 *
 */
declare interface nsITransportSecurityInfoType extends nsISupportsType {
    /**
     *
     */
    readonly securityState: unsigned_long;
    /**
     *
     */
    readonly errorCode: long;
    /**
     *
     */
    readonly errorCodeString: AString;
    /**
     *
     */
    readonly serverCert: nsIX509Cert;
    /**
     *
     */
    readonly cipherName: ACString;
    /**
     *
     */
    readonly keyLength: unsigned_long;
    /**
     *
     */
    readonly secretKeyLength: unsigned_long;
    /**
     *
     */
    readonly keaGroupName: ACString;
    /**
     *
     */
    readonly signatureSchemeName: ACString;
    /**
     *
     */
    readonly protocolVersion: unsigned_short;
    /**
     *
     */
    readonly certificateTransparencyStatus: unsigned_short;
    /**
     *
     */
    readonly isAcceptedEch: boolean;
    /**
     *
     */
    readonly isDelegatedCredential: boolean;
    /**
     *
     */
    readonly overridableErrorCategory: nsITransportSecurityInfo_OverridableErrorCategory;
    /**
     * True if OCSP requests were made to query the status of certificates
     * used in this connection.
     */
    readonly madeOCSPRequests: boolean;
    /**
     * True if the DNS record used for this connection was fetched over an encrypted connection.
     */
    readonly usedPrivateDNS: boolean;
    /**
     * True only if (and after) serverCert was successfully validated as
     * Extended Validation (EV).
     */
    readonly isExtendedValidation: boolean;
    /**
     * Serializes the data represented in this interface to a base64-encoded
     * string that can be deserialized using TransportSecurityInfo::Read.
     */
    toString(): ACString;
    /**
     * negotiatedNPN is '' if no NPN list was provided by the client,
     * or if the server did not select any protocol choice from that
     * list. That also includes the case where the server does not
     * implement NPN.
     *
     * If negotiatedNPN is read before NPN has progressed to the point
     * where this information is available NS_ERROR_NOT_CONNECTED is
     * raised.
     */
    readonly negotiatedNPN: ACString;
    /**
     * True iff the connection was resumed using the resumption token.
     */
    readonly resumed: boolean;
    /**
     * True iff the succeededCertChain is built in root.
     */
    readonly isBuiltCertChainRootBuiltInRoot: boolean;
    /**
     * The id used to uniquely identify the connection to the peer.
     */
    readonly peerId: ACString;
}

/**
 *
 */
declare interface nsITreeSelectionType extends nsISupportsType {
    /**
     * The tree widget for this selection.
     */
    tree: XULTreeElement;
    /**
     * This attribute is a boolean indicating single selection.
     */
    readonly single: boolean;
    /**
     * The number of rows currently selected in this tree.
     */
    readonly count: long;
    /**
     * Indicates whether or not the row at the specified index is
     * part of the selection.
     */
    isSelected(index: long): boolean;
    /**
     * Deselect all rows and select the row at the specified index.
     */
    select(index: long): void;
    /**
     * Perform a timed select.
     */
    timedSelect(index: long, delay: long): void;
    /**
     * Toggle the selection state of the row at the specified index.
     */
    toggleSelect(index: long): void;
    /**
     * Select the range specified by the indices.  If augment is true,
     * then we add the range to the selection without clearing out anything
     * else.  If augment is false, everything is cleared except for the specified range.
     */
    rangedSelect(startIndex: long, endIndex: long, augment: boolean): void;
    /**
     * Clears the range.
     */
    clearRange(startIndex: long, endIndex: long): void;
    /**
     * Clears the selection.
     */
    clearSelection(): void;
    /**
     * Selects all rows.
     */
    selectAll(): void;
    /**
     * Iterate the selection using these methods.
     */
    getRangeCount(): long;
    /**
     *
     */
    getRangeAt(i: long, min: long, max: long): void;
    /**
     * Can be used to invalidate the selection.
     */
    invalidateSelection(): void;
    /**
     * Called when the row count changes to adjust selection indices.
     */
    adjustSelection(index: long, count: long): void;
    /**
     * This attribute is a boolean indicating whether or not the
     * "select" event should fire when the selection is changed using
     * one of our methods.  A view can use this to temporarily suppress
     * the selection while manipulating all of the indices, e.g., on
     * a sort.
     * Note: setting this attribute to false will fire a select event.
     */
    selectEventsSuppressed: boolean;
    /**
     * The current item (the one that gets a focus rect in addition to being
     * selected).
     */
    currentIndex: long;
    /**
     * The selection "pivot".  This is the first item the user selected as
     * part of a ranged select.
     */
    readonly shiftSelectPivot: long;
}

/**
 * The following interface is not scriptable and MUST NEVER BE MADE scriptable.
 * Native treeselections implement it, and we use this to check whether a
 * treeselection is native (and therefore suitable for use by untrusted content).
 */
declare interface nsINativeTreeSelectionType extends nsITreeSelectionType {
}

/**
 *
 */
declare interface nsITreeViewType extends nsISupportsType {
    /**
     * The total number of rows in the tree (including the offscreen rows).
     */
    readonly rowCount: long;
    /**
     * The selection for this view.
     */
    selection: nsITreeSelection;
    /**
     * A whitespace delimited list of properties.  For each property X the view
     * gives back will cause the pseudoclasses  ::-moz-tree-cell(x),
     * ::-moz-tree-row(x), ::-moz-tree-twisty(x), ::-moz-tree-image(x),
     * ::-moz-tree-cell-text(x).  to be matched on the pseudoelement
     * ::moz-tree-row.
     */
    getRowProperties(index: long): AString;
    /**
     * A whitespace delimited list of properties for a given cell.  Each
     * property, x, that the view gives back will cause the pseudoclasses
     * ::-moz-tree-cell(x), ::-moz-tree-row(x), ::-moz-tree-twisty(x),
     * ::-moz-tree-image(x), ::-moz-tree-cell-text(x). to be matched on the
     * cell.
     */
    getCellProperties(row: long, col: TreeColumn): AString;
    /**
     * Called to get properties to paint a column background.  For shading the sort
     * column, etc.
     */
    getColumnProperties(col: TreeColumn): AString;
    /**
     * Methods that can be used to test whether or not a twisty should be drawn,
     * and if so, whether an open or closed twisty should be used.
     */
    isContainer(index: long): boolean;
    /**
     *
     */
    isContainerOpen(index: long): boolean;
    /**
     *
     */
    isContainerEmpty(index: long): boolean;
    /**
     * isSeparator is used to determine if the row at index is a separator.
     * A value of true will result in the tree drawing a horizontal separator.
     * The tree uses the ::moz-tree-separator pseudoclass to draw the separator.
     */
    isSeparator(index: long): boolean;
    /**
     * Specifies if there is currently a sort on any column. Used mostly by dragdrop
     * to affect drop feedback.
     */
    isSorted(): boolean;
    /**
     * Methods used by the drag feedback code to determine if a drag is allowable at
     * the current location. To get the behavior where drops are only allowed on
     * items, such as the mailNews folder pane, always return false when
     * the orientation is not DROP_ON.
     */
    canDrop(index: long, orientation: long, dataTransfer: DataTransfer): boolean;
    /**
     * Called when the user drops something on this view. The |orientation| param
     * specifies before/on/after the given |row|.
     */
    drop(row: long, orientation: long, dataTransfer: DataTransfer): void;
    /**
     * Methods used by the tree to draw thread lines in the tree.
     * getParentIndex is used to obtain the index of a parent row.
     * If there is no parent row, getParentIndex returns -1.
     */
    getParentIndex(rowIndex: long): long;
    /**
     * hasNextSibling is used to determine if the row at rowIndex has a nextSibling
     * that occurs *after* the index specified by afterIndex.  Code that is forced
     * to march down the view looking at levels can optimize the march by starting
     * at afterIndex+1.
     */
    hasNextSibling(rowIndex: long, afterIndex: long): boolean;
    /**
     * The level is an integer value that represents
     * the level of indentation.  It is multiplied by the width specified in the
     * :moz-tree-indentation pseudoelement to compute the exact indendation.
     */
    getLevel(index: long): long;
    /**
     * The image path for a given cell. For defining an icon for a cell.
     * If the empty string is returned, the :moz-tree-image pseudoelement
     * will be used.
     */
    getImageSrc(row: long, col: TreeColumn): AString;
    /**
     * The value for a given cell. This method is only called for columns
     * of type other than |text|.
     */
    getCellValue(row: long, col: TreeColumn): AString;
    /**
     * The text for a given cell.  If a column consists only of an image, then
     * the empty string is returned.
     */
    getCellText(row: long, col: TreeColumn): AString;
    /**
     * Called during initialization to link the view to the front end box object.
     */
    setTree(tree: XULTreeElement): void;
    /**
     * Called on the view when an item is opened or closed.
     */
    toggleOpenState(index: long): void;
    /**
     * Called on the view when a header is clicked.
     */
    cycleHeader(col: TreeColumn): void;
    /**
     * Should be called from a XUL onselect handler whenever the selection changes.
     */
    selectionChanged(): void;
    /**
     * Called on the view when a cell in a non-selectable cycling column (e.g., unread/flag/etc.) is clicked.
     */
    cycleCell(row: long, col: TreeColumn): void;
    /**
     * isEditable is called to ask the view if the cell contents are editable.
     * A value of true will result in the tree popping up a text field when
     * the user tries to inline edit the cell.
     */
    isEditable(row: long, col: TreeColumn): boolean;
    /**
     * setCellValue is called when the value of the cell has been set by the user.
     * This method is only called for columns of type other than |text|.
     */
    setCellValue(row: long, col: TreeColumn, value: AString): void;
    /**
     * setCellText is called when the contents of the cell have been edited by the user.
     */
    setCellText(row: long, col: TreeColumn, value: AString): void;
}

/**
 * **************************** nsTypeAheadFind *****************************
 */
declare interface nsITypeAheadFindType extends nsISupportsType {
    /**
     * **************************** Initializer *****************************
     *
     * Necessary initialization that can't happen in the constructor, either
     * because function calls here may fail, or because the docShell is
     * required.
     */
    init(aDocShell: nsIDocShellType): void;
    /**
     * *************************** Core functions ***************************
     *
     * Find aSearchString in page.  If aLinksOnly is true, only search the page's
     * hyperlinks for the string.
     */
    find(aSearchString: AString, aLinksOnly: boolean, aMode: unsigned_long, aDontIterateFrames: boolean): unsigned_short;
    /**
     * Return the range of the most recent match.
     */
    getFoundRange(): Range;
    /**
     * ************************** Helper functions **************************
     *
     * Change searched docShell.  This happens when e.g. we use the same
     * nsITypeAheadFind object to search different tabs.
     */
    setDocShell(aDocShell: nsIDocShellType): void;
    /**
     * Change the look of the the "found match" selection to aToggle, and repaint
     * the selection.
     */
    setSelectionModeAndRepaint(toggle: short): void;
    /**
     * Collapse the "found match" selection to its start.  Because not all
     * matches are owned by the same selection controller, this doesn't
     * necessarily happen automatically.
     */
    collapseSelection(): void;
    /**
     * Check if a range is visible using heuristics
     */
    isRangeVisible(aRange: Range, aMustBeInViewPort: boolean): boolean;
    /**
     * Check if a range is actually rendered (out of viewport always false)
     */
    isRangeRendered(aRange: Range): boolean;
    /**
     * ***************************** Attributes *****************************
     */
    readonly searchString: AString;
    /**
     *
     */
    caseSensitive: boolean;
    /**
     *
     */
    matchDiacritics: boolean;
    /**
     *
     */
    entireWord: boolean;
    /**
     *
     */
    readonly foundLink: Element;
    /**
     *
     */
    readonly foundEditable: Element;
    /**
     *
     */
    readonly currentWindow: mozIDOMWindow;
}

/**
 * TODO(1737205,1819414) Fold this interface into nsIWebAuthnController when we
 * remove the legacy U2F DOM API.
 *
 * nsIU2FTokenManager
 *
 * An interface to the U2FTokenManager singleton.
 *
 * This should be used only by the WebAuthn browser UI prompts.
 */
declare interface nsIU2FTokenManagerType extends nsISupportsType {
    /**
     * Resumes the current WebAuthn/U2F transaction if that matches the given
     * transaction ID. This is used only when direct attestation was requested
     * and we have to wait for user input to proceed.
     *
     * @param aTransactionID : The ID of the transaction to resume.
     * @param aForceNoneAttestation : The user might enforce none attestation.
     */
    resumeRegister(aTransactionID: uint64_t, aForceNoneAttestation: bool): void;
    /**
     * Cancels the current WebAuthn/U2F transaction if that matches the given
     * transaction ID.
     *
     * @param aTransactionID : The ID of the transaction to cancel.
     */
    cancel(aTransactionID: uint64_t): void;
}

/**
 * nsIUDPSocket
 *
 * An interface to a UDP socket that can accept incoming connections.
 */
declare interface nsIUDPSocketType extends nsISupportsType {
    /**
     * init
     *
     * This method initializes a UDP socket.
     *
     * @param aPort
     * The port of the UDP socket.  Pass -1 to indicate no preference,
     * and a port will be selected automatically.
     * @param aLoopbackOnly
     * If true, the UDP socket will only respond to connections on the
     * local loopback interface.  Otherwise, it will accept connections
     * from any interface.  To specify a particular network interface,
     * use initWithAddress.
     * @param aPrincipal
     * The principal connected to this socket.
     * @param aAddressReuse
     * If true, the socket is allowed to be bound to an address that is
     * already in use. Default is true.
     */
    init(aPort: long, aLoopbackOnly: boolean, aPrincipal: nsIPrincipalType, aAddressReuse: boolean): void;
    /**
     *
     */
    init2(aAddr: AUTF8String, aPort: long, aPrincipal: nsIPrincipalType, aAddressReuse: boolean): void;
    /**
     * close
     *
     * This method closes a UDP socket.  This does not affect already
     * connected client sockets (i.e., the nsISocketTransport instances
     * created from this UDP socket).  This will cause the onStopListening
     * event to asynchronously fire with a status of NS_BINDING_ABORTED.
     */
    close(): void;
    /**
     * asyncListen
     *
     * This method puts the UDP socket in the listening state.  It will
     * asynchronously listen for and accept client connections.  The listener
     * will be notified once for each client connection that is accepted.  The
     * listener's onSocketAccepted method will be called on the same thread
     * that called asyncListen (the calling thread must have a nsIEventTarget).
     *
     * The listener will be passed a reference to an already connected socket
     * transport (nsISocketTransport).  See below for more details.
     *
     * @param aListener
     * The listener to be notified when client connections are accepted.
     */
    asyncListen(aListener: nsIUDPSocketListenerType): void;
    /**
     * This adds a nsIUDPSocketSyncListener listener (defined below).
     * When data is available onPacketReceived is called and the lisener uses
     * recvWithAddr to actually retrive data from the socket.
     * The listener can be use only if it runs on the socket thread.
     * If it is used off the socket thread there is a risk of triggering a bug
     * in OS thatcan cause a crash.
     */
    syncListen(aListener: nsIUDPSocketSyncListenerType): void;
    /**
     * connect
     *
     * This method connects the UDP socket to a remote UDP address.
     *
     * @param aRemoteAddr
     * The remote address to connect to
     */
    connect(aAddr: NetAddrPtr): void;
    /**
     * Returns the local address of this UDP socket
     */
    readonly localAddr: nsINetAddr;
    /**
     * Returns the port of this UDP socket.
     */
    readonly port: long;
    /**
     * send
     *
     * Send out the datagram to specified remote host and port.
     * DNS lookup will be triggered.
     *
     * @param host The remote host name.
     * @param port The remote port.
     * @param data The buffer containing the data to be written.
     * @return number of bytes written. (0 or length of data)
     */
    send(host: AUTF8String, port: unsigned_short, data: invalid): unsigned_long;
    /**
     * sendWithAddr
     *
     * Send out the datagram to specified remote host and port.
     *
     * @param addr The remote host address.
     * @param data The buffer containing the data to be written.
     * @return number of bytes written. (0 or length of data)
     */
    sendWithAddr(addr: nsINetAddrType, data: invalid): unsigned_long;
    /**
     * sendBinaryStream
     *
     * Send out the datagram to specified remote address and port.
     *
     * @param host The remote host name.
     * @param port The remote port.
     * @param stream The input stream to be sent. This must be a buffered stream implementation.
     */
    sendBinaryStream(host: AUTF8String, port: unsigned_short, stream: nsIInputStreamType): void;
    /**
     * sendBinaryStreamWithAddress
     *
     * Send out the datagram to specified remote address and port.
     *
     * @param addr The remote host address.
     * @param stream The input stream to be sent. This must be a buffered stream implementation.
     */
    sendBinaryStreamWithAddress(addr: NetAddrPtr, stream: nsIInputStreamType): void;
    /**
     * joinMulticast
     *
     * Join the multicast group specified by |addr|.  You are then able to
     * receive future datagrams addressed to the group.
     *
     * @param addr
     * The multicast group address.
     * @param iface
     * The local address of the interface on which to join the group.  If
     * this is not specified, the OS may join the group on all interfaces
     * or only the primary interface.
     */
    joinMulticast(addr: AUTF8String, iface: AUTF8String): void;
    /**
     * leaveMulticast
     *
     * Leave the multicast group specified by |addr|.  You will no longer
     * receive future datagrams addressed to the group.
     *
     * @param addr
     * The multicast group address.
     * @param iface
     * The local address of the interface on which to leave the group.
     * If this is not specified, the OS may leave the group on all
     * interfaces or only the primary interface.
     */
    leaveMulticast(addr: AUTF8String, iface: AUTF8String): void;
    /**
     * multicastLoopback
     *
     * Whether multicast datagrams sent via this socket should be looped back to
     * this host (assuming this host has joined the relevant group).  Defaults
     * to true.
     * Note: This is currently write-only.
     */
    multicastLoopback: boolean;
    /**
     * multicastInterface
     *
     * The interface that should be used for sending future multicast datagrams.
     * Note: This is currently write-only.
     */
    multicastInterface: AUTF8String;
    /**
     * multicastInterfaceAddr
     *
     * The interface that should be used for sending future multicast datagrams.
     * Note: This is currently write-only.
     */
    multicastInterfaceAddr: NetAddr;
    /**
     * recvBufferSize
     *
     * The size of the receive buffer. Default depends on the OS.
     */
    recvBufferSize: long;
    /**
     * sendBufferSize
     *
     * The size of the send buffer. Default depends on the OS.
     */
    sendBufferSize: long;
    /**
     * dontFragment
     *
     * The don't fragment flag.
     * The socket must be initialized before calling this function.
     */
    dontFragment: boolean;
}

/**
 * nsIUDPSocketListener
 *
 * This interface is notified whenever a UDP socket accepts a new connection.
 * The transport is in the connected state, and read/write streams can be opened
 * using the normal nsITransport API.  The address of the client can be found by
 * calling the nsISocketTransport::GetAddress method or by inspecting
 * nsISocketTransport::GetHost, which returns a string representation of the
 * client's IP address (NOTE: this may be an IPv4 or IPv6 string literal).
 */
declare interface nsIUDPSocketListenerType extends nsISupportsType {
    /**
     * onPacketReceived
     *
     * This method is called when a client sends an UDP packet.
     *
     * @param aSocket
     * The UDP socket.
     * @param aMessage
     * The message.
     */
    onPacketReceived(aSocket: nsIUDPSocketType, aMessage: nsIUDPMessageType): void;
    /**
     * onStopListening
     *
     * This method is called when the listening socket stops for some reason.
     * The UDP socket is effectively dead after this notification.
     *
     * @param aSocket
     * The UDP socket.
     * @param aStatus
     * The reason why the UDP socket stopped listening.  If the
     * UDP socket was manually closed, then this value will be
     * NS_BINDING_ABORTED.
     */
    onStopListening(aSocket: nsIUDPSocketType, aStatus: nsresult): void;
}

/**
 * nsIUDPMessage
 *
 * This interface is used to encapsulate an incomming UDP message
 */
declare interface nsIUDPMessageType extends nsISupportsType {
    /**
     * Address of the source of the message
     */
    readonly fromAddr: nsINetAddr;
    /**
     * Data of the message
     */
    readonly data: ACString;
    /**
     * Stream to send a response
     */
    readonly outputStream: nsIOutputStream;
    /**
     * Raw Data of the message
     */
    readonly rawData: jsval;
}

/**
 *
 */
declare interface nsIUDPSocketSyncListenerType extends nsISupportsType {
    /**
     * onPacketReceived
     *
     * This method is called when a client sends an UDP packet.
     *
     * @param aSocket
     * The UDP socket.
     * @param aMessage
     * The message.
     */
    onPacketReceived(aSocket: nsIUDPSocketType): void;
    /**
     * onStopListening
     *
     * This method is called when the listening socket stops for some reason.
     * The UDP socket is effectively dead after this notification.
     *
     * @param aSocket
     * The UDP socket.
     * @param aStatus
     * The reason why the UDP socket stopped listening.  If the
     * UDP socket was manually closed, then this value will be
     * NS_BINDING_ABORTED.
     */
    onStopListening(aSocket: nsIUDPSocketType, aStatus: nsresult): void;
}

/**
 * Internal interface for callback from chrome process
 */
declare interface nsIUDPSocketInternalType extends nsISupportsType {
    /**
     *
     */
    callListenerOpened(): void;
    /**
     *
     */
    callListenerConnected(): void;
    /**
     *
     */
    callListenerClosed(): void;
    /**
     *
     */
    callListenerReceivedData(host: AUTF8String, port: unsigned_short, data: invalid): void;
    /**
     *
     */
    callListenerError(message: AUTF8String, filename: AUTF8String, lineNumber: uint32_t): void;
}

/**
 * nsIURI - interface for an uniform resource identifier w/ i18n support.
 *
 * AUTF8String attributes may contain unescaped UTF-8 characters.
 * Consumers should be careful to escape the UTF-8 strings as necessary, but
 * should always try to "display" the UTF-8 version as provided by this
 * interface.
 *
 * AUTF8String attributes may also contain escaped characters.
 *
 * Unescaping URI segments is unadvised unless there is intimate
 * knowledge of the underlying charset or there is no plan to display (or
 * otherwise enforce a charset on) the resulting URI substring.
 *
 * The correct way to create an nsIURI from a string is via
 * nsIIOService.newURI.
 *
 * NOTE: nsBinaryInputStream::ReadObject contains a hackaround to intercept the
 * old (pre-gecko6) nsIURI IID and swap in the current IID instead, in order
 * for sessionstore to work after an upgrade.  If this IID is revved further,
 * we will need to add additional checks there for all intermediate IIDs, until
 * ContentPrincipal is fixed to serialize its URIs as nsISupports (bug 662693).
 */
declare interface nsIURIType extends nsISupportsType {
    /**
     * **********************************************************************
     * The URI is broken down into the following principal components:
     * Returns a string representation of the URI.
     *
     * Some characters may be escaped.
     */
    readonly spec: AUTF8String;
    /**
     * The prePath (eg. scheme://user:password@host:port) returns the string
     * before the path.  This is useful for authentication or managing sessions.
     *
     * Some characters may be escaped.
     */
    readonly prePath: AUTF8String;
    /**
     * The Scheme is the protocol to which this URI refers.  The scheme is
     * restricted to the US-ASCII charset per RFC3986.
     */
    readonly scheme: ACString;
    /**
     * The username:password (or username only if value doesn't contain a ':')
     *
     * Some characters may be escaped.
     */
    readonly userPass: AUTF8String;
    /**
     * The optional username and password, assuming the preHost consists of
     * username:password.
     *
     * Some characters may be escaped.
     */
    readonly username: AUTF8String;
    /**
     *
     */
    readonly password: AUTF8String;
    /**
     * The host:port (or simply the host, if port == -1).
     */
    readonly hostPort: AUTF8String;
    /**
     * The host is the internet domain name to which this URI refers.  It could
     * be an IPv4 (or IPv6) address literal. Otherwise it is an ASCII or punycode
     * encoded string.
     */
    readonly host: AUTF8String;
    /**
     * A port value of -1 corresponds to the protocol's default port (eg. -1
     * implies port 80 for http URIs).
     */
    readonly port: long;
    /**
     * The path, typically including at least a leading '/' (but may also be
     * empty, depending on the protocol).
     *
     * Some characters may be escaped.
     *
     * This attribute contains query and ref parts for historical reasons.
     * Use the 'filePath' attribute if you do not want those parts included.
     */
    readonly pathQueryRef: AUTF8String;
    /**
     * **********************************************************************
     * An URI supports the following methods:
     *
     * URI equivalence test (not a strict string comparison).
     *
     * eg. http://foo.com:80/ == http://foo.com/
     */
    equals(other: nsIURIType): boolean;
    /**
     * An optimization to do scheme checks without requiring the users of nsIURI
     * to GetScheme, thereby saving extra allocating and freeing. Returns true if
     * the schemes match (case ignored).
     */
    schemeIs(scheme: string): boolean;
    /**
     * This method resolves a relative string into an absolute URI string,
     * using this URI as the base.
     *
     * NOTE: some implementations may have no concept of a relative URI.
     */
    resolve(relativePath: AUTF8String): AUTF8String;
    /**
     * **********************************************************************
     * Additional attributes:
     * The URI spec with an ASCII compatible encoding.  Host portion follows
     * the IDNA draft spec.  Other parts are URL-escaped per the rules of
     * RFC2396.  The result is strictly ASCII.
     */
    readonly asciiSpec: ACString;
    /**
     * The host:port (or simply the host, if port == -1), with an ASCII compatible
     * encoding.  Host portion follows the IDNA draft spec.  The result is strictly
     * ASCII.
     */
    readonly asciiHostPort: ACString;
    /**
     * The URI host with an ASCII compatible encoding.  Follows the IDNA
     * draft spec for converting internationalized domain names (UTF-8) to
     * ASCII for compatibility with existing internet infrasture.
     */
    readonly asciiHost: ACString;
    /**
     * **********************************************************************
     * Additional attribute & methods added for .ref support:
     * Returns the reference portion (the part after the "#") of the URI.
     * If there isn't one, an empty string is returned.
     *
     * Some characters may be escaped.
     */
    readonly ref: AUTF8String;
    /**
     * URI equivalence test (not a strict string comparison), ignoring
     * the value of the .ref member.
     *
     * eg. http://foo.com/# == http://foo.com/
     * http://foo.com/#aaa == http://foo.com/#bbb
     */
    equalsExceptRef(other: nsIURIType): boolean;
    /**
     * returns a string for the current URI with the ref element cleared.
     */
    readonly specIgnoringRef: AUTF8String;
    /**
     * Returns if there is a reference portion (the part after the "#") of the URI.
     */
    readonly hasRef: boolean;
    /**
     * **********************************************************************
     * Additional attributes added for .query support:
     * Returns a path including the directory and file portions of a
     * URL.  For example, the filePath of "http://host/foo/bar.html#baz"
     * is "/foo/bar.html".
     *
     * Some characters may be escaped.
     */
    readonly filePath: AUTF8String;
    /**
     * Returns the query portion (the part after the "?") of the URL.
     * If there isn't one, an empty string is returned.
     *
     * Some characters may be escaped.
     */
    readonly query: AUTF8String;
    /**
     * Returns if there is a query portion (the part after the "?") of the URI.
     */
    readonly hasQuery: boolean;
    /**
     * If the URI has a punycode encoded hostname, this will hold the UTF8
     * representation of that hostname (if that representation doesn't contain
     * blacklisted characters, and the network.IDN_show_punycode pref is false)
     * Otherwise, if the hostname is ASCII, it will return the same as .asciiHost
     */
    readonly displayHost: AUTF8String;
    /**
     * The displayHost:port (or simply the displayHost, if port == -1).
     */
    readonly displayHostPort: AUTF8String;
    /**
     * Returns the same as calling .spec, only with a UTF8 encoded hostname
     * (if that hostname doesn't contain blacklisted characters, and
     * the network.IDN_show_punycode pref is false)
     */
    readonly displaySpec: AUTF8String;
    /**
     * Returns the same as calling .prePath, only with a UTF8 encoded hostname
     * (if that hostname doesn't contain blacklisted characters, and
     * the network.IDN_show_punycode pref is false)
     */
    readonly displayPrePath: AUTF8String;
    /**
     * Returns an nsIURIMutator that can be used to make changes to the URI.
     * After performing the setter operations on the mutator, one may call
     * mutator.finalize() to get a new immutable URI with the desired
     * properties.
     */
    mutate(): nsIURIMutator;
}

/**
 * Callback function for nsIURIClassifier lookups.
 */
declare interface nsIURIClassifierCallbackType extends nsISupportsType {
    /**
     * Called by the URI classifier service when it is done checking a URI.
     *
     * Clients are responsible for associating callback objects with classify()
     * calls.
     *
     * @param aErrorCode
     * The error code with which the channel should be cancelled, or
     * NS_OK if the load should continue normally.
     * @param aList
     * Name of the list that matched
     * @param aProvider
     * Name of provider that matched
     * @param aFullHash
     * Full hash of URL that matched
     */
    onClassifyComplete(aErrorCode: nsresult, aList: ACString, aProvider: ACString, aFullHash: ACString): void;
}

/**
 * The URI classifier service checks a URI against lists of phishing
 * and malware sites.
 */
declare interface nsIURIClassifierType extends nsISupportsType {
    /**
     * Classify a Principal using its URI.
     *
     * @param aPrincipal
     * The principal that should be checked by the URI classifier.
     *
     * @param aCallback
     * The URI classifier will call this callback when the URI has been
     * classified.
     *
     * @return `false` if classification is not necessary.  The
     * callback will not be called.
     * `true` if classification will be performed.  The
     * callback will be called.
     */
    classify(aPrincipal: nsIPrincipalType, aCallback: nsIURIClassifierCallbackType): boolean;
    /**
     * Asynchronously classify a URI with list of features. This does not make
     * network requests.
     */
    asyncClassifyLocalWithFeatures(aURI: nsIURIType, aFeatures: invalid, aListType: nsIUrlClassifierFeature_listTypeType, aCallback: nsIUrlClassifierFeatureCallbackType): void;
    /**
     * Returns a feature named aFeatureName.
     */
    getFeatureByName(aFeatureName: ACString): nsIUrlClassifierFeature;
    /**
     * Create a new feature with a list of tables. This method is just for
     * testing! Don't use it elsewhere.
     */
    createFeatureWithTables(aName: ACString, aBlocklistTables: invalid, aEntitylistTables: invalid): nsIUrlClassifierFeature;
    /**
     * Report to the provider that a Safe Browsing warning was shown.
     *
     * @param aChannel
     * Channel for which the URL matched something on the threat list.
     * @param aProvider
     * Provider to notify.
     * @param aList
     * List where the full hash was found.
     * @param aFullHash
     * Full URL hash that triggered the warning.
     */
    sendThreatHitReport(aChannel: nsIChannelType, aProvider: ACString, aList: ACString, aFullHash: ACString): void;
}

/**
 * nsIURIContentListener is an interface used by components which
 * want to know (and have a chance to handle) a particular content type.
 * Typical usage scenarios will include running applications which register
 * a nsIURIContentListener for each of its content windows with the uri
 * dispatcher service.
 */
declare interface nsIURIContentListenerType extends nsISupportsType {
    /**
     * Notifies the content listener to hook up an nsIStreamListener capable of
     * consuming the data stream.
     *
     * @param aContentType         Content type of the data.
     * @param aIsContentPreferred  Indicates whether the content should be
     * preferred by this listener.
     * @param aRequest             Request that is providing the data.
     * @param aContentHandler      nsIStreamListener that will consume the data.
     * This should be set to `nullptr` if
     * this content listener can't handle the content
     * type; in this case, doContent should also fail
     * (i.e., return failure nsresult).
     *
     * @return                     `true` if the load should
     * be aborted and consumer wants to
     * handle the load completely by itself.  This
     * causes the URI Loader do nothing else...
     * `false` if the URI Loader should
     * continue handling the load and call the
     * returned streamlistener's methods.
     */
    doContent(aContentType: ACString, aIsContentPreferred: boolean, aRequest: nsIRequestType, aContentHandler: nsIStreamListenerType): boolean;
    /**
     * When given a uri to dispatch, if the URI is specified as 'preferred
     * content' then the uri loader tries to find a preferred content handler
     * for the content type. The thought is that many content listeners may
     * be able to handle the same content type if they have to. i.e. the mail
     * content window can handle text/html just like a browser window content
     * listener. However, if the user clicks on a link with text/html content,
     * then the browser window should handle that content and not the mail
     * window where the user may have clicked the link.  This is the difference
     * between isPreferred and canHandleContent.
     *
     * @param aContentType         Content type of the data.
     * @param aDesiredContentType  Indicates that aContentType must be converted
     * to aDesiredContentType before processing the
     * data.  This causes a stream converted to be
     * inserted into the nsIStreamListener chain.
     * This argument can be `nullptr` if
     * the content should be consumed directly as
     * aContentType.
     *
     * @return                     `true` if this is a preferred
     * content handler for aContentType;
     * `false` otherwise.
     */
    isPreferred(aContentType: string, aDesiredContentType: string): boolean;
    /**
     * When given a uri to dispatch, if the URI is not specified as 'preferred
     * content' then the uri loader calls canHandleContent to see if the content
     * listener is capable of handling the content.
     *
     * @param aContentType         Content type of the data.
     * @param aIsContentPreferred  Indicates whether the content should be
     * preferred by this listener.
     * @param aDesiredContentType  Indicates that aContentType must be converted
     * to aDesiredContentType before processing the
     * data.  This causes a stream converted to be
     * inserted into the nsIStreamListener chain.
     * This argument can be `nullptr` if
     * the content should be consumed directly as
     * aContentType.
     *
     * @return                     `true` if the data can be consumed.
     * `false` otherwise.
     *
     * Note: I really envision canHandleContent as a method implemented
     * by the docshell as the implementation is generic to all doc
     * shells. The isPreferred decision is a decision made by a top level
     * application content listener that sits at the top of the docshell
     * hierarchy.
     */
    canHandleContent(aContentType: string, aIsContentPreferred: boolean, aDesiredContentType: string): boolean;
    /**
     * The load context associated with a particular content listener.
     * The URI Loader stores and accesses this value as needed.
     */
    loadCookie: nsISupports;
    /**
     * The parent content listener if this particular listener is part of a chain
     * of content listeners (i.e. a docshell!)
     *
     * @note If this attribute is set to an object that implements
     * nsISupportsWeakReference, the implementation should get the
     * nsIWeakReference and hold that.  Otherwise, the implementation
     * should not refcount this interface; it should assume that a non
     * null value is always valid.  In that case, the caller is
     * responsible for explicitly setting this value back to null if the
     * parent content listener is destroyed.
     */
    parentContentListener: nsIURIContentListener;
}

/**
 * Interface indicating what we found/corrected when fixing up a URI
 */
declare interface nsIURIFixupInfoType extends nsISupportsType {
    /**
     * Consumer that asked for fixed up URI.
     */
    consumer: BrowsingContext;
    /**
     * Our best guess as to what URI the consumer will want. Might
     * be null if we couldn't salvage anything (for instance, because
     * the input was invalid as a URI and FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP
     * was not passed)
     */
    preferredURI: nsIURI;
    /**
     * The fixed-up original input, *never* using a keyword search.
     * (might be null if the original input was not recoverable as
     * a URL, e.g. "foo bar"!)
     */
    fixedURI: nsIURI;
    /**
     * The name of the keyword search provider used to provide a keyword search;
     * empty string if no keyword search was done.
     */
    keywordProviderName: AString;
    /**
     * The keyword as used for the search (post trimming etc.)
     * empty string if no keyword search was done.
     */
    keywordAsSent: AString;
    /**
     * Whether we changed the protocol instead of using one from the input as-is.
     */
    fixupChangedProtocol: boolean;
    /**
     * Whether we created an alternative URI. We might have added a prefix and/or
     * suffix, the contents of which are controlled by the
     * browser.fixup.alternate.prefix and .suffix prefs, with the defaults being
     * "www." and ".com", respectively.
     */
    fixupCreatedAlternateURI: boolean;
    /**
     * The original input
     */
    originalInput: AUTF8String;
    /**
     * The POST data to submit with the returned URI (see nsISearchSubmission).
     */
    postData: nsIInputStream;
}

/**
 * Interface implemented by objects capable of fixing up strings into URIs
 */
declare interface nsIURIFixupType extends nsISupportsType {
    /**
     * Tries to converts the specified string into a URI, first attempting
     * to correct any errors in the syntax or other vagaries.
     * It returns information about what it corrected
     * (e.g. whether we could rescue the URI or "just" generated a keyword
     * search URI instead).
     *
     * @param aURIText    Candidate URI.
     * @param aFixupFlags Flags that govern ways the URI may be fixed up.
     * Defaults to FIXUP_FLAG_NONE.
     */
    getFixupURIInfo(aURIText: AUTF8String, aFixupFlags: unsigned_long): nsIURIFixupInfo;
    /**
     * Convert load flags from nsIWebNavigation to URI fixup flags for use in
     * getFixupURIInfo.
     *
     * @param aURIText       Candidate URI; used for determining whether to
     * allow keyword lookups.
     * @param aDocShellFlags Load flags from nsIDocShell to convert.
     */
    webNavigationFlagsToFixupFlags(aURIText: AUTF8String, aDocShellFlags: unsigned_long): unsigned_long;
    /**
     * Converts the specified keyword string into a URI.  Note that it's the
     * caller's responsibility to check whether keywords are enabled and
     * whether aKeyword is a sensible keyword.
     *
     * @param aKeyword  The keyword string to convert into a URI
     * @param aIsPrivateContext Whether this is invoked from a private context.
     */
    keywordToURI(aKeyword: AUTF8String, aIsPrivateContext: boolean): nsIURIFixupInfo;
    /**
     * Given a uri-like string with a protocol, attempt to fix and convert it
     * into an instance of nsIURIFixupInfo.
     *
     * Differently from getFixupURIInfo, this assumes the input string is an
     * http/https uri, and can add a prefix and/or suffix to its hostname.
     *
     * The scheme will be changed to the scheme defined in
     * "browser.fixup.alternate.protocol", which is by default, https.
     *
     * If the prefix and suffix of the host are missing, it will add them to
     * the host using the preferences "browser.fixup.alternate.prefix" and
     * "browser.fixup.alternate.suffix" as references.
     *
     * If a hostname suffix is present, but the URI doesn't contain a prefix,
     * it will add the prefix via "browser.fixup.alternate.prefix"
     *
     * @param aUriString The URI to fixup and convert.
     * @returns nsIURIFixupInfo
     * A nsIURIFixupInfo object with the property fixedURI
     * which contains the modified URI.
     * @throws NS_ERROR_FAILURE
     * If aUriString is undefined, or the scheme is not
     * http/https.
     */
    forceHttpFixup(aUriString: AUTF8String): nsIURIFixupInfo;
    /**
     * With the host associated with the URI, use nsIDNSService to determine
     * if an IP address can be found for this host. This method will ignore checking
     * hosts that are IP addresses. If the host does not contain any periods, depending
     * on the browser.urlbar.dnsResolveFullyQualifiedNames preference value, a period
     * may be appended in order to make it a fully qualified domain name.
     *
     * @param aURI The URI to parse and pass into the DNS lookup.
     * @param aListener The listener when the result from the lookup is available.
     * @param aOriginAttributes The originAttributes to pass the DNS lookup.
     * @throws NS_ERROR_FAILURE if aURI does not have a displayHost or asciiHost.
     */
    checkHost(aURI: nsIURIType, aListener: nsIDNSListenerType, aOriginAttributes: jsval): void;
    /**
     * Returns true if the specified domain is known and false otherwise.
     * A known domain is relevant when we have a single word and can't be
     * sure whether to treat the word as a host name or should instead be
     * treated as a search term.
     *
     * @param aDomain A domain name to query.
     */
    isDomainKnown(aDomain: AUTF8String): bool;
}

/**
 * The uri dispatcher is responsible for taking uri's, determining
 * the content and routing the opened url to the correct content
 * handler.
 *
 * When you encounter a url you want to open, you typically call
 * openURI, passing it the content listener for the window the uri is
 * originating from. The uri dispatcher opens the url to discover the
 * content type. It then gives the content listener first crack at
 * handling the content. If it doesn't want it, the dispatcher tries
 * to hand it off one of the registered content listeners. This allows
 * running applications the chance to jump in and handle the content.
 *
 * If that also fails, then the uri dispatcher goes to the registry
 * looking for the preferred content handler for the content type
 * of the uri. The content handler may create an app instance
 * or it may hand the contents off to a platform specific plugin
 * or helper app. Or it may hand the url off to an OS registered
 * application.
 */
declare interface nsIURILoaderType extends nsISupportsType {
    /**
     * @}
     *
     * As applications such as messenger and the browser are instantiated,
     * they register content listener's with the uri dispatcher corresponding
     * to content windows within that application.
     *
     * Note to self: we may want to optimize things a bit more by requiring
     * the content types the registered content listener cares about.
     *
     * @param aContentListener
     * The listener to register. This listener must implement
     * nsISupportsWeakReference.
     *
     * @see the nsIURILoader class description
     */
    registerContentListener(aContentListener: nsIURIContentListenerType): void;
    /**
     *
     */
    unRegisterContentListener(aContentListener: nsIURIContentListenerType): void;
    /**
     * OpenURI requires the following parameters.....
     * @param aChannel
     * The channel that should be opened. This must not be asyncOpen'd yet!
     * If a loadgroup is set on the channel, it will get replaced with a
     * different one.
     * @param aFlags
     * Combination (bitwise OR) of the flags specified above. 0 indicates
     * default handling.
     * @param aWindowContext
     * If you are running the url from a doc shell or a web shell, this is
     * your window context. If you have a content listener you want to
     * give first crack to, the uri loader needs to be able to get it
     * from the window context. We will also be using the window context
     * to get at the progress event sink interface.
     * **Must not be null!**
     */
    openURI(aChannel: nsIChannelType, aFlags: unsigned_long, aWindowContext: nsIInterfaceRequestorType): void;
    /**
     * Loads data from a channel. This differs from openURI in that the channel
     * may already be opened, and that it returns a stream listener into which the
     * caller should pump data. The caller is responsible for opening the channel
     * and pumping the channel's data into the returned stream listener.
     *
     * Note: If the channel already has a loadgroup, it will be replaced with the
     * window context's load group, or null if the context doesn't have one.
     *
     * If the window context's nsIURIContentListener refuses the load immediately
     * (e.g. in nsIURIContentListener::onStartURIOpen), this method will return
     * NS_ERROR_WONT_HANDLE_CONTENT. At that point, the caller should probably
     * cancel the channel if it's already open (this method will not cancel the
     * channel).
     *
     * If flags include DONT_RETARGET, and the content listener refuses the load
     * during onStartRequest (e.g. in canHandleContent/isPreferred), then the
     * returned stream listener's onStartRequest method will return
     * NS_ERROR_WONT_HANDLE_CONTENT.
     *
     * @param aChannel
     * The channel that should be loaded. The channel may already be
     * opened. It must not be closed (i.e. this must be called before the
     * channel calls onStopRequest on its stream listener).
     * @param aFlags
     * Combination (bitwise OR) of the flags specified above. 0 indicates
     * default handling.
     * @param aWindowContext
     * If you are running the url from a doc shell or a web shell, this is
     * your window context. If you have a content listener you want to
     * give first crack to, the uri loader needs to be able to get it
     * from the window context. We will also be using the window context
     * to get at the progress event sink interface.
     * **Must not be null!**
     */
    openChannel(aChannel: nsIChannelType, aFlags: unsigned_long, aWindowContext: nsIInterfaceRequestorType): nsIStreamListener;
    /**
     * Stops an in progress load
     */
    stop(aLoadCookie: nsISupportsType): void;
}

/**
 *
 */
declare interface nsIURISetSpecType extends nsISupportsType {
    /**
     * This setter is different from all other setters because it may be used to
     * initialize the object. We define it separately allowing mutator implementors
     * to define it separately, while the rest of the setters may be simply
     * forwarded to the mutable URI.
     */
    setSpec(aSpec: AUTF8String): nsIURIMutator;
}

/**
 * These methods allow the mutator to change various parts of the URI.
 * They return the same nsIURIMutator so that we may chain setter operations:
 * Example:
 * let newURI = uri.mutate()
 * .setSpec("http://example.com")
 * .setQuery("hello")
 * .finalize();
 */
declare interface nsIURISettersType extends nsIURISetSpecType {
    /**
     * Setting the scheme outside of a protocol handler implementation is highly
     * discouraged since that will generally lead to incorrect results.
     */
    setScheme(aScheme: AUTF8String): nsIURIMutator;
    /**
     *
     */
    setUserPass(aUserPass: AUTF8String): nsIURIMutator;
    /**
     *
     */
    setUsername(aUsername: AUTF8String): nsIURIMutator;
    /**
     *
     */
    setPassword(aPassword: AUTF8String): nsIURIMutator;
    /**
     * If you setHostPort to a value that only has a host part, the port
     * will not be reset. To reset the port set it to -1 beforehand.
     * If setting the host succeeds, this method will return NS_OK, even if
     * setting the port fails (error in parsing the port, or value out of range)
     */
    setHostPort(aHostPort: AUTF8String): nsIURIMutator;
    /**
     *
     */
    setHost(aHost: AUTF8String): nsIURIMutator;
    /**
     *
     */
    setPort(aPort: long): nsIURIMutator;
    /**
     *
     */
    setPathQueryRef(aPathQueryRef: AUTF8String): nsIURIMutator;
    /**
     *
     */
    setRef(aRef: AUTF8String): nsIURIMutator;
    /**
     *
     */
    setFilePath(aFilePath: AUTF8String): nsIURIMutator;
    /**
     *
     */
    setQuery(aQuery: AUTF8String): nsIURIMutator;
}

/**
 *
 */
declare interface nsIURIMutatorType extends nsIURISettersType {
    /**
     * Finishes changing or constructing the URI and returns an immutable URI.
     */
    finalize(): nsIURI;
}

/**
 * nsIURIWithSpecialOrigin is implemented by URIs need to supply an origin that
 * does not match the spec. This is exclusively used in comm-central's Mailnews module.
 */
declare interface nsIURIWithSpecialOriginType extends nsISupportsType {
    /**
     * Special origin.
     */
    readonly origin: nsIURI;
}

/**
 * The nsIURL interface provides convenience methods that further
 * break down the path portion of nsIURI:
 *
 * http://host/directory/fileBaseName.fileExtension?query
 * http://host/directory/fileBaseName.fileExtension#ref
 * \          \                       /
 * \          -----------------------
 * \                   |          /
 * \               fileName     /
 * ----------------------------
 * |
 * filePath
 */
declare interface nsIURLType extends nsIURIType {
    /**
     * ***********************************************************************
     * The URL path is broken down into the following principal components:
     *
     * attribute AUTF8String filePath;
     * attribute AUTF8String query;
     *
     * These are inherited from nsIURI.
     * ***********************************************************************
     * The URL filepath is broken down into the following sub-components:
     * Returns the directory portion of a URL.  If the URL denotes a path to a
     * directory and not a file, e.g. http://host/foo/bar/, then the Directory
     * attribute accesses the complete /foo/bar/ portion, and the FileName is
     * the empty string. If the trailing slash is omitted, then the Directory
     * is /foo/ and the file is bar (i.e. this is a syntactic, not a semantic
     * breakdown of the Path).  And hence don't rely on this for something to
     * be a definitely be a file. But you can get just the leading directory
     * portion for sure.
     *
     * Some characters may be escaped.
     */
    readonly directory: AUTF8String;
    /**
     * Returns the file name portion of a URL.  If the URL denotes a path to a
     * directory and not a file, e.g. http://host/foo/bar/, then the Directory
     * attribute accesses the complete /foo/bar/ portion, and the FileName is
     * the empty string. Note that this is purely based on searching for the
     * last trailing slash. And hence don't rely on this to be a definite file.
     *
     * Some characters may be escaped.
     */
    readonly fileName: AUTF8String;
    /**
     * ***********************************************************************
     * The URL filename is broken down even further:
     * Returns the file basename portion of a filename in a url.
     *
     * Some characters may be escaped.
     */
    readonly fileBaseName: AUTF8String;
    /**
     * Returns the file extension portion of a filename in a url.  If a file
     * extension does not exist, the empty string is returned.
     *
     * Some characters may be escaped.
     */
    readonly fileExtension: AUTF8String;
    /**
     * This method takes a uri and compares the two.  The common uri portion
     * is returned as a string.  The minimum common uri portion is the
     * protocol, and any of these if present:  login, password, host and port
     * If no commonality is found, "" is returned.  If they are identical, the
     * whole path with file/ref/etc. is returned.  For file uris, it is
     * expected that the common spec would be at least "file:///" since '/' is
     * a shared common root.
     *
     * Examples:
     * this.spec               aURIToCompare.spec        result
     * 1) http://mozilla.org/     http://www.mozilla.org/   ""
     * 2) http://foo.com/bar/     ftp://foo.com/bar/        ""
     * 3) http://foo.com:8080/    http://foo.com/bar/       ""
     * 4) ftp://user@foo.com/     ftp://user:pw@foo.com/    ""
     * 5) ftp://foo.com/bar/      ftp://foo.com/bar         ftp://foo.com/
     * 6) ftp://foo.com/bar/      ftp://foo.com/bar/b.html  ftp://foo.com/bar/
     * 7) http://foo.com/a.htm#i  http://foo.com/b.htm      http://foo.com/
     * 8) ftp://foo.com/c.htm#i   ftp://foo.com/c.htm       ftp://foo.com/c.htm
     * 9) file:///a/b/c.html      file:///d/e/c.html        file:///
     */
    getCommonBaseSpec(aURIToCompare: nsIURIType): AUTF8String;
    /**
     * This method tries to create a string which specifies the location of the
     * argument relative to |this|.  If the argument and |this| are equal, the
     * method returns "".  If any of the URIs' scheme, host, userpass, or port
     * don't match, the method returns the full spec of the argument.
     *
     * Examples:
     * this.spec               aURIToCompare.spec        result
     * 1) http://mozilla.org/     http://www.mozilla.org/   http://www.mozilla.org/
     * 2) http://mozilla.org/     http://www.mozilla.org    http://www.mozilla.org/
     * 3) http://foo.com/bar/     http://foo.com:80/bar/    ""
     * 4) http://foo.com/         http://foo.com/a.htm#b    a.html#b
     * 5) http://foo.com/a/b/     http://foo.com/c          ../../c
     */
    getRelativeSpec(aURIToCompare: nsIURIType): AUTF8String;
}

/**
 *
 */
declare interface nsIURLMutatorType extends nsISupportsType {
    /**
     *
     */
    setFileName(aFileName: AUTF8String): nsIURIMutator;
    /**
     *
     */
    setFileBaseName(aFileBaseName: AUTF8String): nsIURIMutator;
    /**
     *
     */
    setFileExtension(aFileExtension: AUTF8String): nsIURIMutator;
}

/**
 * A service that monitors updates to the anti-tracking URL decoration
 * annotations from remote settings.
 */
declare interface nsIURLDecorationAnnotationsServiceType extends nsISupportsType {
    /**
     * Ensures that the list is updated and resolves the returned promise when
     * the update is finished.
     *
     * The new list will be written to a space-separated list of tokens inside
     * the following string preference:
     * privacy.restrict3rdpartystorage.url_decorations
     *
     * This preference will be kept up to date with future list updates from
     * the remote settings server.  This preference cannot be modified by any
     * external component and is managed by this service.
     */
    ensureUpdated(): Promise;
}

/**
 *
 */
declare interface nsIURLFormatterType extends nsISupportsType {
    /**
     * formatURL - Formats a string URL
     *
     * The set of known variables is predefined.
     * If a variable is unknown, it is left unchanged and a non-fatal error is reported.
     *
     * @param aFormat string Unformatted URL.
     *
     * @return The formatted URL.
     */
    formatURL(aFormat: AString): AString;
    /**
     * formatURLPref - Formats a string URL stored in a preference
     *
     * If the preference value cannot be retrieved, a fatal error is reported
     * and the "about:blank" URL is returned.
     *
     * @param aPref string Preference name.
     *
     * @return The formatted URL returned by formatURL(), or "about:blank".
     */
    formatURLPref(aPref: AString): AString;
    /**
     * Remove all of the sensitive query parameter strings from URLs in |aMsg|.
     */
    trimSensitiveURLs(aMsg: AString): AString;
}

/**
 * nsIURLParser specifies the interface to an URL parser that attempts to
 * follow the definitions of RFC 2396.
 */
declare interface nsIURLParserType extends nsISupportsType {
    /**
     * The string to parse in the following methods may be given as a null
     * terminated string, in which case the length argument should be -1.
     *
     * Out parameters of the following methods are all optional (ie. the caller
     * may pass-in a NULL value if the corresponding results are not needed).
     * Signed out parameters may hold a value of -1 if the corresponding result
     * is not part of the string being parsed.
     *
     * The parsing routines attempt to be as forgiving as possible.
     *
     * ParseSpec breaks the URL string up into its 3 major components: a scheme,
     * an authority section (hostname, etc.), and a path.
     *
     * spec = <scheme>://<authority><path>
     */
    parseURL(spec: string, specLen: long, schemePos: unsigned_long, schemeLen: long, authorityPos: unsigned_long, authorityLen: long, pathPos: unsigned_long, pathLen: long): void;
    /**
     * ParseAuthority breaks the authority string up into its 4 components:
     * username, password, hostname, and hostport.
     *
     * auth = <username>:<password>@<hostname>:<port>
     */
    parseAuthority(authority: string, authorityLen: long, usernamePos: unsigned_long, usernameLen: long, passwordPos: unsigned_long, passwordLen: long, hostnamePos: unsigned_long, hostnameLen: long, port: long): void;
    /**
     * userinfo = <username>:<password>
     */
    parseUserInfo(userinfo: string, userinfoLen: long, usernamePos: unsigned_long, usernameLen: long, passwordPos: unsigned_long, passwordLen: long): void;
    /**
     * serverinfo = <hostname>:<port>
     */
    parseServerInfo(serverinfo: string, serverinfoLen: long, hostnamePos: unsigned_long, hostnameLen: long, port: long): void;
    /**
     * ParsePath breaks the path string up into its 3 major components: a file path,
     * a query string, and a reference string.
     *
     * path = <filepath>?<query>#<ref>
     */
    parsePath(path: string, pathLen: long, filepathPos: unsigned_long, filepathLen: long, queryPos: unsigned_long, queryLen: long, refPos: unsigned_long, refLen: long): void;
    /**
     * ParseFilePath breaks the file path string up into: the directory portion,
     * file base name, and file extension.
     *
     * filepath = <directory><basename>.<extension>
     */
    parseFilePath(filepath: string, filepathLen: long, directoryPos: unsigned_long, directoryLen: long, basenamePos: unsigned_long, basenameLen: long, extensionPos: unsigned_long, extensionLen: long): void;
    /**
     * filename = <basename>.<extension>
     */
    parseFileName(filename: string, filenameLen: long, basenamePos: unsigned_long, basenameLen: long, extensionPos: unsigned_long, extensionLen: long): void;
}

/**
 * nsIURLQueryStringStripper is responsible for stripping certain part of the
 * query string of the given URI to address the bounce(redirect) tracking
 * issues. It will strip every query parameter which matches the strip list
 * defined in the pref 'privacy.query_stripping.strip_list'. Note that It's
 * different from URLDecorationStripper which strips the entire query string
 * from the referrer if there is a tracking query parameter present in the URI.
 *
 * TODO: Given that nsIURLQueryStringStripper and URLDecorationStripper are
 * doing similar things. We could somehow combine these two modules into
 * one. We will improve this in the future.
 */
declare interface nsIURLQueryStringStripperType extends nsISupportsType {
    /**
     *
     */
    strip(aURI: nsIURIType, aIsPBM: bool, aOutput: nsIURIType): uint32_t;
    /**
     *
     */
    stripForCopyOrShare(aURI: nsIURIType): nsIURI;
    /**
     *
     */
    testGetStripList(): ACString;
}

/**
 * Observer for query stripping list updates.
 */
declare interface nsIURLQueryStrippingListObserverType extends nsISupportsType {
    /**
     * Called by nsIQueryStrippingListService when the list of query stripping
     * changes and when the observer is first registered. Note that the lists
     * could have duplicate entries because we would combine the lists from the
     * pref and remote settings.
     *
     * @param aStripList
     * A space-separated list of query parameters that will be stripped.
     * @param aAllowList
     * A comma-separated list of hosts (eTLD+1) that are exempt from query
     * stripping.
     */
    onQueryStrippingListUpdate(aStripList: AString, aAllowList: ACString): void;
    /**
     * Called by nsIQueryStrippingListService when the list of query stripping
     * parameters for strip-on-share feature is updated and when the observer is first registered.
     *
     * @param aStripRules
     * An Array of stringified strip rules.
     * A stringified rule has the form of:
     * "'queryParams': ['param1', 'param2', ...], 'topLevelSites': ['www.site.com', 'www.site.de', ...]"
     */
    onStripOnShareUpdate(aStripRules: invalid): void;
}

/**
 * A service that monitors updates to the query stripping list from sources such
 * as a local pref and remote settings updates.
 */
declare interface nsIURLQueryStrippingListServiceType extends nsISupportsType {
    /**
     * Register a new observer to query stripping list updates. When the observer
     * is registered it is called immediately once. Afterwards it will be called
     * whenever the specified pref changes or when remote settings for
     * partitioning updates.
     *
     * @param aObserver
     * An nsIURLQueryStrippingListObserver object or function that
     * will receive updates to the strip list and the allow list. Will be
     * called immediately with the current list value.
     */
    registerAndRunObserver(aObserver: nsIURLQueryStrippingListObserverType): void;
    /**
     * Register a new observer to strip-on-share stripping list updates
     * (this is the strip-on-share list combined with the QPS list).
     * When the observer is registered it is called immediately once. Afterwards it will be called
     * when there is an remote settings update to the QPS strip list.
     *
     * @param aObserver
     * An nsIURLQueryStrippingListObserver object or function that
     * will receive updates to the strip list and the allow list. Will be
     * called immediately with the current list value.
     */
    registerAndRunObserverStripOnShare(aObserver: nsIURLQueryStrippingListObserverType): void;
    /**
     * Unregister an observer.
     *
     * @param aObserver
     * The nsIURLQueryStrippingListObserver object to unregister.
     */
    unregisterObserver(aObserver: nsIURLQueryStrippingListObserverType): void;
    /**
     * Unregister an observer for strip-on-share.
     *
     * @param aObserver
     * The nsIURLQueryStrippingListObserver object to unregister.
     */
    unregisterStripOnShareObserver(aObserver: nsIURLQueryStrippingListObserverType): void;
    /**
     * Clear all Lists.
     *
     * Note that this is for testing purpose.
     */
    clearLists(): void;
    /**
     * Test-only method used to wait for the list service to initialize fully.
     * Resolves once the service has reached a fully disabled (false) or fully
     * enabled state (true).
     * May also be called when the service is already fully initialized or
     * disabled, in this case it will resolve immediately.
     */
    testWaitForInit(): Promise;
}

/**
 * nsIUUIDGenerator is implemented by a service that can generate
 * universally unique identifiers, ideally using any platform-native
 * method for generating UUIDs.
 */
declare interface nsIUUIDGeneratorType extends nsISupportsType {
    /**
     * Obtains a new UUID using appropriate platform-specific methods to
     * obtain a nsID that can be considered to be globally unique.
     *
     * @returns an nsID filled in with a new UUID.
     *
     * @throws NS_ERROR_FAILURE if a UUID cannot be generated (e.g. if
     * an underlying source of randomness is not available)
     */
    generateUUID(): nsIDPtr;
}

/**
 * Abstract UTF-16 input stream
 * @see nsIInputStream
 */
declare interface nsIUnicharInputStreamType extends nsISupportsType {
    /**
     * Read into a string object.
     *
     * @param aCount The number of UTF-16 code units that should be read
     * @return The number of UTF-16 code units that were read.
     */
    readString(aCount: unsigned_long, aString: AString): unsigned_long;
    /**
     * Close the stream and free associated resources. This also closes the
     * underlying stream, if any.
     */
    close(): void;
}

/**
 *
 */
declare interface nsIUnicharLineInputStreamType extends nsISupportsType {
    /**
     * Read a single line from the stream, where a line is a
     * possibly zero length sequence of characters terminated by a
     * CR, LF, CRLF, LFCR, or eof.
     * The line terminator is not returned.
     * @retval false
     * End of file. This line is the last line of the file
     * (aLine is valid).
     * @retval true
     * The file contains further lines.
     * @note Do not mix readLine with other read functions.
     * Doing so can cause various problems and is not supported.
     */
    readLine(aLine: AString): boolean;
}

/**
 * An interface that allows writing unicode data.
 */
declare interface nsIUnicharOutputStreamType extends nsISupportsType {
    /**
     * Write a single character to the stream. When writing many characters,
     * prefer the string-taking write method.
     *
     * @retval true The character was written successfully
     * @retval false Not all bytes of the character could be written.
     */
    write(aCount: unsigned_long, c: char16_t[]): boolean;
    /**
     * Write a string to the stream.
     *
     * @retval true The string was written successfully
     * @retval false Not all bytes of the string could be written.
     */
    writeString(str: AString): boolean;
    /**
     * Flush the stream. This finishes the conversion and writes any bytes that
     * finish the current byte sequence.
     *
     * It does NOT flush the underlying stream.
     */
    flush(): void;
    /**
     * Close the stream and free associated resources. This also closes the
     * underlying stream.
     */
    close(): void;
}

/**
 * An interface that describes an object representing a patch file that can
 * be downloaded and applied to a version of this application so that it
 * can be updated.
 */
declare interface nsIUpdatePatchType extends nsISupportsType {
    /**
     * The type of this patch:
     * "partial"      A binary difference between two application versions
     * "complete"     A complete patch containing all of the replacement files
     * to update to the new version
     */
    readonly type: AString;
    /**
     * The URL this patch was being downloaded from
     */
    readonly URL: AString;
    /**
     * The final URL this patch was being downloaded from
     */
    finalURL: AString;
    /**
     * The size of this file, in bytes.
     */
    readonly size: unsigned_long;
    /**
     * The state of this patch
     */
    state: AString;
    /**
     * A numeric error code that conveys additional information about the state of
     * a failed update. If the update is not in the "failed" state the value is
     * zero. The possible values are located in common/updatererrors.h and values between
     * 80 and 99 are in nsUpdateService.js.
     */
    errorCode: long;
    /**
     * true if this patch is currently selected as the patch to be downloaded and
     * installed for this update transaction, false if another patch from this
     * update has been selected.
     */
    selected: boolean;
    /**
     * Serializes this patch object into a DOM Element
     * @param   updates
     * The document to serialize into
     * @returns The DOM Element created by the serialization process
     */
    serialize(updates: Document): Element;
}

/**
 * An interface that describes an object representing an available update to
 * the current application - this update may have several available patches
 * from which one must be selected to download and install, for example we
 * might select a binary difference patch first and attempt to apply that,
 * then if the application process fails fall back to downloading a complete
 * file-replace patch. This object also contains information about the update
 * that the front end and other application services can use to learn more
 * about what is going on.
 */
declare interface nsIUpdateType extends nsISupportsType {
    /**
     * The type of update:
     * "major"  A major new version of the Application
     * "minor"  A minor update to the Application (e.g. security update)
     */
    readonly type: AString;
    /**
     * The name of the update, or "<Application Name> <Update Version>"
     */
    readonly name: AString;
    /**
     * The string to display in the user interface for the version. If you want
     * a real version number use appVersion.
     */
    readonly displayVersion: AString;
    /**
     * The Application version of this update.
     */
    readonly appVersion: AString;
    /**
     * The Application version prior to the application being updated.
     */
    readonly previousAppVersion: AString;
    /**
     * The Build ID of this update. Used to determine a particular build, down
     * to the hour, minute and second of its creation. This allows the system
     * to differentiate between several nightly builds with the same |version|
     * for example.
     */
    readonly buildID: AString;
    /**
     * The URL to a page which offers details about the content of this
     * update. Ideally, this page is not the release notes but some other page
     * that summarizes the differences between this update and the previous,
     * which also links to the release notes.
     */
    readonly detailsURL: AString;
    /**
     * The URL to the Update Service that supplied this update.
     */
    readonly serviceURL: AString;
    /**
     * The channel used to retrieve this update from the Update Service.
     */
    readonly channel: AString;
    /**
     * Whether the update is no longer supported on this system.
     */
    readonly unsupported: boolean;
    /**
     * Allows overriding the default amount of time in seconds before prompting the
     * user to apply an update. If not specified, the value of
     * app.update.promptWaitTime will be used.
     */
    promptWaitTime: long_long;
    /**
     * Whether or not the update being downloaded is a complete replacement of
     * the user's existing installation or a patch representing the difference
     * between the new version and the previous version.
     */
    isCompleteUpdate: boolean;
    /**
     * When the update was installed.
     */
    installDate: long_long;
    /**
     * A message associated with this update, if any.
     */
    statusText: AString;
    /**
     * The currently selected patch for this update.
     */
    readonly selectedPatch: nsIUpdatePatch;
    /**
     * The state of the selected patch:
     * "downloading"        The update is being downloaded.
     * "pending"            The update is ready to be applied.
     * "pending-service"    The update is ready to be applied with the service.
     * "pending-elevate"    The update is ready to be applied but requires elevation.
     * "applying"           The update is being applied.
     * "applied"            The update is ready to be switched to.
     * "applied-os"         The update is OS update and to be installed.
     * "applied-service"    The update is ready to be switched to with the service.
     * "succeeded"          The update was successfully applied.
     * "download-failed"    The update failed to be downloaded.
     * "failed"             The update failed to be applied.
     */
    state: AString;
    /**
     * A numeric error code that conveys additional information about the state of
     * a failed update. If the update is not in the "failed" state the value is
     * zero. The possible values are located in common/updatererrors.h and values between
     * 80 and 99 are in nsUpdateService.js.
     */
    errorCode: long;
    /**
     * Whether an elevation failure has been encountered for this update.
     */
    elevationFailure: boolean;
    /**
     * The number of patches supplied by this update.
     */
    readonly patchCount: unsigned_long;
    /**
     * Retrieves a patch.
     * @param   index
     * The index of the patch to retrieve.
     * @returns The nsIUpdatePatch at the specified index.
     */
    getPatchAt(index: unsigned_long): nsIUpdatePatch;
    /**
     * Serializes this update object into a DOM Element
     * @param   updates
     * The document to serialize into
     * @returns The DOM Element created by the serialization process
     */
    serialize(updates: Document): Element;
}

/**
 * An interface describing the result of an update check.
 */
declare interface nsIUpdateCheckResultType extends nsISupportsType {
    /**
     * True if update checks are allowed. otherwise false.
     */
    readonly checksAllowed: boolean;
    /**
     * True if the update check succeeded, otherwise false. Guaranteed to be false
     * if checksAllowed is false.
     */
    readonly succeeded: boolean;
    /**
     * The XMLHttpRequest handling the update check. Depending on exactly how the
     * check failed, it's possible for this to be null.
     */
    readonly request: jsval;
}

/**
 * An interface describing an update check that may still be in-progress or may
 * be completed.
 */
declare interface nsIUpdateCheckType extends nsISupportsType {
    /**
     * An id that represents a particular update check. Can be passed to
     * nsIUpdateChecker::stopCheck.
     *
     * Ids are guaranteed to be truthy (non-zero) and non-repeating. This is
     * just for caller convenience so that (a) it's not an error to cancel a check
     * that already completed and (b) they can easily check `if (idVar)` to see if
     * they stored an id.
     */
    readonly id: long;
    /**
     * A promise that resolves to the results of the update check, which will be
     * of type nsIUpdateCheckResult.
     */
    readonly result: Promise;
}

/**
 * An interface describing an object that knows how to check for updates. It can
 * perform multiple update checks simultaneously or consolidate multiple check
 * requests into a single web request, depending on whether the parameters
 * specified for update checking match.
 */
declare interface nsIUpdateCheckerType extends nsISupportsType {
    /**
     * Checks for available updates.
     * @param   checkType
     * Must be either BACKGROUND_CHECK or FOREGROUND_CHECK. If
     * FOREGROUND_CHECK is specified, the normal
     * nsIApplicationUpdateService.canCheckForUpdates check will be
     * overridden and the "force" parameter will be included in the
     * update URL.
     *
     * Regarding the "force" parameter:
     * Sometimes the update server throttles updates, arbitrarily
     * refraining from returning the newest version to some clients. The
     * force parameter overrides this behavior and tells it to
     * unconditionally return the newest available version.
     *
     * It's worth noting that the update server technically supports
     * forcing the decision in the other direction too, preventing
     * the newest version from being returned, but this interface doesn't
     * actually support setting the force parameter this way. If the
     * force parameter is used, it always forces getting the newest
     * version.
     * @returns An nsIUpdateCheck object that describes the update check and
     * provides a Promise that resolves to the update check results.
     */
    checkForUpdates(checkType: long): nsIUpdateCheck;
    /**
     * Gets the update URL.
     * @param   checkType
     * Must be either BACKGROUND_CHECK or FOREGROUND_CHECK. See the
     * checkType parameter of nsIUpdateChecker.checkForUpdates for more
     * details.
     * @returns A Promise that resolves to the URL to be used to check for
     * updates, as a string. This URL should resolve to an XML describing
     * the updates that are available to the current Firefox
     * installation.
     */
    getUpdateURL(checkType: long): Promise;
    /**
     * Ends a pending update check. Has no effect if the id is invalid or the
     * check corresponding to the id has already completed.
     *
     * Note that because `nsIUpdateChecker` potentially combines multiple update
     * checks, it is not guaranteed that this will actually cause the update
     * request to be aborted. It also doesn't guarantee that
     * `nsIUpdateCheck.result` will resolve when this is called. This merely marks
     * the check id as cancelled and only if there are no other check ids waiting
     * on the request does it abort it.
     *
     * @param   id
     * The id of a check to stop (accessible via nsIUpdateCheck).
     */
    stopCheck(id: long): void;
    /**
     * Ends all pending update checks.
     */
    stopAllChecks(): void;
}

/**
 * An interface describing a global application service that handles performing
 * background update checks and provides utilities for selecting and
 * downloading update patches.
 */
declare interface nsIApplicationUpdateServiceType extends nsISupportsType {
    /**
     * Checks for available updates in the background using the listener provided
     * by the application update service for background checks.
     * @returns true if the update check was started, false if not. Note that the
     * check starting does not necessarily mean that the check will
     * succeed or that an update will be downloaded.
     */
    checkForBackgroundUpdates(): bool;
    /**
     * Selects the best update to install from a list of available updates.
     * @param   updates
     * An array of updates that are available
     */
    selectUpdate(updates: invalid): nsIUpdate;
    /**
     * Adds a listener that receives progress and state information about the
     * update that is currently being downloaded, e.g. to update a user
     * interface. Registered listeners will be called for all downloads and all
     * updates during a browser session; they are not automatically removed
     * following the first (successful or failed) download.
     * @param   listener
     * An object implementing nsIRequestObserver and optionally
     * nsIProgressEventSink that is to be notified of state and
     * progress information as the update is downloaded.
     */
    addDownloadListener(listener: nsIRequestObserverType): void;
    /**
     * Removes a listener that is receiving progress and state information
     * about the update that is currently being downloaded.
     * @param   listener
     * The listener object to remove.
     */
    removeDownloadListener(listener: nsIRequestObserverType): void;
    /**
     * Starts downloading the update passed. Once the update is downloaded, it
     * will automatically be prepared for installation.
     *
     * @param   update
     * The update to download.
     * @returns A promise that resolves to `true` if an update download was
     * started, otherwise `false.
     */
    downloadUpdate(update: nsIUpdateType): Promise;
    /**
     * This is the function called internally by the Application Update Service
     * when an update check is complete. Though this can be used to potentially
     * start an update download, `downloadUpdate` should used for that.
     * This is mostly exposed in the interface in order to make it accessible for
     * testing.
     */
    onCheckComplete(result: nsIUpdateCheckResultType): Promise;
    /**
     * Stop the active update download process. This is the equivalent of
     * calling nsIRequest::Cancel on the download's nsIRequest. When downloading
     * with nsIIncrementalDownload, this will leave the partial download in place.
     * When downloading with BITS, any partial download progress will be removed.
     *
     * @returns A Promise that resolves once the download has been stopped.
     */
    stopDownload(): Promise;
    /**
     * There are a few things that can disable the Firefox updater at runtime
     * such as Enterprise Policies. If this attribute is set to true, update
     * should not be performed and most update interfaces will return errors.
     */
    readonly disabled: boolean;
    /**
     * Whether or not the Update Service can usually check for updates. This is a
     * function of whether or not application update is disabled by the
     * application and the platform the application is running on.
     */
    readonly canUsuallyCheckForUpdates: boolean;
    /**
     * Whether or not the Update Service can check for updates right now. This is
     * a function of whether or not application update is disabled by the
     * application, the platform the application is running on, and transient
     * factors such as whether other instances are running.
     */
    readonly canCheckForUpdates: boolean;
    /**
     * Whether or not the installation requires elevation. Currently only
     * implemented on OSX, returns false on other platforms.
     */
    readonly elevationRequired: boolean;
    /**
     * Whether or not the Update Service can usually download and install updates.
     * On Windows, this is a function of whether or not the maintenance service
     * is installed and enabled. On other systems, and as a fallback on Windows,
     * this depends on whether the current user has write access to the install
     * directory.
     */
    readonly canUsuallyApplyUpdates: boolean;
    /**
     * Whether or not the Update Service can download and install updates right now.
     * On Windows, this is a function of whether or not the maintenance service
     * is installed and enabled. On other systems, and as a fallback on Windows,
     * this depends on whether the current user has write access to the install
     * directory. On all systems, this includes transient factors such as whether
     * other instances are running.
     */
    readonly canApplyUpdates: boolean;
    /**
     * Whether or not a different instance is handling updates of this
     * installation.  This currently only ever returns true on Windows
     * when 2 instances of an application are open. Only one of the instances
     * will actually handle updates for the installation.
     */
    readonly isOtherInstanceHandlingUpdates: boolean;
    /**
     * Whether the Update Service is usually able to stage updates.
     */
    readonly canUsuallyStageUpdates: boolean;
    /**
     * Whether the Update Service is able to stage updates right now.  On all
     * systems, this includes transient factors such as whether other instances
     * are running.
     */
    readonly canStageUpdates: boolean;
    /**
     * On Windows, whether the Update Service can usually use BITS.
     */
    readonly canUsuallyUseBits: boolean;
    /**
     * On Windows, whether the Update Service can use BITS right now.  This
     * includes transient factors such as whether other instances are running.
     */
    readonly canUseBits: boolean;
    /**
     * Indicates whether or not the enterprise policy that allows only manual
     * updating is active. One of the features of this policy is not being
     * notified of updates; you are intended to need to manually tell Firefox
     * that you want to update each time that you want to do so.
     *
     * This policy has some implications for the way that update checks work. We
     * don't want to do background update checks. Without being able to notify
     * the user, there's not really anything to do if we find one. However, we
     * will allow "automatic" update checks when loading the update interfaces
     * in about:preferences, the About Dialog, etc. When those interfaces are
     * open, we do have a way of telling the user about an update without
     * bothering them with a doorhanger.
     */
    readonly manualUpdateOnly: boolean;
    /**
     * Determines if the base directory is writable. If not, we assume that
     * further permissions are required and that we are dealing with an elevated
     * installation.
     */
    readonly isAppBaseDirWritable: boolean;
    /**
     * This can be set to true to prevent updates being processed beyond starting
     * an update download. This should only be used when we are being run as a
     * background task.
     * This exists to prevent a particularly fast update download from beginning
     * to stage while the background task is shutting down.
     */
    onlyDownloadUpdatesThisSession: boolean;
    /**
     * Gets a string describing the state (mostly intended to be make console
     * logs easier to read).
     */
    getStateName(state: long): AString;
    /**
     * The current state of the application updater. Returns one of the enumerated
     * constants, above.
     *
     * The expected flow looks like this:
     * STATE_IDLE -> STATE_DOWNLOADING -> STATE_STAGING -> STATE_PENDING
     * If a failure is encountered at some time, we go back to STATE_IDLE.
     * If staging is not enabled, STATE_STAGING will be skipped.
     *
     * We may download additional updates after we reach STATE_PENDING. If we do,
     * the state will remain at STATE_PENDING while we download the new update. If
     * we restart during that time, the pending update will be installed and the
     * partially downloaded update will be discarded. If a download completes
     * successfully, there will be a brief period where STATE_PENDING is no longer
     * correct, because the Update Service is in the process of removing the old
     * update and replacing it with the new update. So if we restart during that
     * period, the update will not be correctly installed. Thus, we switch away
     * from STATE_PENDING to STATE_SWAP during that time. Assuming that the swap
     * is successful, the state will then switch back STATE_STAGING (assuming that
     * staging is enabled), then to STATE_PENDING. So the full expected state flow
     * looks more like this:
     * STATE_IDLE -> STATE_DOWNLOADING -> STATE_STAGING -> STATE_PENDING ->
     * STATE_SWAP -> STATE_STAGING -> STATE_PENDING ->
     * STATE_SWAP -> STATE_STAGING -> STATE_PENDING -> ...
     * (Omitting STATE_STAGING if staging is not enabled).
     */
    readonly currentState: long;
    /**
     * A Promise that resolves immediately after `currentState` changes.
     */
    readonly stateTransition: Promise;
}

/**
 * An interface describing a component which handles the job of processing
 * an update after it's been downloaded.
 */
declare interface nsIUpdateProcessorType extends nsISupportsType {
    /**
     * Stages an update while the application is running.
     */
    processUpdate(): void;
    /**
     * The installer writes an installation-specific registry key if the
     * Maintenance Service can be used for this installation. This function checks
     * for that key's existence (it does not read or verify the key's contents).
     *
     * This function should only be called on Windows.
     *
     * @returns true if the registry key exists, false if it does not.
     * @throws  NS_ERROR_NOT_AVAILABLE
     * If registry access fails.
     * @throws  NS_ERROR_NOT_IMPLEMENTED
     * If this is called on a non-Windows platform.
     */
    getServiceRegKeyExists(): bool;
    /**
     * Registers an application restart upon program exit with the same
     * arguments it was started with, while accepting additional arguments.
     * The application must have been running for a minimum of 60 seconds
     * before invoking this function due to limitations in
     * RegisterApplicationRestart.
     *
     * This function should only be called on Windows.
     *
     * @param  argvExtra
     * An array of strings to be passed to the application upon
     * restart as additional arguments.
     * @throws NS_ERROR_ABORT
     * If the application is in a restart loop.
     * @throws NS_ERROR_NOT_IMPLEMENTED
     * If this is called on a non-Windows platform.
     * @throws NS_ERROR_NOT_AVAILABLE
     * If the command line cannot be read.
     */
    registerApplicationRestartWithLaunchArgs(argvExtra: invalid): void;
}

/**
 * Upon creation, which should happen early during startup, the sync manager
 * creates/opens and locks a file. All other running instances of the same
 * installation of the app also open the same lock, so we can use it to
 * determine whether any other instance is running. If so, we'll temporarily
 * hold off on performing update tasks until there are no other instances or
 * until a timeout expires, whichever comes first. That way we can avoid
 * updating behind the back of copies that are still running, so we don't force
 * all running instances to restart (see bug 1366808, where an error was added
 * informing the user of the need to restart any running instances that have
 * been updated).
 */
declare interface nsIUpdateSyncManagerType extends nsISupportsType {
    /**
     * Returns whether another instance of this application is running.
     * @returns true if another instance has the lock open, false if not
     */
    isOtherInstanceRunning(): bool;
    /**
     * Should only be used for testing.
     *
     * Closes and reopens the lock file, possibly under a different name if a
     * parameter is given (or the path hash has changed, which should only happen
     * if a test is forcing it).
     */
    resetLock(anAppFile: nsIFileType): void;
}

/**
 * An interface describing a global application service that maintains a list
 * of updates previously performed as well as the current active update.
 */
declare interface nsIUpdateManagerType extends nsISupportsType {
    /**
     * Gets the update at the specified index
     * @param   index
     * The index within the updates array
     * @returns The nsIUpdate object at the specified index
     */
    getUpdateAt(index: long): nsIUpdate;
    /**
     * Gets the total number of updates in the history list.
     */
    getUpdateCount(): long;
    /**
     * The update that has been downloaded, or null if there isn't one.
     */
    readyUpdate: nsIUpdate;
    /**
     * The update that is currently downloading, or null if there isn't one.
     * An update is no longer considered to be downloading once onStopRequest is
     * called. This means that both onStopRequest handlers for download listeners
     * and observers of the "update-downloaded" topic should expect the update
     * that was just downloaded to be stored in readyUpdate, not
     * downloadingUpdate.
     */
    downloadingUpdate: nsIUpdate;
    /**
     * Adds the specified update to the update history. The update history is
     * limited to 10 items, so this may also remove the last item from the
     * history.
     */
    addUpdateToHistory(update: nsIUpdateType): void;
    /**
     * Saves all updates to disk.
     */
    saveUpdates(): void;
    /**
     * Refresh the update status based on the information in update.status.
     *
     * @returns A Promise that resolves after the update status is refreshed.
     */
    refreshUpdateStatus(): Promise;
    /**
     * The user agreed to proceed with an elevated update and we are now
     * permitted to show an elevation prompt.
     */
    elevationOptedIn(): void;
    /**
     * These functions both clean up and remove an active update without applying
     * it. The first function does this for the update that is currently being
     * downloaded. The second function does this for the update that has already
     * been downloaded.
     */
    cleanupDownloadingUpdate(): void;
    /**
     *
     */
    cleanupReadyUpdate(): void;
    /**
     * Runs cleanup that ought to happen on a Firefox paveover install to
     * prevent a stale update from being processed when Firefox is first
     * launched.
     * This is best-effort. It will not throw on cleanup failure.
     *
     * The returned promise does not resolve with any particular value. It simply
     * conveys that the cleanup has completed.
     */
    doInstallCleanup(): Promise;
    /**
     * Runs cleanup that ought to happen when Firefox is uninstalled to clean up
     * old update data that is no longer needed.
     * This is best-effort. It will not throw on cleanup failure.
     *
     * The returned promise does not resolve with any particular value. It simply
     * conveys that the cleanup has completed.
     */
    doUninstallCleanup(): Promise;
}

/**
 * An interface describing a global application service that allows long
 * duration (e.g. 1-7 or more days, weeks or months) timers to be registered
 * and then fired.
 */
declare interface nsIUpdateTimerManagerType extends nsISupportsType {
    /**
     * Register an interval with the timer manager. The timer manager
     * periodically checks to see if the interval has expired and if it has
     * calls the specified callback. This is persistent across application
     * restarts and can handle intervals of long durations. The callback will be
     * called soon after the first registration unless you ask to skip it.
     * @param   id
     * An id that identifies the interval, used for persistence
     * @param   callback
     * A nsITimerCallback object that is notified when the interval
     * expires
     * @param   interval
     * The length of time, in seconds, of the interval
     * @param   skipFirst
     * Whether to skip the initial callback on first registration.
     *
     * Note: to avoid having to instantiate a component to call registerTimer
     * the component can intead register an update-timer category with comma
     * separated values as a single string:
     *
     * contractID,method,id,preference,interval
     *
     * via a manifest entry. The values are as follows:
     * contractID : the contract ID for the component.
     * method     : the method used to instantiate the interface. This should be
     * either getService or createInstance depending on your
     * component.
     * id         : the id that identifies the interval, used for persistence.
     * preference : the preference to for timer interval. This value can be
     * optional by specifying an empty string for the value.
     * interval   : the default interval in seconds for the timer.
     */
    registerTimer(id: AString, callback: nsITimerCallbackType, interval: unsigned_long, skipFirst: boolean): void;
    /**
     * Unregister an existing interval from the timer manager.
     *
     * @param   id
     * An id that identifies the interval.
     */
    unregisterTimer(id: AString): void;
}

/**
 * nsIUploadChannel
 *
 * A channel may optionally implement this interface if it supports the
 * notion of uploading a data stream.  The upload stream may only be set
 * prior to the invocation of asyncOpen on the channel.
 */
declare interface nsIUploadChannelType extends nsISupportsType {
    /**
     * Sets a stream to be uploaded by this channel.
     *
     * Most implementations of this interface require that the stream:
     * (1) implement threadsafe addRef and release
     * (2) implement nsIInputStream::readSegments
     * (3) implement nsISeekableStream::seek
     *
     * History here is that we need to support both streams that already have
     * headers (e.g., Content-Type and Content-Length) information prepended to
     * the stream (by plugins) as well as clients (composer, uploading
     * application) that want to upload data streams without any knowledge of
     * protocol specifications.  For this reason, we have a special meaning
     * for the aContentType parameter (see below).
     *
     * @param aStream
     * The stream to be uploaded by this channel.
     * @param aContentType
     * If aContentType is empty, the protocol will assume that no
     * content headers are to be added to the uploaded stream and that
     * any required headers are already encoded in the stream.  In the
     * case of HTTP, if this parameter is non-empty, then its value will
     * replace any existing Content-Type header on the HTTP request.
     * In the case of FTP and FILE, this parameter is ignored.
     * @param aContentLength
     * A value of -1 indicates that the length of the stream should be
     * determined by calling the stream's |available| method.
     */
    setUploadStream(aStream: nsIInputStreamType, aContentType: ACString, aContentLength: long_long): void;
    /**
     * Get the stream (to be) uploaded by this channel.
     */
    readonly uploadStream: nsIInputStream;
}

/**
 *
 */
declare interface nsIUploadChannel2Type extends nsISupportsType {
    /**
     * Sets a stream to be uploaded by this channel with the specified
     * Content-Type and Content-Length header values.
     *
     * Most implementations of this interface require that the stream:
     * (1) implement threadsafe addRef and release
     * (2) implement nsIInputStream::readSegments
     * (3) implement nsISeekableStream::seek
     *
     * @param aStream
     * The stream to be uploaded by this channel.
     * @param aContentType
     * This value will replace any existing Content-Type
     * header on the HTTP request, regardless of whether
     * or not its empty.
     * @param aContentLength
     * A value of -1 indicates that the length of the stream should be
     * determined by calling the stream's |available| method.
     * @param aMethod
     * The HTTP request method to set on the stream.
     * @param aStreamHasHeaders
     * True if the stream already contains headers for the HTTP request.
     */
    explicitSetUploadStream(aStream: nsIInputStreamType, aContentType: ACString, aContentLength: long_long, aMethod: ACString, aStreamHasHeaders: boolean): void;
    /**
     * Value of aStreamHasHeaders from the last successful call to
     * explicitSetUploadStream.  TRUE indicates the attached upload stream
     * contains request headers.
     */
    readonly uploadStreamHasHeaders: boolean;
}

/**
 *
 */
declare interface nsIUrlClassifierCallbackType extends nsISupportsType {
    /**
     *
     */
    handleEvent(value: ACString): void;
}

/**
 * The nsIUrlClassifierUpdateObserver interface is implemented by
 * clients streaming updates to the url-classifier (usually
 * nsUrlClassifierStreamUpdater.
 */
declare interface nsIUrlClassifierUpdateObserverType extends nsISupportsType {
    /**
     * The update requested a new URL whose contents should be downloaded
     * and sent to the classifier as a new stream.
     *
     * @param url The url that was requested.
     * @param table The table name that this URL's contents will be associated
     * with.  This should be passed back to beginStream().
     */
    updateUrlRequested(url: ACString, table: ACString): void;
    /**
     * A stream update has completed.
     *
     * @param status The state of the update process.
     * @param delay The amount of time the updater should wait to fetch the
     * next URL in ms.
     */
    streamFinished(status: nsresult, delay: unsigned_long): void;
    /**
     * The update has encountered an error and should be cancelled
     */
    updateError(error: nsresult): void;
    /**
     * The update has completed successfully.
     *
     * @param requestedTimeout The number of seconds that the caller should
     * wait before trying to update again.
     */
    updateSuccess(requestedTimeout: unsigned_long): void;
}

/**
 * This is a proxy class that is instantiated and called from the JS thread.
 * It provides async methods for querying and updating the database.  As the
 * methods complete, they call the callback function.
 */
declare interface nsIUrlClassifierDBServiceType extends nsISupportsType {
    /**
     * Looks up a URI in the specified tables.
     *
     * @param principal: The principal containing the URI to search.
     * @param c: The callback will be called with a comma-separated list
     * of tables to which the key belongs.
     */
    lookup(principal: nsIPrincipalType, tables: ACString, c: nsIUrlClassifierCallbackType): void;
    /**
     * Lists the tables along with their meta info in the following format:
     *
     * tablename;[metadata]\n
     * tablename2;[metadata]\n
     *
     * For v2 tables, the metadata is the chunks info such as
     *
     * goog-phish-shavar;a:10,14,30-40s:56,67
     * goog-unwanted-shavar;a:1-3,5
     *
     * For v4 tables, base64 encoded state is currently the only info in the
     * metadata (can be extended whenever necessary). For exmaple,
     *
     * goog-phish-proto;Cg0IARAGGAEiAzAwMTABEKqTARoCGAjT1gDD:oCGAjT1gDD\n
     * goog-malware-proto;Cg0IAhAGGAEiAzAwMTABENCQARoCGAjx5Yty:BENCQARoCGAj\n
     *
     * Note that the metadata is colon-separated.
     */
    getTables(c: nsIUrlClassifierCallbackType): void;
    /**
     * Set the nsIUrlClassifierCompleter object for a given table.  This
     * object will be used to request complete versions of partial
     * hashes.
     */
    setHashCompleter(tableName: ACString, completer: nsIUrlClassifierHashCompleterType): void;
    /**
     * Forget the results that were used in the last DB update.
     */
    clearLastResults(): void;
    /**
     * Begin an update process.  Will throw NS_ERROR_NOT_AVAILABLE if there
     * is already an update in progress.
     *
     * @param updater The update observer tied to this update.
     * @param tables A comma-separated list of tables included in this update.
     */
    beginUpdate(updater: nsIUrlClassifierUpdateObserverType, tables: ACString): void;
    /**
     * Begin a stream update.  This should be called once per url being
     * fetched.
     *
     * @param table The table the contents of this stream will be associated
     * with, or empty for the initial stream.
     */
    beginStream(table: ACString): void;
    /**
     * Update the table incrementally.
     */
    updateStream(updateChunk: ACString): void;
    /**
     * Finish an individual stream update.  Must be called for every
     * beginStream() call, before the next beginStream() or finishUpdate().
     *
     * The update observer's streamFinished will be called once the
     * stream has been processed.
     */
    finishStream(): void;
    /**
     * Finish an incremental update.  This will attempt to commit any
     * pending changes and resets the update interface.
     *
     * The update observer's updateSucceeded or updateError methods
     * will be called when the update has been processed.
     */
    finishUpdate(): void;
    /**
     * Cancel an incremental update.  This rolls back any pending changes.
     * and resets the update interface.
     *
     * The update observer's updateError method will be called when the
     * update has been rolled back.
     */
    cancelUpdate(): void;
    /**
     * Reset the url-classifier database.  This call will delete the existing
     * database, emptying all tables.  Mostly intended for use in unit tests.
     */
    resetDatabase(): void;
    /**
     * Reload he url-classifier database. This will empty all cache for
     * completions from gethash, and reload it from database. Mostly intended
     * for use in tests.
     */
    reloadDatabase(): void;
    /**
     * Empty all the caches.
     */
    clearCache(): void;
}

/**
 * This is an internal helper interface for communication between the
 * main thread and the dbservice worker thread.  It is called for each
 * lookup to provide a set of possible results, which the main thread
 * may need to expand using an nsIUrlClassifierCompleter.
 */
declare interface nsIUrlClassifierLookupCallbackType extends nsISupportsType {
    /**
     * The lookup process is complete.
     *
     * @param results
     * If this parameter is null, there were no results found.
     * If not, it contains an array of nsUrlClassifierEntry objects
     * with possible matches.  The callee is responsible for freeing
     * this array.
     */
    lookupComplete(results: ResultArray): void;
}

/**
 * This is an internal helper interface which is called after each
 * classify completes to provide and handle a set of possible results,
 * which the main thread may need to expand using an nsIURIClassifierCallback.
 */
declare interface nsIUrlClassifierClassifyCallbackType extends nsISupportsType {
    /**
     * The function is called each time the URL matches a Safe Browsing list
     * The function could be called multiple times if URL matches multiple lists
     */
    handleResult(aList: ACString, aPrefix: ACString): void;
}

/**
 * Observer for exception list updates.
 */
declare interface nsIUrlClassifierExceptionListObserverType extends nsISupportsType {
    /**
     * Called by nsIUrlClassifierExceptionListService when the exception list
     * for a designated feature changes and when the observer is first registered.
     *
     * @param aList
     * A comma-separated list of url patterns, intended to be parsed
     * by nsContentUtils::IsURIInList.
     */
    onExceptionListUpdate(aList: ACString): void;
}

/**
 * A service that monitors updates to the exception list of url-classifier
 * feature from sources such as a local pref and remote settings updates.
 */
declare interface nsIUrlClassifierExceptionListServiceType extends nsISupportsType {
    /**
     * Register a new observer to exception list updates. When the observer is
     * registered it is called immediately once. Afterwards it will be called
     * whenever the specified pref changes or when remote settings for
     * url-classifier features updates.
     *
     * @param aFeature
     * The feature for which to observe the exception list.
     *
     * @param aPrefName
     * (Optional) A pref name to monitor. The pref must be of string
     * type and contain a comma-separated list of URL patterns.
     *
     * @param aObserver
     * An nsIUrlClassifierExceptionListObserver object or function that
     * will receive updates to the exception list as a comma-separated
     * string. Will be called immediately with the current exception
     * list value.
     */
    registerAndRunExceptionListObserver(aFeature: ACString, aPrefName: ACString, aObserver: nsIUrlClassifierExceptionListObserverType): void;
    /**
     * Unregister an observer.
     *
     * @param aFeature
     * The feature for which to stop observing.
     *
     * @param aObserver
     * The nsIUrlClassifierExceptionListObserver object to unregister.
     */
    unregisterExceptionListObserver(aFeature: ACString, aObserver: nsIUrlClassifierExceptionListObserverType): void;
    /**
     * Clear all data in the service.
     * This API is for testing only.
     */
    clear(): void;
}

/**
 * A single URLClassifier feature.
 */
declare interface nsIUrlClassifierFeatureType extends nsISupportsType {
    /**
     * The feature name
     */
    readonly name: ACString;
    /**
     * Returns a comma-separated list of hosts to be ignored.
     */
    readonly exceptionHostList: ACString;
}

/**
 * The result of the classifier operation is this interface.
 * See asyncClassifyLocalWithFeatures() in nsIURIClassifier.idl.
 */
declare interface nsIUrlClassifierFeatureResultType extends nsISupportsType {
    /**
     *
     */
    readonly uri: nsIURI;
    /**
     *
     */
    readonly feature: nsIUrlClassifierFeature;
    /**
     *
     */
    readonly list: ACString;
}

/**
 * Callback function for nsIURIClassifier lookups.
 * See asyncClassifyLocalWithFeatures() in nsIURIClassifier.idl.
 */
declare interface nsIUrlClassifierFeatureCallbackType extends nsISupportsType {
    /**
     * Called by the URI classifier service when it is done checking a URI.
     *
     * Clients are responsible for associating callback objects with classify()
     * calls.
     *
     * @param aResults
     * List of nsIUrlClassifierFeatureResult objects.
     */
    onClassifyComplete(aResults: invalid): void;
}

/**
 * This interface contains feilds in Matches object of FullHashResponse(V4).
 * Reference from:
 * https://developers.google.com/safe-browsing/v4/update-api#http-post-response_2
 */
declare interface nsIFullHashMatchType extends nsISupportsType {
    /**
     *
     */
    readonly tableName: ACString;
    /**
     *
     */
    readonly fullHash: ACString;
    /**
     *
     */
    readonly cacheDuration: uint32_t;
}

/**
 * This interface is implemented by nsIUrlClassifierHashCompleter clients.
 */
declare interface nsIUrlClassifierHashCompleterCallbackType extends nsISupportsType {
    /**
     * A complete hash has been found that matches the partial hash.
     * This method may be called 0-n times for a given
     * nsIUrlClassifierCompleter::complete() call.
     *
     * @param hash
     * The 256-bit hash that was discovered.
     * @param table
     * The name of the table that this hash belongs to.
     * @param chunkId
     * The database chunk that this hash belongs to.
     */
    completionV2(hash: ACString, table: ACString, chunkId: uint32_t): void;
    /**
     * This will be called when a fullhash response is received and parsed
     * no matter if any full hash has been found.
     *
     * @param partialHash
     * The hash that was sent for completion.
     * @param table
     * The name of the table that this hash belongs to.
     * @param negativeCacheDuration
     * The negative cache duration in millisecond.
     * @param fullHashes
     * Array of fullhashes that match the prefix.
     */
    completionV4(partialHash: ACString, table: ACString, negativeCacheDuration: uint32_t, fullHashes: nsIArrayType): void;
    /**
     * The completion is complete.  This method is called once per
     * nsIUrlClassifierCompleter::complete() call, after all completion()
     * calls are finished.
     *
     * @param status
     * NS_OK if the request completed successfully, or an error code.
     */
    completionFinished(status: nsresult): void;
}

/**
 * Clients updating the url-classifier database have the option of sending
 * partial (32-bit) hashes of URL fragments to be blocklisted.  If the
 * url-classifier encounters one of these truncated hashes, it will ask an
 * nsIUrlClassifierCompleter instance to asynchronously provide the complete
 * hash, along with some associated metadata.
 * This is only ever used for testing and should absolutely be deleted (I
 * think).
 */
declare interface nsIUrlClassifierHashCompleterType extends nsISupportsType {
    /**
     * Request a completed hash from the given gethash url.
     *
     * @param partialHash
     * The 32-bit hash encountered by the url-classifier.
     * @param gethashUrl
     * The gethash url to use.
     * @param tableName
     * The table where we matched the partial hash.
     * @param callback
     * An nsIUrlClassifierCompleterCallback instance.
     */
    complete(partialHash: ACString, gethashUrl: ACString, tableName: ACString, callback: nsIUrlClassifierHashCompleterCallbackType): void;
}

/**
 * nsIUrlClassifierPositiveCacheEntry Represents a positive cache entry.
 */
declare interface nsIUrlClassifierPositiveCacheEntryType extends nsISupportsType {
    /**
     * Fullhash for the positive cache entry.
     */
    readonly fullhash: ACString;
    /**
     * Positive cache expiry.
     */
    readonly expiry: long_long;
}

/**
 * nsIUrlClassifierCacheEntry contains cache information for
 * a given prefix.
 */
declare interface nsIUrlClassifierCacheEntryType extends nsISupportsType {
    /**
     * Prefix for this cache entry.
     */
    readonly prefix: ACString;
    /**
     * Negative cache expiry.
     */
    readonly expiry: long_long;
    /**
     * An array of nsIUrlClassifierPositiveCacheEntry, each item represents
     * a positive cache entry with its fullhash and expiry.
     */
    readonly matches: nsIArray;
}

/**
 * Cache information for a given table.
 */
declare interface nsIUrlClassifierCacheInfoType extends nsISupportsType {
    /**
     * Table name.
     */
    readonly table: ACString;
    /**
     * An array of nsIUrlClassifierCacheEntry.
     */
    readonly entries: nsIArray;
}

/**
 *
 */
declare interface nsIUrlClassifierGetCacheCallbackType extends nsISupportsType {
    /**
     *
     */
    onGetCacheComplete(info: nsIUrlClassifierCacheInfoType): void;
}

/**
 * Interface to query url-classifier information.
 */
declare interface nsIUrlClassifierInfoType extends nsISupportsType {
    /**
     * An asynchronous call to return cache information for the table.
     */
    getCacheInfo(table: ACString, callback: nsIUrlClassifierGetCacheCallbackType): void;
}

/**
 *
 */
declare interface nsIUrlClassifierPrefixSetType extends nsISupportsType {
    /**
     *
     */
    init(aName: ACString): void;
    /**
     *
     */
    setPrefixes(aPrefixes: unsigned_long[], aLength: unsigned_long): void;
    /**
     *
     */
    getPrefixes(aCount: unsigned_long, aPrefixes: unsigned_long[]): void;
    /**
     *
     */
    contains(aPrefix: unsigned_long): boolean;
    /**
     *
     */
    isEmpty(): boolean;
}

/**
 * A service that serves Safe Browsing list data (V2 protocol) via
 * Remote Settings.
 */
declare interface nsIUrlClassifierRemoteSettingsServiceType extends nsISupportsType {
    /**
     * Fetch the Safe Browsing list data from the service. The service
     * returns the response data by simulating how the data is sent over a
     * stream listener when a HTTP request is made.
     *
     *
     * @param aPayload the request payload for list data request
     * @param aListener An nsIStreamListener object
     */
    fetchList(aPayload: ACString, aListener: nsIStreamListenerType): void;
    /**
     * Clear all data in the service.
     * This API is for testing only.
     */
    clear(): void;
}

/**
 * This is a class to manage large table updates from the server.  Rather than
 * downloading the whole update and then updating the sqlite database, we
 * update tables as the data is streaming in.
 */
declare interface nsIUrlClassifierStreamUpdaterType extends nsISupportsType {
    /**
     * Try to download updates from updateUrl. If an update is already in
     * progress, queues the requested update. This is used in nsIUrlListManager
     * as well as in testing.
     * @param aRequestTables Comma-separated list of tables included in this
     * update.
     * @param aRequestPayload The payload for the request.
     * @param aIsPostRequest Whether the request should be sent by POST method.
     * Should be 'true' for v2 usage.
     * @param aUpdateUrl The plaintext url from which to request updates.
     * @param aSuccessCallback Called after a successful update.
     * @param aUpdateErrorCallback Called for problems applying the update
     * @param aDownloadErrorCallback Called if we get an http error or a
     * connection refused error.
     */
    downloadUpdates(aRequestTables: ACString, aRequestPayload: ACString, aIsPostRequest: boolean, aUpdateUrl: ACString, aSuccessCallback: nsIUrlClassifierCallbackType, aUpdateErrorCallback: nsIUrlClassifierCallbackType, aDownloadErrorCallback: nsIUrlClassifierCallbackType): boolean;
}

/**
 * Interface for parseFindFullHashResponseV4 callback
 */
declare interface nsIUrlClassifierParseFindFullHashCallbackType extends nsISupportsType {
    /**
     * Callback when a match is found in full hash response. This callback may be
     * called multiple times when there are more than one matches in response.
     *
     * @param aCompleteHash A 32-byte complete hash string.
     * @param aTableNames The table names that this complete hash is associated with.
     * Since the server responded with a threat type, multiple
     * list names can be returned. The caller is reponsible
     * for filtering out the unrequested table names.
     * See |convertThreatTypeToListNames| for the format.
     * @param aPerHashCacheDuration See "FindFullHashesResponse" in safebrowsing.proto.
     */
    onCompleteHashFound(aCompleteHash: ACString, aTableNames: ACString, aPerHashCacheDuration: unsigned_long): void;
    /**
     * Callback when full hash response is received.
     *
     * @param aMinWaitDuration See "FindFullHashesResponse" in safebrowsing.proto.
     * @param aNegCacheDuration See "FindFullHashesResponse" in safebrowsing.proto.
     */
    onResponseParsed(aMinWaitDuration: unsigned_long, aNegCacheDuration: unsigned_long): void;
}

/**
 *
 */
declare interface nsIUrlClassifierUtilsType extends nsISupportsType {
    /**
     * Get the lookup string for a given URI.  This normalizes the hostname,
     * url-decodes the string, and strips off the protocol.
     *
     * @param uri URI to get the lookup key for.
     *
     * @returns String containing the canonicalized URI.
     */
    getKeyForURI(uri: nsIURIType): ACString;
    /**
     * Get the provider by table name.
     *
     * @param tableName The table name that we want to lookup
     *
     * @returns the provider name that the given table belongs.
     */
    getProvider(tableName: ACString): ACString;
    /**
     * Get the provider used for Telemetry.
     * Because recording Telemetry will leak user-controlled strings,
     * only built-in providers should be recorded.
     *
     * @param tableName The table name that we want to lookup
     *
     * @returns the filtered provider for telemetry.
     */
    getTelemetryProvider(tableName: ACString): ACString;
    /**
     * Get the protocol version for the given provider.
     *
     * @param provider String the provider name. e.g. "google"
     *
     * @returns String to indicate the protocol version. e.g. "2.2"
     */
    getProtocolVersion(provider: ACString): ACString;
    /**
     * Convert threat type to list name.
     *
     * @param Integer to indicate threat type.
     *
     * @returns The list names separated by ','. For example,
     * 'goog-phish-proto,test-phish-proto'.
     */
    convertThreatTypeToListNames(threatType: uint32_t): ACString;
    /**
     * Convert list name to threat type.
     *
     * @param The list name.
     *
     * @returns The threat type in integer.
     */
    convertListNameToThreatType(listName: ACString): uint32_t;
    /**
     * Make update request for given lists and their states.
     *
     * @param aListNames An array of list name represented in string.
     * @param aState An array of states (encoded in base64 format) for each list.
     *
     * The two argument arrays must be the same length.
     *
     * @returns A base64url encoded string.
     */
    makeUpdateRequestV4(aListNames: invalid, aStatesBase64: invalid): ACString;
    /**
     * Make "find full hash" request by for the given prefixes.
     *
     * @param aListNames An array of list names represented in string.
     * @param aListStatesBase64 An array of list states represented in base64.
     * @param aPrefixes An array of prefixes for which we'd like to find full hashes..
     *
     * The aListNames and aListStatesBase64 arrays must be the same length.
     *
     * @returns A base64url encoded string.
     */
    makeFindFullHashRequestV4(aListNames: invalid, aListStatesBase64: invalid, aPrefixes: invalid): ACString;
    /**
     * Make ThreatHit report request body.
     *
     * @param aChannel channel which encountered the threat.
     * @param aListName listname represented in string.
     * @param aHashBase64 hash-based hit represented in base64.
     *
     * @returns A base64 encoded string.
     */
    makeThreatHitReport(aChannel: nsIChannelType, aListName: ACString, aHashBase64: ACString): ACString;
    /**
     * Parse V4 FindFullHash response.
     *
     * @param aResponse Byte stream from the server.
     * @param aCallback The callback function on each complete hash parsed.
     * Can be called multiple times in one parsing.
     */
    parseFindFullHashResponseV4(aResponse: ACString, aCallback: nsIUrlClassifierParseFindFullHashCallbackType): void;
}

/**
 * Interface for a class that manages updates of the url classifier database.
 */
declare interface nsIUrlListManagerType extends nsISupportsType {
    /**
     * Get the gethash url for this table
     */
    getGethashUrl(tableName: ACString): ACString;
    /**
     * Get the update url for this table
     */
    getUpdateUrl(tableName: ACString): ACString;
    /**
     * Add a table to the list of tables we are managing. The name is a
     * string of the format provider_name-semantic_type-table_type.  For
     * @param tableName A string of the format
     * provider_name-semantic_type-table_type.  For example,
     * goog-white-enchash or goog-black-url.
     * @param providerName The name of the entity providing the list.
     * @param updateUrl The URL from which to fetch updates.
     * @param gethashUrl The URL from which to fetch hash completions.
     */
    registerTable(tableName: ACString, providerName: ACString, updateUrl: ACString, gethashUrl: ACString): boolean;
    /**
     * Unregister table from the list
     */
    unregisterTable(tableName: ACString): void;
    /**
     * Turn on update checking for a table. I.e., during the next server
     * check, download updates for this table.
     */
    enableUpdate(tableName: ACString): void;
    /**
     * Turn off update checking for all tables.
     */
    disableAllUpdates(): void;
    /**
     * Turn off update checking for a single table. Only used in tests.
     */
    disableUpdate(tableName: ACString): void;
    /**
     * Toggle update checking, if necessary.
     */
    maybeToggleUpdateChecking(): void;
    /**
     * This is currently used by about:url-classifier to force an update
     * for the update url. Update may still fail because of backoff algorithm.
     */
    checkForUpdates(updateUrl: ACString): boolean;
    /**
     * Force updates for the given tables, updates are still restricted to
     * backoff algorithm.
     * @param tables  A string lists all the tables that we want to trigger updates.
     * table names are separated with ','.
     */
    forceUpdates(tableNames: ACString): boolean;
    /**
     * This is currently used by about:url-classifier to get back-off time
     * (in millisecond since epoch) for the given provider. Return 0 if we
     * are not in back-off mode.
     */
    getBackOffTime(provider: ACString): uint64_t;
    /**
     * Return true if someone registers a table, this is used by testcase
     * to figure out it SafeBrowsing.jsm is initialized.
     */
    isRegistered(): boolean;
}

/**
 * This interface lets you monitor how long the user has been 'idle',
 * i.e. not used their mouse or keyboard. You can get the idle time directly,
 * but in most cases you will want to register an observer for a predefined
 * interval. The observer will get an 'idle' notification when the user is idle
 * for that interval (or longer), and receive an 'active' notification when the
 * user starts using their computer again.
 */
declare interface nsIUserIdleServiceType extends nsISupportsType {
    /**
     * The amount of time in milliseconds that has passed
     * since the last user activity.
     *
     * If we do not have a valid idle time to report, 0 is returned
     * (this can happen if the user never interacted with the browser
     * at all, and if we are also unable to poll for idle time manually).
     */
    readonly idleTime: unsigned_long;
    /**
     * Add an observer to be notified when the user idles for some period of
     * time, and when they get back from that.
     *
     * @param observer the observer to be notified
     * @param time the amount of time in seconds the user should be idle before
     * the observer should be notified.
     *
     * @note
     * The subject of the notification the observer will get is always the
     * nsIUserIdleService itself.
     * When the user goes idle, the observer topic is "idle" and when he gets
     * back, the observer topic is "active".
     * The data param for the notification contains the current user idle time.
     *
     * @note
     * You can add the same observer twice.
     * @note
     * Most implementations need to poll the OS for idle info themselves,
     * meaning your notifications could arrive with a delay up to the length
     * of the polling interval in that implementation.
     * Current implementations use a delay of 5 seconds.
     */
    addIdleObserver(observer: nsIObserverType, time: unsigned_long): void;
    /**
     * Remove an observer registered with addIdleObserver.
     * @param observer the observer that needs to be removed.
     * @param time the amount of time they were listening for.
     * @note
     * Removing an observer will remove it once, for the idle time you specify.
     * If you have added an observer multiple times, you will need to remove it
     * just as many times.
     */
    removeIdleObserver(observer: nsIObserverType, time: unsigned_long): void;
    /**
     * If true, the idle service is temporarily disabled, and all idle events
     * will be ignored.
     *
     * This should only be used in automation.
     */
    disabled: boolean;
}

/**
 *
 */
declare interface nsIUserIdleServiceInternalType extends nsIUserIdleServiceType {
    /**
     * "Resets the idle time to the value specified."
     *
     * @param idleDelta the time (in milliseconds) since the last user inter
     * action
     */
    resetIdleTimeOut(idleDeltaInMS: unsigned_long): void;
}

/**
 *
 */
declare interface nsIUtilityProcessTestType extends nsISupportsType {
    /**
     * ** Test-only Method **
     *
     * Allowing to start Utility Process from JS code.
     *
     * actorsToAdd: An array of actor names, taken from WebIDLUtilityActorName.
     * Unlike normal utility processes, test processes launched this way do not
     * have any associated actor names unless specified here.  Empty by default.
     */
    startProcess(actorsToAdd: invalid): Promise;
    /**
     * ** Test-only Method **
     *
     * Note that we are going to manually crash a process
     */
    noteIntentionalCrash(pid: unsigned_long): void;
    /**
     * ** Test-only Method **
     *
     * Allowing to stop Utility Process from JS code.
     * Default behavior is to stop any utility process.
     */
    stopProcess(utilityActorName: string): void;
    /**
     * ** Test-only Method **
     *
     * Sending Telemetry probes
     */
    testTelemetryProbes(): void;
}

/**
 * XPConnect has magic to transparently convert between nsIVariant and JS types.
 * We mark the interface [scriptable] so that JS can use methods
 * that refer to this interface. But we mark all the methods and attributes
 * [noscript] since any nsIVariant object will be automatically converted to a
 * JS type anyway.
 */
declare interface nsIVariantType extends nsISupportsType {
    /**
     *
     */
    readonly dataType: uint16_t;
    /**
     *
     */
    getAsID(retval: nsIDType): nsresult;
    /**
     *
     */
    getAsArray(type: uint16_t, iid: nsIIDType, count: uint32_t, ptr: voidPtr): nsresult;
}

/**
 * An object that implements nsIVariant may or may NOT also implement this
 * nsIWritableVariant.
 *
 * If the 'writable' attribute is false then attempts to call any of the 'set'
 * methods can be expected to fail. Setting the 'writable' attribute may or
 * may not succeed.
 */
declare interface nsIWritableVariantType extends nsIVariantType {
    /**
     *
     */
    writable: boolean;
    /**
     *
     */
    setAsInt8(aValue: uint8_t): void;
    /**
     *
     */
    setAsInt16(aValue: int16_t): void;
    /**
     *
     */
    setAsInt32(aValue: int32_t): void;
    /**
     *
     */
    setAsInt64(aValue: int64_t): void;
    /**
     *
     */
    setAsUint8(aValue: uint8_t): void;
    /**
     *
     */
    setAsUint16(aValue: uint16_t): void;
    /**
     *
     */
    setAsUint32(aValue: uint32_t): void;
    /**
     *
     */
    setAsUint64(aValue: uint64_t): void;
    /**
     *
     */
    setAsFloat(aValue: float): void;
    /**
     *
     */
    setAsDouble(aValue: double): void;
    /**
     *
     */
    setAsBool(aValue: boolean): void;
    /**
     *
     */
    setAsChar(aValue: char): void;
    /**
     *
     */
    setAsWChar(aValue: wchar): void;
    /**
     *
     */
    setAsID(aValue: nsIDRefType): void;
    /**
     *
     */
    setAsAString(aValue: AString): void;
    /**
     *
     */
    setAsACString(aValue: ACString): void;
    /**
     *
     */
    setAsAUTF8String(aValue: AUTF8String): void;
    /**
     *
     */
    setAsString(aValue: string): void;
    /**
     *
     */
    setAsWString(aValue: wstring): void;
    /**
     *
     */
    setAsISupports(aValue: nsISupportsType): void;
    /**
     *
     */
    setAsInterface(iid: nsIIDRefType, iface: nsQIResult): void;
    /**
     *
     */
    setAsStringWithSize(size: uint32_t, str: string): void;
    /**
     *
     */
    setAsWStringWithSize(size: uint32_t, str: wstring): void;
    /**
     *
     */
    setAsVoid(): void;
    /**
     *
     */
    setAsEmpty(): void;
    /**
     *
     */
    setAsEmptyArray(): void;
    /**
     *
     */
    setFromVariant(aValue: nsIVariantType): void;
}

/**
 * Version strings are dot-separated sequences of version-parts.
 *
 * A version-part consists of up to four parts, all of which are optional:
 *
 * <number-a><string-b><number-c><string-d (everything else)>
 *
 * A version-part may also consist of a single asterisk "*" which indicates
 * "infinity".
 *
 * Numbers are base-10, and are zero if left out.
 * Strings are compared bytewise.
 *
 * For additional backwards compatibility, if "string-b" is "+" then
 * "number-a" is incremented by 1 and "string-b" becomes "pre".
 *
 * 1.0pre1
 * < 1.0pre2
 * < 1.0 == 1.0.0 == 1.0.0.0
 * < 1.1pre == 1.1pre0 == 1.0+
 * < 1.1pre1a
 * < 1.1pre1
 * < 1.1pre10a
 * < 1.1pre10
 *
 * Although not required by this interface, it is recommended that
 * numbers remain within the limits of a signed char, i.e. -127 to 128.
 */
declare interface nsIVersionComparatorType extends nsISupportsType {
    /**
     * Compare two version strings
     * @param   A   The first version
     * @param   B   The second version
     * @returns < 0 if A < B
     * = 0 if A == B
     * > 0 if A > B
     */
    compare(A: ACString, B: ACString): long;
}

/**
 *
 */
declare interface nsIViewSourceChannelType extends nsIChannelType {
    /**
     * The actual (MIME) content type of the data.
     *
     * nsIViewSourceChannel returns a content type of
     * "application/x-view-source" if you ask it for the contentType
     * attribute.
     *
     * However, callers interested in finding out or setting the
     * actual content type can utilize this attribute.
     */
    originalContentType: ACString;
    /**
     * Whether the channel was created to view the source of a srcdoc document.
     */
    readonly isSrcdocChannel: boolean;
    /**
     * Set to indicate the base URI.  If this channel is a srcdoc channel, it
     * returns the base URI provided by the embedded channel.  It is used to
     * provide an indication of the base URI in circumstances where it isn't
     * otherwise recoverable.  Returns null when it isn't set and isn't a
     * srcdoc channel.
     */
    baseURI: nsIURI;
    /**
     * Get the inner channel wrapped by this nsIViewSourceChannel.
     */
    getInnerChannel(): nsIChannel;
}

/**
 *
 */
declare interface nsIWakeLockType extends nsISupportsType {
    /**
     *
     */
    unlock(): void;
}

/**
 * An instance of |nsIWeakReference| is a proxy object that cooperates with
 * its referent to give clients a non-owning, non-dangling reference.  Clients
 * own the proxy, and should generally manage it with an |nsCOMPtr| (see the
 * type |nsWeakPtr| for a |typedef| name that stands out) as they would any
 * other XPCOM object.  The |QueryReferent| member function provides a
 * (hopefully short-lived) owning reference on demand, through which clients
 * can get useful access to the referent, while it still exists.
 *
 * @version 1.0
 * @see nsISupportsWeakReference
 * @see nsWeakReference
 * @see nsWeakPtr
 */
declare interface nsIWeakReferenceType extends nsISupportsType {
    /**
     * |QueryReferent| queries the referent, if it exists, and like |QueryInterface|, produces
     * an owning reference to the desired interface.  It is designed to look and act exactly
     * like (a proxied) |QueryInterface|.  Don't hold on to the produced interface permanently;
     * that would defeat the purpose of using a non-owning |nsIWeakReference| in the first place.
     */
    QueryReferent(uuid: nsIIDRefType, result: nsQIResult): void;
    /**
     *
     */
    sizeOfOnlyThis(aMallocSizeOf: MallocSizeOf): size_t;
}

/**
 * |nsISupportsWeakReference| is a factory interface which produces appropriate
 * instances of |nsIWeakReference|.  Weak references in this scheme can only be
 * produced for objects that implement this interface.
 *
 * @version 1.0
 * @see nsIWeakReference
 * @see nsSupportsWeakReference
 */
declare interface nsISupportsWeakReferenceType extends nsISupportsType {
    /**
     * |GetWeakReference| produces an appropriate instance of |nsIWeakReference|.
     * As with all good XPCOM `getters', you own the resulting interface and should
     * manage it with an |nsCOMPtr|.
     *
     * @see nsIWeakReference
     * @see nsWeakPtr
     * @see nsCOMPtr
     */
    GetWeakReference(): nsIWeakReference;
}

/**
 *
 */
declare interface nsICtapRegisterArgsType extends nsISupportsType {
    /**
     *
     */
    readonly origin: AString;
    /**
     *
     */
    readonly rpId: AString;
    /**
     *
     */
    readonly rpName: AString;
    /**
     *
     */
    readonly userName: AString;
    /**
     *
     */
    readonly userDisplayName: AString;
    /**
     *
     */
    readonly credProps: bool;
    /**
     *
     */
    readonly hmacCreateSecret: bool;
    /**
     *
     */
    readonly residentKey: AString;
    /**
     *
     */
    readonly userVerification: AString;
    /**
     *
     */
    readonly authenticatorAttachment: AString;
    /**
     *
     */
    readonly timeoutMS: uint32_t;
    /**
     *
     */
    readonly attestationConveyancePreference: AString;
}

/**
 *
 */
declare interface nsICtapSignArgsType extends nsISupportsType {
    /**
     *
     */
    readonly origin: AString;
    /**
     *
     */
    readonly rpId: AString;
    /**
     *
     */
    readonly hmacCreateSecret: bool;
    /**
     *
     */
    readonly appId: AString;
    /**
     *
     */
    readonly userVerification: AString;
    /**
     *
     */
    readonly timeoutMS: unsigned_long;
}

/**
 *
 */
declare interface nsICtapRegisterResultType extends nsISupportsType {
    /**
     *
     */
    readonly status: nsresult;
    /**
     *
     */
    readonly credPropsRk: bool;
}

/**
 *
 */
declare interface nsIWebAuthnAttObjType extends nsISupportsType {
    /**
     *
     */
    readonly publicKeyAlgorithm: COSEAlgorithmIdentifier;
}

/**
 *
 */
declare interface nsICtapSignResultType extends nsISupportsType {
    /**
     *
     */
    readonly status: nsresult;
    /**
     *
     */
    readonly userName: ACString;
    /**
     *
     */
    readonly usedAppId: bool;
}

/**
 *
 */
declare interface nsIWebAuthnControllerType extends nsISupportsType {
    /**
     *
     */
    pinCallback(aTransactionId: uint64_t, aPin: ACString): void;
    /**
     *
     */
    signatureSelectionCallback(aTransactionId: uint64_t, aIndex: uint64_t): void;
    /**
     *
     */
    resumeRegister(aTransactionID: uint64_t, aForceNoneAttestation: bool): void;
    /**
     *
     */
    cancel(aTransactionID: uint64_t): void;
}

/**
 *
 */
declare interface nsICredentialParametersType extends nsISupportsType {
    /**
     *
     */
    readonly credentialId: ACString;
    /**
     *
     */
    readonly isResidentCredential: bool;
    /**
     *
     */
    readonly rpId: ACString;
    /**
     *
     */
    readonly privateKey: ACString;
    /**
     *
     */
    readonly userHandle: ACString;
    /**
     *
     */
    readonly signCount: uint32_t;
}

/**
 *
 */
declare interface nsIWebAuthnTransportType extends nsISupportsType {
    /**
     *
     */
    controller: nsIWebAuthnController;
    /**
     *
     */
    makeCredential(aTransactionId: uint64_t, browsingContextId: uint64_t, args: nsICtapRegisterArgsType): void;
    /**
     *
     */
    getAssertion(aTransactionId: uint64_t, browsingContextId: uint64_t, args: nsICtapSignArgsType): void;
    /**
     *
     */
    addVirtualAuthenticator(protocol: ACString, transport: ACString, hasResidentKey: bool, hasUserVerification: bool, isUserConsenting: bool, isUserVerified: bool): uint64_t;
    /**
     *
     */
    removeVirtualAuthenticator(authenticatorId: uint64_t): void;
    /**
     *
     */
    addCredential(authenticatorId: uint64_t, credentialId: ACString, isResidentCredential: bool, rpId: ACString, privateKey: ACString, userHandle: ACString, signCount: uint32_t): void;
    /**
     *
     */
    removeCredential(authenticatorId: uint64_t, credentialId: ACString): void;
    /**
     *
     */
    removeAllCredentials(authenticatorId: uint64_t): void;
    /**
     *
     */
    setUserVerified(authenticatorId: uint64_t, isUserVerified: bool): void;
}

/**
 * The nsIWebBrowser interface is implemented by web browser objects.
 * Embedders use this interface during initialisation to associate
 * the new web browser instance with the embedders chrome and
 * to register any listeners. The interface may also be used at runtime
 * to obtain the content DOM window and from that the rest of the DOM.
 */
declare interface nsIWebBrowserType extends nsISupportsType {
    /**
     * The chrome object associated with the browser instance. The embedder
     * must create one chrome object for _each_ browser object
     * that is instantiated. The embedder must associate the two by setting
     * this property to point to the chrome object before creating the browser
     * window via the browser's `nsIBaseWindow` interface.
     *
     * The chrome may optionally implement `nsIInterfaceRequestor`,
     * `nsIWebBrowserChromeFocus`,
     * `nsIContextMenuListener` and
     * `nsITooltipListener` to receive additional notifications
     * from the browser object.
     *
     * The chrome object may optionally implement
     * `nsIWebProgressListener` to register a progress listener
     * object. If the implementation does this, it must also implement
     * `nsIWeakReference`.
     *
     * @note The implementation should not refcount the supplied chrome
     * object; it should assume that a non `nullptr` value is
     * always valid. The embedder must explicitly set this value back
     * to nullptr if the chrome object is destroyed before the browser
     * object.
     *
     * @see nsIBaseWindow
     * @see nsIWebBrowserChrome
     * @see nsIInterfaceRequestor
     * @see nsIWebBrowserChromeFocus
     * @see nsIContextMenuListener
     * @see nsITooltipListener
     * @see nsIWeakReference
     * @see nsIWebProgressListener
     */
    containerWindow: nsIWebBrowserChrome;
    /**
     * The top-level DOM window. The embedder may walk the entire
     * DOM starting from this value.
     */
    readonly contentDOMWindow: mozIDOMWindowProxy;
}

/**
 * nsIWebBrowserChrome corresponds to the top-level, outermost window
 * containing an embedded Gecko web browser.
 */
declare interface nsIWebBrowserChromeType extends nsISupportsType {
    /**
     * Called when the link hover status is being changed.
     * @param status status string. empty string is an acceptable value
     * meaning no link is hovered.
     */
    setLinkStatus(status: AString): void;
    /**
     * The chrome flags for this browser chrome. The implementation should
     * reflect the value of this attribute by hiding or showing its chrome
     * appropriately.
     */
    chromeFlags: unsigned_long;
    /**
     * Shows the window as a modal window.
     */
    showAsModal(): void;
    /**
     * Is the window modal (that is, currently executing a modal loop)?
     * @return true if it's a modal window
     */
    isWindowModal(): boolean;
    /**
     * Allows to request the change of individual dimensions of a window
     * without specifying all dimensions.
     *
     * Gets called as fallback when no nsIBaseWindow is available.
     *
     * @see nsIBaseWindow
     */
    setDimensions(aRequest: DimensionRequest): void;
    /**
     * Gets the dimensions of the window. The caller may pass
     * `nullptr` for any value it is uninterested in receiving.
     *
     * Gets called as fallback when no nsIBaseWindow is available.
     *
     * @see nsIBaseWindow
     */
    getDimensions(aDimensionKind: DimensionKind, aX: long, aY: long, aCX: long, aCY: long): void;
    /**
     * Blur the window. This should unfocus the window and send an onblur event.
     */
    blur(): void;
}

/**
 * The nsIWebBrowserChromeFocus is implemented by the same object as the
 * nsIEmbeddingSiteWindow. It represents the focus up-calls from mozilla
 * to the embedding chrome. See mozilla bug #70224 for gratuitous info.
 */
declare interface nsIWebBrowserChromeFocusType extends nsISupportsType {
    /**
     * Set the focus at the next focusable element in the chrome. If
     * aForDocumentNavigation is true, this was a document navigation, so
     * focus the parent window.
     */
    focusNextElement(aForDocumentNavigation: bool): void;
    /**
     * Set the focus at the previous focusable element in the chrome.
     */
    focusPrevElement(aForDocumentNavigation: bool): void;
}

/**
 * nsIWebBrowserFind
 *
 * Searches for text in a web browser.
 *
 * Get one by doing a GetInterface on an nsIWebBrowser.
 *
 * By default, the implementation will search the focussed frame, or
 * if there is no focussed frame, the web browser content area. It
 * does not by default search subframes or iframes. To change this
 * behaviour, and to explicitly set the frame to search,
 * QueryInterface to nsIWebBrowserFindInFrames.
 */
declare interface nsIWebBrowserFindType extends nsISupportsType {
    /**
     * findNext
     *
     * Finds, highlights, and scrolls into view the next occurrence of the
     * search string, using the current search settings. Fails if the
     * search string is empty.
     *
     * @return  Whether an occurrence was found
     */
    findNext(): boolean;
    /**
     * searchString
     *
     * The string to search for. This must be non-empty to search.
     */
    searchString: AString;
    /**
     * findBackwards
     *
     * Whether to find backwards (towards the beginning of the document).
     * Default is false (search forward).
     */
    findBackwards: boolean;
    /**
     * wrapFind
     *
     * Whether the search wraps around to the start (or end) of the document
     * if no match was found between the current position and the end (or
     * beginning). Works correctly when searching backwards. Default is
     * false.
     */
    wrapFind: boolean;
    /**
     * entireWord
     *
     * Whether to match entire words only. Default is false.
     */
    entireWord: boolean;
    /**
     * matchCase
     *
     * Whether to match case (case sensitive) when searching. Default is false.
     */
    matchCase: boolean;
    /**
     * matchDiacritics
     *
     * Whether to match diacritics when searching. Default is false.
     */
    matchDiacritics: boolean;
    /**
     * searchFrames
     *
     * Whether to search through all frames in the content area. Default is true.
     *
     * Note that you can control whether the search propagates into child or
     * parent frames explicitly using nsIWebBrowserFindInFrames, but if one,
     * but not both, of searchSubframes and searchParentFrames are set, this
     * returns false.
     */
    searchFrames: boolean;
}

/**
 * nsIWebBrowserFindInFrames
 *
 * Controls how find behaves when multiple frames or iframes are present.
 *
 * Get by doing a QueryInterface from nsIWebBrowserFind.
 */
declare interface nsIWebBrowserFindInFramesType extends nsISupportsType {
    /**
     * currentSearchFrame
     *
     * Frame at which to start the search. Once the search is done, this will
     * be set to be the last frame searched, whether or not a result was found.
     * Has to be equal to or contained within the rootSearchFrame.
     */
    currentSearchFrame: mozIDOMWindowProxy;
    /**
     * rootSearchFrame
     *
     * Frame within which to confine the search (normally the content area frame).
     * Set this to only search a subtree of the frame hierarchy.
     */
    rootSearchFrame: mozIDOMWindowProxy;
    /**
     * searchSubframes
     *
     * Whether to recurse down into subframes while searching. Default is true.
     *
     * Setting nsIWebBrowserfind.searchFrames to true sets this to true.
     */
    searchSubframes: boolean;
    /**
     * searchParentFrames
     *
     * Whether to allow the search to propagate out of the currentSearchFrame into its
     * parent frame(s). Search is always confined within the rootSearchFrame. Default
     * is true.
     *
     * Setting nsIWebBrowserfind.searchFrames to true sets this to true.
     */
    searchParentFrames: boolean;
}

/**
 * Interface for persisting DOM documents and URIs to local or remote storage.
 */
declare interface nsIWebBrowserPersistType extends nsICancelableType {
    /**
     * Flags governing how data is fetched and saved from the network.
     * It is best to set this value explicitly unless you are prepared
     * to accept the default values.
     */
    persistFlags: unsigned_long;
    /**
     * Current state of the persister object.
     */
    readonly currentState: unsigned_long;
    /**
     * Value indicating the success or failure of the persist
     * operation.
     *
     * @throws NS_BINDING_ABORTED Operation cancelled.
     * @throws NS_ERROR_FAILURE Non-specific failure.
     */
    readonly result: nsresult;
    /**
     * Callback listener for progress notifications. The object that the
     * embbedder supplies may also implement nsIInterfaceRequestor and be
     * prepared to return nsIAuthPrompt or other interfaces that may be required
     * to download data.
     *
     * @see nsIAuthPrompt
     * @see nsIInterfaceRequestor
     */
    progressListener: nsIWebProgressListener;
    /**
     * Save the specified URI to file.
     *
     * @param aURI       URI to save to file. Some implementations of this interface
     * may also support `nullptr` to imply the currently
     * loaded URI.
     * @param aTriggeringPrincipal
     * The triggering principal for the URI we're saving.
     * @param aCacheKey  The necko cache key integer.
     * @param aReferrerInfo  The referrer info for compute and send referrer via
     * HTTP Referer header.
     * @param aCookieJarSettings The cookieJarSettings for the HTTP channel which
     * is saving the URI.
     * @param aPostData  Post data to pass with an HTTP request or
     * `nullptr`.
     * @param aExtraHeaders Additional headers to supply with an HTTP request
     * or `nullptr`.
     * @param aFile      Target file. This may be a nsIFile object or an
     * nsIURI object with a file scheme or a scheme that
     * supports uploading (e.g. ftp).
     * @param aContentPolicyType The type of content we're saving.
     * @param aIsPrivate Treat the save operation as private (ie. with
     * regards to networking operations and persistence
     * of intermediate data, etc.)
     *
     * @see nsIFile
     * @see nsIURI
     * @see nsIInputStream
     *
     * @throws NS_ERROR_INVALID_ARG One or more arguments was invalid.
     */
    saveURI(aURI: nsIURIType, aTriggeringPrincipal: nsIPrincipalType, aCacheKey: unsigned_long, aReferrerInfo: nsIReferrerInfoType, aCookieJarSettings: nsICookieJarSettingsType, aPostData: nsIInputStreamType, aExtraHeaders: string, aFile: nsISupportsType, aContentPolicyType: nsContentPolicyType, aIsPrivate: boolean): void;
    /**
     * Save a channel to a file. It must not be opened yet.
     * @see saveURI
     */
    saveChannel(aChannel: nsIChannelType, aFile: nsISupportsType): void;
    /**
     * Save the specified DOM document to file and optionally all linked files
     * (e.g. images, CSS, JS & subframes). Do not call this method until the
     * document has finished loading!
     *
     * @param aDocument          Document to save to file. Some implementations of
     * this interface may also support `nullptr`
     * to imply the currently loaded document.  Can be an
     * nsIWebBrowserPersistDocument or Document.
     * @param aFile              Target local file. This may be a nsIFile object or an
     * nsIURI object with a file scheme or a scheme that
     * supports uploading (e.g. ftp).
     * @param aDataPath          Path to directory where URIs linked to the document
     * are saved or nullptr if no linked URIs should be saved.
     * This may be a nsIFile object or an nsIURI object
     * with a file scheme.
     * @param aOutputContentType The desired MIME type format to save the
     * document and all subdocuments into or nullptr to use
     * the default behaviour.
     * @param aEncodingFlags     Flags to pass to the encoder.
     * @param aWrapColumn        For text documents, indicates the desired width to
     * wrap text at. Parameter is ignored if wrapping is not
     * specified by the encoding flags.
     *
     * @see nsIWebBrowserPersistDocument
     * @see WebBrowserPersistable
     * @see nsIFile
     * @see nsIURI
     *
     * @throws NS_ERROR_INVALID_ARG One or more arguments was invalid.
     */
    saveDocument(aDocument: nsISupportsType, aFile: nsISupportsType, aDataPath: nsISupportsType, aOutputContentType: string, aEncodingFlags: unsigned_long, aWrapColumn: unsigned_long): void;
    /**
     * Cancels the current operation. The caller is responsible for cleaning up
     * partially written files or directories. This has the same effect as calling
     * cancel with an argument of NS_BINDING_ABORTED.
     */
    cancelSave(): void;
}

/**
 * Interface for the URI-mapping information that can be supplied when
 * serializing the DOM of an nsIWebBrowserPersistDocument.
 *
 * @see nsIWebBrowserPersistDocument
 */
declare interface nsIWebBrowserPersistURIMapType extends nsISupportsType {
    /**
     * The number of URI mappings.
     */
    readonly numMappedURIs: unsigned_long;
    /**
     * Obtain the URI mapping at the given index, which must be less than
     * numMappedURIs, as a pair of URI spec strings.
     */
    getURIMapping(aIndex: unsigned_long, aMapFrom: AUTF8String, aMapTo: AUTF8String): void;
    /**
     * The spec of the base URI that the document will have after it is
     * serialized.
     */
    readonly targetBaseURI: AUTF8String;
}

/**
 * Interface representing a document that can be serialized with
 * nsIWebBrowserPersist; it may or may not be in this process.  Some
 * information is exposed as attributes, which may or may not reflect
 * changes made to the underlying document; most of these are
 * self-explanatory from their names and types.
 */
declare interface nsIWebBrowserPersistDocumentType extends nsISupportsType {
    /**
     *
     */
    readonly isClosed: boolean;
    /**
     *
     */
    readonly isPrivate: boolean;
    /**
     *
     */
    readonly documentURI: AUTF8String;
    /**
     *
     */
    readonly baseURI: AUTF8String;
    /**
     *
     */
    readonly contentType: ACString;
    /**
     *
     */
    readonly characterSet: ACString;
    /**
     *
     */
    readonly title: AString;
    /**
     *
     */
    readonly referrerInfo: nsIReferrerInfo;
    /**
     *
     */
    readonly cookieJarSettings: nsICookieJarSettings;
    /**
     *
     */
    readonly contentDisposition: AString;
    /**
     *
     */
    readonly postData: nsIInputStream;
    /**
     *
     */
    readonly principal: nsIPrincipal;
    /**
     * The cache key.  Unlike in nsISHEntry, where it's wrapped in an
     * nsISupportsPRUint32, this is just the integer.
     */
    readonly cacheKey: unsigned_long;
    /**
     * This attribute is set by nsIWebBrowserPersist implementations to
     * propagate persist flags that apply to the DOM traversal and
     * serialization (rather than to managing file I/O).
     */
    persistFlags: unsigned_long;
    /**
     * Walk the DOM searching for external resources needed to render it.
     * The visitor callbacks may be called either before or after
     * readResources returns.
     *
     * @see nsIWebBrowserPersistResourceVisitor
     */
    readResources(aVisitor: nsIWebBrowserPersistResourceVisitorType): void;
    /**
     * Serialize the document's DOM.
     *
     * @param aStream       The output stream to write the document to.
     *
     * @param aURIMap       Optional; specifies URI rewriting to perform on
     * external references (as read by readResources).
     * If given, also causes relative hyperlinks to be
     * converted to absolute in the written text.
     *
     * @param aRequestedContentType
     * The desired MIME type to save the document as;
     * optional and defaults to the document's type.
     * (If no encoder exists for that type, "text/html"
     * is used instead.)
     *
     * @param aEncoderFlags Flags to pass to the encoder.
     *
     * @param aWrapColumn   Desired text width, ignored if wrapping is not
     * specified by the encoding flags, or if 0.
     *
     * @param aCompletion   Callback invoked when writing is complete.
     * It may be called either before or after writeContent
     * returns.
     *
     * @see nsIDocumentEncoder
     */
    writeContent(aStream: nsIOutputStreamType, aURIMap: nsIWebBrowserPersistURIMapType, aRequestedContentType: ACString, aEncoderFlags: unsigned_long, aWrapColumn: unsigned_long, aCompletion: nsIWebBrowserPersistWriteCompletionType): void;
    /**
     *
     */
    GetHistory(): SHEntryRef;
}

/**
 * Asynchronous visitor that receives external resources linked by an
 * nsIWebBrowserPersistDocument and which are needed to render the
 * document.
 */
declare interface nsIWebBrowserPersistResourceVisitorType extends nsISupportsType {
    /**
     * Indicates a resource that is not a document; e.g., an image, script,
     * or stylesheet.
     *
     * @param aDocument   The document containing the reference.
     * @param aURI        The absolute URI spec for the referenced resource.
     * @param aContentPolicyType The type of resource.
     */
    visitResource(aDocument: nsIWebBrowserPersistDocumentType, aURI: AUTF8String, aContentPolicyType: nsContentPolicyType): void;
    /**
     * Indicates a subdocument resource; e.g., a frame or iframe.
     *
     * @param aDocument     The document containing the reference.
     * @param aSubDocument  The referenced document.
     */
    visitDocument(aDocument: nsIWebBrowserPersistDocumentType, aSubDocument: nsIWebBrowserPersistDocumentType): void;
    /**
     * Indicates a cross origin subdocument resource; e.g., a frame
     * or iframe loaded in another process.
     *
     * @param aDocument     The document containing the reference.
     * @param aContext      The referenced document's browsing context.
     */
    visitBrowsingContext(aDocument: nsIWebBrowserPersistDocumentType, aContext: BrowsingContext): void;
    /**
     * Indicates that the document traversal is complete.
     *
     * @param aDocument   The document that was being traversed.
     * @param aStatus     Indicates whether the traversal encountered an error.
     */
    endVisit(aDocument: nsIWebBrowserPersistDocumentType, aStatus: nsresult): void;
}

/**
 * Asynchronous callback for when nsIWebBrowserPersistDocument is finished
 * serializing the document's DOM.
 */
declare interface nsIWebBrowserPersistWriteCompletionType extends nsISupportsType {
    /**
     * Indicates that serialization is finished.
     *
     * @param aDocument     The document that was being serialized.
     *
     * @param aStream       The stream that was being written to.  If it
     * needs to be closed, the callback must do that;
     * the serialization process leaves it open.
     *
     * @param aContentType  The content type with which the document was
     * actually serialized; this may be useful to set
     * metadata on the result, or if uploading it.
     *
     * @param aStatus       Indicates whether serialization encountered an error.
     */
    onFinish(aDocument: nsIWebBrowserPersistDocumentType, aStream: nsIOutputStreamType, aContentType: ACString, aStatus: nsresult): void;
}

/**
 * Asynchronous callback for creating a persistable document from some
 * other object.
 *
 * XXXbz This should really be changed to just return a promise that
 * then gets resolved or rejected...
 *
 * @see WebBrowserPersistable in FrameLoader.webidl.
 */
declare interface nsIWebBrowserPersistDocumentReceiverType extends nsISupportsType {
    /**
     *
     */
    onDocumentReady(aDocument: nsIWebBrowserPersistDocumentType): void;
    /**
     *
     */
    onError(aFailure: nsresult): void;
}

/**
 * nsIWebBrowserPrint corresponds to the main interface
 * for printing an embedded Gecko web browser window/document
 */
declare interface nsIWebBrowserPrintType extends nsISupportsType {
    /**
     * Returns whether it is in Print mode
     */
    readonly doingPrint: boolean;
    /**
     * Returns whether it is in Print Preview mode
     */
    readonly doingPrintPreview: boolean;
    /**
     * This represents the "raw" total number of pages, where "raw" means that
     * this value is *not amended* to account for reductions from pages-per-sheet
     * or page ranges (unlike other APIs on this interface).
     *
     * So e.g. for a 20-page document, this attribute will be 20, regardless of
     * whether the user has chosen a smaller page range, and regardless of
     * whether the user is using pages-per-sheet to reduce the number of sheets.
     */
    readonly rawNumPages: long;
    /**
     * This returns the total number of pages for the Print Preview
     *
     * XXXdholbert Consider renaming this? Strictly speaking, this is the number
     * of *sheets* (which is the same as the number of pages in the default
     * configuration of one page per sheet). Fix in bug 1669762.
     */
    readonly printPreviewNumPages: long;
    /**
     * This returns the number of the page which is currently in the Print Preview viewport
     *
     * XXXdholbert Consider renaming this? (similar to printPreviewNumPages above)
     * Strictly speaking, this is the number of the *sheet* which is currently in
     * the print preview viewport. Fix in bug 1669762.
     */
    readonly printPreviewCurrentPageNumber: long;
    /**
     * @param aNavType - navigation enum
     * @param aPageNum - page num to navigate to when aNavType = ePrintPreviewGoToPageNum
     * @return void
     */
    printPreviewScrollToPage(aNavType: short, aPageNum: long): void;
    /**
     * This exists PrintPreview mode and returns browser window to galley mode
     * @return void
     */
    exitPrintPreview(): void;
}

/**
 * The nsIWebNavigation interface defines an interface for navigating the web.
 * It provides methods and attributes to direct an object to navigate to a new
 * location, stop or restart an in process load, or determine where the object
 * has previously gone.
 *
 * Even though this is builtinclass, most of the interface is also implemented
 * in RemoteWebNavigation, so if this interface changes, the implementation
 * there may also need to change.
 */
declare interface nsIWebNavigationType extends nsISupportsType {
    /**
     * Indicates if the object can go back.  If true this indicates that
     * there is back session history available for navigation.
     */
    readonly canGoBack: boolean;
    /**
     * Indicates if the object can go forward.  If true this indicates that
     * there is forward session history available for navigation
     */
    readonly canGoForward: boolean;
    /**
     * Tells the object to navigate to the previous session history item.  When a
     * page is loaded from session history, all content is loaded from the cache
     * (if available) and page state (such as form values and scroll position) is
     * restored.
     *
     * @param {boolean} aRequireUserInteraction
     * Tells goBack to skip history items that did not record any user
     * interaction on their corresponding document while they were active.
     * This means in case of multiple entries mapping to the same document,
     * each entry has to have been flagged with user interaction separately.
     * If no items have user interaction, the function will fall back
     * to the first session history entry.
     *
     * @param {boolean} aUserActivation
     * Tells goBack that the call was triggered by a user action (e.g.:
     * The user clicked the back button).
     *
     * @throw NS_ERROR_UNEXPECTED
     * Indicates that the call was unexpected at this time, which implies
     * that canGoBack is false.
     */
    goBack(aRequireUserInteraction: boolean, aUserActivation: boolean): void;
    /**
     * Tells the object to navigate to the next session history item.  When a
     * page is loaded from session history, all content is loaded from the cache
     * (if available) and page state (such as form values and scroll position) is
     * restored.
     *
     * @param {boolean} aRequireUserInteraction
     * Tells goForward to skip history items that did not record any user
     * interaction on their corresponding document while they were active.
     * This means in case of multiple entries mapping to the same document,
     * each entry has to have been flagged with user interaction separately.
     * If no items have user interaction, the function will fall back
     * to the latest session history entry.
     *
     * @param {boolean} aUserActivation
     * Tells goForward that the call was triggered by a user action (e.g.:
     * The user clicked the forward button).
     *
     * @throw NS_ERROR_UNEXPECTED
     * Indicates that the call was unexpected at this time, which implies
     * that canGoForward is false.
     */
    goForward(aRequireUserInteraction: boolean, aUserActivation: boolean): void;
    /**
     * Tells the object to navigate to the session history item at a given index.
     *
     * @param {boolean} aUserActivation
     * Tells goForward that the call was triggered by a user action (e.g.:
     * The user clicked the forward button).
     *
     * @throw NS_ERROR_UNEXPECTED
     * Indicates that the call was unexpected at this time, which implies
     * that session history entry at the given index does not exist.
     */
    gotoIndex(index: long, aUserActivation: boolean): void;
    /**
     * Loads a given URI.  This will give priority to loading the requested URI
     * in the object implementing this interface.  If it can't be loaded here
     * however, the URI dispatcher will go through its normal process of content
     * loading.
     *
     * @param aURI
     * The URI to load.
     * @param aLoadURIOptions
     * A JSObject defined in LoadURIOptions.webidl holding info like e.g.
     * the triggeringPrincipal, the referrer info.
     */
    loadURI(aURI: nsIURIType, aLoadURIOptions: jsval): void;
    /**
     * Parse / fix up a URI out of the string and load it.
     * This will give priority to loading the requested URI
     * in the object implementing this interface.  If it can't be loaded here
     * however, the URI dispatcher will go through its normal process of content
     * loading.
     *
     * @param aURIString
     * The URI string to load.  For HTTP and FTP URLs and possibly others,
     * characters above U+007F will be converted to UTF-8 and then URL-
     * escaped per the rules of RFC 2396.
     * This method may use nsIURIFixup to try to fix up typos etc. in the
     * input string based on the load flag arguments in aLoadURIOptions.
     * It can even convert the input to a search results page using the
     * default search service.
     * If you have an nsIURI anyway, prefer calling `loadURI`, above.
     * @param aLoadURIOptions
     * A JSObject defined in LoadURIOptions.webidl holding info like e.g.
     * the triggeringPrincipal, the referrer info.
     */
    fixupAndLoadURIString(aURIString: AString, aLoadURIOptions: jsval): void;
    /**
     * A C++ friendly version of loadURI
     */
    binaryLoadURI(aURI: nsIURIType, aLoadURIOptions: LoadURIOptionsRef): void;
    /**
     * A C++ friendly version of fixupAndLoadURIString
     */
    binaryFixupAndLoadURIString(aURIString: AString, aLoadURIOptions: LoadURIOptionsRef): void;
    /**
     * Tells the Object to reload the current page.  There may be cases where the
     * user will be asked to confirm the reload (for example, when it is
     * determined that the request is non-idempotent).
     *
     * @param aReloadFlags
     * Flags modifying load behaviour.  This parameter is a bitwise
     * combination of the Load Flags defined above.  (Undefined bits are
     * reserved for future use.)  Generally you will pass LOAD_FLAGS_NONE
     * for this parameter.
     *
     * @throw NS_BINDING_ABORTED
     * Indicating that the user canceled the reload.
     */
    reload(aReloadFlags: unsigned_long): void;
    /**
     * Stops a load of a URI.
     *
     * @param aStopFlags
     * This parameter is one of the stop flags defined above.
     */
    stop(aStopFlags: unsigned_long): void;
    /**
     * Retrieves the current DOM document for the frame, or lazily creates a
     * blank document if there is none.  This attribute never returns null except
     * for unexpected error situations.
     */
    readonly document: Document;
    /**
     * The currently loaded URI or null.
     */
    readonly currentURI: nsIURI;
    /**
     * The session history object used by this web navigation instance. This
     * object will be a mozilla::dom::ChildSHistory object, but is returned as
     * nsISupports so it can be called from JS code.
     */
    readonly sessionHistory: nsISupports;
    /**
     * Resume a load which has been redirected from another process.
     *
     * A negative |aHistoryIndex| value corresponds to a non-history load being
     * resumed.
     */
    resumeRedirectedLoad(aLoadIdentifier: unsigned_long_long, aHistoryIndex: long): void;
}

/**
 * The nsIWebNavigationInfo interface exposes a way to get information
 * on the capabilities of Gecko webnavigation objects.
 */
declare interface nsIWebNavigationInfoType extends nsISupportsType {
    /**
     * Query whether aType is supported.
     * @param aType the MIME type in question.
     * @return an enum value indicating whether and how aType is supported.
     * @note This method may rescan plugins to ensure that they're properly
     * registered for the types they support.
     */
    isTypeSupported(aType: ACString): unsigned_long;
}

/**
 * The nsIWebPageDescriptor interface allows content being displayed in one
 * window to be loaded into another window without refetching it from the
 * network.
 */
declare interface nsIWebPageDescriptorType extends nsISupportsType {
    /**
     * Tells the object to load the page that otherDocShell is currently loading,
     * or has loaded already, as view source, with the url being `aURL`.
     *
     * @throws NS_ERROR_FAILURE - NS_ERROR_INVALID_POINTER
     */
    loadPageAsViewSource(otherDocShell: nsIDocShellType, aURL: AString): void;
    /**
     * Retrieves the page descriptor for the curent document.
     * @note, currentDescriptor is currently always an nsISHEntry object or null.
     */
    readonly currentDescriptor: nsISupports;
}

/**
 * The nsIWebProgress interface is used to add or remove nsIWebProgressListener
 * instances to observe the loading of asynchronous requests (usually in the
 * context of a DOM window).
 *
 * nsIWebProgress instances may be arranged in a parent-child configuration,
 * corresponding to the parent-child configuration of their respective DOM
 * windows.  However, in some cases a nsIWebProgress instance may not have an
 * associated DOM window.  The parent-child relationship of nsIWebProgress
 * instances is not made explicit by this interface, but the relationship may
 * exist in some implementations.
 *
 * A nsIWebProgressListener instance receives notifications for the
 * nsIWebProgress instance to which it added itself, and it may also receive
 * notifications from any nsIWebProgress instances that are children of that
 * nsIWebProgress instance.
 */
declare interface nsIWebProgressType extends nsISupportsType {
    /**
     * Registers a listener to receive web progress events.
     *
     * @param aListener
     * The listener interface to be called when a progress event occurs.
     * This object must also implement nsISupportsWeakReference.
     * @param aNotifyMask
     * The types of notifications to receive.
     *
     * @throw NS_ERROR_INVALID_ARG
     * Indicates that aListener was either null or that it does not
     * support weak references.
     * @throw NS_ERROR_FAILURE
     * Indicates that aListener was already registered.
     */
    addProgressListener(aListener: nsIWebProgressListenerType, aNotifyMask: unsigned_long): void;
    /**
     * Removes a previously registered listener of progress events.
     *
     * @param aListener
     * The listener interface previously registered with a call to
     * addProgressListener.
     *
     * @throw NS_ERROR_FAILURE
     * Indicates that aListener was not registered.
     */
    removeProgressListener(aListener: nsIWebProgressListenerType): void;
    /**
     * BrowsingContext associated with this nsIWebProgress instance, or `null` if
     * there is no BrowsingContext.
     */
    readonly browsingContext: BrowsingContext;
    /**
     * The DOM window associated with this nsIWebProgress instance.
     *
     * @throw NS_ERROR_FAILURE
     * Indicates that there is no associated DOM window.
     */
    readonly DOMWindow: mozIDOMWindowProxy;
    /**
     * Indicates whether DOMWindow.top == DOMWindow.
     */
    readonly isTopLevel: boolean;
    /**
     * Indicates whether or not a document is currently being loaded
     * in the context of this nsIWebProgress instance.
     */
    readonly isLoadingDocument: boolean;
    /**
     * Contains a load type as specified by the load* constants in
     * nsIDocShell:LoadCommand.
     */
    readonly loadType: unsigned_long;
    /**
     * Main thread event target to which progress updates should be
     * dispatched. This typically will be a SchedulerEventTarget
     * corresponding to the tab requesting updates.
     */
    target: nsIEventTarget;
    /**
     * The request for the currently loading document. It is null if
     * isLoadingDocument is false.
     * Note, the request may not be the actual nsIChannel instance used for
     * loading, but a dummy RemoteWebProgressRequest. And since redirects are
     * hidden from the child processes, this may not reflect the complete
     * redirect state of the load.
     */
    readonly documentRequest: nsIRequest;
}

/**
 * The nsIWebProgressListener interface is implemented by clients wishing to
 * listen in on the progress associated with the loading of asynchronous
 * requests in the context of a nsIWebProgress instance as well as any child
 * nsIWebProgress instances.  nsIWebProgress.idl describes the parent-child
 * relationship of nsIWebProgress instances.
 */
declare interface nsIWebProgressListenerType extends nsISupportsType {
    /**
     * Notification indicating the state has changed for one of the requests
     * associated with aWebProgress.
     *
     * @param aWebProgress
     * The nsIWebProgress instance that fired the notification
     * @param aRequest
     * The nsIRequest that has changed state.
     * @param aStateFlags
     * Flags indicating the new state.  This value is a combination of one
     * of the State Transition Flags and one or more of the State Type
     * Flags defined above.  Any undefined bits are reserved for future
     * use.
     * @param aStatus
     * Error status code associated with the state change.  This parameter
     * should be ignored unless aStateFlags includes the STATE_STOP bit.
     * The status code indicates success or failure of the request
     * associated with the state change.  NOTE: aStatus may be a success
     * code even for server generated errors, such as the HTTP 404 error.
     * In such cases, the request itself should be queried for extended
     * error information (e.g., for HTTP requests see nsIHttpChannel).
     */
    onStateChange(aWebProgress: nsIWebProgressType, aRequest: nsIRequestType, aStateFlags: unsigned_long, aStatus: nsresult): void;
    /**
     * Notification that the progress has changed for one of the requests
     * associated with aWebProgress.  Progress totals are reset to zero when all
     * requests in aWebProgress complete (corresponding to onStateChange being
     * called with aStateFlags including the STATE_STOP and STATE_IS_WINDOW
     * flags).
     *
     * @param aWebProgress
     * The nsIWebProgress instance that fired the notification.
     * @param aRequest
     * The nsIRequest that has new progress.
     * @param aCurSelfProgress
     * The current progress for aRequest.
     * @param aMaxSelfProgress
     * The maximum progress for aRequest.
     * @param aCurTotalProgress
     * The current progress for all requests associated with aWebProgress.
     * @param aMaxTotalProgress
     * The total progress for all requests associated with aWebProgress.
     *
     * NOTE: If any progress value is unknown, or if its value would exceed the
     * maximum value of type long, then its value is replaced with -1.
     *
     * NOTE: If the object also implements nsIWebProgressListener2 and the caller
     * knows about that interface, this function will not be called. Instead,
     * nsIWebProgressListener2::onProgressChange64 will be called.
     */
    onProgressChange(aWebProgress: nsIWebProgressType, aRequest: nsIRequestType, aCurSelfProgress: long, aMaxSelfProgress: long, aCurTotalProgress: long, aMaxTotalProgress: long): void;
    /**
     * Called when the location of the window being watched changes.  This is not
     * when a load is requested, but rather once it is verified that the load is
     * going to occur in the given window.  For instance, a load that starts in a
     * window might send progress and status messages for the new site, but it
     * will not send the onLocationChange until we are sure that we are loading
     * this new page here.
     *
     * @param aWebProgress
     * The nsIWebProgress instance that fired the notification.
     * @param aRequest
     * The associated nsIRequest.  This may be null in some cases.
     * @param aLocation
     * The URI of the location that is being loaded.
     * @param aFlags
     * This is a value which explains the situation or the reason why
     * the location has changed.
     */
    onLocationChange(aWebProgress: nsIWebProgressType, aRequest: nsIRequestType, aLocation: nsIURIType, aFlags: unsigned_long): void;
    /**
     * Notification that the status of a request has changed.  The status message
     * is intended to be displayed to the user (e.g., in the status bar of the
     * browser).
     *
     * @param aWebProgress
     * The nsIWebProgress instance that fired the notification.
     * @param aRequest
     * The nsIRequest that has new status.
     * @param aStatus
     * This value is not an error code.  Instead, it is a numeric value
     * that indicates the current status of the request.  This interface
     * does not define the set of possible status codes.  NOTE: Some
     * status values are defined by nsITransport and nsISocketTransport.
     * @param aMessage
     * Localized text corresponding to aStatus.
     */
    onStatusChange(aWebProgress: nsIWebProgressType, aRequest: nsIRequestType, aStatus: nsresult, aMessage: wstring): void;
    /**
     * Notification called for security progress.  This method will be called on
     * security transitions (eg HTTP -> HTTPS, HTTPS -> HTTP, FOO -> HTTPS) and
     * after document load completion.  It might also be called if an error
     * occurs during network loading.
     *
     * @param aWebProgress
     * The nsIWebProgress instance that fired the notification.
     * @param aRequest
     * The nsIRequest that has new security state.
     * @param aState
     * A value composed of the Security State Flags and the Security
     * Strength Flags listed above.  Any undefined bits are reserved for
     * future use.
     *
     * NOTE: These notifications will only occur if a security package is
     * installed.
     */
    onSecurityChange(aWebProgress: nsIWebProgressType, aRequest: nsIRequestType, aState: unsigned_long): void;
    /**
     * Notification called for content blocking events.  This method will be
     * called when content gets allowed/blocked for various reasons per the
     * Content Blocking rules.
     *
     * @param aWebProgress
     * The nsIWebProgress instance that fired the notification.
     * @param aRequest
     * The nsIRequest that has new security state.
     * @param aEvent
     * A value composed of the Content Blocking Event Flags listed above.
     * Any undefined bits are reserved for future use.
     */
    onContentBlockingEvent(aWebProgress: nsIWebProgressType, aRequest: nsIRequestType, aEvent: unsigned_long): void;
}

/**
 * An extended version of nsIWebProgressListener.
 */
declare interface nsIWebProgressListener2Type extends nsIWebProgressListenerType {
    /**
     * Notification that the progress has changed for one of the requests
     * associated with aWebProgress.  Progress totals are reset to zero when all
     * requests in aWebProgress complete (corresponding to onStateChange being
     * called with aStateFlags including the STATE_STOP and STATE_IS_WINDOW
     * flags).
     *
     * This function is identical to nsIWebProgressListener::onProgressChange,
     * except that this function supports 64-bit values.
     *
     * @param aWebProgress
     * The nsIWebProgress instance that fired the notification.
     * @param aRequest
     * The nsIRequest that has new progress.
     * @param aCurSelfProgress
     * The current progress for aRequest.
     * @param aMaxSelfProgress
     * The maximum progress for aRequest.
     * @param aCurTotalProgress
     * The current progress for all requests associated with aWebProgress.
     * @param aMaxTotalProgress
     * The total progress for all requests associated with aWebProgress.
     *
     * NOTE: If any progress value is unknown, then its value is replaced with -1.
     *
     * @see nsIWebProgressListener2::onProgressChange64
     */
    onProgressChange64(aWebProgress: nsIWebProgressType, aRequest: nsIRequestType, aCurSelfProgress: long_long, aMaxSelfProgress: long_long, aCurTotalProgress: long_long, aMaxTotalProgress: long_long): void;
    /**
     * Notification that a refresh or redirect has been requested in aWebProgress
     * For example, via a <meta http-equiv="refresh"> or an HTTP Refresh: header
     *
     * @param aWebProgress
     * The nsIWebProgress instance that fired the notification.
     * @param aRefreshURI
     * The new URI that aWebProgress has requested redirecting to.
     * @param aMillis
     * The delay (in milliseconds) before refresh.
     * @param aSameURI
     * True if aWebProgress is requesting a refresh of the
     * current URI.
     * False if aWebProgress is requesting a redirection to
     * a different URI.
     *
     * @return True if the refresh may proceed.
     * False if the refresh should be aborted.
     */
    onRefreshAttempted(aWebProgress: nsIWebProgressType, aRefreshURI: nsIURIType, aMillis: unsigned_long, aSameURI: boolean): boolean;
}

/**
 * nsIWebProtocolHandlerRegistrar
 *
 * Applications wishing to use web protocol handlers need to implement this
 * interface. Typically they will prompt the user to confirm adding an entry
 * to the local list.
 *
 * The component must have the contract id defined below so that the Navigator
 * implementation can invoke it.
 */
declare interface nsIWebProtocolHandlerRegistrarType extends nsISupportsType {
    /**
     * See documentation in Navigator.webidl
     * The additional contentWindow param for this method represents the dom
     * content window from which the method has been called, or its browser window.
     */
    registerProtocolHandler(protocol: AString, uri: nsIURIType, title: AString, documentURI: nsIURIType, windowOrBrowser: nsISupportsType): void;
    /**
     * Removes a registered protocol handler
     *
     * While registerProtocolHandler is exposed on Navigator, unregistering
     * is exposed through the UI code.
     * @param   protocol
     * The protocol scheme to remove a service handler for
     * @param   uri
     * The uri of the service handler to remove
     */
    removeProtocolHandler(protocol: AString, uri: AString): void;
}

/**
 * Low-level websocket API: handles network protocol.
 *
 * This is primarly intended for use by the higher-level nsIWebSocket.idl.
 * We are also making it scriptable for now, but this may change once we have
 * WebSockets for Workers.
 */
declare interface nsIWebSocketChannelType extends nsISupportsType {
    /**
     * The original URI used to construct the protocol connection. This is used
     * in the case of a redirect or URI "resolution" (e.g. resolving a
     * resource: URI to a file: URI) so that the original pre-redirect
     * URI can still be obtained.  This is never null.
     */
    readonly originalURI: nsIURI;
    /**
     * The readonly URI corresponding to the protocol connection after any
     * redirections are completed.
     */
    readonly URI: nsIURI;
    /**
     * The notification callbacks for authorization, etc..
     */
    notificationCallbacks: nsIInterfaceRequestor;
    /**
     * Transport-level security information (if any)
     */
    readonly securityInfo: nsITransportSecurityInfo;
    /**
     * The load group of of the websocket
     */
    loadGroup: nsILoadGroup;
    /**
     * The load info of the websocket
     */
    loadInfo: nsILoadInfo;
    /**
     * Sec-Websocket-Protocol value
     */
    protocol: ACString;
    /**
     * Sec-Websocket-Extensions response header value
     */
    readonly extensions: ACString;
    /**
     * The channelId of the underlying http channel.
     * It's available only after nsIWebSocketListener::onStart
     */
    readonly httpChannelId: uint64_t;
    /**
     * Init the WebSocketChannel with LoadInfo arguments.
     * @param aLoadingNode
     * @param aLoadingPrincipal
     * @param aTriggeringPrincipal
     * @param aCookieJarSettings
     * @param aSecurityFlags
     * @param aContentPolicyType
     * These will be used as values for the nsILoadInfo object on the
     * created channel. For details, see nsILoadInfo in nsILoadInfo.idl
     * @return reference to the new nsIChannel object
     *
     * Keep in mind that URIs coming from a webpage should *never* use the
     * systemPrincipal as the loadingPrincipal.
     *
     * Please note, if you provide both a loadingNode and a loadingPrincipal,
     * then loadingPrincipal must be equal to loadingNode->NodePrincipal().
     * But less error prone is to just supply a loadingNode.
     */
    initLoadInfoNative(aLoadingNode: Node, aLoadingPrincipal: nsIPrincipalType, aTriggeringPrincipal: nsIPrincipalType, aCookieJarSettings: nsICookieJarSettingsType, aSecurityFlags: unsigned_long, aContentPolicyType: nsContentPolicyType, aSandboxFlags: unsigned_long): nsresult;
    /**
     * Similar to the previous one but without nsICookieJarSettings.
     * This method is used by JS code where nsICookieJarSettings is not exposed.
     */
    initLoadInfo(aLoadingNode: Node, aLoadingPrincipal: nsIPrincipalType, aTriggeringPrincipal: nsIPrincipalType, aSecurityFlags: unsigned_long, aContentPolicyType: nsContentPolicyType): void;
    /**
     * Asynchronously open the websocket connection.  Received messages are fed
     * to the socket listener as they arrive.  The socket listener's methods
     * are called on the thread that calls asyncOpen and are not called until
     * after asyncOpen returns.  If asyncOpen returns successfully, the
     * protocol implementation promises to call at least onStop on the listener.
     *
     * NOTE: Implementations should throw NS_ERROR_ALREADY_OPENED if the
     * websocket connection is reopened.
     *
     * @param aURI the uri of the websocket protocol - may be redirected
     * @param aOrigin the uri of the originating resource
     * @param aOriginAttributes attributes of the originating resource.
     * @param aInnerWindowID the inner window ID
     * @param aListener the nsIWebSocketListener implementation
     * @param aContext an opaque parameter forwarded to aListener's methods
     */
    asyncOpen(aURI: nsIURIType, aOrigin: ACString, aOriginAttributes: jsval, aInnerWindowID: unsigned_long_long, aListener: nsIWebSocketListenerType, aContext: nsISupportsType): void;
    /**
     *
     */
    asyncOpenNative(aURI: nsIURIType, aOrigin: ACString, aOriginAttributes: OriginAttributes, aInnerWindowID: unsigned_long_long, aListener: nsIWebSocketListenerType, aContext: nsISupportsType): void;
    /**
     * Close the websocket connection for writing - no more calls to sendMsg
     * or sendBinaryMsg should be made after calling this. The listener object
     * may receive more messages if a server close has not yet been received.
     *
     * @param aCode the websocket closing handshake close code. Set to 0 if
     * you are not providing a code.
     * @param aReason the websocket closing handshake close reason
     */
    close(aCode: unsigned_short, aReason: AUTF8String): void;
    /**
     * Use to send text message down the connection to WebSocket peer.
     *
     * @param aMsg the utf8 string to send
     */
    sendMsg(aMsg: AUTF8String): void;
    /**
     * Use to send binary message down the connection to WebSocket peer.
     *
     * @param aMsg the data to send
     */
    sendBinaryMsg(aMsg: ACString): void;
    /**
     * Use to send a binary stream (Blob) to Websocket peer.
     *
     * @param aStream The input stream to be sent.
     */
    sendBinaryStream(aStream: nsIInputStreamType, length: unsigned_long): void;
    /**
     * This value determines how often (in seconds) websocket keepalive
     * pings are sent.  If set to 0 (the default), no pings are ever sent.
     *
     * This value can currently only be set before asyncOpen is called, else
     * NS_ERROR_IN_PROGRESS is thrown.
     *
     * Be careful using this setting: ping traffic can consume lots of power and
     * bandwidth over time.
     */
    pingInterval: unsigned_long;
    /**
     * This value determines how long (in seconds) the websocket waits for
     * the server to reply to a ping that has been sent before considering the
     * connection broken.
     *
     * This value can currently only be set before asyncOpen is called, else
     * NS_ERROR_IN_PROGRESS is thrown.
     */
    pingTimeout: unsigned_long;
    /**
     * Unique ID for this channel. It's not readonly because when the channel is
     * created via IPC, the serial number is received from the child process.
     */
    serial: unsigned_long;
    /**
     * Set a nsITransportProvider and negotated extensions to be used by this
     * channel. Calling this function also means that this channel will
     * implement the server-side part of a websocket connection rather than the
     * client-side part.
     */
    setServerParameters(aProvider: nsITransportProviderType, aNegotiatedExtensions: ACString): void;
}

/**
 *
 */
declare interface nsIWebSocketFrameType extends nsISupportsType {
    /**
     *
     */
    readonly timeStamp: DOMHighResTimeStamp;
    /**
     *
     */
    readonly finBit: boolean;
    /**
     *
     */
    readonly rsvBit1: boolean;
    /**
     *
     */
    readonly rsvBit2: boolean;
    /**
     *
     */
    readonly rsvBit3: boolean;
    /**
     *
     */
    readonly opCode: unsigned_short;
    /**
     *
     */
    readonly maskBit: boolean;
    /**
     *
     */
    readonly mask: unsigned_long;
    /**
     *
     */
    readonly payload: ACString;
}

/**
 *
 */
declare interface nsIWebSocketEventListenerType extends nsISupportsType {
    /**
     *
     */
    webSocketCreated(aWebSocketSerialID: unsigned_long, aURI: AString, aProtocols: ACString): void;
    /**
     *
     */
    webSocketOpened(aWebSocketSerialID: unsigned_long, aEffectiveURI: AString, aProtocols: ACString, aExtensions: ACString, aHttpChannelId: uint64_t): void;
    /**
     *
     */
    webSocketMessageAvailable(aWebSocketSerialID: unsigned_long, aMessage: ACString, aType: unsigned_short): void;
    /**
     *
     */
    webSocketClosed(aWebSocketSerialID: unsigned_long, aWasClean: boolean, aCode: unsigned_short, aReason: AString): void;
    /**
     *
     */
    frameReceived(aWebSocketSerialID: unsigned_long, aFrame: nsIWebSocketFrameType): void;
    /**
     *
     */
    frameSent(aWebSocketSerialID: unsigned_long, aFrame: nsIWebSocketFrameType): void;
}

/**
 *
 */
declare interface nsIWebSocketEventServiceType extends nsISupportsType {
    /**
     *
     */
    sendMessage(aWebSocketSerialID: unsigned_long, aMessage: AString): void;
    /**
     *
     */
    addListener(aInnerWindowID: unsigned_long_long, aListener: nsIWebSocketEventListenerType): void;
    /**
     *
     */
    removeListener(aInnerWindowID: unsigned_long_long, aListener: nsIWebSocketEventListenerType): void;
    /**
     *
     */
    hasListenerFor(aInnerWindowID: unsigned_long_long): bool;
}

/**
 *
 */
declare interface nsIWebSocketImplType extends nsISupportsType {
    /**
     * Called to send message of type string through web socket
     *
     * @param aMessage the message to send
     */
    sendMessage(aMessage: AString): void;
}

/**
 * nsIWebSocketListener: passed to nsIWebSocketChannel::AsyncOpen. Receives
 * websocket traffic events as they arrive.
 */
declare interface nsIWebSocketListenerType extends nsISupportsType {
    /**
     * Called to signify the establishment of the message stream.
     *
     * Unlike most other networking channels (which use nsIRequestObserver
     * instead of this class), we do not guarantee that OnStart is always
     * called: OnStop is called without calling this function if errors occur
     * during connection setup.  If the websocket connection is successful,
     * OnStart will be called before any other calls to this API.
     *
     * @param aContext user defined context
     */
    onStart(aContext: nsISupportsType): void;
    /**
     * Called to signify the completion of the message stream.
     * OnStop is the final notification the listener will receive and it
     * completes the WebSocket connection: after it returns the
     * nsIWebSocketChannel will release its reference to the listener.
     *
     * Note: this event can be received in error cases even if
     * nsIWebSocketChannel::Close() has not been called.
     *
     * @param aContext user defined context
     * @param aStatusCode reason for stopping (NS_OK if completed successfully)
     */
    onStop(aContext: nsISupportsType, aStatusCode: nsresult): void;
    /**
     * Called to deliver text message.
     *
     * @param aContext user defined context
     * @param aMsg the message data
     */
    onMessageAvailable(aContext: nsISupportsType, aMsg: AUTF8String): void;
    /**
     * Called to deliver binary message.
     *
     * @param aContext user defined context
     * @param aMsg the message data
     */
    onBinaryMessageAvailable(aContext: nsISupportsType, aMsg: ACString): void;
    /**
     * Called to acknowledge message sent via sendMsg() or sendBinaryMsg.
     *
     * @param aContext user defined context
     * @param aSize number of bytes placed in OS send buffer
     */
    onAcknowledge(aContext: nsISupportsType, aSize: uint32_t): void;
    /**
     * Called to inform receipt of WebSocket Close message from server.
     * In the case of errors onStop() can be called without ever
     * receiving server close.
     *
     * No additional messages through onMessageAvailable(),
     * onBinaryMessageAvailable() or onAcknowledge() will be delievered
     * to the listener after onServerClose(), though outgoing messages can still
     * be sent through the nsIWebSocketChannel connection.
     *
     * @param aContext user defined context
     * @param aCode the websocket closing handshake close code.
     * @param aReason the websocket closing handshake close reason
     */
    onServerClose(aContext: nsISupportsType, aCode: unsigned_short, aReason: AUTF8String): void;
    /**
     * Called to inform an error is happened. The connection will be closed
     * when this is called.
     */
    OnError(): void;
}

/**
 *
 */
declare interface nsIWebTransportType extends nsISupportsType {
    /**
     *
     */
    asyncConnect(aURI: nsIURIType, aLoadingPrincipal: nsIPrincipalType, aSecurityFlags: unsigned_long, aListener: WebTransportSessionEventListener): void;
    /**
     *
     */
    asyncConnectWithClient(aURI: nsIURIType, aLoadingPrincipal: nsIPrincipalType, aSecurityFlags: unsigned_long, aListener: WebTransportSessionEventListener, aClientInfo: const_MaybeClientInfoRef): void;
    /**
     *
     */
    getStats(): void;
    /**
     *
     */
    closeSession(aErrorCode: uint32_t, aReason: ACString): void;
    /**
     *
     */
    createOutgoingBidirectionalStream(aListener: nsIWebTransportStreamCallbackType): void;
    /**
     *
     */
    createOutgoingUnidirectionalStream(aListener: nsIWebTransportStreamCallbackType): void;
    /**
     *
     */
    sendDatagram(aData: invalid, aTrackingId: uint64_t): void;
    /**
     *
     */
    getMaxDatagramSize(): void;
}

/**
 *
 */
declare interface WebTransportSessionEventListenerType extends nsISupportsType {
    /**
     *
     */
    onSessionReady(aSessionId: uint64_t): void;
    /**
     *
     */
    onSessionReadyInternal(aSession: Http3WebTransportSessionPtr): void;
    /**
     *
     */
    onSessionClosed(aCleanly: bool, aErrorCode: uint32_t, aReason: ACString): void;
    /**
     *
     */
    onIncomingBidirectionalStreamAvailable(aStream: nsIWebTransportBidirectionalStreamType): void;
    /**
     *
     */
    onIncomingUnidirectionalStreamAvailable(aStream: nsIWebTransportReceiveStreamType): void;
    /**
     *
     */
    onIncomingStreamAvailableInternal(aStream: Http3WebTransportStreamPtr): void;
    /**
     *
     */
    onStopSending(aStreamId: uint64_t, aError: nsresult): void;
    /**
     *
     */
    onResetReceived(aStreamId: uint64_t, aError: nsresult): void;
    /**
     *
     */
    onDatagramReceived(aData: invalid): void;
    /**
     *
     */
    onDatagramReceivedInternal(aData: Datagram): void;
    /**
     *
     */
    onMaxDatagramSize(aSize: uint64_t): void;
    /**
     *
     */
    onOutgoingDatagramOutCome(aId: uint64_t, aOutCome: WebTransportSessionEventListener_DatagramOutcome): void;
}

/**
 *
 */
declare interface nsIWebTransportStreamCallbackType extends nsISupportsType {
    /**
     *
     */
    onBidirectionalStreamReady(aStream: nsIWebTransportBidirectionalStreamType): void;
    /**
     *
     */
    onUnidirectionalStreamReady(aStream: nsIWebTransportSendStreamType): void;
    /**
     *
     */
    onError(aError: uint8_t): void;
}

/**
 *
 */
declare interface nsIWebTransportSendStreamStatsType extends nsISupportsType {
    /**
     *
     */
    readonly timestamp: TimeStamp;
    /**
     *
     */
    readonly bytesSent: unsigned_long_long;
    /**
     *
     */
    readonly bytesAcknowledged: unsigned_long_long;
}

/**
 *
 */
declare interface nsIWebTransportReceiveStreamStatsType extends nsISupportsType {
    /**
     *
     */
    readonly timestamp: TimeStamp;
    /**
     *
     */
    readonly bytesReceived: unsigned_long_long;
}

/**
 *
 */
declare interface nsIWebTransportStreamStatsCallbackType extends nsISupportsType {
    /**
     *
     */
    onSendStatsAvailable(aStats: nsIWebTransportSendStreamStatsType): void;
    /**
     *
     */
    onReceiveStatsAvailable(aStats: nsIWebTransportReceiveStreamStatsType): void;
}

/**
 *
 */
declare interface nsIWebTransportReceiveStreamType extends nsISupportsType {
    /**
     *
     */
    sendStopSending(aError: uint8_t): void;
    /**
     *
     */
    getReceiveStreamStats(aCallback: nsIWebTransportStreamStatsCallbackType): void;
    /**
     *
     */
    readonly hasReceivedFIN: boolean;
    /**
     *
     */
    readonly inputStream: nsIAsyncInputStream;
    /**
     *
     */
    readonly streamId: uint64_t;
}

/**
 *
 */
declare interface nsIWebTransportSendStreamType extends nsISupportsType {
    /**
     *
     */
    sendFin(): void;
    /**
     *
     */
    reset(aErrorCode: uint8_t): void;
    /**
     *
     */
    getSendStreamStats(aCallback: nsIWebTransportStreamStatsCallbackType): void;
    /**
     *
     */
    readonly outputStream: nsIAsyncOutputStream;
    /**
     *
     */
    readonly streamId: uint64_t;
    /**
     *
     */
    setSendOrder(aSendOrder: int64_t): void;
}

/**
 *
 */
declare interface nsIWebTransportBidirectionalStreamType extends nsISupportsType {
    /**
     *
     */
    sendStopSending(aError: uint8_t): void;
    /**
     *
     */
    sendFin(): void;
    /**
     *
     */
    reset(aErrorCode: uint8_t): void;
    /**
     *
     */
    readonly hasReceivedFIN: boolean;
    /**
     *
     */
    readonly inputStream: nsIAsyncInputStream;
    /**
     *
     */
    readonly outputStream: nsIAsyncOutputStream;
    /**
     *
     */
    readonly streamId: uint64_t;
    /**
     *
     */
    setSendOrder(aSendOrder: int64_t): void;
}

/**
 * Listener for a JS WebVTT parser (vtt.js).
 */
declare interface nsIWebVTTListenerType extends nsISupportsType {
    /**
     * Is called when the WebVTTParser successfully parses a WebVTT cue.
     *
     * @param cue An object representing the data of a parsed WebVTT cue.
     */
    onCue(cue: jsval): void;
    /**
     * Is called when the WebVTT parser successfully parses a WebVTT region.
     *
     * @param region An object representing the data of a parsed
     * WebVTT region.
     */
    onRegion(region: jsval): void;
    /**
     * Is called when the WebVTT parser encounters a parsing error.
     *
     * @param error The error code of the ParserError the occured.
     */
    onParsingError(errorCode: long): void;
}

/**
 * Interface for a wrapper of a JS WebVTT parser (vtt.js).
 */
declare interface nsIWebVTTParserWrapperType extends nsISupportsType {
    /**
     * Loads the JS WebVTTParser and sets it to use the passed window to create
     * VTTRegions and VTTCues. This function must be called before calling
     * parse, flush, or watch.
     *
     * @param window The window that the parser will use to create VTTCues and
     * VTTRegions.
     */
    loadParser(window: mozIDOMWindow): void;
    /**
     * Attempts to parse the stream's data as WebVTT format. When it successfully
     * parses a WebVTT region or WebVTT cue it will create a VTTRegion or VTTCue
     * object and pass it back to the callee through its callbacks.
     *
     * @param data   The buffer that contains the WebVTT data received by the
     * Necko consumer so far.
     */
    parse(data: ACString): void;
    /**
     * Flush indicates that no more data is expected from the stream. As such the
     * parser should try to parse any kind of partial data it has.
     */
    flush(): void;
    /**
     * Set this parser object to use an nsIWebVTTListener object for its onCue
     * and onRegion callbacks.
     *
     * @param callback The nsIWebVTTListener object that exposes onCue and
     * onRegion callbacks for the parser.
     */
    watch(callback: nsIWebVTTListenerType): void;
    /**
     * Cancel watching notifications which parser would send.
     */
    cancel(): void;
    /**
     * Convert the text content of a WebVTT cue to a document fragment so that
     * we can display it on the page.
     *
     * @param window A window object with which the document fragment will be
     * created.
     * @param cue    The cue whose content will be converted to a document
     * fragment.
     */
    convertCueToDOMTree(window: mozIDOMWindow, cue: nsISupportsType): DocumentFragment;
    /**
     * Compute the display state of the VTTCues in cues along with any VTTRegions
     * that they might be in. First, it computes the positioning and styling of
     * the cues and regions passed and converts them into a DOM tree rooted at
     * a containing HTMLDivElement. It then adjusts those computed divs for
     * overlap avoidance using the dimensions of 'overlay'. Finally, it adds the
     * computed divs to the VTTCues display state property for use later.
     *
     * @param window  A window object with which it will create the DOM tree
     * and containing div element.
     * @param cues    An array of VTTCues who need there display state to be
     * computed.
     * @param overlay The HTMLElement that the cues will be displayed within.
     * @param controls The video control element that will affect cues position.
     */
    processCues(window: mozIDOMWindow, cues: nsIVariantType, overlay: nsISupportsType, controls: nsISupportsType): void;
}

/**
 *
 */
declare interface nsIWellKnownOpportunisticUtilsType extends nsISupportsType {
    /**
     *
     */
    verify(aJSON: ACString, aOrigin: ACString): void;
    /**
     *
     */
    readonly valid: bool;
}

/**
 *
 */
declare interface nsIWifiAccessPointType extends nsISupportsType {
    /**
     * The mac address of the WiFi node.  The format of this string is:
     * XX-XX-XX-XX-XX-XX
     */
    readonly mac: ACString;
    /**
     * Public name of a wireless network.  The charset of this string is ASCII.
     * This string will be null if not available.
     *
     * Note that this is a conversion of the SSID which makes it "displayable".
     * for any comparisons, you want to use the Raw SSID.
     */
    readonly ssid: AString;
    /**
     * Public name of a wireless network.  These are the bytes that are read off
     * of the network, may contain nulls, and generally shouldn't be displayed to
     * the user.
     */
    readonly rawSSID: ACString;
    /**
     * Current signal strength measured in dBm.
     */
    readonly signal: long;
}

/**
 *
 */
declare interface nsIWifiListenerType extends nsISupportsType {
    /**
     * Called when the list of access points changes.
     *
     * @param accessPoints An array of nsIWifiAccessPoint representing all
     * access points in view.
     */
    onChange(accessPoints: invalid): void;
    /**
     * Called when there is a problem with listening to wifi
     *
     * @param error the error which caused this event.  The
     * error values will be nsresult codes.
     */
    onError(error: nsresult): void;
}

/**
 *
 */
declare interface nsIWifiMonitorType extends nsISupportsType {
    /**
     * startWatching
     * aListener will be called once, then each time the list of wifi access
     * points change.  The wifi access point list will be updated when our
     * network changes, or on a regular interval if we are on a mobile network.
     * If aForcePolling is true then we will always poll as long as this
     * listener is watching.
     */
    startWatching(aListener: nsIWifiListenerType, aForcePolling: boolean): void;
    /**
     * stopWatching
     * cancels all notifications to the |aListener|.
     */
    stopWatching(aListener: nsIWifiListenerType): void;
}

/**
 * A scriptable interface used on Windows only to do some work from
 * a special process that gets created with elevated privileges.
 *
 * @status UNSTABLE - This interface is not frozen and will probably change in
 * future releases.
 */
declare interface nsIWinAppHelperType extends nsISupportsType {
    /**
     *
     */
    readonly userCanElevate: boolean;
}

/**
 * An interface for Windows Task Scheduler 2.0.
 * Documentation for the underlying APIs can be found at
 * https://docs.microsoft.com/en-us/windows/win32/taskschd/task-scheduler-start-page
 */
declare interface nsIWinTaskSchedulerServiceType extends nsISupportsType {
    /**
     * Register (create) a task from an XML definition.
     * The task will be created so that it only runs as the current user
     * (TASK_LOGON_INTERACTIVE_TOKEN).
     *
     * @throws NS_ERROR_FILE_NOT_FOUND if the folder does not exist.
     * @throws NS_ERROR_FILE_ALREADY_EXISTS if the task already existed and aUpdateExisting is false.
     *
     * @param aFolderName     Full name of the folder in which to create the task, starting with "\".
     *
     * @param aTaskName       Name of the task.
     *
     * @param aDefinitionXML  XML definition of the task. This is passed directly to Task Scheduler,
     * see the schema at
     * https://docs.microsoft.com/en-us/windows/win32/taskschd/task-scheduler-schema
     *
     * @param aUpdateExisting Whether to update an existing task with the same name, default false.
     */
    registerTask(aFolderName: wstring, aTaskName: wstring, aDefinitionXML: wstring, aUpdateExisting: boolean): void;
    /**
     * Validate the XML task definition with Task Scheduler without creating a task, for testing.
     * Doesn't throw if only the final ITaskFolder::RegisterTask() fails.
     *
     * @param aDefinitionXML      Definition to validate.
     * @return                    HRESULT from ITaskFolder::RegisterTask()
     * Success should be S_OK (0). XML validation failure could be one of
     * SCHED_E_UNEXPECTED_NODE, SCHED_E_NAMESPACE, SCHED_E_INVALIDVALUE,
     * SCHED_E_MISSINGNODE, SCHED_E_MALFORMEDXML, but there may be others.
     */
    validateTaskDefinition(aDefinitionXML: wstring): long;
    /**
     * Get the registration information for a task.
     *
     * @throws NS_ERROR_FILE_NOT_FOUND if the folder or task do not exist.
     *
     * @param aFolderName     Full name of the folder containing the task, starting with "\".
     * @param aTaskName       Name of the task to read.
     * @return                Registration information for the task, as XML text.
     */
    getTaskXML(aFolderName: wstring, aTaskName: wstring): AString;
    /**
     * Delete a task.
     *
     * @throws NS_ERROR_FILE_NOT_FOUND if the folder or task do not exist.
     *
     * @param aFolderName     Full name of the folder containing the task, starting with "\".
     * @param aTaskName       Name of the task to delete.
     */
    deleteTask(aFolderName: wstring, aTaskName: wstring): void;
    /**
     * Create a new task subfolder under a given parent folder.
     *
     * @throws NS_ERROR_FILE_NOT_FOUND if the parent folder does not exist.
     * @throws NS_ERROR_FILE_ALREADY_EXISTS if the subfolder already exists.
     *
     * @param aParentFolderName       Immediate parent for the new folder, starting with "\".
     * @param aSubFolderName          Name of the new folder to create.
     */
    createFolder(aParentFolderName: wstring, aSubFolderName: wstring): void;
    /**
     * Delete a folder.
     *
     * @throws NS_ERROR_FILE_NOT_FOUND if the parent folder does not exist.
     * @throws NS_ERROR_FILE_DIR_NOT_EMPTY if the folder was not empty.
     *
     * @param aParentFolderName       Immediate parent of the folder to delete, starting with "\".
     * @param aSubFolderName          Name of the folder to delete.
     */
    deleteFolder(aParentFolderName: wstring, aSubFolderName: wstring): void;
}

/**
 * nsIWinTaskbar
 *
 * This interface represents a service which exposes the APIs provided by the
 * Windows taskbar to applications.
 *
 * Starting in Windows 7, applications gain some control over their appearance
 * in the taskbar. By default, there is one taskbar preview per top level
 * window (excluding popups). This preview is represented by an
 * nsITaskbarWindowPreview object.
 *
 * An application can register its own "tab" previews. Such previews will hide
 * the corresponding nsITaskbarWindowPreview automatically (though this is not
 * reflected in the visible attribute of the nsITaskbarWindowPreview). These
 * tab previews do not have to correspond to tabs in the application - they can
 * vary in size, shape and location. They do not even need to be actual GUI
 * elements on the window. Unlike window previews, tab previews require most of
 * the functionality of the nsITaskbarPreviewController to be implemented.
 *
 * Applications can also show progress on their taskbar icon. This does not
 * interact with the taskbar previews except if the nsITaskbarWindowPreview is
 * made invisible in which case the progress is naturally not shown on that
 * window.
 *
 * When taskbar icons are combined as is the default in Windows 7, the progress
 * for those windows is also combined as defined here:
 * http://msdn.microsoft.com/en-us/library/dd391697%28VS.85%29.aspx
 *
 * Applications may also define custom taskbar jump lists on application shortcuts.
 * See nsIJumpListBuilder for more information.
 */
declare interface nsIWinTaskbarType extends nsISupportsType {
    /**
     * Returns true if the operating system supports Win7+ taskbar features.
     * This property acts as a replacement for in-place os version checking.
     */
    readonly available: boolean;
    /**
     * Returns the default application user model identity the application
     * registers with the system. This id is used by the taskbar in grouping
     * windows and in associating pinned shortcuts with running instances and
     * jump lists.
     */
    readonly defaultGroupId: AString;
    /**
     * Same as above, but a different value so that Private Browsing windows
     * can be separated in the Taskbar.
     */
    readonly defaultPrivateGroupId: AString;
    /**
     * Taskbar window and tab preview management
     *
     * Creates a taskbar preview. The docshell should be a toplevel docshell and
     * is used to find the toplevel window. See the documentation for
     * nsITaskbarTabPreview for more information.
     */
    createTaskbarTabPreview(shell: nsIDocShellType, controller: nsITaskbarPreviewControllerType): nsITaskbarTabPreview;
    /**
     * Gets the taskbar preview for a window. The docshell is used to find the
     * toplevel window. See the documentation for nsITaskbarTabPreview for more
     * information.
     *
     * Note: to implement custom drawing or buttons, a controller is required.
     */
    getTaskbarWindowPreview(shell: nsIDocShellType): nsITaskbarWindowPreview;
    /**
     * Taskbar icon progress indicator
     *
     * Gets the taskbar progress for a window. The docshell is used to find the
     * toplevel window. See the documentation for nsITaskbarProgress for more
     * information.
     */
    getTaskbarProgress(shell: nsIDocShellType): nsITaskbarProgress;
    /**
     * Taskbar icon overlay
     *
     * Gets the taskbar icon overlay controller for a window. The docshell is used
     * to find the toplevel window. See the documentation in
     * nsITaskbarOverlayIconController for more details.
     */
    getOverlayIconController(shell: nsIDocShellType): nsITaskbarOverlayIconController;
    /**
     * Taskbar and start menu jump list management
     *
     * Retrieve a taskbar jump list builder
     *
     * Fails if a jump list build operation has already been initiated, developers
     * should make use of a single instance of nsIJumpListBuilder for building lists
     * within an application.
     *
     * @throw NS_ERROR_ALREADY_INITIALIZED if an nsIJumpListBuilder instance is
     * currently building a list.
     */
    createJumpListBuilder(aPrivateBrowsing: boolean): nsIJumpListBuilder;
    /**
     * Application window taskbar group settings
     *
     * Set the grouping id for a window.
     *
     * The runtime sets a default, global grouping id for all windows on startup.
     * setGroupIdForWindow allows individual windows to be grouped independently
     * on the taskbar. Ids should be unique to the app and window to insure
     * conflicts with other pinned applications do no arise.
     *
     * The default group id is based on application.ini vendor, application, and
     * version values, with a format of 'vendor.app.version'. The default can be
     * retrieved via defaultGroupId.
     *
     * Note, when a window changes taskbar window stacks, it is placed at the
     * bottom of the new stack.
     *
     * @throw NS_ERROR_INVALID_ARG if the window is not a valid top level window
     * associated with a widget.
     * @throw NS_ERROR_FAILURE if the property on the window could not be set.
     * @throw NS_ERROR_UNEXPECTED for general failures.
     */
    setGroupIdForWindow(aParent: mozIDOMWindow, aIdentifier: AString): void;
}

/**
 *
 */
declare interface nsIWindowCreatorType extends nsISupportsType {
    /**
     * Create a new window. Gecko will/may call this method, if made
     * available to it, to create new windows.
     * @param parent Parent window, if any. Null if not. The newly created
     * window should be made a child/dependent window of
     * the parent, if any (and if the concept applies
     * to the underlying OS).
     * @param chromeFlags Chrome features from nsIWebBrowserChrome
     * @param aOpenWindowInfo Information used to open initial content in
     * the new chrome window. Can be nullptr.
     * @param cancel Return |true| to reject window creation. If true the
     * implementation has determined the window should not
     * be created at all. The caller should not default
     * to any possible backup scheme for creating the window.
     * @return the new window. Will be null if canceled or an error occurred.
     */
    createChromeWindow(parent: nsIWebBrowserChromeType, chromeFlags: uint32_t, aOpenWindowInfo: nsIOpenWindowInfoType, cancel: boolean): nsIWebBrowserChrome;
}

/**
 *
 */
declare interface nsIWindowMediatorType extends nsISupportsType {
    /**
     * Return an enumerator which iterates over all windows of type aWindowType
     * from the oldest window to the youngest.
     * @param  aWindowType the returned enumerator will enumerate only
     * windows of this type. ("type" is the
     * |windowtype| attribute of the XML <window> element.)
     * If null, all windows will be enumerated.
     * @return an enumerator of nsIDOMWindows.  Note that windows close
     * asynchronously in many cases, so windows returned from this
     * enumerator can have .closed set to true.  Caveat enumerator!
     */
    getEnumerator(aWindowType: wstring): nsISimpleEnumerator;
    /**
     * Identical to getEnumerator except:
     * @return an enumerator of nsIAppWindows
     */
    getAppWindowEnumerator(aWindowType: wstring): nsISimpleEnumerator;
    /**
     * Return an enumerator which iterates over all windows of type aWindowType
     * in their z (front-to-back) order. Note this interface makes
     * no requirement that a window couldn't be revisited if windows
     * are re-ordered while z-order enumerators are active.
     * @param  aWindowType the returned enumerator will enumerate only
     * windows of this type. ("type" is the
     * |windowtype| attribute of the XML <window> element.)
     * If null, all windows will be enumerated.
     * @param  aFrontToBack if true, the enumerator enumerates windows in order
     * from front to back. back to front if false.
     * @return an enumerator of nsIAppWindows
     */
    getZOrderAppWindowEnumerator(aWindowType: wstring, aFrontToBack: boolean): nsISimpleEnumerator;
    /**
     * This is a shortcut for simply fetching the first window in
     * front to back order.
     * @param  aWindowType return the topmost window of this type.
     * ("type" is the |windowtype| attribute of
     * the XML <window> element.)
     * If null, return the topmost window of any type.
     * @return the topmost window
     */
    getMostRecentWindow(aWindowType: wstring): mozIDOMWindowProxy;
    /**
     * This is a shortcut for getMostRecentWindow('navigator:browser'), but
     * if that fails it also tries 'navigator:geckoview' and 'mail:3pane'.
     *
     * @return the topmost browser window
     */
    getMostRecentBrowserWindow(): mozIDOMWindowProxy;
    /**
     * Same as getMostRecentWindow, but ignores private browsing
     * windows.
     */
    getMostRecentNonPBWindow(aWindowType: wstring): mozIDOMWindowProxy;
    /**
     * Return the outer window with the given ID, if any.  Can return null.
     */
    getOuterWindowWithId(aOuterWindowID: unsigned_long_long): mozIDOMWindowProxy;
    /**
     * Return the inner window with the given current window ID, if any.
     * Can return null if no inner window with the ID exists or if it's not
     * a current inner anymore.
     */
    getCurrentInnerWindowWithId(aInnerWindowID: unsigned_long_long): mozIDOMWindow;
    /**
     * Register a listener for window status changes.
     * keeps strong ref? (to be decided)
     * @param aListener the listener to register
     */
    addListener(aListener: nsIWindowMediatorListenerType): void;
    /**
     * Unregister a listener of window status changes.
     * @param aListener the listener to unregister
     */
    removeListener(aListener: nsIWindowMediatorListenerType): void;
}

/**
 *
 */
declare interface nsIWindowMediatorListenerType extends nsISupportsType {
    /**
     *
     */
    onOpenWindow(window: nsIAppWindowType): void;
    /**
     *
     */
    onCloseWindow(window: nsIAppWindowType): void;
}

/**
 * The nsIWindowProvider interface exists so that the window watcher's default
 * behavior of opening a new window can be easly modified.  When the window
 * watcher needs to open a new window, it will first check with the
 * nsIWindowProvider it gets from the parent window.  If there is no provider
 * or the provider does not provide a window, the window watcher will proceed
 * to actually open a new window.
 */
declare interface nsIWindowProviderType extends nsISupportsType {
}

/**
 * nsIWindowWatcher is the keeper of Gecko/DOM Windows. It maintains
 * a list of open top-level windows, and allows some operations on them.
 * Usage notes:
 * This component has an |activeWindow| property. Clients may expect
 * this property to be always current, so to properly integrate this component
 * the application will need to keep it current by setting the property
 * as the active window changes.
 * This component should not keep a (XPCOM) reference to any windows;
 * the implementation will claim no ownership. Windows must notify
 * this component when they are created or destroyed, so only a weak
 * reference is kept. Note that there is no interface for such notifications
 * (not a public one, anyway). This is taken care of both in Mozilla and
 * by common embedding code. Embedding clients need do nothing special
 * about that requirement.
 * This component must be initialized at application startup by calling
 * setWindowCreator.
 */
declare interface nsIWindowWatcherType extends nsISupportsType {
    /**
     * Create a new window. It will automatically be added to our list
     * (via addWindow()).
     * @param aParent parent window, if any. Null if no parent.  If it is
     * impossible to get to an nsIWebBrowserChrome from aParent, this
     * method will effectively act as if aParent were null.
     * @param aURL url to which to open the new window. Must already be
     * escaped, if applicable. can be null.
     * @param aName window name from JS window.open. can be null.  If a window
     * with this name already exists, the openWindow call may just load
     * aUrl in it (if aUrl is not null) and return it.
     * @param aFeatures window features from JS window.open. can be null.
     * @param aArguments extra argument(s) to the new window, to be attached
     * as the |arguments| property. An nsIArray will be
     * unwound into multiple arguments (but not recursively!).
     * can be null.
     * @return the new window
     *
     * @note This method may examine the JS context stack for purposes of
     * determining the security context to use for the search for a given
     * window named aName.
     * @note This method should try to set the default charset for the new
     * window to the default charset of aParent.  This is not guaranteed,
     * however.
     * @note This method may dispatch a "toplevel-window-ready" notification
     * via nsIObserverService if the window did not already exist.
     */
    openWindow(aParent: mozIDOMWindowProxy, aUrl: ACString, aName: ACString, aFeatures: ACString, aArguments: nsISupportsType): mozIDOMWindowProxy;
    /**
     * Clients of this service can register themselves to be notified
     * when a window is opened or closed (added to or removed from this
     * service). This method adds an aObserver to the list of objects
     * to be notified.
     * @param aObserver the object to be notified when windows are
     * opened or closed. Its Observe method will be
     * called with the following parameters:
     *
     * aObserver::Observe interprets its parameters so:
     * aSubject the window being opened or closed, sent as an nsISupports
     * which can be QIed to an nsIDOMWindow.
     * aTopic   a wstring, either "domwindowopened" or "domwindowclosed".
     * someData not used.
     */
    registerNotification(aObserver: nsIObserverType): void;
    /**
     * Clients of this service can register themselves to be notified
     * when a window is opened or closed (added to or removed from this
     * service). This method removes an aObserver from the list of objects
     * to be notified.
     * @param aObserver the observer to be removed.
     */
    unregisterNotification(aObserver: nsIObserverType): void;
    /**
     * Get an iterator for currently open windows in the order they were opened,
     * guaranteeing that each will be visited exactly once.
     * @return an enumerator which will itself return nsISupports objects which
     * can be QIed to an nsIDOMWindow
     */
    getWindowEnumerator(): nsISimpleEnumerator;
    /**
     * Return a newly created nsIPrompt implementation.
     * @param aParent the parent window used for posing alerts. can be null.
     * @return a new nsIPrompt object
     */
    getNewPrompter(aParent: mozIDOMWindowProxy): nsIPrompt;
    /**
     * Return a newly created nsIAuthPrompt implementation.
     * @param aParent the parent window used for posing alerts. can be null.
     * @return a new nsIAuthPrompt object
     */
    getNewAuthPrompter(aParent: mozIDOMWindowProxy): nsIAuthPrompt;
    /**
     * Set the window creator callback. It must be filled in by the app.
     * openWindow will use it to create new windows.
     * @param creator the callback. if null, the callback will be cleared
     * and window creation capabilities lost.
     */
    setWindowCreator(creator: nsIWindowCreatorType): void;
    /**
     * Returns true if a window creator callback has been set, false otherwise.
     */
    hasWindowCreator(): boolean;
    /**
     * Retrieve the chrome window mapped to the given DOM window. Window
     * Watcher keeps a list of all top-level DOM windows currently open,
     * along with their corresponding chrome interfaces. Since DOM Windows
     * lack a (public) means of retrieving their corresponding chrome,
     * this method will do that.
     * @param aWindow the DOM window whose chrome window the caller needs
     * @return the corresponding chrome window
     */
    getChromeForWindow(aWindow: mozIDOMWindowProxy): nsIWebBrowserChrome;
    /**
     * Retrieve an existing chrome window (or frame).
     * @param aTargetName the window name
     *
     * Note: This method will not consider special names like "_blank", "_top",
     * "_self", or "_parent", as there is no reference window.
     *
     * Note: This method will search all open windows for any window or
     * frame with the given window name. Make sure you understand the
     * security implications of this before using this method!
     */
    getWindowByName(aTargetName: AString): mozIDOMWindowProxy;
    /**
     * Retrieves the active window from the focus manager.
     */
    readonly activeWindow: mozIDOMWindowProxy;
}

/**
 * This interface represents a nsIWebBrowser instance with no associated OS
 * window. Its main function is to manage the lifetimes of those windows.
 * A strong reference to this object must be held until the window is
 * ready to be destroyed.
 */
declare interface nsIWindowlessBrowserType extends nsIWebNavigationType {
    /**
     * "Closes" the windowless browser and destroys its associated nsIWebBrowser
     * and docshell.
     *
     * This method *must* be called for every windowless browser before its last
     * reference is released.
     */
    close(): void;
    /**
     * Get the docshell for this browser.  This is the docshell that gets
     * navigated when the browser's nsIWebNavigation interface is used.
     */
    readonly docShell: nsIDocShell;
    /**
     * Get the Browsing Context for this browser.  This is the Browsing Context
     * that owns the docshell used for navigation.
     */
    readonly browsingContext: BrowsingContext;
}

/**
 *
 */
declare interface nsIWindowsAlertsServiceType extends nsIAlertsServiceType {
    /**
     * If callbacks for the given Windows-specific tag string will be handled by
     * this Firefox process, set the associated event.
     *
     * @param {AString} aWindowsTag the tag
     * @return {Promise}
     * @resolves {Object}
     * Resolves with an Object, may contain the following optional
     * properties if notification exists but wasn't registered with
     * the WindowsAlertsService:
     *
     * `notificationData` {string} relaunch data, generally opaque to
     * the Windows notification server DLL, for this relaunch.
     *
     * @rejects `nsresult` when there was an error retrieving the notification.
     */
    handleWindowsTag(aWindowsTag: AString): Promise;
    /**
     * Get the Windows-specific XML generated for the given alert.
     *
     * @note This method is intended for testing purposes.
     *
     * @param {nsIAlertNotification} aAlert the alert
     * @param {AString} an optional Windows tag; default is generated
     * @return {string} generated XML
     */
    getXmlStringForWindowsAlert(aAlert: nsIAlertNotificationType, aWindowsTag: AString): AString;
    /**
     * Removes all action center and snoozed notifications associated with this
     * install. Note that this removes all notifications regardless of which profile
     * they originated from.
     */
    removeAllNotificationsForInstall(): void;
}

/**
 *
 */
declare interface nsIWindowsPackageManagerType extends nsISupportsType {
    /**
     * When running within a Packaged App environment, returns the
     * InstalledDate of the Package. If called when not running within
     * a Packaged App environment, throws NS_ERROR_NOT_IMPLEMENTED.
     * Any other others will cause NS_ERROR_FAILURE to be thrown.
     */
    getInstalledDate(): unsigned_long_long;
    /**
     * Retrieves the campaignId, if any, a user's Microsoft Store install is
     * associated with. These are present if the user clicked a "ms-window-store://"
     * or "https://" link that included a "cid" query argument the very first time
     * they installed the app. (This value appears to be cached forever, so
     * subsequent installs will not refresh it.) If a non-empty campaign ID is
     * found it will be assumed to be a properly formatted attribution code and
     * have an additional "msstoresignedin" key appended to it indicate whether or
     * not the user was signed in when they installed the application. This key
     * will either be set to "true" or "false".
     *
     * @throw NS_ERROR_NOT_IMPLEMENTED if called on Windows 8 or earlier, or from
     * a non-packaged build.
     * @throw NS_ERROR_FAILURE for any other errors
     */
    getCampaignId(): AString;
}

/**
 * This interface is designed to provide scriptable access to the Windows
 * registry system ("With Great Power Comes Great Responsibility").  The
 * interface represents a single key in the registry.
 *
 * This interface is highly Win32 specific.
 */
declare interface nsIWindowsRegKeyType extends nsISupportsType {
    /**
     * This attribute exposes the native HKEY and is available to provide C++
     * consumers with the flexibility of making other Windows registry API calls
     * that are not exposed via this interface.
     *
     * It is possible to initialize this object by setting an HKEY on it.  In
     * that case, it is the responsibility of the consumer setting the HKEY to
     * ensure that it is a valid HKEY.
     *
     * WARNING: Setting the key does not close the old key.
     */
    key: HKEY;
    /**
     * This method closes the key.  If the key is already closed, then this
     * method does nothing.
     */
    close(): void;
    /**
     * This method opens an existing key.  This method fails if the key
     * does not exist.
     *
     * NOTE: On 32-bit Windows, it is valid to pass any HKEY as the rootKey
     * parameter of this function.  However, for compatibility with 64-bit
     * Windows, that usage should probably be avoided in favor of openChild.
     *
     * @param rootKey
     * A root key defined above or any valid HKEY on 32-bit Windows.
     * @param relPath
     * A relative path from the given root key.
     * @param mode
     * Access mode, which is a bit-wise OR of the ACCESS_ values defined
     * above.
     */
    open(rootKey: unsigned_long, relPath: AString, mode: unsigned_long): void;
    /**
     * This method opens an existing key or creates a new key.
     *
     * NOTE: On 32-bit Windows, it is valid to pass any HKEY as the rootKey
     * parameter of this function.  However, for compatibility with 64-bit
     * Windows, that usage should probably be avoided in favor of createChild.
     *
     * @param rootKey
     * A root key defined above or any valid HKEY on 32-bit Windows.
     * @param relPath
     * A relative path from the given root key.
     * @param mode
     * Access mode, which is a bit-wise OR of the ACCESS_ values defined
     * above.
     */
    create(rootKey: unsigned_long, relPath: AString, mode: unsigned_long): void;
    /**
     * This method opens a subkey relative to this key.  This method fails if the
     * key does not exist.
     *
     * @return nsIWindowsRegKey for the newly opened subkey.
     */
    openChild(relPath: AString, mode: unsigned_long): nsIWindowsRegKey;
    /**
     * This method opens or creates a subkey relative to this key.
     *
     * @return nsIWindowsRegKey for the newly opened or created subkey.
     */
    createChild(relPath: AString, mode: unsigned_long): nsIWindowsRegKey;
    /**
     * This attribute returns the number of child keys.
     */
    readonly childCount: unsigned_long;
    /**
     * This method returns the name of the n'th child key.
     *
     * @param index
     * The index of the requested child key.
     */
    getChildName(index: unsigned_long): AString;
    /**
     * This method checks to see if the key has a child by the given name.
     *
     * @param name
     * The name of the requested child key.
     */
    hasChild(name: AString): boolean;
    /**
     * This attribute returns the number of values under this key.
     */
    readonly valueCount: unsigned_long;
    /**
     * This method returns the name of the n'th value under this key.
     *
     * @param index
     * The index of the requested value.
     */
    getValueName(index: unsigned_long): AString;
    /**
     * This method checks to see if the key has a value by the given name.
     *
     * @param name
     * The name of the requested value.
     */
    hasValue(name: AString): boolean;
    /**
     * This method removes a child key and all of its values.  This method will
     * fail if the key has any children of its own.
     *
     * @param relPath
     * The relative path from this key to the key to be removed.
     */
    removeChild(relPath: AString): void;
    /**
     * This method removes the value with the given name.
     *
     * @param name
     * The name of the value to be removed.
     */
    removeValue(name: AString): void;
    /**
     * This method returns the type of the value with the given name.  The return
     * value is one of the "TYPE_" constants defined above.
     *
     * @param name
     * The name of the value to query.
     */
    getValueType(name: AString): unsigned_long;
    /**
     * This method reads the string contents of the named value as a Unicode
     * string.
     *
     * @param name
     * The name of the value to query.  This parameter can be the empty
     * string to request the key's default value.
     */
    readStringValue(name: AString): AString;
    /**
     * This method reads the integer contents of the named value.
     *
     * @param name
     * The name of the value to query.
     */
    readIntValue(name: AString): unsigned_long;
    /**
     * This method reads the 64-bit integer contents of the named value.
     *
     * @param name
     * The name of the value to query.
     */
    readInt64Value(name: AString): unsigned_long_long;
    /**
     * This method reads the binary contents of the named value under this key.
     *
     * JavaScript callers should take care with the result of this method since
     * it will be byte-expanded to form a JS string.  (The binary data will be
     * treated as an ISO-Latin-1 character string, which it is not).
     *
     * @param name
     * The name of the value to query.
     */
    readBinaryValue(name: AString): ACString;
    /**
     * This method writes the unicode string contents of the named value.  The
     * value will be created if it does not already exist.
     *
     * @param name
     * The name of the value to modify.  This parameter can be the empty
     * string to modify the key's default value.
     * @param data
     * The data for the value to modify.
     */
    writeStringValue(name: AString, data: AString): void;
    /**
     * This method writes the integer contents of the named value.  The value
     * will be created if it does not already exist.
     *
     * @param name
     * The name of the value to modify.
     * @param data
     * The data for the value to modify.
     */
    writeIntValue(name: AString, data: unsigned_long): void;
    /**
     * This method writes the 64-bit integer contents of the named value.  The
     * value will be created if it does not already exist.
     *
     * @param name
     * The name of the value to modify.
     * @param data
     * The data for the value to modify.
     */
    writeInt64Value(name: AString, data: unsigned_long_long): void;
    /**
     * This method writes the binary contents of the named value.  The value will
     * be created if it does not already exist.
     *
     * JavaScript callers should take care with the value passed to this method
     * since it will be truncated from a JS string (unicode) to a ISO-Latin-1
     * string.  (The binary data will be treated as an ISO-Latin-1 character
     * string, which it is not).  So, JavaScript callers should only pass
     * character values in the range \u0000 to \u00FF, or else data loss will
     * occur.
     *
     * @param name
     * The name of the value to modify.
     * @param data
     * The data for the value to modify.
     */
    writeBinaryValue(name: AString, data: ACString): void;
    /**
     * This method starts watching the key to see if any of its values have
     * changed.  The key must have been opened with mode including ACCESS_NOTIFY.
     * If recurse is true, then this key and any of its descendant keys are
     * watched.  Otherwise, only this key is watched.
     *
     * @param recurse
     * Indicates whether or not to also watch child keys.
     */
    startWatching(recurse: boolean): void;
    /**
     * This method stops any watching of the key initiated by a call to
     * startWatching.  This method does nothing if the key is not being watched.
     */
    stopWatching(): void;
    /**
     * This method returns true if the key is being watched for changes (i.e.,
     * if startWatching() was called).
     */
    isWatching(): boolean;
    /**
     * This method returns true if the key has changed and false otherwise.
     * This method will always return false if startWatching was not called.
     */
    hasChanged(): boolean;
}

/**
 *
 */
declare interface nsIWindowsShellServiceType extends nsISupportsType {
    /**
     * Creates a new shortcut (.lnk) file. This shortcut will be recorded in
     * a new shortcuts log file located in %PROGRAMDATA%\Mozilla-1de4eec8-1241-4177-a864-e594e8d1fb38
     * that is named after the currently running application and current user, eg:
     * Firefox_user123_shortcuts.ini.
     *
     * For reasons that we haven't been able to pin down, these shortcuts get created with
     * extra metadata on them (KnownFolderDataBlock, SpecialFolderDataBlock) that cause
     * the Windows ShellLink classes to improperly read their target path with certain
     * parameters. This causes any 32-bit programs that read the links (such as our
     * installer and uninstaller) to think that 64-bit installs are located in the 32-bit
     * Program Files directory.
     * See https://social.msdn.microsoft.com/Forums/windowsdesktop/en-US/6f2e7920-50a9-459d-bfdd-316e459e87c0/ishelllink-getpath-returns-wrong-folder-for-64-bit-application-when-called-from-32-bit-application
     * for some additional discussion of this.
     *
     * @param aBinary Target file of the shortcut.
     * @param aArguments Arguments to set for the shortcut. May be empty.
     * @param aDescription The description of the shortcut. The string used here
     * shows up as the hover text of the shortcut in Explorer and on the
     * Taskbar (if the shortcut is pinned there).
     * @param aIconFile The file containing the desired icon for the shortcut. This
     * can be the same file as aBinary.
     * @param aIconIndex The index of the in aIconFile. Note that this is 0 based index
     * that IShellLinkW requires, _not_ a Resource ID that is sometimes used
     * for icons.
     * @param aAppUserModelId The App User Model ID to set for the shortcut. This will
     * affect which icon on the Taskbar the application groups with when first
     * launched.
     * @param aShortcutFolder The special Windows folder to create the shortcut in. One of:
     * CommonStartMenu, StartMenu, PublicDesktop, Desktop, or QuickLaunch.
     * @param aShortcutName The filename of the shortcut within aShortcutFolder.
     * @return The full native path to the created shortcut.
     *
     * @throws NS_ERROR_INVALID_ARG if an invalid shortcut folder is passed
     * @throws NS_ERROR_FILE_NOT_FOUND if the shortcut file or shortcuts log cannot be
     * created or accessed
     * @throws NS_ERROR_FAILURE for other types of failures
     */
    createShortcut(aBinary: nsIFileType, aArguments: invalid, aDescription: AString, aIconFile: nsIFileType, aIconIndex: unsigned_short, aAppUserModelId: AString, aShortcutFolder: AString, aShortcutName: AString): Promise;
    /**
     * Pin the current app to the taskbar. If aPrivateBrowsing is true, the
     * Private Browsing version of the app (with a different icon and launch
     * arguments) will be pinned instead.
     *
     * This MUST only be used in response to an active request from the user.
     *
     * If it exists, uses an existing shortcut on the Desktop or Start Menu,
     * which would have been created by the installer (for All Users or
     * Current User). If none can be found, one will be created with the correct
     * AUMID for proper launching and grouping.
     *
     * NOTE: It is possible for the shortcut match to fail even when a
     * shortcut refers to the current executable, if the paths differ due
     * to e.g. symlinks. This should be rare.
     *
     * This will definitely fail on an OS before Windows 10 build 1809
     * (October 2018 Update).
     *
     * NOTE: Can only run on the main thread, but the actual work occurs on a
     * background thread.
     *
     * @throws NS_ERROR_NOT_SAME_THREAD
     * if called off main thread.
     * @throws NS_ERROR_NOT_AVAILABLE
     * if OS is not at least Windows 10 build 1809, or if creating the
     * Taskband Pin object fails
     * @throws NS_ERROR_FAILURE
     * for unexpected errors
     *
     * @rejects NS_ERROR_FILE_NOT_FOUND
     * if a shortcut matching this app's AUMID and exe path wasn't found
     *
     * @returns {Promise<void>} A promise that resolves to |undefined| if
     * successful or rejects with an nserror.
     */
    pinCurrentAppToTaskbarAsync(aPrivateBrowsing: bool): Promise;
    /**
     * Do a dry run of pinCurrentAppToTaskbar().
     *
     * NOTE: Can only be run on the main thread, but the actual work occurs on a
     * background thread.
     *
     * This does all the same checks and setup, throws the same errors, but doesn't
     * do the final step of creating the pin.
     *
     * @throws same as pinCurrentAppToTaskbarAsync()
     * @rejects same as pinCurrentAppToTaskbarAsync()
     * @returns same as pinCurrentAppToTaskbarAsync()
     */
    checkPinCurrentAppToTaskbarAsync(aPrivateBrowsing: bool): Promise;
    /**
     * Search for the current executable among taskbar pins
     *
     * NOTE: Can only be run on the main thread, but the actual work occurs on a
     * background thread.
     *
     * NOTE: It is possible for the check to fail even when a taskbar pin refers
     * to this executable, if the paths differ due to e.g. symlinks.
     * It is also possible for the check to succeed with a shortcut that doesn't
     * actually appear on the taskbar.
     * These cases should be rare.
     *
     * @return Promise that always resolves, true if pinned, false otherwise
     * @throws NS_ERROR_NOT_SAME_THREAD if not run on the main thread
     */
    isCurrentAppPinnedToTaskbarAsync(aumid: AString): Promise;
    /**
     * Determine where a given shortcut likely appears in the shell.
     *
     * Returns one of:
     * - "StartMenu" or "StartMenuPrivate", Current User or All Users Start
     * Menu, including pins
     * - "Desktop" or "DesktopPrivate", Current User or All Users Desktop
     * - "Taskbar" or "TaskbarPrivate", Taskbar Pins
     * - "" otherwise
     *
     * If a Private Browsing shortcut was used to launch, the "Private"
     * variant of one of the above entries will be returned.
     *
     * NOTE: This tries to avoid I/O, so paths are compared directly as
     * strings, which may not be accurate in all cases. It is intended
     * for noncritical telemetry use.
     */
    classifyShortcut(aPath: AString): AString;
    /**
     *
     */
    hasMatchingShortcut(aAUMID: AString, aPrivateBrowsing: bool): Promise;
    /**
     * Check if setDefaultBrowserUserChoice() is expected to succeed.
     *
     * This checks the ProgIDs for this installation, and the hash of the existing
     * UserChoice association.
     *
     * @return true if the check succeeds, false otherwise.
     */
    canSetDefaultBrowserUserChoice(): bool;
    /**
     * checkAllProgIDsExist() and checkBrowserUserChoiceHashes() are components
     * of canSetDefaultBrowserUserChoice(), broken out for telemetry purposes.
     *
     * @return true if the check succeeds, false otherwise.
     */
    checkAllProgIDsExist(): bool;
    /**
     *
     */
    checkBrowserUserChoiceHashes(): bool;
    /**
     * Determines whether or not Firefox is the "Default Handler", i.e.,
     * is registered to handle, the given file extension (like ".pdf")
     * or protocol (like "https").
     */
    isDefaultHandlerFor(aFileExtensionOrProtocol: AString): boolean;
    /**
     * Return the Windows ProgID currently registered to handle the gven
     * file extension (like ".pdf") or protocol (like "https").
     *
     * @return string ProgID, or "" when no association is registered.
     * @throws NS_ERROR_FAILURE when the file extension or protocol
     * cannot be determined.
     */
    queryCurrentDefaultHandlerFor(aFileExtensionOrProtocol: AString): AString;
}

/**
 *
 */
declare interface nsIWindowsUIUtilsType extends nsISupportsType {
    /**
     *
     */
    readonly systemSmallIconSize: long;
    /**
     *
     */
    readonly systemLargeIconSize: long;
    /**
     *
     */
    setWindowIcon(aWindow: mozIDOMWindowProxy, aSmallIcon: imgIContainer, aLargeIcon: imgIContainer): void;
    /**
     *
     */
    setWindowIconFromExe(aWindow: mozIDOMWindowProxy, aExe: AString, aIndex: unsigned_short): void;
    /**
     *
     */
    setWindowIconNoData(aWindow: mozIDOMWindowProxy): void;
    /**
     * Whether the OS is currently in tablet mode. Always false on
     * non-Windows and on versions of Windows before win10
     */
    readonly inTabletMode: boolean;
    /**
     * Share URL
     */
    shareUrl(shareTitle: AString, urlToShare: AString): void;
}

/**
 *
 */
declare interface nsIWorkerChannelLoadInfoType extends nsISupportsType {
    /**
     *
     */
    workerAssociatedBrowsingContextID: unsigned_long_long;
    /**
     *
     */
    readonly workerAssociatedBrowsingContext: BrowsingContext;
}

/**
 *
 */
declare interface nsIWorkerChannelInfoType extends nsISupportsType {
    /**
     *
     */
    loadInfo: nsIWorkerChannelLoadInfo;
    /**
     *
     */
    readonly channelId: uint64_t;
}

/**
 *
 */
declare interface nsIWorkerDebuggerListenerType extends nsISupportsType {
    /**
     *
     */
    onClose(): void;
    /**
     *
     */
    onError(filename: AString, lineno: unsigned_long, message: AString): void;
    /**
     *
     */
    onMessage(message: AString): void;
}

/**
 *
 */
declare interface nsIWorkerDebuggerType extends nsISupportsType {
    /**
     *
     */
    readonly isClosed: bool;
    /**
     *
     */
    readonly isChrome: bool;
    /**
     *
     */
    readonly isInitialized: bool;
    /**
     *
     */
    readonly parent: nsIWorkerDebugger;
    /**
     *
     */
    readonly type: unsigned_long;
    /**
     *
     */
    readonly url: AString;
    /**
     *
     */
    readonly window: mozIDOMWindow;
    /**
     *
     */
    readonly principal: nsIPrincipal;
    /**
     *
     */
    readonly serviceWorkerID: unsigned_long;
    /**
     *
     */
    readonly id: AString;
    /**
     *
     */
    initialize(url: AString): void;
    /**
     *
     */
    postMessage(message: AString): void;
    /**
     *
     */
    addListener(listener: nsIWorkerDebuggerListenerType): void;
    /**
     *
     */
    removeListener(listener: nsIWorkerDebuggerListenerType): void;
    /**
     *
     */
    setDebuggerReady(ready: boolean): void;
}

/**
 *
 */
declare interface nsIWorkerDebuggerManagerListenerType extends nsISupportsType {
    /**
     *
     */
    onRegister(_debugger: nsIWorkerDebuggerType): void;
    /**
     *
     */
    onUnregister(_debugger: nsIWorkerDebuggerType): void;
}

/**
 *
 */
declare interface nsIWorkerDebuggerManagerType extends nsISupportsType {
    /**
     *
     */
    getWorkerDebuggerEnumerator(): nsISimpleEnumerator;
    /**
     *
     */
    addListener(listener: nsIWorkerDebuggerManagerListenerType): void;
    /**
     *
     */
    removeListener(listener: nsIWorkerDebuggerManagerListenerType): void;
}

/**
 *
 */
declare interface nsIWritablePropertyBagType extends nsIPropertyBagType {
    /**
     * Set a property with the given name to the given value.  If
     * a property already exists with the given name, it is
     * overwritten.
     */
    setProperty(name: AString, value: nsIVariantType): void;
    /**
     * Delete a property with the given name.
     * @throws NS_ERROR_FAILURE if a property with that name doesn't
     * exist.
     */
    deleteProperty(name: AString): void;
}

/**
 *
 */
declare interface nsIWritablePropertyBag2Type extends nsIPropertyBag2Type {
    /**
     *
     */
    setPropertyAsInt32(prop: AString, value: int32_t): void;
    /**
     *
     */
    setPropertyAsUint32(prop: AString, value: uint32_t): void;
    /**
     *
     */
    setPropertyAsInt64(prop: AString, value: int64_t): void;
    /**
     *
     */
    setPropertyAsUint64(prop: AString, value: uint64_t): void;
    /**
     *
     */
    setPropertyAsDouble(prop: AString, value: double): void;
    /**
     *
     */
    setPropertyAsAString(prop: AString, value: AString): void;
    /**
     *
     */
    setPropertyAsACString(prop: AString, value: ACString): void;
    /**
     *
     */
    setPropertyAsAUTF8String(prop: AString, value: AUTF8String): void;
    /**
     *
     */
    setPropertyAsBool(prop: AString, value: boolean): void;
    /**
     *
     */
    setPropertyAsInterface(prop: AString, value: nsISupportsType): void;
}

/**
 * This represents a X.509 certificate.
 *
 * NOTE: Service workers persist x.509 certs in object form on disk.  If you
 * change this uuid you probably need a hack in nsBinaryInputStream to
 * read the old uuid.  If you change the format of the object
 * serialization then more complex changes will be needed.
 */
declare interface nsIX509CertType extends nsISupportsType {
    /**
     * The primary email address of the certificate, if present.
     */
    readonly emailAddress: AString;
    /**
     * Did this certificate ship with the platform as a built-in root?
     */
    readonly isBuiltInRoot: bool;
    /**
     * Check whether a given address is contained in the certificate.
     * The comparison will convert the email address to lowercase.
     * The behaviour for non ASCII characters is undefined.
     *
     * @param aEmailAddress The address to search for.
     *
     * @return True if the address is contained in the certificate.
     */
    containsEmailAddress(aEmailAddress: AString): boolean;
    /**
     * The subject owning the certificate.
     */
    readonly subjectName: AString;
    /**
     * The subject's common name.
     */
    readonly commonName: AString;
    /**
     * The subject's organization.
     */
    readonly organization: AString;
    /**
     * The subject's organizational unit.
     */
    readonly organizationalUnit: AString;
    /**
     * The fingerprint of the certificate's DER encoding,
     * calculated using the SHA-256 algorithm.
     */
    readonly sha256Fingerprint: AString;
    /**
     * The fingerprint of the certificate's DER encoding,
     * calculated using the SHA1 algorithm.
     */
    readonly sha1Fingerprint: AString;
    /**
     * A human readable name identifying the hardware or
     * software token the certificate is stored on.
     */
    readonly tokenName: AString;
    /**
     * The subject identifying the issuer certificate.
     */
    readonly issuerName: AString;
    /**
     * The serial number the issuer assigned to this certificate.
     */
    readonly serialNumber: AString;
    /**
     * The issuer subject's common name.
     */
    readonly issuerCommonName: AString;
    /**
     * The issuer subject's organization.
     */
    readonly issuerOrganization: AString;
    /**
     * The issuer subject's organizational unit.
     */
    readonly issuerOrganizationUnit: AString;
    /**
     * This certificate's validity period.
     */
    readonly validity: nsIX509CertValidity;
    /**
     * A unique identifier of this certificate within the local storage.
     */
    readonly dbKey: ACString;
    /**
     * A human readable identifier to label this certificate.
     */
    readonly displayName: AString;
    /**
     * Type of this certificate
     */
    readonly certType: unsigned_long;
    /**
     * Obtain a base 64 string representation of this certificate
     * in DER format.
     *
     * @return The DER encoded certificate as a string.
     */
    getBase64DERString(): ACString;
    /**
     * The base64 encoding of the DER encoded public key info using the specified
     * digest.
     */
    readonly sha256SubjectPublicKeyInfoDigest: ACString;
}

/**
 *
 */
declare interface nsIOpenSignedAppFileCallbackType extends nsISupportsType {
    /**
     *
     */
    openSignedAppFileFinished(rv: nsresult, aZipReader: nsIZipReaderType, aSignerCert: nsIX509CertType): void;
}

/**
 *
 */
declare interface nsIAsyncBoolCallbackType extends nsISupportsType {
    /**
     *
     */
    onResult(result: bool): void;
}

/**
 * Callback type for use with asyncVerifyCertAtTime.
 * If aPRErrorCode is PRErrorCodeSuccess (i.e. 0), aVerifiedChain represents the
 * verified certificate chain determined by asyncVerifyCertAtTime. aHasEVPolicy
 * represents whether or not the end-entity certificate verified as EV.
 * If aPRErrorCode is non-zero, it represents the error encountered during
 * verification. aVerifiedChain is null in that case and aHasEVPolicy has no
 * meaning.
 */
declare interface nsICertVerificationCallbackType extends nsISupportsType {
    /**
     *
     */
    verifyCertFinished(aPRErrorCode: int32_t, aVerifiedChain: invalid, aHasEVPolicy: bool): void;
}

/**
 * This represents a service to access and manipulate
 * X.509 certificates stored in a database.
 */
declare interface nsIX509CertDBType extends nsISupportsType {
    /**
     * Will find a certificate based on its dbkey
     * retrieved by getting the dbKey attribute of
     * the certificate.
     *
     * @param aDBkey Database internal key, as obtained using
     * attribute dbkey in nsIX509Cert.
     */
    findCertByDBKey(aDBkey: ACString): nsIX509Cert;
    /**
     * Use this to import a stream sent down as a mime type into
     * the certificate database on the default token.
     * The stream may consist of one or more certificates.
     *
     * @param data The raw data to be imported
     * @param length The length of the data to be imported
     * @param type The type of the certificate, see constants in nsIX509Cert
     * @param ctx A UI context.
     */
    importCertificates(data: octet[], length: unsigned_long, type: unsigned_long, ctx: nsIInterfaceRequestorType): void;
    /**
     * Import another person's email certificate into the database.
     *
     * @param data The raw data to be imported
     * @param length The length of the data to be imported
     * @param ctx A UI context.
     */
    importEmailCertificate(data: octet[], length: unsigned_long, ctx: nsIInterfaceRequestorType): void;
    /**
     * Import a personal certificate into the database, assuming
     * the database already contains the private key for this certificate.
     *
     * @param data The raw data to be imported
     * @param length The length of the data to be imported
     * @param ctx A UI context.
     */
    importUserCertificate(data: octet[], length: unsigned_long, ctx: nsIInterfaceRequestorType): void;
    /**
     * Delete a certificate stored in the database.
     *
     * @param aCert Delete this certificate.
     */
    deleteCertificate(aCert: nsIX509CertType): void;
    /**
     * Modify the trust that is stored and associated to a certificate within
     * a database. Separate trust is stored for
     * One call manipulates the trust for one trust type only.
     * See the trust type constants defined within this interface.
     *
     * @param cert Change the stored trust of this certificate.
     * @param type The type of the certificate. See nsIX509Cert.
     * @param trust A bitmask. The new trust for the possible usages.
     * See the trust constants defined within this interface.
     */
    setCertTrust(cert: nsIX509CertType, type: unsigned_long, trust: unsigned_long): void;
    /**
     * @param cert        The certificate for which to modify trust.
     * @param trustString decoded by CERT_DecodeTrustString. 3 comma separated
     * characters, indicating SSL, Email, and Object signing
     * trust. The object signing trust flags are effectively
     * ignored by gecko, but they still must be specified (at
     * least by a final trailing comma) because this argument
     * is passed to CERT_DecodeTrustString.
     */
    setCertTrustFromString(cert: nsIX509CertType, trustString: ACString): void;
    /**
     * Query whether a certificate is trusted for a particular use.
     *
     * @param cert Obtain the stored trust of this certificate.
     * @param certType The type of the certificate. See nsIX509Cert.
     * @param trustType A single bit from the usages constants defined
     * within this interface.
     *
     * @return Returns true if the certificate is trusted for the given use.
     */
    isCertTrusted(cert: nsIX509CertType, certType: unsigned_long, trustType: unsigned_long): boolean;
    /**
     * Import certificate(s) from file
     *
     * @param aFile Identifies a file that contains the certificate
     * to be imported.
     * @param aType Describes the type of certificate that is going to
     * be imported. See type constants in nsIX509Cert.
     */
    importCertsFromFile(aFile: nsIFileType, aType: unsigned_long): void;
    /**
     * Import a PKCS#12 file containing cert(s) and key(s) into the database.
     *
     * @param aFile Identifies a file that contains the data to be imported.
     * @param password The password used to protect the file.
     * @return Success or the specific error code on failure.  The return
     * values are defined in this file.
     */
    importPKCS12File(aFile: nsIFileType, aPassword: AString): uint32_t;
    /**
     * Export a set of certs and keys from the database to a PKCS#12 file.
     *
     * @param aFile Identifies a file that will be filled with the data to be
     * exported.
     * @param count The number of certificates to be exported.
     * @param aCerts The array of all certificates to be exported.
     * @param password The password used to protect the file.
     * @return Success or the specific error code on failure
     */
    exportPKCS12File(aFile: nsIFileType, aCerts: invalid, aPassword: AString): uint32_t;
    /**
     * Decode a raw data presentation and instantiate an object in memory.
     *
     * @param base64 The raw representation of a certificate,
     * encoded as Base 64.
     * @return The new certificate object.
     */
    constructX509FromBase64(base64: ACString): nsIX509Cert;
    /**
     * Decode a raw data presentation and instantiate an object in memory.
     *
     * @param certDER The raw representation of a certificate,
     * encoded as raw DER.
     * @return The new certificate object.
     */
    constructX509(certDER: invalid): nsIX509Cert;
    /**
     *
     */
    openSignedAppFileAsync(trustedRoot: AppTrustedRoot, aJarFile: nsIFileType, callback: nsIOpenSignedAppFileCallbackType): void;
    /**
     * Add a cert to a cert DB from a binary string.
     *
     * @param certDER The raw DER encoding of a certificate.
     * @param trust String describing the trust settings to assign the
     * certificate. Decoded by CERT_DecodeTrustString. Consists of 3
     * comma separated sets of characters, indicating SSL, Email, and
     * Object signing trust. The object signing trust flags are
     * effectively ignored by gecko, but they still must be specified
     * (at least by a final trailing comma) because this argument is
     * passed to CERT_DecodeTrustString.
     * @return nsIX509Cert the resulting certificate
     */
    addCert(certDER: ACString, trust: ACString): nsIX509Cert;
    /**
     * Asynchronously verify a certificate given a set of parameters. Calls the
     * `verifyCertFinished` function on the provided `nsICertVerificationCallback`
     * with the results of the verification operation.
     * See the documentation for  nsICertVerificationCallback.
     *
     * @param aCert the certificate to verify
     * @param aUsage an integer representing the usage to verify for (see
     * SECCertificateUsage in certt.h from NSS)
     * @param aFlags flags as described above
     * @param aHostname the (optional) hostname to verify for
     * @param aTime the time at which to verify, in seconds since the epoch
     * @param aCallback the nsICertVerificationCallback that will receive the
     * results of this verification
     * @return a succeeding nsresult if the job was dispatched successfully
     */
    asyncVerifyCertAtTime(aCert: nsIX509CertType, aUsage: int64_t, aFlags: uint32_t, aHostname: ACString, aTime: uint64_t, aCallback: nsICertVerificationCallbackType): void;
    /**
     *
     */
    clearOCSPCache(): void;
    /**
     * Add a cert to a cert DB from a base64 encoded string.
     *
     * @param base64 The raw representation of a certificate, encoded as Base 64.
     * @param trust String describing the trust settings to assign the
     * certificate. Decoded by CERT_DecodeTrustString. Consists of 3
     * comma separated sets of characters, indicating SSL, Email, and
     * Object signing trust. The object signing trust flags are
     * effectively ignored by gecko, but they still must be specified
     * (at least by a final trailing comma) because this argument is
     * passed to CERT_DecodeTrustString.
     * @return nsIX509Cert the resulting certificate
     */
    addCertFromBase64(base64: ACString, trust: ACString): nsIX509Cert;
    /**
     * Encode the list of certificates as a PKCS#7 SignedData structure. No data
     * is actually signed - this is merely a way of exporting a collection of
     * certificates.
     */
    asPKCS7Blob(certList: invalid): ACString;
    /**
     * Iterates through all the certs and returns false if any of the trusted
     * CA certs are not built-in roots; and true otherwise.
     */
    asyncHasThirdPartyRoots(callback: nsIAsyncBoolCallbackType): void;
}

/**
 * Information on the validity period of a X.509 certificate.
 */
declare interface nsIX509CertValidityType extends nsISupportsType {
    /**
     * The earliest point in time where
     * a certificate is valid.
     */
    readonly notBefore: PRTime;
    /**
     * The latest point in time where
     * a certificate is valid.
     */
    readonly notAfter: PRTime;
}

/**
 * Note: This is not really an XPCOM interface.  For example, callers must
 * guarantee that they set the *_retval of the various methods that return a
 * boolean to PR_TRUE before making the call.  Implementations may skip writing
 * to *_retval unless they want to return PR_FALSE.
 */
declare interface nsIXPCScriptableType extends nsISupportsType {
    /**
     *
     */
    readonly className: AUTF8String;
    /**
     *
     */
    getScriptableFlags(): uint32_t;
    /**
     *
     */
    getJSClass(): JSClassPtr;
    /**
     *
     */
    preCreate(nativeObj: nsISupportsType, cx: JSContextPtr, globalObj: JSObjectPtr, parentObj: JSObjectPtr): void;
    /**
     *
     */
    newEnumerate(wrapper: nsIXPConnectWrappedNativeType, cx: JSContextPtr, obj: JSObjectPtr, properties: JSMutableHandleIdVector, enumerableOnly: boolean): boolean;
    /**
     *
     */
    resolve(wrapper: nsIXPConnectWrappedNativeType, cx: JSContextPtr, obj: JSObjectPtr, id: jsid, resolvedp: boolean): boolean;
    /**
     *
     */
    finalize(wrapper: nsIXPConnectWrappedNativeType, gcx: JSGCContextPtr, obj: JSObjectPtr): void;
    /**
     *
     */
    call(wrapper: nsIXPConnectWrappedNativeType, cx: JSContextPtr, obj: JSObjectPtr, args: JSCallArgsRef): boolean;
    /**
     *
     */
    construct(wrapper: nsIXPConnectWrappedNativeType, cx: JSContextPtr, obj: JSObjectPtr, args: JSCallArgsRef): boolean;
    /**
     *
     */
    hasInstance(wrapper: nsIXPConnectWrappedNativeType, cx: JSContextPtr, obj: JSObjectPtr, val: jsval, bp: boolean): boolean;
}

/**
 *
 */
declare interface nsIXREDirProviderType extends nsISupportsType {
    /**
     * Only intended to be used from xpcshell tests. Allows setting the local
     * and normal profile data directories. Calling this after something using
     * them has started up will cause problems.
     */
    setUserDataDirectory(aFile: nsIFileType, aLocal: boolean): void;
    /**
     * Gets the hash for the current installation directory.
     */
    getInstallHash(): AString;
}

/**
 * A scriptable interface to the nsXULAppAPI structure. See nsXULAppAPI.h for
 * a detailed description of each attribute.
 */
declare interface nsIXULAppInfoType extends nsIPlatformInfoType {
    /**
     * @see XREAppData.vendor
     * @returns an empty string if XREAppData.vendor is not set.
     */
    readonly vendor: ACString;
    /**
     * @see XREAppData.name
     */
    readonly name: ACString;
    /**
     * @see XREAppData.ID
     * @returns an empty string if XREAppData.ID is not set.
     */
    readonly ID: ACString;
    /**
     * The version of the XUL application. It is different than the
     * version of the XULRunner platform. Be careful about which one you want.
     *
     * @see XREAppData.version
     * @returns an empty string if XREAppData.version is not set.
     */
    readonly version: ACString;
    /**
     * The build ID/date of the application. For xulrunner applications,
     * this will be different than the build ID of the platform. Be careful
     * about which one you want.
     */
    readonly appBuildID: ACString;
    /**
     * @see XREAppData.UAName
     * @returns an empty string if XREAppData.UAName is not set.
     */
    readonly UAName: ACString;
    /**
     * @see XREAppData.sourceURL
     * @returns an empty string if XREAppData.sourceURL is not set.
     */
    readonly sourceURL: ACString;
    /**
     * @see XREAppData.updateURL
     */
    readonly updateURL: ACString;
}

/**
 * The nsIXULBrowserWindow supplies the methods that may be called from the
 * internals of the browser area to tell the containing xul window to update
 * its ui.
 */
declare interface nsIXULBrowserWindowType extends nsISupportsType {
    /**
     * Tells the object implementing this function what link we are currently
     * over.
     */
    setOverLink(link: AString): void;
    /**
     * Determines the appropriate target for a link.
     */
    onBeforeLinkTraversal(originalTarget: AString, linkURI: nsIURIType, linkNode: Node, isAppTab: boolean): AString;
    /**
     * Show/hide a tooltip (when the user mouses over a link, say).
     *
     * x and y coordinates are in device pixels.
     */
    showTooltip(x: long, y: long, tooltip: AString, direction: AString, browser: Element): void;
    /**
     *
     */
    hideTooltip(): void;
    /**
     * Return the number of tabs in this window.
     */
    getTabCount(): uint32_t;
}

/**
 * Provides information about the XUL runtime.
 * @status UNSTABLE - This interface is not frozen and will probably change in
 * future releases. If you need this functionality to be
 * stable/frozen, please contact Benjamin Smedberg.
 */
declare interface nsIXULRuntimeType extends nsISupportsType {
    /**
     * Whether the application was launched in safe mode.
     */
    readonly inSafeMode: boolean;
    /**
     *
     */
    readonly win32kExperimentStatus: nsIXULRuntime_ExperimentStatus;
    /**
     *
     */
    readonly win32kLiveStatusTestingOnly: nsIXULRuntime_ContentWin32kLockdownState;
    /**
     *
     */
    readonly win32kSessionStatus: nsIXULRuntime_ContentWin32kLockdownState;
    /**
     * Whether Fission should be automatically enabled for new browser windows.
     * This may not match the value of the 'fission.autostart' pref.
     *
     * This value is guaranteed to remain constant for the length of a browser
     * session.
     */
    readonly fissionAutostart: boolean;
    /**
     * The deciding factor which caused Fission to be enabled or disabled in
     * this session. The string version is the same of the name of the constant,
     * without the leading `eFission`, and with an initial lower-case letter.
     */
    readonly fissionDecisionStatus: nsIXULRuntime_FissionDecisionStatus;
    /**
     *
     */
    readonly fissionDecisionStatusString: ACString;
    /**
     * Whether session history is stored in the parent process.
     */
    readonly sessionHistoryInParent: boolean;
    /**
     * Whether to write console errors to a log file. If a component
     * encounters startup errors that might prevent the app from showing
     * proper UI, it should set this flag to "true".
     */
    logConsoleErrors: boolean;
    /**
     * A string tag identifying the current operating system. This is taken
     * from the OS_TARGET configure variable. It will always be available.
     */
    readonly OS: AUTF8String;
    /**
     * A string tag identifying the binary ABI of the current processor and
     * compiler vtable. This is taken from the TARGET_XPCOM_ABI configure
     * variable. It may not be available on all platforms, especially
     * unusual processor or compiler combinations.
     *
     * The result takes the form <processor>-<compilerABI>, for example:
     * x86-msvc
     * ppc-gcc3
     *
     * This value should almost always be used in combination with "OS".
     *
     * @throw NS_ERROR_NOT_AVAILABLE if not available.
     */
    readonly XPCOMABI: AUTF8String;
    /**
     * A string tag identifying the target widget toolkit in use.
     * This is taken from the MOZ_WIDGET_TOOLKIT configure variable.
     */
    readonly widgetToolkit: AUTF8String;
    /**
     * The type of the caller's process.  Returns one of the values above.
     */
    readonly processType: unsigned_long;
    /**
     * The system process ID of the caller's process.
     */
    readonly processID: unsigned_long;
    /**
     * A globally unique and non-recycled ID of the caller's process.
     */
    readonly uniqueProcessID: uint64_t;
    /**
     * The type of remote content process we're running in.
     * null if we're in the parent/chrome process. This can contain
     * a URI if Fission is enabled, so don't use it for any kind of
     * telemetry.
     */
    readonly remoteType: AUTF8String;
    /**
     * If true, browser tabs may be opened by default in a different process
     * from the main browser UI.
     */
    readonly browserTabsRemoteAutostart: boolean;
    /**
     * Returns the number of content processes to use for normal web pages. If
     * this value is > 1, then e10s-multi should be considered to be "on".
     *
     * NB: If browserTabsRemoteAutostart is false, then this value has no
     * meaning and e10s should be considered to be "off"!
     */
    readonly maxWebProcessCount: uint32_t;
    /**
     * If true, the accessibility service is running.
     */
    readonly accessibilityEnabled: boolean;
    /**
     * Executable of Windows service that activated accessibility.
     */
    readonly accessibilityInstantiator: AString;
    /**
     * Indicates whether the current Firefox build is 64-bit.
     */
    readonly is64Bit: boolean;
    /**
     * Indicates whether or not text recognition of images supported by the OS.
     */
    readonly isTextRecognitionSupported: boolean;
    /**
     * Signal the apprunner to invalidate caches on the next restart.
     * This will cause components to be autoregistered and all
     * fastload data to be re-created.
     */
    invalidateCachesOnRestart(): void;
    /**
     * Starts a child process. This method is intented to pre-start a
     * content child process so that when it is actually needed, it is
     * ready to go.
     *
     * @throw NS_ERROR_NOT_AVAILABLE if not available.
     */
    ensureContentProcess(): void;
    /**
     * Modification time of the profile lock before the profile was locked on
     * this startup. Used to know the last time the profile was used and not
     * closed cleanly. This is set to 0 if there was no existing profile lock.
     */
    readonly replacedLockTime: PRTime;
    /**
     * The default update channel (MOZ_UPDATE_CHANNEL).
     */
    readonly defaultUpdateChannel: AUTF8String;
    /**
     * The distribution ID for this build (MOZ_DISTRIBUTION_ID).
     */
    readonly distributionID: AUTF8String;
    /**
     * True if Windows DLL blocklist initialized correctly. This is
     * primarily for automated testing purposes.
     */
    readonly windowsDLLBlocklistStatus: boolean;
    /**
     * True if this application was started by the OS as part of an automatic
     * restart mechanism (such as RegisterApplicationRestart on Windows).
     */
    readonly restartedByOS: boolean;
    /**
     * Whether the chrome color-scheme is dark
     */
    readonly chromeColorSchemeIsDark: boolean;
    /**
     * Whether the content color-scheme derived from the app theme is dark
     */
    readonly contentThemeDerivedColorSchemeIsDark: boolean;
    /**
     * Whether the user prefers reduced motion
     */
    readonly prefersReducedMotion: boolean;
    /**
     * Whether we should draw over the titlebar
     */
    readonly drawInTitlebar: boolean;
    /**
     * Returns the desktop environment identifier. Only meaningful on GTK
     */
    readonly desktopEnvironment: ACString;
    /**
     * Whether we use Wayland. Only meaningful on GTK
     */
    readonly isWayland: boolean;
    /**
     * The path of the shortcut used to start the current process, or "" if none.
     *
     * Windows Main process only, otherwise throws NS_ERROR_NOT_AVAILABLE
     *
     * May be mising in some cases where the user did launch from a shortcut:
     * - If the updater ran on startup
     * - If the AUMID was set before the shortcut could be saved
     *
     * @throw NS_ERROR_NOT_AVAILABLE if not available.
     */
    readonly processStartupShortcut: AString;
    /**
     * Returns a value corresponding to one of the
     * |mozilla::LauncherRegistryInfo::EnabledState| values.
     */
    readonly launcherProcessState: uint32_t;
    /**
     * Returns the last application version that used the current profile or null
     * if the last version could not be found (compatibility.ini was either
     * missing or invalid). Throws NS_ERROR_UNAVAILABLE if called from a content
     * process.
     */
    readonly lastAppVersion: ACString;
    /**
     * Returns the last application build ID that used the current profile or null
     * if the last build ID could not be found (compatibility.ini was either
     * missing or invalid). Throws NS_ERROR_UNAVAILABLE if called from a content
     * process.
     */
    readonly lastAppBuildID: ACString;
}

/**
 * The XUL store is used to store information related to a XUL document/application.
 * Typically it is used to store the persisted state for the document, such as
 * window location, toolbars that are open and nodes that are open and closed in a tree.
 *
 * The data is serialized to [profile directory]/xulstore.json
 */
declare interface nsIXULStoreType extends nsISupportsType {
    /**
     * Sets a value for a specified node's attribute, except in
     * the case below:
     * If the value is empty and if calling `hasValue` with the node's
     * document and ID and `attr` would return true, then the
     * value instead gets removed from the store (see Bug 1476680).
     *
     * @param node - DOM node
     * @param attr - attribute to store
     */
    persist(aNode: Node, attr: AString): void;
    /**
     * Sets a value in the store.
     *
     * @param doc - document URI
     * @param id - identifier of the node
     * @param attr - attribute to store
     * @param value - value of the attribute
     */
    setValue(doc: AString, id: AString, attr: AString, value: AString): void;
    /**
     * Returns true if the store contains a value for attr.
     *
     * @param doc - URI of the document
     * @param id - identifier of the node
     * @param attr - attribute
     */
    hasValue(doc: AString, id: AString, attr: AString): bool;
    /**
     * Retrieves a value in the store, or an empty string if it does not exist.
     *
     * @param doc - document URI
     * @param id - identifier of the node
     * @param attr - attribute to retrieve
     *
     * @returns the value of the attribute
     */
    getValue(doc: AString, id: AString, attr: AString): AString;
    /**
     * Removes a value in the store.
     *
     * @param doc - document URI
     * @param id - identifier of the node
     * @param attr - attribute to remove
     */
    removeValue(doc: AString, id: AString, attr: AString): void;
    /**
     * Removes all values related to the given document.
     *
     * @param doc - document URI
     */
    removeDocument(doc: AString): void;
    /**
     * Iterates over all of the ids associated with a given document uri that
     * have stored data.
     *
     * @param doc - document URI
     */
    getIDsEnumerator(doc: AString): nsIStringEnumerator;
    /**
     * Iterates over all of the attributes associated with a given document uri
     * and id that have stored data.
     *
     * @param doc - document URI
     * @param id - identifier of the node
     */
    getAttributeEnumerator(doc: AString, id: AString): nsIStringEnumerator;
}

/**
 *
 */
declare interface nsIZipEntryType extends nsISupportsType {
    /**
     * The type of compression used for the item.  The possible values and
     * their meanings are defined in the zip file specification at
     * http://www.pkware.com/business_and_developers/developer/appnote/
     */
    readonly compression: unsigned_short;
    /**
     * The compressed size of the data in the item.
     */
    readonly size: unsigned_long;
    /**
     * The uncompressed size of the data in the item.
     */
    readonly realSize: unsigned_long;
    /**
     * The CRC-32 hash of the file in the entry.
     */
    readonly CRC32: unsigned_long;
    /**
     * True if the name of the entry ends with '/' and false otherwise.
     */
    readonly isDirectory: boolean;
    /**
     * The time at which this item was last modified.
     */
    readonly lastModifiedTime: PRTime;
    /**
     * Use this attribute to determine whether this item is an actual zip entry
     * or is one synthesized for part of a real entry's path.  A synthesized
     * entry represents a directory within the zip file which has no
     * corresponding entry within the zip file.  For example, the entry for the
     * directory foo/ in a zip containing exactly one entry for foo/bar.txt
     * is synthetic.  If the zip file contains an actual entry for a directory,
     * this attribute will be false for the nsIZipEntry for that directory.
     * It is impossible for a file to be synthetic.
     */
    readonly isSynthetic: boolean;
    /**
     * The UNIX style file permissions of this item.
     */
    readonly permissions: unsigned_long;
}

/**
 *
 */
declare interface nsIZipReaderType extends nsISupportsType {
    /**
     * Opens a zip file for reading.
     * It is allowed to open with another file,
     * but it needs to be closed first with close().
     */
    open(zipFile: nsIFileType): void;
    /**
     * Opens a zip file inside a zip file for reading.
     */
    openInner(zipReader: nsIZipReaderType, zipEntry: AUTF8String): void;
    /**
     * Opens a zip file stored in memory; the file attribute will be null.
     *
     * The ZipReader does not copy or take ownership of this memory; the
     * caller must ensure that it is valid and unmodified until the
     * ZipReader is closed or destroyed, and must free the memory as
     * appropriate afterwards.
     */
    openMemory(aData: voidPtr, aLength: unsigned_long): void;
    /**
     * The file that represents the zip with which this zip reader was
     * initialized.  This will be null if there is no underlying file.
     */
    readonly file: nsIFile;
    /**
     * Closes a zip reader. Subsequent attempts to extract files or read from
     * its input stream will result in an error.
     *
     * Subsequent attempts to access a nsIZipEntry obtained from this zip
     * reader will cause unspecified behavior.
     */
    close(): void;
    /**
     * Tests the integrity of the archive by performing a CRC check
     * on each item expanded into memory.  If an entry is specified
     * the integrity of only that item is tested.  If null (javascript)
     * or ""_ns (c++) is passed in the integrity of all items
     * in the archive are tested.
     */
    test(aEntryName: AUTF8String): void;
    /**
     * Extracts a zip entry into a local file specified by outFile.
     * The entry must be stored in the zip in either uncompressed or
     * DEFLATE-compressed format for the extraction to be successful.
     * If the entry is a directory, the directory will be extracted
     * non-recursively.
     */
    extract(zipEntry: AUTF8String, outFile: nsIFileType): void;
    /**
     * Returns a nsIZipEntry describing a specified zip entry.
     */
    getEntry(zipEntry: AUTF8String): nsIZipEntry;
    /**
     * Checks whether the zipfile contains an entry specified by entryName.
     */
    hasEntry(zipEntry: AUTF8String): boolean;
    /**
     * Returns a string enumerator containing the matching entry names.
     *
     * @param aPattern
     * A regular expression used to find matching entries in the zip file.
     * Set this parameter to null (javascript) or ""_ns (c++) or "*"
     * to get all entries; otherwise, use the
     * following syntax:
     *
     * o * matches anything
     * o ? matches one character
     * o $ matches the end of the string
     * o [abc] matches one occurrence of a, b, or c. The only character that
     * must be escaped inside the brackets is ].  ^ and - must never
     * appear in the first and second positions within the brackets,
     * respectively.  (In the former case, the behavior specified for
     * '[^az]' will happen.)
     * o [a-z] matches any character between a and z.  The characters a and z
     * must either both be letters or both be numbers, with the
     * character represented by 'a' having a lower ASCII value than
     * the character represented by 'z'.
     * o [^az] matches any character except a or z.  If ] is to appear inside
     * the brackets as a character to not match, it must be escaped.
     * o pat~pat2 returns matches to the pattern 'pat' which do not also match
     * the pattern 'pat2'.  This may be used to perform filtering
     * upon the results of one pattern to remove all matches which
     * also match another pattern.  For example, because '*'
     * matches any string and '*z*' matches any string containing a
     * 'z', '*~*z*' will match all strings except those containing
     * a 'z'.  Note that a pattern may not use '~' multiple times,
     * so a string such as '*~*z*~*y*' is not a valid pattern.
     * o (foo|bar) will match either the pattern foo or the pattern bar.
     * Neither of the patterns foo or bar may use the 'pat~pat2'
     * syntax described immediately above.
     * o \ will escape a special character.  Escaping is required for all
     * special characters unless otherwise specified.
     * o All other characters match case-sensitively.
     *
     * An aPattern not conforming to this syntax has undefined behavior.
     *
     * @throws NS_ERROR_ILLEGAL_VALUE on many but not all invalid aPattern
     * values.
     */
    findEntries(aPattern: AUTF8String): nsIUTF8StringEnumerator;
    /**
     * Returns an input stream containing the contents of the specified zip
     * entry.
     * @param zipEntry the name of the entry to open the stream from
     */
    getInputStream(zipEntry: AUTF8String): nsIInputStream;
    /**
     * Returns an input stream containing the contents of the specified zip
     * entry. If the entry refers to a directory (ends with '/'), a directory stream
     * is opened, otherwise the contents of the file entry is returned.
     * @param aJarSpec the Spec of the URI for the JAR (only used for directory streams)
     * @param zipEntry the name of the entry to open the stream from
     */
    getInputStreamWithSpec(aJarSpec: AUTF8String, zipEntry: AUTF8String): nsIInputStream;
}

/**
 *
 */
declare interface nsIZipReaderCacheType extends nsISupportsType {
    /**
     * Initializes a new zip reader cache.
     * @param cacheSize - the number of released entries to maintain before
     * beginning to throw some out (note that the number of outstanding
     * entries can be much greater than this number -- this is the count
     * for those otherwise unused entries)
     */
    init(cacheSize: unsigned_long): void;
    /**
     * Returns a (possibly shared) nsIZipReader for an nsIFile.
     *
     * If the zip reader for given file is not in the cache, a new zip reader
     * is created, initialized, and opened (see nsIZipReader::init and
     * nsIZipReader::open). Otherwise the previously created zip reader is
     * returned.
     *
     * @note If someone called close() on the shared nsIZipReader, this method
     * will return the closed zip reader.
     */
    getZip(zipFile: nsIFileType): nsIZipReader;
    /**
     * Like getZip(), returns a (possibly shared) nsIZipReader for an nsIFile,
     * but if a zip reader for the given file is not in the cache, returns
     * error NS_ERROR_CACHE_KEY_NOT_FOUND rather than creating a new reader.
     *
     * @note If someone called close() on the shared nsIZipReader, this method
     * will return the closed zip reader.
     */
    getZipIfCached(zipFile: nsIFileType): nsIZipReader;
    /**
     * returns true if this zipreader already has this file cached
     */
    isCached(zipFile: nsIFileType): bool;
    /**
     * Returns a (possibly shared) nsIZipReader for a zip inside another zip
     *
     * See getZip
     */
    getInnerZip(zipFile: nsIFileType, zipEntry: AUTF8String): nsIZipReader;
    /**
     * Returns the cached NSPR file descriptor of the file.
     * Note: currently not supported on Windows platform.
     */
    getFd(zipFile: nsIFileType): PRFileDescStar;
}

/**
 * nsIZipWriter
 *
 * An interface for a zip archiver that can be used from script.
 *
 * The interface supports both a synchronous method of archiving data and a
 * queueing system to allow operations to be prepared then run in sequence
 * with notification after completion.
 *
 * Operations added to the queue do not get performed until performQueue is
 * called at which point they will be performed in the order that they were
 * added to the queue.
 *
 * Operations performed on the queue will throw any errors out to the
 * observer.
 *
 * An attempt to perform a synchronous operation while the background queue
 * is in progress will throw NS_ERROR_IN_PROGRESS.
 *
 * Entry names should use /'s as path separators and should not start with
 * a /.
 *
 * It is not generally necessary to add directory entries in order to add file
 * entries within them, however it is possible that some zip programs may
 * experience problems what that.
 */
declare interface nsIZipWriterType extends nsISupportsType {
    /**
     * Gets or sets the comment associated with the open zip file.
     *
     * @throws NS_ERROR_NOT_INITIALIZED if no zip file has been opened
     */
    comment: ACString;
    /**
     * Indicates that operations on the background queue are being performed.
     */
    readonly inQueue: boolean;
    /**
     * The file that the zipwriter is writing to.
     */
    readonly file: nsIFile;
    /**
     * Opens a zip file.
     *
     * @param aFile the zip file to open
     * @param aIoFlags the open flags for the zip file from prio.h
     *
     * @throws NS_ERROR_ALREADY_INITIALIZED if a zip file is already open
     * @throws NS_ERROR_INVALID_ARG if aFile is null
     * @throws NS_ERROR_FILE_NOT_FOUND if aFile does not exist and flags did
     * not allow for creation
     * @throws NS_ERROR_FILE_CORRUPTED if the file does not contain zip markers
     * @throws <other-error> on failure to open zip file (most likely corrupt
     * or unsupported form)
     */
    open(aFile: nsIFileType, aIoFlags: int32_t): void;
    /**
     * Returns a nsIZipEntry describing a specified zip entry or null if there
     * is no such entry in the zip file
     *
     * @param aZipEntry the path of the entry
     */
    getEntry(aZipEntry: AUTF8String): nsIZipEntry;
    /**
     * Checks whether the zipfile contains an entry specified by zipEntry.
     *
     * @param aZipEntry the path of the entry
     */
    hasEntry(aZipEntry: AUTF8String): boolean;
    /**
     * Adds a new directory entry to the zip file. If aZipEntry does not end with
     * "/" then it will be added.
     *
     * @param aZipEntry the path of the directory entry
     * @param aModTime the modification time of the entry in microseconds
     * @param aQueue adds the operation to the background queue. Will be
     * performed when processQueue is called.
     *
     * @throws NS_ERROR_NOT_INITIALIZED if no zip file has been opened
     * @throws NS_ERROR_FILE_ALREADY_EXISTS if the path already exists in the
     * file
     * @throws NS_ERROR_IN_PROGRESS if another operation is currently in progress
     * @throws NS_ERROR_INVALID_ARG if aModTime is older than 1980-1-1
     */
    addEntryDirectory(aZipEntry: AUTF8String, aModTime: PRTime, aQueue: boolean): void;
    /**
     * Adds a new file or directory to the zip file. If the specified file is
     * a directory then this will be equivalent to a call to
     * addEntryDirectory(aZipEntry, aFile.lastModifiedTime, aQueue)
     *
     * @param aZipEntry the path of the file entry
     * @param aCompression the compression level, 0 is no compression, 9 is best
     * @param aFile the file to get the data and modification time from
     * @param aQueue adds the operation to the background queue. Will be
     * performed when processQueue is called.
     *
     * @throws NS_ERROR_NOT_INITIALIZED if no zip file has been opened
     * @throws NS_ERROR_FILE_ALREADY_EXISTS if the path already exists in the zip
     * @throws NS_ERROR_IN_PROGRESS if another operation is currently in progress
     * @throws NS_ERROR_FILE_NOT_FOUND if file does not exist
     */
    addEntryFile(aZipEntry: AUTF8String, aCompression: int32_t, aFile: nsIFileType, aQueue: boolean): void;
    /**
     * Adds data from a channel to the zip file. If the operation is performed
     * on the queue then the channel will be opened asynchronously, otherwise
     * the channel must support being opened synchronously.
     *
     * @param aZipEntry the path of the file entry
     * @param aModTime the modification time of the entry in microseconds
     * @param aCompression the compression level, 0 is no compression, 9 is best
     * @param aChannel the channel to get the data from
     * @param aQueue adds the operation to the background queue. Will be
     * performed when processQueue is called.
     *
     * @throws NS_ERROR_NOT_INITIALIZED if no zip file has been opened
     * @throws NS_ERROR_FILE_ALREADY_EXISTS if the path already exists in the zip
     * @throws NS_ERROR_IN_PROGRESS if another operation is currently in progress
     * @throws NS_ERROR_INVALID_ARG if aModTime is older than 1980-1-1
     */
    addEntryChannel(aZipEntry: AUTF8String, aModTime: PRTime, aCompression: int32_t, aChannel: nsIChannelType, aQueue: boolean): void;
    /**
     * Adds data from an input stream to the zip file.
     *
     * @param aZipEntry the path of the file entry
     * @param aModTime the modification time of the entry in microseconds
     * @param aCompression the compression level, 0 is no compression, 9 is best
     * @param aStream the input stream to get the data from
     * @param aQueue adds the operation to the background queue. Will be
     * performed when processQueue is called.
     *
     * @throws NS_ERROR_NOT_INITIALIZED if no zip file has been opened
     * @throws NS_ERROR_FILE_ALREADY_EXISTS if the path already exists in the zip
     * @throws NS_ERROR_IN_PROGRESS if another operation is currently in progress
     * @throws NS_ERROR_INVALID_ARG if aModTime is older than 1980-1-1
     */
    addEntryStream(aZipEntry: AUTF8String, aModTime: PRTime, aCompression: int32_t, aStream: nsIInputStreamType, aQueue: boolean): void;
    /**
     * Removes an existing entry from the zip file.
     *
     * @param aZipEntry the path of the entry to be removed
     * @param aQueue adds the operation to the background queue. Will be
     * performed when processQueue is called.
     *
     * @throws NS_ERROR_NOT_INITIALIZED if no zip file has been opened
     * @throws NS_ERROR_IN_PROGRESS if another operation is currently in progress
     * @throws NS_ERROR_FILE_NOT_FOUND if no entry with the given path exists
     * @throws <other-error> on failure to update the zip file
     */
    removeEntry(aZipEntry: AUTF8String, aQueue: boolean): void;
    /**
     * Processes all queued items until complete or some error occurs. The
     * observer will be notified when the first operation starts and when the
     * last operation completes. Any failures will be passed to the observer.
     * The zip writer will be busy until the queue is complete or some error
     * halted processing of the queue early. In the event of an early failure,
     * remaining items will stay in the queue and calling processQueue will
     * continue.
     *
     * @throws NS_ERROR_NOT_INITIALIZED if no zip file has been opened
     * @throws NS_ERROR_IN_PROGRESS if the queue is already in progress
     */
    processQueue(aObserver: nsIRequestObserverType, aContext: nsISupportsType): void;
    /**
     * Closes the zip file.
     *
     * @throws NS_ERROR_NOT_INITIALIZED if no zip file has been opened
     * @throws NS_ERROR_IN_PROGRESS if another operation is currently in progress
     * @throws <other-error> on failure to complete the zip file
     */
    close(): void;
    /**
     * Make all stored(uncompressed) files align to given alignment size.
     *
     * @param aAlignSize is the alignment size, valid values from 2 to 32768, and
     * must be power of 2.
     *
     * @throws NS_ERROR_INVALID_ARG if aAlignSize is invalid
     * @throws <other-error> on failure to update the zip file
     */
    alignStoredFiles(aAlignSize: uint16_t): void;
}

/**
 * This is a private interface used by the internals of the networking library.
 * It will never be frozen.  Do not use it in external code.
 */
declare interface nsPIDNSServiceType extends nsIDNSServiceType {
    /**
     * called to initialize the DNS service.
     */
    init(): void;
    /**
     * called to shutdown the DNS service.  any pending asynchronous
     * requests will be canceled, and the local cache of DNS records
     * will be cleared.  NOTE: the operating system may still have
     * its own cache of DNS records, which would be unaffected by
     * this method.
     */
    shutdown(): void;
    /**
     * Whether or not DNS prefetching (aka RESOLVE_SPECULATE) is enabled
     */
    prefetchEnabled: boolean;
}

/**
 *
 */
declare interface nsPIPromptServiceType extends nsISupportsType {
    /**
     *
     */
    doDialog(aParent: nsIDOMWindowType, aParamBlock: nsIDialogParamBlockType, aChromeURL: string): void;
}

/**
 * This is a private interface used by the internals of the networking library.
 * It will never be frozen.  Do not use it in external code.
 */
declare interface nsPISocketTransportServiceType extends nsIRoutedSocketTransportServiceType {
    /**
     * init/shutdown routines.
     */
    init(): void;
    /**
     *
     */
    shutdown(aXpcomShutdown: bool): void;
    /**
     * controls the TCP sender window clamp
     */
    readonly sendBufferSize: long;
    /**
     * Controls whether the socket transport service is offline.
     * Setting it offline will cause non-local socket detachment.
     */
    offline: boolean;
    /**
     * Controls the default timeout (in seconds) for sending keepalive probes.
     */
    readonly keepaliveIdleTime: long;
    /**
     * Controls the default interval (in seconds) between retrying keepalive probes.
     */
    readonly keepaliveRetryInterval: long;
    /**
     * Controls the default retransmission count for keepalive probes.
     */
    readonly keepaliveProbeCount: long;
}

/**
 *
 */
declare interface nsPIWidgetCocoaType extends nsISupportsType {
    /**
     *
     */
    SendSetZLevelEvent(): void;
    /**
     *
     */
    GetChildSheet(aShown: boolean): nsIWidget;
    /**
     *
     */
    GetRealParent(): nsIWidget;
    /**
     *
     */
    readonly sheetWindowParent: NSWindowPtr;
    /**
     *
     */
    readonly isSheet: boolean;
}

/**
 *
 */
declare interface nsPIWindowWatcherType extends nsISupportsType {
    /**
     * A window has been created. Add it to our list.
     * @param aWindow the window to add
     * @param aChrome the corresponding chrome window. The DOM window
     * and chrome will be mapped together, and the corresponding
     * chrome can be retrieved using the (not private)
     * method getChromeForWindow. If null, any extant mapping
     * will be cleared.
     */
    addWindow(aWindow: mozIDOMWindowProxy, aChrome: nsIWebBrowserChromeType): void;
    /**
     * A window has been closed. Remove it from our list.
     * @param aWindow the window to remove
     */
    removeWindow(aWindow: mozIDOMWindowProxy): void;
    /**
     * Opens a new window so that the window that aOpeningTab belongs to
     * is set as the parent window. The newly opened window will also
     * inherit load context information from aOpeningTab.
     *
     * @param aOpeningTab
     * The nsIRemoteTab that is requesting the new window be opened.
     * @param aFeatures
     * Window features if called with window.open or similar.
     * @param aCalledFromJS
     * True if called via window.open or similar.
     * @param aOpenerFullZoom
     * The current zoom multiplier for the opener tab. This is then
     * applied to the newly opened window.
     * @param aOpenWindowInfo
     * Information used to create the initial content browser in the new
     * window.
     *
     * @return the nsIRemoteTab of the initial browser for the newly opened
     * window.
     */
    openWindowWithRemoteTab(aOpeningTab: nsIRemoteTabType, aFeatures: WindowFeaturesRef, aCalledFromJS: boolean, aOpenerFullZoom: float, aOpenWindowInfo: nsIOpenWindowInfoType): nsIRemoteTab;
}

/**
 *
 */
declare interface txIEXSLTFunctionsType extends nsISupportsType {
    /**
     *
     */
    match(str: AString, regex: AString, flags: AString, doc: Document): DocumentFragment;
    /**
     *
     */
    replace(str: AString, regex: AString, flags: AString, replace: AString): AString;
    /**
     *
     */
    test(str: AString, regex: AString, flags: AString): boolean;
}

/**
 *
 */
declare interface xpcIJSWeakReferenceType extends nsISupportsType {
    /**
     * To be called from JS only.
     *
     * Returns the referenced JS object or null if the JS object has
     * been garbage collected.
     */
    get(): jsval;
}

/**
 * interface of Components.interfaces
 * (interesting stuff only reflected into JavaScript)
 */
declare interface nsIXPCComponents_InterfacesType extends nsISupportsType {
}

/**
 * interface of Components.classes
 * (interesting stuff only reflected into JavaScript)
 */
declare interface nsIXPCComponents_ClassesType extends nsISupportsType {
}

/**
 * interface of Components.results
 * (interesting stuff only reflected into JavaScript)
 */
declare interface nsIXPCComponents_ResultsType extends nsISupportsType {
}

/**
 * interface of Components.ID
 * (interesting stuff only reflected into JavaScript)
 */
declare interface nsIXPCComponents_IDType extends nsISupportsType {
}

/**
 * interface of Components.Exception
 * (interesting stuff only reflected into JavaScript)
 */
declare interface nsIXPCComponents_ExceptionType extends nsISupportsType {
}

/**
 * interface of Components.Constructor
 * (interesting stuff only reflected into JavaScript)
 */
declare interface nsIXPCComponents_ConstructorType extends nsISupportsType {
}

/**
 * interface of object returned by Components.utils.Sandbox.
 */
declare interface nsIXPCComponents_utils_SandboxType extends nsISupportsType {
}

/**
 * interface for callback to be passed to Cu.schedulePreciseGC
 */
declare interface nsIScheduledGCCallbackType extends nsISupportsType {
    /**
     *
     */
    callback(): void;
}

/**
 * interface of Components.utils
 */
declare interface nsIXPCComponents_UtilsType extends nsISupportsType {
    /**
     * Prints the provided message to stderr.
     */
    printStderr(message: AUTF8String): void;
    /**
     * reportError is designed to be called from JavaScript only.
     *
     * It will report a JS Error object to the JS console, and return. It
     * is meant for use in exception handler blocks which want to "eat"
     * an exception, but still want to report it to the console.
     *
     * It must be called with one param, usually an object which was caught by
     * an exception handler.  If it is not a JS error object, the parameter
     * is converted to a string and reported as a new error.
     *
     * If called with two parameters, and the first parameter is not an
     * object, the second parameter is used as the stack for the error report.
     */
    reportError(error: jsval, stack: jsval): void;
    /**
     * Cu.Sandbox is used to create a sandbox object
     *
     * let sandbox = Cu.Sandbox(principal[, options]);
     *
     * Using new Cu.Sandbox(...) to create a sandbox has the same effect as
     * calling Cu.Sandbox(...) without new.
     *
     * In JS, Cu.Sandbox uses the following parameters:
     *
     * @param {Principal} principal
     * The security principal defined for a sandbox determines what code
     * running in that sandbox will be allowed to do. The principal may be one
     * of four types: the system principal, a content principal, an expanded
     * principal or a null principal. Depending on the principal type,
     * this argument can be a nsIPrincipal, a Window, a String, an Array
     * or null. See below.
     * A content principal can be provided by passing a nsIPrincipal, a
     * DOM Window, or a string URI (not recommended).
     * An expanded (or extended) principal is an array of principals,
     * where each item can be either a nsIPrincipal, a DOM window or a
     * string URI.
     * A null principal can either be specified by passing `null` or
     * created explicitly with `Cc["@mozilla.org/nullprincipal;1"].createInstance(Ci.nsIPrincipal);`
     * @param {Object} options
     * Optional parameters, valid properties are:
     * - allowWaivers: {Boolean} Allows the caller to waive Xrays, in case
     * Xrays were used. Defaults to true.
     * - discardSource: {Boolean} For certain globals, we know enough about
     * the code that will run in them that we can discard script source
     * entirely. A discarded source will be re-read when stringifying
     * functions.
     * Defaults to false.
     * - forceSecureContext: {Boolean} Determines whether content windows and
     * workers are marked as "Secure Context"s. If principal is the system
     * principal, the value is forced to true. Otherwise defaults to false.
     * - freshCompartment: {Boolean} Whether the sandbox should be created
     * using a new compartment. Defaults to false.
     * - freshZone: {Boolean} if true creates a new GC region separate from
     * both the calling context's and the sandbox prototype's region.
     * Defaults to false.
     * - invisibleToDebugger: {Boolean} Whether this sandbox and its scripts
     * can be accessed by the JavaScript Debugger.
     * Defaults to false.
     * - isWebExtensionContentScript: {Boolean} Whether this sandbox
     * corresponds to a WebExtension content script, and should receive
     * various bits of special compatibility behavior.
     * Defaults to false.
     * - metadata: {Object} Object to use as the metadata for the sandbox. See
     * setSandboxMetadata.
     * - originAttributes: {Object} Dictionary of origin attributes to use if
     * the principal was provided as a string.
     * - sameZoneAs: {Object} Javascript Object in whose garbage collection
     * region the sandbox should be created. This helps to improve memory
     * usage by allowing sandboxes to be discarded when that zone goes away.
     * It also improves performance and memory usage by allowing strings
     * to be passed between the compartments without copying or using
     * wrappers.
     * Content scripts should pass the window they're running in as this
     * parameter, in order to ensure that the script is cleaned up at the
     * same time as the content itself.
     * - sandboxName: {String} Identifies the sandbox in about:memory. This
     * property is optional, but very useful for tracking memory usage. A
     * recommended value for this property is an absolute path to the script
     * responsible for creating the sandbox. If you don't specify a sandbox
     * name it will default to the caller's filename.
     * - sandboxPrototype: {Object} Prototype object for the sandbox. The
     * sandbox will inherit the contents of this object if it's provided.
     * Passing a content window object, setting wantXrays:true (default) and
     * using an extended principal provides a clean, isolated execution
     * environment in which javascript code that needs Web APIs (such as
     * accessing the window's DOM) can be executed without interference from
     * untrusted content code.
     * - userContextId: {Number} The id of the user context this sandbox is
     * inside. Defaults to 0.
     * - wantComponents: {Boolean} Indicates whether the Components object is
     * available or not in the sandbox. If the sandbox interacts with
     * untrusted content this should be set to false when possible to
     * further reduce possible attack surface.
     * Defaults to true.
     * - wantExportHelpers: {Boolean} if true, then createObjectIn(),
     * evalInWindow(), and exportFunction() are available in the sandbox.
     * Defaults to false.
     * - wantGlobalProperties: {Array<String>} Each string is the name of an
     * object that you want to make available as a global to code running in
     * the sandbox. Possible values: Blob, ChromeUtils, CSS, CSSRule,
     * Directory, DOMParser, Element, Event, File, FileReader, FormData,
     * InspectorUtils, MessageChannel, Node, NodeFilter, PromiseDebugging,
     * TextDecoder, TextEncoder, URL, URLSearchParams, XMLHttpRequest,
     * XMLSerializer, atob, btoa, caches, crypto, fetch, indexedDB,
     * rtcIdentityProvider
     * - wantXrays: {Boolean} Whether the sandbox wants Xray vision with
     * respect to same-origin objects outside the sandbox.
     * Note that wantXrays is essentially deprecated. The preferred method
     * of handling this now is to give the sandbox an expanded principal
     * which inherits from the principal of the content compartment the
     * sandbox will interact with. That lets the sandbox see the content
     * compartment through X-ray wrappers, and gives any object passed from
     * the sandbox to the content compartment opaque security wrappers unless
     * export helpers are explicitly used.
     * "Xray vision" is exactly the same Xray behavior that script always
     * gets, by default, when working with DOM objects across origin
     * boundaries. This is primarily visible for chrome code accessing
     * content. However, it also occurs during cross-origin access between
     * two content pages, since each page sees a "vanilla" view of the
     * other. The protection is bidirectional: the caller sees the bonafide
     * DOM objects without being confused by sneakily-redefined properties,
     * and the target receives appropriate privacy from having its expandos
     * inspected by untrusted callers. In situations where only
     * unidirectional protection is needed, callers have the option to waive
     * the X-ray behavior using wrappedJSObject or XPCNativeWrapper.unwrap().
     * In general, when accessing same-origin content, script gets a
     * Transparent wrapper rather than an Xray wrapper. However, sandboxes
     * are often used when chrome wants to run script as another origin,
     * possibly to interact with the page. In this case, same-origin Xrays
     * are desirable, and wantXrays should be set to true.
     * Defaults to true.
     */
    readonly Sandbox: nsIXPCComponents_utils_Sandbox;
    /**
     * evalInSandbox is designed to be called from JavaScript only.
     *
     * evalInSandbox evaluates the provided source string in the given sandbox.
     * It returns the result of the evaluation to the caller.
     *
     * var s = new C.u.Sandbox("http://www.mozilla.org");
     * var res = C.u.evalInSandbox("var five = 5; 2 + five", s);
     * var outerFive = s.five;
     * s.seven = res;
     * var thirtyFive = C.u.evalInSandbox("five * seven", s);
     */
    evalInSandbox(source: AString, sandbox: jsval, version: jsval, filename: AUTF8String, lineNo: long, enforceFilenameRestrictions: bool): jsval;
    /**
     * Get the sandbox for running JS-implemented UA widgets (video controls etc.),
     * hosted inside UA-created Shadow DOM.
     */
    getUAWidgetScope(principal: nsIPrincipalType): jsval;
    /**
     * getSandboxMetadata is designed to be called from JavaScript only.
     *
     * getSandboxMetadata retrieves the metadata associated with
     * a sandbox object. It will return undefined if there
     * is no metadata attached to the sandbox.
     *
     * var s = C.u.Sandbox(..., { metadata: "metadata" });
     * var metadata = C.u.getSandboxMetadata(s);
     */
    getSandboxMetadata(sandbox: jsval): jsval;
    /**
     * setSandboxMetadata is designed to be called from JavaScript only.
     *
     * setSandboxMetadata sets the metadata associated with
     * a sandbox object.
     *
     * Note that the metadata object will be copied before being used.
     * The copy will be performed using the structured clone algorithm.
     * Note that this algorithm does not support reflectors and
     * it will throw if it encounters them.
     */
    setSandboxMetadata(sandbox: jsval, metadata: jsval): void;
    /**
     * import is designed to be called from JavaScript only.
     *
     * Synchronously loads and evaluates the js file located at
     * 'registryLocation' with a new, fully privileged global object.
     *
     * If 'targetObj' is specified and equal to null, returns the
     * module's global object. Otherwise (if 'targetObj' is not
     * specified, or 'targetObj' is != null) looks for a property
     * 'EXPORTED_SYMBOLS' on the new global object. 'EXPORTED_SYMBOLS'
     * is expected to be an array of strings identifying properties on
     * the global object.  These properties will be installed as
     * properties on 'targetObj', or, if 'targetObj' is not specified,
     * on the caller's global object. If 'EXPORTED_SYMBOLS' is not
     * found, an error is thrown.
     *
     * @param resourceURI A resource:// URI string to load the module from.
     * @param targetObj  the object to install the exported properties on.
     * If this parameter is a primitive value, this method throws
     * an exception.
     * @returns the module code's global object.
     *
     * The implementation maintains a hash of registryLocation->global obj.
     * Subsequent invocations of importModule with 'registryLocation'
     * pointing to the same file will not cause the module to be re-evaluated,
     * but the symbols in EXPORTED_SYMBOLS will be exported into the
     * specified target object and the global object returned as above.
     */
    import(aResourceURI: AUTF8String, targetObj: jsval): jsval;
    /**
     * Returns true if the JSM is loaded into the system global previously via
     * the import method above, or corresponding ESM is loaded. Returns false
     * otherwise.
     *
     * @param resourceURI A resource:// URI string representing the location of
     * the js file to be checked if it is already loaded or not.
     * @returns boolean, true if the js file has been loaded via import. false
     * otherwise
     */
    isModuleLoaded(aResourceURI: AUTF8String): boolean;
    /**
     * Returns true if the JSM is loaded into the system global previously via
     * the import method above. Returns false otherwise.
     */
    isJSModuleLoaded(aResourceURI: AUTF8String): boolean;
    /**
     * Returns true if the ESM is loaded into the system global previously via
     * the ChromeUtils.importESModule method etc. Returns false otherwise.
     */
    isESModuleLoaded(aResourceURI: AUTF8String): boolean;
    /**
     * Unloads the JS module at 'registryLocation'. Existing references to the
     * module will continue to work but any subsequent import of the module will
     * reload it and give new reference. If the JS module hasn't yet been
     * imported then this method will do nothing.
     *
     * @param resourceURI A resource:// URI string to unload the module from.
     */
    unload(registryLocation: AUTF8String): void;
    /**
     * Imports global properties (like DOM constructors) into the scope, defining
     * them on the caller's global. aPropertyList should be an array of property
     * names.
     *
     * See xpc::GlobalProperties::Parse for the current list of supported
     * properties.
     */
    importGlobalProperties(aPropertyList: jsval): void;
    /**
     * To be called from JS only.
     *
     * Return a weak reference for the given JS object.
     */
    getWeakReference(obj: jsval): xpcIJSWeakReference;
    /**
     * To be called from JS only.
     *
     * Force an immediate garbage collection cycle.
     */
    forceGC(): void;
    /**
     * To be called from JS only.
     *
     * Force an immediate cycle collection cycle.
     */
    forceCC(aListener: nsICycleCollectorListenerType): void;
    /**
     * To be called from JS only.  C++ callers should use the
     * nsCycleCollector_createLogger() function instead.
     *
     * Create an instance of the built-in cycle collector logger object.
     */
    createCCLogger(): nsICycleCollectorListener;
    /**
     * To be called from JS only.
     *
     * If any incremental CC is in progress, finish it. For testing.
     */
    finishCC(): void;
    /**
     * To be called from JS only.
     *
     * Do some cycle collector work, with the given work budget.
     * The cost of calling Traverse() on a single object is set as 1.
     * For testing.
     */
    ccSlice(budget: long_long): void;
    /**
     * To be called from JS only.
     *
     * Return the longest cycle collector slice time since the last
     * time clearMaxCCTime() was called.
     */
    getMaxCCSliceTimeSinceClear(): long;
    /**
     * To be called from JS only.
     *
     * Reset the internal max slice time value used for
     * getMaxCCSliceTimeSinceClear().
     */
    clearMaxCCTime(): void;
    /**
     * To be called from JS only.
     *
     * Force an immediate shrinking garbage collection cycle.
     */
    forceShrinkingGC(): void;
    /**
     * Schedule a garbage collection cycle for a point in the future when no JS
     * is running. Call the provided function once this has occurred.
     */
    schedulePreciseGC(callback: nsIScheduledGCCallbackType): void;
    /**
     * Schedule a shrinking garbage collection cycle for a point in the future
     * when no JS is running. Call the provided function once this has occured.
     */
    schedulePreciseShrinkingGC(callback: nsIScheduledGCCallbackType): void;
    /**
     * In a debug build, unlink any ghost windows. This is only for debugging
     * leaks, and can cause bad things to happen if called.
     */
    unlinkGhostWindows(): void;
    /**
     * In an NS_FREE_PERMANENT_DATA build, intentionally leak a C++ object. This
     * is needed to test leak checking.
     */
    intentionallyLeak(): void;
    /**
     *
     */
    getJSTestingFunctions(): jsval;
    /**
     * Returns an object containing `filename` and `lineNumber` properties
     * describing the source location of the given function.
     */
    getFunctionSourceLocation(func: jsval): jsval;
    /**
     * To be called from JS only.
     *
     * Call 'function', using the provided stack as the async stack responsible
     * for the call, and propagate its return value or the exception it throws.
     * The function is called with no arguments, and 'this' is 'undefined'.
     *
     * The code in the function will see the given stack frame as the
     * asyncCaller of its own stack frame, instead of the current caller.
     */
    callFunctionWithAsyncStack(_function: jsval, stack: nsIStackFrameType, asyncCause: AString): jsval;
    /**
     * To be called from JS only.
     *
     * Returns the global object with which the given object is associated.
     *
     * @param obj The JavaScript object whose global is to be gotten.
     * @return the corresponding global.
     */
    getGlobalForObject(obj: jsval): jsval;
    /**
     * To be called from JS only.
     *
     * Returns the true if the object is a (scripted) proxy.
     * NOTE: Security wrappers are unwrapped first before the check.
     */
    isProxy(vobject: jsval): boolean;
    /**
     * To be called from JS only.
     *
     * Instead of simply wrapping a function into another compartment,
     * this helper function creates a native function in the target
     * compartment and forwards the call to the original function.
     * That call will be different than a regular JS function call in
     * that, the |this| is left unbound, and all the non-native JS
     * object arguments will be cloned using the structured clone
     * algorithm.
     * The return value is the new forwarder function, wrapped into
     * the caller's compartment.
     * The 3rd argument is an optional options object:
     * - defineAs: the name of the property that will
     * be set on the target scope, with
     * the forwarder function as the value.
     */
    exportFunction(vfunction: jsval, vscope: jsval, voptions: jsval): jsval;
    /**
     * To be called from JS only.
     *
     * Returns an object created in |vobj|'s compartment.
     * If defineAs property on the options object is a non-null ID,
     * the new object will be added to vobj as a property. Also, the
     * returned new object is always automatically waived (see waiveXrays).
     */
    createObjectIn(vobj: jsval, voptions: jsval): jsval;
    /**
     * To be called from JS only.
     *
     * Ensures that all functions come from vobj's scope (and aren't cross
     * compartment wrappers).
     */
    makeObjectPropsNormal(vobj: jsval): void;
    /**
     * Determines whether this object is backed by a DeadObjectProxy.
     *
     * Dead-wrapper objects hold no other objects alive (they have no outgoing
     * reference edges) and will throw if you touch them (e.g. by
     * reading/writing a property).
     */
    isDeadWrapper(obj: jsval): bool;
    /**
     * Determines whether this value is a remote object proxy, such as
     * RemoteWindowProxy or RemoteLocationProxy, for an out-of-process frame.
     *
     * Remote object proxies do not grant chrome callers the same exemptions
     * to the same-origin-policy that in-process wrappers typically do, so
     * this can be used to determine whether access to cross-origin proxies is
     * safe:
     *
     * if (!Cu.isRemoteProxy(frame.contentWindow)) {
     * frame.contentWindow.doCrossOriginThing();
     * }
     */
    isRemoteProxy(val: jsval): bool;
    /**
     * To be called from JS only. This is for Gecko internal use only, and may
     * disappear at any moment.
     *
     * Forces a recomputation of all wrappers in and out of the compartment
     * containing |vobj|. If |vobj| is not an object, all wrappers system-wide
     * are recomputed.
     */
    recomputeWrappers(vobj: jsval): void;
    /**
     * To be called from JS only. This is for Gecko internal use only, and may
     * disappear at any moment.
     *
     * Enables Xray vision for same-compartment access for the compartment
     * indicated by |vscope|. All outgoing wrappers are recomputed.
     *
     * This must not be called on chrome (system-principal) scopes.
     */
    setWantXrays(vscope: jsval): void;
    /**
     * Dispatches a runnable to the current/main thread. If |scope| is passed,
     * the runnable will be dispatch in the compartment of |scope|, which
     * affects which error reporter gets called.
     */
    dispatch(runnable: jsval, scope: jsval): void;
    /**
     *
     */
    readonly isInAutomation: boolean;
    /**
     *
     */
    exitIfInAutomation(): void;
    /**
     *
     */
    crashIfNotInAutomation(): void;
    /**
     *
     */
    setGCZeal(zeal: long): void;
    /**
     *
     */
    nukeSandbox(obj: jsval): void;
    /**
     * API to dynamically block script for a given global. This takes effect
     * immediately, unlike other APIs that only affect newly-created globals.
     *
     * The machinery here maintains a counter, and allows script only if each
     * call to blockScriptForGlobal() has been matched with a call to
     * unblockScriptForGlobal(). The caller _must_ make sure never to call
     * unblock() more times than it calls block(), since that could potentially
     * interfere with another consumer's script blocking.
     */
    blockScriptForGlobal(global: jsval): void;
    /**
     *
     */
    unblockScriptForGlobal(global: jsval): void;
    /**
     * Check whether the given object is an opaque wrapper (PermissiveXrayOpaque).
     */
    isOpaqueWrapper(obj: jsval): bool;
    /**
     * Check whether the given object is an XrayWrapper.
     */
    isXrayWrapper(obj: jsval): bool;
    /**
     * Waive Xray on a given value. Identity op for primitives.
     */
    waiveXrays(aVal: jsval): jsval;
    /**
     * Strip off Xray waivers on a given value. Identity op for primitives.
     */
    unwaiveXrays(aVal: jsval): jsval;
    /**
     * Gets the name of the JSClass of the object.
     *
     * if |aUnwrap| is true, all wrappers are unwrapped first. Unless you're
     * specifically trying to detect whether the object is a proxy, this is
     * probably what you want.
     */
    getClassName(aObj: jsval, aUnwrap: bool): string;
    /**
     * Get a DOM classinfo for the given classname.  Only some class
     * names are supported.
     */
    getDOMClassInfo(aClassName: AString): nsIClassInfo;
    /**
     * Gets the incument global for the execution of this function. For internal
     * and testing use only.
     *
     * If |callback| is passed, it is invoked with the incumbent global as its
     * sole argument. This allows the incumbent global to be measured in callback
     * environments with no scripted frames on the stack.
     */
    getIncumbentGlobal(callback: jsval): jsval;
    /**
     * Returns a name for the given function or object which is useful for
     * debugging. It will be very similar to the name displayed in call
     * stacks.
     * Objects which contain a single enumerable property which is a function
     * will generate a name based on that function. Any other non-function
     * objects will return "nonfunction".
     */
    getDebugName(obj: jsval): ACString;
    /**
     * Retrieve the last time, in microseconds since epoch, that a given
     * watchdog-related event occured.
     *
     * Valid categories:
     * "ContextStateChange"      - Context switching between active and inactive states
     * "WatchdogWakeup"          - Watchdog waking up from sleeping
     * "WatchdogHibernateStart"  - Watchdog begins hibernating
     * "WatchdogHibernateStop"   - Watchdog stops hibernating
     */
    getWatchdogTimestamp(aCategory: AString): PRTime;
    /**
     *
     */
    getJSEngineTelemetryValue(): jsval;
    /**
     * Clone an object into a scope.
     * The 3rd argument is an optional options object:
     * - cloneFunctions: boolean. If true, functions in the value are
     * wrapped in a function forwarder that appears to be a native function in
     * the content scope. Defaults to false.
     * - wrapReflectors: boolean. If true, DOM objects are passed through the
     * clone directly with cross-compartment wrappers. Otherwise, the clone
     * fails when such an object is encountered. Defaults to false.
     */
    cloneInto(value: jsval, scope: jsval, options: jsval): jsval;
    /**
     * When C++-Implemented code does security checks, it can generally query
     * the subject principal (i.e. the principal of the most-recently-executed
     * script) in order to determine the responsible party. However, when an API
     * is implemented in JS, this doesn't work - the most-recently-executed
     * script is always the System-Principaled API implementation. So we need
     * another mechanism.
     *
     * Hence the notion of the "WebIDL Caller". If the current Entry Script on
     * the Script Settings Stack represents the invocation of JS-implemented
     * WebIDL, this API returns the principal of the caller at the time
     * of invocation. Otherwise (i.e. outside of JS-implemented WebIDL), this
     * function throws. If it throws, you probably shouldn't be using it.
     */
    getWebIDLCallerPrincipal(): nsIPrincipal;
    /**
     * Gets the principal of a script object, after unwrapping any cross-
     * compartment wrappers.
     */
    getObjectPrincipal(obj: jsval): nsIPrincipal;
    /**
     * Gets the URI or identifier string associated with an object's
     * realm (the same one used by the memory reporter machinery).
     *
     * Unwraps cross-compartment wrappers first.
     *
     * The string formats and values may change at any time. Do not depend on
     * this from addon code.
     */
    getRealmLocation(obj: jsval): ACString;
    /**
     * Return a fractional number of milliseconds from process
     * startup, measured with a monotonic clock.
     */
    now(): double;
    /**
     * Reads the given file and returns its contents. If called during early
     * startup, the file will be pre-read on a background thread during profile
     * startup so its contents will be available the next time they're read.
     *
     * The file must be a text file encoded in UTF-8. Otherwise the result is
     * undefined.
     */
    readUTF8File(file: nsIFileType): AUTF8String;
    /**
     * Reads the given local file URL and returns its contents. This has the
     * same semantics of readUTF8File.
     * Only supports file URLs or URLs that point into one of the omnijars.
     */
    readUTF8URI(url: nsIURIType): AUTF8String;
    /**
     * Create a spellchecker object.
     */
    createSpellChecker(): nsIEditorSpellCheck;
    /**
     * Create a commandline object.
     *
     * @return a new `nsICommandLine` instance.
     *
     * @param args
     * The arguments of the command line, not including the app/program itself.
     * @param workingDir
     * An optional working directory for the command line.
     * @param state
     * The command line's state, one of `nsICommandLine.STATE_INITIAL_LAUNCH`,
     * `nsICommandLine.STATE_REMOTE_AUTO`, or
     * `nsICommandLine.STATE_REMOTE_EXPLICIT`.
     */
    createCommandLine(args: invalid, workingDir: nsIFileType, state: unsigned_long): nsISupports;
    /**
     * Create a command params object.
     */
    createCommandParams(): nsICommandParams;
    /**
     * Create a loadcontext object.
     */
    createLoadContext(): nsILoadContext;
    /**
     * Create a private loadcontext object.
     */
    createPrivateLoadContext(): nsILoadContext;
    /**
     * Create a persistent property object.
     */
    createPersistentProperties(): nsIPersistentProperties;
    /**
     * Create a document encoder object.
     */
    createDocumentEncoder(contentType: string): nsIDocumentEncoder;
    /**
     * Create an HTML copy encoder object.
     */
    createHTMLCopyEncoder(): nsIDocumentEncoder;
    /**
     *
     */
    getModuleImportStack(aLocation: AUTF8String): ACString;
}

/**
 * Interface for the 'Components' object.
 */
declare interface nsIXPCComponentsType extends nsISupportsType {
    /**
     *
     */
    readonly interfaces: nsIXPCComponents_Interfaces;
    /**
     *
     */
    readonly results: nsIXPCComponents_Results;
    /**
     *
     */
    isSuccessCode(result: nsresult): boolean;
    /**
     *
     */
    readonly classes: nsIXPCComponents_Classes;
    /**
     *
     */
    readonly stack: nsIStackFrame;
    /**
     *
     */
    readonly manager: nsIComponentManager;
    /**
     *
     */
    readonly utils: nsIXPCComponents_Utils;
    /**
     *
     */
    readonly ID: nsIXPCComponents_ID;
    /**
     *
     */
    readonly Exception: nsIXPCComponents_Exception;
    /**
     *
     */
    readonly Constructor: nsIXPCComponents_Constructor;
    /**
     *
     */
    returnCode: jsval;
}

/**
 * This defines the interface for a test object.
 */
declare interface nsIXPCTestObjectReadOnlyType extends nsISupportsType {
    /**
     *
     */
    readonly strReadOnly: string;
    /**
     *
     */
    readonly boolReadOnly: boolean;
    /**
     *
     */
    readonly shortReadOnly: short;
    /**
     *
     */
    readonly longReadOnly: long;
    /**
     *
     */
    readonly floatReadOnly: float;
    /**
     *
     */
    readonly charReadOnly: char;
    /**
     *
     */
    readonly timeReadOnly: PRTime;
}

/**
 *
 */
declare interface nsIXPCTestObjectReadWriteType extends nsISupportsType {
    /**
     *
     */
    stringProperty: string;
    /**
     *
     */
    booleanProperty: boolean;
    /**
     *
     */
    shortProperty: short;
    /**
     *
     */
    longProperty: long;
    /**
     *
     */
    floatProperty: float;
    /**
     *
     */
    charProperty: char;
    /**
     *
     */
    timeProperty: PRTime;
}

/**
 * Test interface for https://bugzilla.mozilla.org/show_bug.cgi?id=809674 .
 *
 * This test makes sure that accessing JS-implemented attributes or methods
 * marked with [implicit_jscontext] works as expected.
 *
 * It also makes sure [optional_argc] is not supported on JS-implemented
 * methods.
 */
declare interface nsIXPCTestBug809674Type extends nsISupportsType {
    /**
     *
     */
    addArgs(x: unsigned_long, y: unsigned_long): unsigned_long;
    /**
     *
     */
    addSubMulArgs(x: unsigned_long, y: unsigned_long, subOut: unsigned_long, mulOut: unsigned_long): unsigned_long;
    /**
     *
     */
    addVals(x: jsval, y: jsval): jsval;
    /**
     *
     */
    methodNoArgs(): unsigned_long;
    /**
     *
     */
    methodNoArgsNoRetVal(): void;
    /**
     *
     */
    addMany(x1: unsigned_long, x2: unsigned_long, x3: unsigned_long, x4: unsigned_long, x5: unsigned_long, x6: unsigned_long, x7: unsigned_long, x8: unsigned_long): unsigned_long;
    /**
     *
     */
    valProperty: jsval;
    /**
     *
     */
    uintProperty: unsigned_long;
    /**
     *
     */
    methodWithOptionalArgc(): void;
}

/**
 * This defines the interface for a test object.
 */
declare interface nsIXPCTestCEnumsType extends nsISupportsType {
    /**
     *
     */
    testCEnumInput(abc: nsIXPCTestCEnums_testFlagsExplicitType): void;
    /**
     *
     */
    testCEnumOutput(): nsIXPCTestCEnums_testFlagsExplicit;
}

/**
 *
 */
declare interface nsIXPCTestESMReturnCodeParentType extends nsISupportsType {
    /**
     *
     */
    callChild(childBehavior: long): nsresult;
}

/**
 *
 */
declare interface nsIXPCTestESMReturnCodeChildType extends nsISupportsType {
    /**
     *
     */
    doIt(behavior: long): void;
}

/**
 *
 */
declare interface nsIXPCTestInterfaceAType extends nsISupportsType {
    /**
     *
     */
    name: string;
}

/**
 *
 */
declare interface nsIXPCTestInterfaceBType extends nsISupportsType {
    /**
     *
     */
    name: string;
}

/**
 *
 */
declare interface nsIXPCTestInterfaceCType extends nsISupportsType {
    /**
     *
     */
    someInteger: long;
}

/**
 *
 */
declare interface nsIXPCTestParamsType extends nsISupportsType {
    /**
     *
     */
    testBoolean(a: boolean, b: boolean): boolean;
    /**
     *
     */
    testOctet(a: octet, b: octet): octet;
    /**
     *
     */
    testShort(a: short, b: short): short;
    /**
     *
     */
    testLong(a: long, b: long): long;
    /**
     *
     */
    testLongLong(a: long_long, b: long_long): long_long;
    /**
     *
     */
    testUnsignedShort(a: unsigned_short, b: unsigned_short): unsigned_short;
    /**
     *
     */
    testUnsignedLong(a: unsigned_long, b: unsigned_long): unsigned_long;
    /**
     *
     */
    testUnsignedLongLong(a: unsigned_long_long, b: unsigned_long_long): unsigned_long_long;
    /**
     *
     */
    testFloat(a: float, b: float): float;
    /**
     *
     */
    testDouble(a: double, b: float): double;
    /**
     *
     */
    testChar(a: char, b: char): char;
    /**
     *
     */
    testString(a: string, b: string): string;
    /**
     *
     */
    testWchar(a: wchar, b: wchar): wchar;
    /**
     *
     */
    testWstring(a: wstring, b: wstring): wstring;
    /**
     *
     */
    testAString(a: AString, b: AString): AString;
    /**
     *
     */
    testAUTF8String(a: AUTF8String, b: AUTF8String): AUTF8String;
    /**
     *
     */
    testACString(a: ACString, b: ACString): ACString;
    /**
     *
     */
    testJsval(a: jsval, b: jsval): jsval;
    /**
     *
     */
    testInterfaceIsSequence(aIID: nsIIDPtrType, a: invalid, bIID: nsIIDPtrType, b: invalid, rvIID: nsIIDPtrType, rv: invalid): void;
    /**
     *
     */
    testShortArray(aLength: unsigned_long, a: short[], bLength: unsigned_long, b: short[], rvLength: unsigned_long, rv: short[]): void;
    /**
     *
     */
    testDoubleArray(aLength: unsigned_long, a: double[], bLength: unsigned_long, b: double[], rvLength: unsigned_long, rv: double[]): void;
    /**
     *
     */
    testStringArray(aLength: unsigned_long, a: string[], bLength: unsigned_long, b: string[], rvLength: unsigned_long, rv: string[]): void;
    /**
     *
     */
    testWstringArray(aLength: unsigned_long, a: wstring[], bLength: unsigned_long, b: wstring[], rvLength: unsigned_long, rv: wstring[]): void;
    /**
     *
     */
    testInterfaceArray(aLength: unsigned_long, a: nsIXPCTestInterfaceAType[], bLength: unsigned_long, b: nsIXPCTestInterfaceAType[], rvLength: unsigned_long, rv: nsIXPCTestInterfaceAType[]): void;
    /**
     *
     */
    testByteArrayOptionalLength(a: uint8_t[], aLength: unsigned_long): unsigned_long;
    /**
     *
     */
    testSizedString(aLength: unsigned_long, a: string, bLength: unsigned_long, b: string, rvLength: unsigned_long, rv: string): void;
    /**
     *
     */
    testSizedWstring(aLength: unsigned_long, a: wstring, bLength: unsigned_long, b: wstring, rvLength: unsigned_long, rv: wstring): void;
    /**
     *
     */
    testInterfaceIs(aIID: nsIIDPtrType, a: nsQIResult, bIID: nsIIDPtrType, b: nsQIResult, rvIID: nsIIDPtrType, rv: nsQIResult): void;
    /**
     *
     */
    testInterfaceIsArray(aLength: unsigned_long, aIID: nsIIDPtrType, a: nsQIResult[], bLength: unsigned_long, bIID: nsIIDPtrType, b: nsQIResult[], rvLength: unsigned_long, rvIID: nsIIDPtrType, rv: nsQIResult[]): void;
    /**
     *
     */
    testJsvalArray(aLength: unsigned_long, a: jsval[], bLength: unsigned_long, b: jsval[], rvLength: unsigned_long, rv: jsval[]): void;
    /**
     *
     */
    testOutAString(o: AString): void;
    /**
     *
     */
    testStringArrayOptionalSize(a: string[], aLength: unsigned_long): ACString;
    /**
     *
     */
    testOmittedOptionalOut(aJSObj: nsIXPCTestParamsType, aOut: nsIURIType): void;
    /**
     *
     */
    readonly testNaN: double;
}

/**
 *
 */
declare interface nsIXPCTestReturnCodeParentType extends nsISupportsType {
    /**
     *
     */
    callChild(childBehavior: long): nsresult;
}

/**
 *
 */
declare interface nsIXPCTestReturnCodeChildType extends nsISupportsType {
    /**
     *
     */
    doIt(behavior: long): void;
}

/**
 *
 */
declare interface nsIXPCTestFunctionInterfaceType extends nsISupportsType {
    /**
     *
     */
    echo(arg: string): string;
}

/**
 *
 */
declare interface nsIXPCTestUtilsType extends nsISupportsType {
    /**
     *
     */
    doubleWrapFunction(f: nsIXPCTestFunctionInterfaceType): nsIXPCTestFunctionInterface;
}

type CiKeys = "IJSDebugger" | "IPeerConnectionObserver" | "IPeerConnection" | "IUrlClassifierUITelemetry" | "nsIScriptableOK" | "nsIScriptableWithNotXPCOM" | "nsISessionStoreFunctions" | "amIAddonManagerStartup" | "amIWebInstallPrompt" | "extIWebNavigation" | "imgICache" | "imgIContainer" | "imgIContainerDebug" | "imgIEncoder" | "imgILoader" | "imgINotificationObserver" | "imgIRequest" | "imgIScriptedNotificationObserver" | "imgITools" | "imgIContainerCallback" | "inIDeepTreeWalker" | "mozIAppServicesLogger" | "mozIVisitInfo" | "mozIPlaceInfo" | "mozIVisitInfoCallback" | "mozIVisitedStatusCallback" | "mozIAsyncHistory" | "mozIBridgedSyncEngineCallback" | "mozIBridgedSyncEngineApplyCallback" | "mozIBridgedSyncEngine" | "mozIDOMWindow" | "mozIDOMWindowProxy" | "mozIDownloadPlatform" | "mozIExtensionServiceWorkerInfo" | "mozIExtensionListenerCallOptions" | "mozIExtensionEventListener" | "mozIExtensionAPIRequest" | "mozIExtensionAPIRequestResult" | "mozIExtensionAPIRequestHandler" | "mozIExtensionProcessScript" | "mozIExtensionStorageArea" | "mozIConfigurableExtensionStorageArea" | "mozISyncedExtensionStorageArea" | "mozIExtensionStorageListener" | "mozIExtensionStorageCallback" | "mozIGeckoMediaPluginChromeService" | "mozIGeckoMediaPluginService" | "mozIInterruptible" | "mozIJSSubScriptLoader" | "mozILocaleService" | "mozIMozIntl" | "mozIMozIntlHelper" | "mozIOSPreferences" | "mozIPersonalDictionary" | "mozIPlacesAutoComplete" | "mozIPlacesPendingOperation" | "mozIRemoteLazyInputStream" | "mozISandboxReport" | "mozISandboxReportArray" | "mozISandboxReporter" | "mozISandboxSettings" | "mozISandboxTest" | "mozIServicesLogSink" | "mozISpellCheckingEngine" | "mozIStorageAsyncConnection" | "mozIStorageAsyncStatement" | "mozIStorageBaseStatement" | "mozIStorageBindingParams" | "mozIStorageBindingParamsArray" | "mozIStorageCompletionCallback" | "mozIStorageConnection" | "mozIStorageError" | "mozIStorageFunction" | "mozIStoragePendingStatement" | "mozIStorageProgressHandler" | "mozIStorageResultSet" | "mozIStorageRow" | "mozIStorageService" | "mozIStorageStatement" | "mozIStorageStatementCallback" | "mozIStorageVacuumParticipant" | "mozIStorageValueArray" | "mozISyncedBookmarksMirrorProgressListener" | "mozISyncedBookmarksMirrorCallback" | "mozISyncedBookmarksMirrorLogger" | "mozISyncedBookmarksMerger" | "mozITXTToHTMLConv" | "mozITestInterfaceJS" | "mozIThirdPartyUtil" | "nsIASN1Tree" | "nsIAboutModule" | "nsIAboutNewTabService" | "nsIInstalledApplication" | "nsIAboutThirdParty" | "nsIAddonPolicyService" | "nsIAddonContentPolicy" | "nsIAlertNotificationImageListener" | "nsIAlertAction" | "nsIAlertNotification" | "nsIAlertsService" | "nsIAlertsDoNotDisturb" | "nsIAlertsIconData" | "nsIAlertsIconURI" | "nsIAndroidEventCallback" | "nsIAndroidEventFinalizer" | "nsIAndroidEventListener" | "nsIAndroidEventDispatcher" | "nsIAndroidView" | "nsIAndroidBridge" | "nsIAppShell" | "nsIAppShellService" | "nsIAppStartup" | "nsIAppWindow" | "nsIApplicationChooserFinishedCallback" | "nsIApplicationChooser" | "nsIApplicationReputationService" | "nsIApplicationReputationQuery" | "nsIApplicationReputationCallback" | "nsIArray" | "nsIArrayBufferInputStream" | "nsIArrayExtensions" | "nsIAsyncInputStream" | "nsIInputStreamCallback" | "nsIAsyncOutputStream" | "nsIOutputStreamCallback" | "nsIAsyncShutdownBlocker" | "nsIAsyncShutdownClient" | "nsIAsyncShutdownCompletionCallback" | "nsIAsyncShutdownBarrier" | "nsIAsyncShutdownService" | "nsIAsyncStreamCopier" | "nsIAsyncStreamCopier2" | "nsIAsyncVerifyRedirectCallback" | "nsISuspendedTypes" | "nsIAudioChannelAgentCallback" | "nsIAudioChannelAgent" | "nsIAudioDeviceInfo" | "nsIAuthInformation" | "nsIAuthModule" | "nsIAuthPrompt" | "nsIAuthPrompt2" | "nsIAuthPromptAdapterFactory" | "nsIAuthPromptCallback" | "nsIAuthPromptProvider" | "nsIAutoCompleteController" | "nsIAutoCompleteInput" | "nsIAutoCompletePopup" | "nsIAutoCompleteResult" | "nsIAutoCompleteSearch" | "nsIAutoCompleteObserver" | "nsIAutoCompleteSearchDescriptor" | "nsIAutoCompleteSimpleResult" | "nsIAutoCompleteSimpleResultListener" | "nsIAutoCompleteSimpleSearch" | "nsIAutoplay" | "nsITabUnloader" | "nsIAvailableMemoryWatcherBase" | "nsIBFCacheEntry" | "nsIBackgroundChannelRegistrar" | "nsIBackgroundFileSaver" | "nsIBackgroundFileSaverObserver" | "nsIBackgroundTasks" | "nsIBackgroundTasksManager" | "nsIBackgroundTasksRunner" | "nsIBaseWindow" | "nsIBidiKeyboard" | "nsIBinaryHttpRequest" | "nsIBinaryHttpResponse" | "nsIBinaryHttp" | "nsIBinaryInputStream" | "nsIBinaryOutputStream" | "nsIBits" | "nsIBitsNewRequestCallback" | "nsIBitsRequest" | "nsIBitsCallback" | "nsIBlocklistService" | "nsIBounceTrackingProtection" | "nsIBrowser" | "nsIBrowserChild" | "nsIBrowserController" | "nsIOpenURIInFrameParams" | "nsIBrowserDOMWindow" | "nsIBrowserElementAPI" | "nsIBrowserHandler" | "nsIBrowserUsage" | "nsIVisibleTab" | "nsIBrowserWindowTracker" | "nsIBufferedInputStream" | "nsIBufferedOutputStream" | "nsIByteRangeRequest" | "nsICacheEntry" | "nsICacheEntryMetaDataVisitor" | "nsICacheEntryDoomCallback" | "nsICacheEntryOpenCallback" | "nsIInputStreamReceiver" | "nsICacheInfoChannel" | "nsICachePurgeLock" | "nsICacheStorage" | "nsICacheStorageService" | "nsICacheStorageConsumptionObserver" | "nsICacheStorageVisitor" | "nsICacheTesting" | "nsICachingChannel" | "nsICancelable" | "nsICaptivePortalCallback" | "nsICaptivePortalDetector" | "nsICaptivePortalServiceCallback" | "nsICaptivePortalService" | "nsICascadeFilter" | "nsICategoryEntry" | "nsICategoryManager" | "nsICertOverride" | "nsICertOverrideService" | "nsICertStorageCallback" | "nsIRevocationState" | "nsIIssuerAndSerialRevocationState" | "nsISubjectAndPubKeyRevocationState" | "nsICRLiteCoverage" | "nsICRLiteTimestamp" | "nsICertInfo" | "nsICertStorage" | "nsICertTreeItem" | "nsICertTree" | "nsICertificateDialogs" | "nsIChannel" | "nsIIdentChannel" | "nsIUrlClassifierBlockedChannel" | "nsIChannelClassifierService" | "nsIChannelEventSink" | "nsIChildChannel" | "nsIChromeRegistry" | "nsIXULChromeRegistry" | "nsIClassInfo" | "nsIClassOfService" | "nsIClassifiedChannel" | "nsIClearDataService" | "nsIClearDataCallback" | "nsIClickRule" | "nsIClientAuthDialogCallback" | "nsIClientAuthDialogService" | "nsIClientAuthDialogs" | "nsIClientAuthRememberRecord" | "nsIClientAuthRememberService" | "nsIAsyncSetClipboardData" | "nsIAsyncSetClipboardDataCallback" | "nsIClipboard" | "nsIClipboardHelper" | "nsIClipboardOwner" | "nsICloneableInputStream" | "nsICloneableInputStreamWithRange" | "nsICodeCoverage" | "nsIColorPickerShownCallback" | "nsIColorPicker" | "nsICommandLine" | "nsICommandLineHandler" | "nsICommandLineRunner" | "nsICommandLineValidator" | "nsICommandManager" | "nsICommandParams" | "nsIComponentManager" | "nsIComponentRegistrar" | "nsICompressConvStats" | "nsIConsoleAPIStorage" | "nsIConsoleListener" | "nsIConsoleMessage" | "nsIConsoleService" | "nsIContentBlockingAllowList" | "nsIContentDispatchChooser" | "nsIContentHandler" | "nsIContentPermissionType" | "nsIContentPermissionRequest" | "nsIContentPermissionPrompt" | "nsIContentPolicy" | "nsIContentPrefObserver" | "nsIContentPrefService2" | "nsIContentPrefCallback2" | "nsIContentPref" | "nsIContentProcessInfo" | "nsIContentProcessProvider" | "nsIContentSecurityManager" | "nsIContentSecurityPolicy" | "nsICSPEventListener" | "nsIContentSignatureVerifier" | "nsIContentSniffer" | "nsIContentViewer" | "nsIContentViewerEdit" | "nsIController" | "nsICommandController" | "nsIControllerCommand" | "nsIControllerCommandTable" | "nsIControllerContext" | "nsIControllers" | "nsIConverterInputStream" | "nsIConverterOutputStream" | "nsICookie" | "nsICookieBannerListService" | "nsICookieBannerRule" | "nsICookieBannerService" | "nsICookieJarSettings" | "nsICookieManager" | "nsICookieNotification" | "nsICookiePermission" | "nsICookieRule" | "nsICookieTransactionCallback" | "nsICookieService" | "nsICrashReporter" | "nsICrashService" | "nsICryptoHash" | "nsICycleCollectorHandler" | "nsICycleCollectorLogSink" | "nsICycleCollectorListener" | "nsIDAPTelemetry" | "nsIDHCPClient" | "nsIDNSAdditionalInfo" | "nsIDNSByTypeRecord" | "nsIDNSTXTRecord" | "nsISVCParam" | "nsISVCParamAlpn" | "nsISVCParamNoDefaultAlpn" | "nsISVCParamPort" | "nsISVCParamIPv4Hint" | "nsISVCParamEchConfig" | "nsISVCParamIPv6Hint" | "nsISVCParamODoHConfig" | "nsISVCBRecord" | "nsIDNSHTTPSSVCRecord" | "nsIDNSListener" | "nsIDNSRecord" | "nsIDNSAddrRecord" | "nsIDNSService" | "nsIDOMChromeWindow" | "nsIDOMEventListener" | "nsIDOMGeoPosition" | "nsIDOMGeoPositionCallback" | "nsIDOMGeoPositionCoords" | "nsIDOMGeoPositionErrorCallback" | "nsIDOMGlobalPropertyInitializer" | "nsIDOMMozBrowserFrame" | "nsIDOMProcessChild" | "nsIDOMProcessParent" | "nsIDOMRequestService" | "nsIDOMStorageManager" | "nsIDOMSessionStorageManager" | "nsIDOMMozWakeLockListener" | "nsIDOMWindow" | "nsIDOMWindowUtils" | "nsITranslationNodeList" | "nsIJSRAIIHelper" | "nsIDOMXULButtonElement" | "nsIDOMXULCommandDispatcher" | "nsIDOMXULContainerItemElement" | "nsIDOMXULContainerElement" | "nsIDOMXULControlElement" | "nsIDOMXULMenuListElement" | "nsIDOMXULMultiSelectControlElement" | "nsIDOMXULRadioGroupElement" | "nsIDOMXULRelatedElement" | "nsIDOMXULSelectControlElement" | "nsIDOMXULSelectControlItemElement" | "nsINetDashboardCallback" | "nsIDashboard" | "nsIDashboardEventNotifier" | "nsIDataStorageManager" | "nsIDataStorage" | "nsIDataStorageItem" | "nsIDebug2" | "nsIDeviceSensorData" | "nsIDeviceSensors" | "nsIDialogParamBlock" | "nsIDirIndex" | "nsIDirIndexListener" | "nsIDirIndexParser" | "nsIDirectTaskDispatcher" | "nsIDirectoryEnumerator" | "nsIDirectoryServiceProvider" | "nsIDirectoryServiceProvider2" | "nsIDirectoryService" | "nsIDisplayInfo" | "nsIDocShell" | "nsIDocShellTreeItem" | "nsIDocShellTreeOwner" | "nsIDocumentEncoderNodeFixup" | "nsIDocumentEncoder" | "nsIDocumentLoader" | "nsIDocumentLoaderFactory" | "nsIDocumentStateListener" | "nsIDomainPolicy" | "nsIDomainSet" | "nsIDownloader" | "nsIDownloadObserver" | "nsIDragService" | "nsIDragSession" | "nsIDroppedLinkItem" | "nsIDroppedLinkHandler" | "nsIE10SUtils" | "nsIEarlyHintObserver" | "nsIEdgeMigrationUtils" | "nsIEditActionListener" | "nsIEditingSession" | "nsIEditor" | "nsIEditorMailSupport" | "nsIEditorSpellCheck" | "nsIEditorSpellCheckCallback" | "nsIEffectiveTLDService" | "nsIEmbeddingSiteWindow" | "nsISupports" | "nsIEncodedChannel" | "nsIEnterprisePolicies" | "nsIEnvironment" | "nsIEventListenerChange" | "nsIListenerChangeListener" | "nsIEventListenerInfo" | "nsIEventListenerService" | "nsIEventSourceEventListener" | "nsIEventSourceEventService" | "nsIEventTarget" | "nsIStackFrame" | "nsIException" | "nsIExpatSink" | "nsIExternalHelperAppService" | "nsPIExternalAppLauncher" | "nsIHelperAppLauncher" | "nsIExternalProtocolHandler" | "nsIExternalProtocolService" | "nsIFOG" | "nsIFactory" | "nsIFaviconService" | "nsIFaviconDataCallback" | "nsIFile" | "nsIFileChannel" | "nsIFilePicker" | "nsIFilePickerShownCallback" | "nsIFileProtocolHandler" | "nsIFileInputStream" | "nsIFileOutputStream" | "nsIFileRandomAccessStream" | "nsIFileMetadata" | "nsIAsyncFileMetadata" | "nsIFileMetadataCallback" | "nsIFileURL" | "nsIFileURLMutator" | "nsIFinalizationWitnessService" | "nsIFind" | "nsIFindService" | "nsIFocusManager" | "nsIFontEnumerator" | "nsIFontLoadCompleteCallback" | "nsIForcePendingChannel" | "nsIFormAutoComplete" | "nsIFormAutoCompleteObserver" | "nsIFormFillController" | "nsIFormPOSTActionChannel" | "nsIFormatConverter" | "nsIGIOMimeApp" | "nsIGIOService" | "nsIGNOMEShellService" | "nsIGSettingsCollection" | "nsIGSettingsService" | "nsIGeolocationUpdate" | "nsIGeolocationProvider" | "nsIGfxInfo" | "nsIGfxInfoDebug" | "nsIGleanBoolean" | "nsIGleanDatetime" | "nsIGleanCounter" | "nsIGleanTimingDistribution" | "nsIGleanMemoryDistribution" | "nsIGleanCustomDistribution" | "nsIGleanPingTestCallback" | "nsIGleanPing" | "nsIGleanString" | "nsIGleanStringList" | "nsIGleanTimespan" | "nsIGleanUuid" | "nsIGleanEvent" | "nsIGleanQuantity" | "nsIGleanDenominator" | "nsIGleanNumerator" | "nsIGleanRate" | "nsIGleanUrl" | "nsIGleanText" | "nsIGtkTaskbarProgress" | "nsIHTMLAbsPosEditor" | "nsIHTMLEditor" | "nsIHTMLInlineTableEditor" | "nsIHTMLObjectResizer" | "nsIHandlerService" | "nsIHangDetails" | "nsIHangReport" | "nsIHapticFeedback" | "nsIHelperAppLauncherDialog" | "nsIHttpActivityObserver" | "nsIHttpActivityDistributor" | "nsIHttpAuthManager" | "nsIHttpAuthenticableChannel" | "nsIHttpAuthenticator" | "nsIHttpAuthenticatorCallback" | "nsIHttpChannel" | "nsIHttpChannelAuthProvider" | "nsIHttpChannelChild" | "nsIHttpUpgradeListener" | "nsIHttpChannelInternal" | "nsIHttpHeaderVisitor" | "nsIHttpProtocolHandler" | "nsIHttpPushListener" | "nsIHttpServer" | "nsIHttpServerStoppedCallback" | "nsIHttpServerIdentity" | "nsIHttpRequestHandler" | "nsIHttpRequest" | "nsIHttpResponse" | "nsIHttpsOnlyModePermission" | "nsIIDBPermissionsRequest" | "nsIIDNService" | "nsIINIParser" | "nsIINIParserWriter" | "nsIINIParserFactory" | "nsIIOService" | "nsIIOServiceInternal" | "nsIIOUtil" | "nsIMozIconURI" | "nsIIdentityCredentialPromptService" | "nsIIdentityCredentialStorageService" | "nsIIdlePeriod" | "nsIImageLoadingContent" | "nsIIncrementalDownload" | "nsIIncrementalStreamLoaderObserver" | "nsIIncrementalStreamLoader" | "nsIInlineSpellChecker" | "nsIInputListAutoComplete" | "nsIInputStream" | "nsIInputStreamChannel" | "nsIInputStreamLength" | "nsIAsyncInputStreamLength" | "nsIInputStreamLengthCallback" | "nsIInputStreamPriority" | "nsIInputStreamPump" | "nsIInputStreamTee" | "nsIInterceptionInfo" | "nsIInterfaceRequestor" | "nsIJARChannel" | "nsIJARURI" | "nsIJARURIMutator" | "nsIJSInspector" | "nsIJumpListCommittedCallback" | "nsIJumpListBuilder" | "nsIJumpListItem" | "nsIJumpListSeparator" | "nsIJumpListLink" | "nsIJumpListShortcut" | "nsIKeyValueService" | "nsIKeyValueDatabase" | "nsIKeyValuePair" | "nsIKeyValueEnumerator" | "nsIKeyValueDatabaseCallback" | "nsIKeyValueEnumeratorCallback" | "nsIKeyValuePairCallback" | "nsIKeyValueVariantCallback" | "nsIKeyValueVoidCallback" | "nsIKeychainMigrationUtils" | "nsILayoutDebuggingTools" | "nsILayoutHistoryState" | "nsILineInputStream" | "nsILoadContext" | "nsILoadContextInfo" | "nsILoadContextInfoFactory" | "nsILoadGroup" | "nsILoadGroupChild" | "nsILoadInfo" | "nsILoadURIDelegate" | "nsILocalFileMac" | "nsILocalFileWin" | "nsILocalStorageManager" | "nsILoginAutoCompleteSearch" | "nsILoginDetectionService" | "nsILoginInfo" | "nsILoginSearchCallback" | "nsILoginManager" | "nsILoginManagerAuthPrompter" | "nsILoginManagerCrypto" | "nsILoginManagerPrompter" | "nsILoginManagerStorage" | "nsILoginMetaInfo" | "nsILoginReputationVerdictType" | "nsILoginReputationQuery" | "nsILoginReputationQueryCallback" | "nsILoginReputationService" | "nsIMIMEHeaderParam" | "nsIHandlerInfo" | "nsIMIMEInfo" | "nsIHandlerApp" | "nsILocalHandlerApp" | "nsIWebHandlerApp" | "nsIDBusHandlerApp" | "nsIMIMEInputStream" | "nsIMIMEService" | "nsIMacAttributionService" | "nsIMacDockSupport" | "nsIMacFinderProgressCanceledCallback" | "nsIMacFinderProgress" | "nsIMacPreferencesReader" | "nsIMacSharingService" | "nsIMacShellService" | "nsIMacUserActivityUpdater" | "nsITrashAppCallback" | "nsIMacWebAppUtils" | "nsIMarionette" | "nsIMediaDevice" | "nsIMediaManagerService" | "nsIFinishDumpingCallback" | "nsIDumpGCAndCCLogsCallback" | "nsIMemoryInfoDumper" | "nsIHandleReportCallback" | "nsIMemoryReporter" | "nsIFinishReportingCallback" | "nsIHeapAllocatedCallback" | "nsIMemoryReporterManager" | "nsIMessageLoop" | "nsIMessageSender" | "nsIInProcessContentFrameMessageManager" | "nsIMozBrowserFrame" | "nsIMultiPartChannel" | "nsIMultiPartChannelListener" | "nsIMultiplexInputStream" | "nsIMutableArray" | "nsINSSComponent" | "nsINSSErrorsService" | "nsINSSVersion" | "nsINamed" | "nsINamedPipeDataObserver" | "nsINamedPipeService" | "nsINativeAppSupport" | "nsINativeDNSResolverOverride" | "nsINativeOSFileResult" | "nsINativeOSFileSuccessCallback" | "nsINativeOSFileErrorCallback" | "nsINativeOSFileInternalsService" | "nsINavBookmarksService" | "nsINavHistoryResultNode" | "nsINavHistoryContainerResultNode" | "nsINavHistoryQueryResultNode" | "nsINavHistoryResultObserver" | "nsINavHistoryResult" | "nsINavHistoryQuery" | "nsINavHistoryQueryOptions" | "nsINavHistoryService" | "nsINestedURI" | "nsINestedURIMutator" | "nsINestedAboutURIMutator" | "nsIJSURIMutator" | "nsINetAddr" | "nsINetUtil" | "nsINetworkConnectivityService" | "nsIListNetworkAddressesListener" | "nsIGetHostnameListener" | "nsINetworkInfoService" | "nsIInterceptedBodyCallback" | "nsIInterceptedChannel" | "nsINetworkInterceptController" | "nsINetworkLinkService" | "nsINetworkPredictor" | "nsINetworkPredictorVerifier" | "nsINotificationStorageCallback" | "nsINotificationStorage" | "nsINullChannel" | "nsIOSFileConstantsService" | "nsIOSKeyStore" | "nsIOSPermissionRequest" | "nsIOSReauthenticator" | "nsIObjectInputStream" | "nsIObjectLoadingContent" | "nsIObjectOutputStream" | "nsIObliviousHttpClientResponse" | "nsIObliviousHttpClientRequest" | "nsIObliviousHttpServerResponse" | "nsIObliviousHttpServer" | "nsIObliviousHttp" | "nsIObliviousHttpService" | "nsIObserver" | "nsIObserverService" | "nsIBrowsingContextReadyCallback" | "nsIOpenWindowInfo" | "nsIOutputStream" | "nsIPK11Token" | "nsIPK11TokenDB" | "nsIPKCS11Module" | "nsIPKCS11ModuleDB" | "nsIPKCS11Slot" | "nsIPageThumbsStorageService" | "nsIPaper" | "nsIPaperMargin" | "nsIParentChannel" | "nsIAsyncVerifyRedirectReadyCallback" | "nsIParentRedirectingChannel" | "nsIParentalControlsService" | "nsIParserUtils" | "nsIPartitioningExceptionListObserver" | "nsIPartitioningExceptionListService" | "nsIPaymentResponseData" | "nsIGeneralResponseData" | "nsIBasicCardResponseData" | "nsIPaymentActionResponse" | "nsIPaymentCanMakeActionResponse" | "nsIPaymentShowActionResponse" | "nsIPaymentAbortActionResponse" | "nsIPaymentCompleteActionResponse" | "nsIMethodChangeDetails" | "nsIGeneralChangeDetails" | "nsIBasicCardChangeDetails" | "nsIPaymentAddress" | "nsIPaymentMethodData" | "nsIPaymentCurrencyAmount" | "nsIPaymentItem" | "nsIPaymentDetailsModifier" | "nsIPaymentShippingOption" | "nsIPaymentDetails" | "nsIPaymentOptions" | "nsIPaymentRequest" | "nsIPaymentRequestService" | "nsIPaymentUIService" | "nsIPermission" | "nsIPermissionDelegateHandler" | "nsIPermissionManager" | "nsIPropertyElement" | "nsIPersistentProperties" | "nsIPipe" | "nsISearchableInputStream" | "nsIPlacesPreviewsHelperService" | "nsIPlatformInfo" | "nsIPluginTag" | "nsIFakePluginTag" | "nsIPowerManagerService" | "nsIPrefBranch" | "nsIPrefLocalizedString" | "nsIPrefStatsCallback" | "nsIPrefObserver" | "nsIPrefService" | "nsIPrefetchService" | "nsIPreloadedStyleSheet" | "nsIPrincipal" | "nsIExpandedPrincipal" | "nsIPrintDialogService" | "nsIPrintPreviewNavigation" | "nsIPrintSettings" | "nsIPrintSettingsService" | "nsIPrintSettingsWin" | "nsIPrinterInfo" | "nsIPrinter" | "nsIPrinterList" | "nsIPrivacyTransitionObserver" | "nsIPrivateBrowsingChannel" | "nsIProcess" | "nsIProcessToolsService" | "nsIProfileStartup" | "nsIProfileMigrator" | "nsIProfileUnlocker" | "nsIProfilerStartParams" | "nsIProfiler" | "nsIProgressEventSink" | "nsIPrompt" | "nsIPromptCollection" | "nsIPromptFactory" | "nsIPromptInstance" | "nsIPromptService" | "nsIProperties" | "nsIProperty" | "nsIPropertyBag" | "nsIPropertyBag2" | "nsIProtectedAuthThread" | "nsIProtocolHandlerWithDynamicFlags" | "nsIProtocolHandler" | "nsIProtocolProxyCallback" | "nsIProxyProtocolFilterResult" | "nsIProtocolProxyFilter" | "nsIProtocolProxyChannelFilter" | "nsIProxyConfigChangedCallback" | "nsIProtocolProxyService" | "nsIProtocolProxyService2" | "nsIProxiedChannel" | "nsIProxiedProtocolHandler" | "nsIProxyInfo" | "nsIPublicKeyPinningService" | "nsIPurgeTrackerService" | "nsIPushErrorReporter" | "nsIPushNotifier" | "nsIPushData" | "nsIPushMessage" | "nsIPushSubscription" | "nsIPushSubscriptionCallback" | "nsIUnsubscribeResultCallback" | "nsIPushClearResultCallback" | "nsIPushService" | "nsIPushQuotaManager" | "nsIQueryContentEventResult" | "nsIQuotaUsageCallback" | "nsIQuotaCallback" | "nsIQuotaManagerService" | "nsIQuotaRequestBase" | "nsIQuotaUsageRequest" | "nsIQuotaRequest" | "nsIQuotaFullOriginMetadataResult" | "nsIQuotaUsageResult" | "nsIQuotaOriginUsageResult" | "nsIQuotaEstimateResult" | "nsIRaceCacheWithNetwork" | "nsIRandomAccessStream" | "nsIRandomGenerator" | "nsIRddProcessTest" | "nsIRedirectChannelRegistrar" | "nsIRedirectHistoryEntry" | "nsIRedirectResultListener" | "nsIReferrerInfo" | "nsIReflowObserver" | "nsIRefreshURI" | "nsIRegion" | "nsIRelativeFilePref" | "nsIRemoteAgent" | "nsIRemoteTab" | "nsIRequest" | "nsIRequestTailUnblockCallback" | "nsIRequestContext" | "nsIRequestContextService" | "nsIRequestObserver" | "nsIRequestObserverProxy" | "nsIResProtocolHandler" | "nsIResumableChannel" | "nsIRunnable" | "nsIRunnablePriority" | "nsIRunnableIPCMessageType" | "nsISDBCallback" | "nsISDBCloseCallback" | "nsISDBConnection" | "nsISDBRequest" | "nsISDBResult" | "nsISHEntry" | "nsISHistory" | "nsISHistoryListener" | "nsISafeOutputStream" | "nsIScreen" | "nsIScreenManager" | "nsIScriptChannel" | "nsIScriptErrorNote" | "nsIScriptError" | "nsIScriptLoaderObserver" | "nsIScriptSecurityManager" | "nsIScriptableBase64Encoder" | "nsIScriptableContentIterator" | "nsIScriptableInputStream" | "nsIScriptableUnicodeConverter" | "nsISearchSubmission" | "nsISearchEngine" | "nsISearchParseSubmissionResult" | "nsISearchService" | "nsISecCheckWrapChannel" | "nsISecretDecoderRing" | "nsISecureBrowserUI" | "nsISecurityConsoleMessage" | "nsISecurityUITelemetry" | "nsISeekableStream" | "nsISelectionController" | "nsISelectionDisplay" | "nsISelectionListener" | "nsISensitiveInfoHiddenURI" | "nsISerialEventTarget" | "nsISerializable" | "nsISerializationHelper" | "nsIServerSocket" | "nsIServerSocketListener" | "nsIServiceManager" | "nsIServiceWorkerUnregisterCallback" | "nsIServiceWorkerInfo" | "nsIServiceWorkerRegistrationInfoListener" | "nsIServiceWorkerRegistrationInfo" | "nsIServiceWorkerManagerListener" | "nsIServiceWorkerManager" | "nsISessionStorageService" | "nsISessionStoreRestoreData" | "nsISharePicker" | "nsISharingHandlerApp" | "nsIShellService" | "nsIJSEnumerator" | "nsISimpleEnumeratorBase" | "nsISimpleEnumerator" | "nsISimpleStreamListener" | "nsISimpleURIMutator" | "nsISiteSecurityService" | "nsISlowScriptDebugCallback" | "nsISlowScriptDebuggerStartupCallback" | "nsISlowScriptDebugRemoteCallback" | "nsISlowScriptDebug" | "nsISocketFilter" | "nsISocketFilterHandler" | "nsISocketProvider" | "nsISocketProviderService" | "nsISocketTransport" | "nsISTSShutdownObserver" | "nsISocketTransportService" | "nsIRoutedSocketTransportService" | "nsISound" | "nsISpeculativeConnect" | "nsISpeculativeConnectionOverrider" | "nsISpeechGrammarCompilationCallback" | "nsISpeechRecognitionService" | "nsISpeechTaskCallback" | "nsISpeechTask" | "nsISpeechService" | "nsIStandaloneNativeMenu" | "nsIStandardURL" | "nsIStandardURLMutator" | "nsIStartupCacheInfo" | "nsIStorageActivityService" | "nsIStorageStream" | "nsIStreamBufferAccess" | "nsIStreamConverter" | "nsIStreamConverterService" | "nsIStreamListener" | "nsIStreamListenerTee" | "nsIStreamLoaderObserver" | "nsIStreamLoader" | "nsIStreamTransportService" | "nsIInputAvailableCallback" | "nsIStringBundle" | "nsIStringBundleService" | "nsIStringEnumeratorBase" | "nsIStringEnumerator" | "nsIUTF8StringEnumerator" | "nsIStringInputStream" | "nsIStructuredCloneContainer" | "nsISFVBareItem" | "nsISFVInteger" | "nsISFVString" | "nsISFVBool" | "nsISFVDecimal" | "nsISFVToken" | "nsISFVByteSeq" | "nsISFVParams" | "nsISFVParametrizable" | "nsISFVItemOrInnerList" | "nsISFVSerialize" | "nsISFVItem" | "nsISFVInnerList" | "nsISFVList" | "nsISFVDictionary" | "nsISFVService" | "nsIStyleSheetService" | "nsISubstitutingProtocolHandler" | "nsIOutputIterator" | "nsIInputIterator" | "nsIForwardIterator" | "nsIBidirectionalIterator" | "nsIRandomAccessIterator" | "nsISupportsPrimitive" | "nsISupportsID" | "nsISupportsCString" | "nsISupportsString" | "nsISupportsPRBool" | "nsISupportsPRUint8" | "nsISupportsPRUint16" | "nsISupportsPRUint32" | "nsISupportsPRUint64" | "nsISupportsPRTime" | "nsISupportsChar" | "nsISupportsPRInt16" | "nsISupportsPRInt32" | "nsISupportsPRInt64" | "nsISupportsFloat" | "nsISupportsDouble" | "nsISupportsInterfacePointer" | "nsISupportsPriority" | "nsISyncStreamListener" | "nsISynthVoiceRegistry" | "nsISystemInfo" | "nsISystemProxySettings" | "nsISystemStatusBar" | "nsITCPSocketCallback" | "nsITLSServerSocket" | "nsITLSClientStatus" | "nsITLSServerConnectionInfo" | "nsITLSServerSecurityObserver" | "nsITLSSocketControl" | "nsITRRSkipReason" | "nsITXTToHTMLConv" | "nsITableEditor" | "nsITaggingService" | "nsITaskbarOverlayIconController" | "nsITaskbarPreview" | "nsITaskbarPreviewButton" | "nsITaskbarPreviewCallback" | "nsITaskbarPreviewController" | "nsITaskbarProgress" | "nsITaskbarTabPreview" | "nsITaskbarWindowPreview" | "nsIFetchTelemetryDataCallback" | "nsITelemetry" | "nsITellableStream" | "nsITextInputProcessor" | "nsITextInputProcessorNotification" | "nsITextInputProcessorCallback" | "nsITextToSubURI" | "nsIThread" | "nsIThreadInternal" | "nsIThreadObserver" | "nsINestedEventLoopCondition" | "nsIThreadManager" | "nsIThreadPoolListener" | "nsIThreadPool" | "nsIThreadRetargetableRequest" | "nsIThreadRetargetableStreamListener" | "nsIThreadShutdown" | "nsIInputChannelThrottleQueue" | "nsIThrottledInputChannel" | "nsIServerTiming" | "nsITimedChannel" | "nsITimerCallback" | "nsITimer" | "nsITimerManager" | "nsITlsHandshakeCallbackListener" | "nsITokenDialogs" | "nsITokenPasswordDialogs" | "nsIToolkitChromeRegistry" | "nsIProfileLock" | "nsIToolkitProfile" | "nsIToolkitProfileService" | "nsIToolkitShellService" | "nsITooltipListener" | "nsITooltipTextProvider" | "nsITouchBarHelper" | "nsITouchBarInputCallback" | "nsITouchBarInput" | "nsITouchBarUpdater" | "nsITraceableChannel" | "nsITrackingDBService" | "nsITransaction" | "nsITransactionManager" | "nsITransfer" | "nsIFlavorDataProvider" | "nsITransferable" | "nsITransport" | "nsITransportEventSink" | "nsITransportProvider" | "nsITransportSecurityInfo" | "nsITreeSelection" | "nsINativeTreeSelection" | "nsITreeView" | "nsITypeAheadFind" | "nsIU2FTokenManager" | "nsIUDPSocket" | "nsIUDPSocketListener" | "nsIUDPMessage" | "nsIUDPSocketSyncListener" | "nsIUDPSocketInternal" | "nsIURI" | "nsIURIClassifierCallback" | "nsIURIClassifier" | "nsIURIContentListener" | "nsIURIFixupInfo" | "nsIURIFixup" | "nsIURILoader" | "nsIURISetSpec" | "nsIURISetters" | "nsIURIMutator" | "nsIURIWithSpecialOrigin" | "nsIURL" | "nsIURLMutator" | "nsIURLDecorationAnnotationsService" | "nsIURLFormatter" | "nsIURLParser" | "nsIURLQueryStringStripper" | "nsIURLQueryStrippingListObserver" | "nsIURLQueryStrippingListService" | "nsIUUIDGenerator" | "nsIUnicharInputStream" | "nsIUnicharLineInputStream" | "nsIUnicharOutputStream" | "nsIUpdatePatch" | "nsIUpdate" | "nsIUpdateCheckResult" | "nsIUpdateCheck" | "nsIUpdateChecker" | "nsIApplicationUpdateService" | "nsIUpdateProcessor" | "nsIUpdateSyncManager" | "nsIUpdateManager" | "nsIUpdateTimerManager" | "nsIUploadChannel" | "nsIUploadChannel2" | "nsIUrlClassifierCallback" | "nsIUrlClassifierUpdateObserver" | "nsIUrlClassifierDBService" | "nsIUrlClassifierLookupCallback" | "nsIUrlClassifierClassifyCallback" | "nsIUrlClassifierExceptionListObserver" | "nsIUrlClassifierExceptionListService" | "nsIUrlClassifierFeature" | "nsIUrlClassifierFeatureResult" | "nsIUrlClassifierFeatureCallback" | "nsIFullHashMatch" | "nsIUrlClassifierHashCompleterCallback" | "nsIUrlClassifierHashCompleter" | "nsIUrlClassifierPositiveCacheEntry" | "nsIUrlClassifierCacheEntry" | "nsIUrlClassifierCacheInfo" | "nsIUrlClassifierGetCacheCallback" | "nsIUrlClassifierInfo" | "nsIUrlClassifierPrefixSet" | "nsIUrlClassifierRemoteSettingsService" | "nsIUrlClassifierStreamUpdater" | "nsIUrlClassifierParseFindFullHashCallback" | "nsIUrlClassifierUtils" | "nsIUrlListManager" | "nsIUserIdleService" | "nsIUserIdleServiceInternal" | "nsIUtilityProcessTest" | "nsIVariant" | "nsIWritableVariant" | "nsIVersionComparator" | "nsIViewSourceChannel" | "nsIWakeLock" | "nsIWeakReference" | "nsISupportsWeakReference" | "nsICtapRegisterArgs" | "nsICtapSignArgs" | "nsICtapRegisterResult" | "nsIWebAuthnAttObj" | "nsICtapSignResult" | "nsIWebAuthnController" | "nsICredentialParameters" | "nsIWebAuthnTransport" | "nsIWebBrowser" | "nsIWebBrowserChrome" | "nsIWebBrowserChromeFocus" | "nsIWebBrowserFind" | "nsIWebBrowserFindInFrames" | "nsIWebBrowserPersist" | "nsIWebBrowserPersistURIMap" | "nsIWebBrowserPersistDocument" | "nsIWebBrowserPersistResourceVisitor" | "nsIWebBrowserPersistWriteCompletion" | "nsIWebBrowserPersistDocumentReceiver" | "nsIWebBrowserPrint" | "nsIWebNavigation" | "nsIWebNavigationInfo" | "nsIWebPageDescriptor" | "nsIWebProgress" | "nsIWebProgressListener" | "nsIWebProgressListener2" | "nsIWebProtocolHandlerRegistrar" | "nsIWebSocketChannel" | "nsIWebSocketFrame" | "nsIWebSocketEventListener" | "nsIWebSocketEventService" | "nsIWebSocketImpl" | "nsIWebSocketListener" | "nsIWebTransport" | "WebTransportSessionEventListener" | "nsIWebTransportStreamCallback" | "nsIWebTransportSendStreamStats" | "nsIWebTransportReceiveStreamStats" | "nsIWebTransportStreamStatsCallback" | "nsIWebTransportReceiveStream" | "nsIWebTransportSendStream" | "nsIWebTransportBidirectionalStream" | "nsIWebVTTListener" | "nsIWebVTTParserWrapper" | "nsIWellKnownOpportunisticUtils" | "nsIWifiAccessPoint" | "nsIWifiListener" | "nsIWifiMonitor" | "nsIWinAppHelper" | "nsIWinTaskSchedulerService" | "nsIWinTaskbar" | "nsIWindowCreator" | "nsIWindowMediator" | "nsIWindowMediatorListener" | "nsIWindowProvider" | "nsIWindowWatcher" | "nsIWindowlessBrowser" | "nsIWindowsAlertsService" | "nsIWindowsPackageManager" | "nsIWindowsRegKey" | "nsIWindowsShellService" | "nsIWindowsUIUtils" | "nsIWorkerChannelLoadInfo" | "nsIWorkerChannelInfo" | "nsIWorkerDebuggerListener" | "nsIWorkerDebugger" | "nsIWorkerDebuggerManagerListener" | "nsIWorkerDebuggerManager" | "nsIWritablePropertyBag" | "nsIWritablePropertyBag2" | "nsIX509Cert" | "nsIOpenSignedAppFileCallback" | "nsIAsyncBoolCallback" | "nsICertVerificationCallback" | "nsIX509CertDB" | "nsIX509CertValidity" | "nsIXPCScriptable" | "nsIXREDirProvider" | "nsIXULAppInfo" | "nsIXULBrowserWindow" | "nsIXULRuntime" | "nsIXULStore" | "nsIZipEntry" | "nsIZipReader" | "nsIZipReaderCache" | "nsIZipWriter" | "nsPIDNSService" | "nsPIPromptService" | "nsPISocketTransportService" | "nsPIWidgetCocoa" | "nsPIWindowWatcher" | "txIEXSLTFunctions" | "xpcIJSWeakReference" | "nsIXPCComponents_Interfaces" | "nsIXPCComponents_Classes" | "nsIXPCComponents_Results" | "nsIXPCComponents_ID" | "nsIXPCComponents_Exception" | "nsIXPCComponents_Constructor" | "nsIXPCComponents_utils_Sandbox" | "nsIScheduledGCCallback" | "nsIXPCComponents_Utils" | "nsIXPCComponents" | "nsIXPCTestObjectReadOnly" | "nsIXPCTestObjectReadWrite" | "nsIXPCTestBug809674" | "nsIXPCTestCEnums" | "nsIXPCTestESMReturnCodeParent" | "nsIXPCTestESMReturnCodeChild" | "nsIXPCTestInterfaceA" | "nsIXPCTestInterfaceB" | "nsIXPCTestInterfaceC" | "nsIXPCTestParams" | "nsIXPCTestReturnCodeParent" | "nsIXPCTestReturnCodeChild" | "nsIXPCTestFunctionInterface" | "nsIXPCTestUtils";
interface CiMap {
    IJSDebugger: IJSDebuggerType;
    IPeerConnectionObserver: IPeerConnectionObserverType;
    IPeerConnection: IPeerConnectionType;
    IUrlClassifierUITelemetry: IUrlClassifierUITelemetryType;
    nsIScriptableOK: nsIScriptableOKType;
    nsIScriptableWithNotXPCOM: nsIScriptableWithNotXPCOMType;
    nsISessionStoreFunctions: nsISessionStoreFunctionsType;
    amIAddonManagerStartup: amIAddonManagerStartupType;
    amIWebInstallPrompt: amIWebInstallPromptType;
    extIWebNavigation: extIWebNavigationType;
    imgICache: imgICacheType;
    imgIContainer: imgIContainerType;
    imgIContainerDebug: imgIContainerDebugType;
    imgIEncoder: imgIEncoderType;
    imgILoader: imgILoaderType;
    imgINotificationObserver: imgINotificationObserverType;
    imgIRequest: imgIRequestType;
    imgIScriptedNotificationObserver: imgIScriptedNotificationObserverType;
    imgITools: imgIToolsType;
    imgIContainerCallback: imgIContainerCallbackType;
    inIDeepTreeWalker: inIDeepTreeWalkerType;
    mozIAppServicesLogger: mozIAppServicesLoggerType;
    mozIVisitInfo: mozIVisitInfoType;
    mozIPlaceInfo: mozIPlaceInfoType;
    mozIVisitInfoCallback: mozIVisitInfoCallbackType;
    mozIVisitedStatusCallback: mozIVisitedStatusCallbackType;
    mozIAsyncHistory: mozIAsyncHistoryType;
    mozIBridgedSyncEngineCallback: mozIBridgedSyncEngineCallbackType;
    mozIBridgedSyncEngineApplyCallback: mozIBridgedSyncEngineApplyCallbackType;
    mozIBridgedSyncEngine: mozIBridgedSyncEngineType;
    mozIDOMWindow: mozIDOMWindowType;
    mozIDOMWindowProxy: mozIDOMWindowProxyType;
    mozIDownloadPlatform: mozIDownloadPlatformType;
    mozIExtensionServiceWorkerInfo: mozIExtensionServiceWorkerInfoType;
    mozIExtensionListenerCallOptions: mozIExtensionListenerCallOptionsType;
    mozIExtensionEventListener: mozIExtensionEventListenerType;
    mozIExtensionAPIRequest: mozIExtensionAPIRequestType;
    mozIExtensionAPIRequestResult: mozIExtensionAPIRequestResultType;
    mozIExtensionAPIRequestHandler: mozIExtensionAPIRequestHandlerType;
    mozIExtensionProcessScript: mozIExtensionProcessScriptType;
    mozIExtensionStorageArea: mozIExtensionStorageAreaType;
    mozIConfigurableExtensionStorageArea: mozIConfigurableExtensionStorageAreaType;
    mozISyncedExtensionStorageArea: mozISyncedExtensionStorageAreaType;
    mozIExtensionStorageListener: mozIExtensionStorageListenerType;
    mozIExtensionStorageCallback: mozIExtensionStorageCallbackType;
    mozIGeckoMediaPluginChromeService: mozIGeckoMediaPluginChromeServiceType;
    mozIGeckoMediaPluginService: mozIGeckoMediaPluginServiceType;
    mozIInterruptible: mozIInterruptibleType;
    mozIJSSubScriptLoader: mozIJSSubScriptLoaderType;
    mozILocaleService: mozILocaleServiceType;
    mozIMozIntl: mozIMozIntlType;
    mozIMozIntlHelper: mozIMozIntlHelperType;
    mozIOSPreferences: mozIOSPreferencesType;
    mozIPersonalDictionary: mozIPersonalDictionaryType;
    mozIPlacesAutoComplete: mozIPlacesAutoCompleteType;
    mozIPlacesPendingOperation: mozIPlacesPendingOperationType;
    mozIRemoteLazyInputStream: mozIRemoteLazyInputStreamType;
    mozISandboxReport: mozISandboxReportType;
    mozISandboxReportArray: mozISandboxReportArrayType;
    mozISandboxReporter: mozISandboxReporterType;
    mozISandboxSettings: mozISandboxSettingsType;
    mozISandboxTest: mozISandboxTestType;
    mozIServicesLogSink: mozIServicesLogSinkType;
    mozISpellCheckingEngine: mozISpellCheckingEngineType;
    mozIStorageAsyncConnection: mozIStorageAsyncConnectionType;
    mozIStorageAsyncStatement: mozIStorageAsyncStatementType;
    mozIStorageBaseStatement: mozIStorageBaseStatementType;
    mozIStorageBindingParams: mozIStorageBindingParamsType;
    mozIStorageBindingParamsArray: mozIStorageBindingParamsArrayType;
    mozIStorageCompletionCallback: mozIStorageCompletionCallbackType;
    mozIStorageConnection: mozIStorageConnectionType;
    mozIStorageError: mozIStorageErrorType;
    mozIStorageFunction: mozIStorageFunctionType;
    mozIStoragePendingStatement: mozIStoragePendingStatementType;
    mozIStorageProgressHandler: mozIStorageProgressHandlerType;
    mozIStorageResultSet: mozIStorageResultSetType;
    mozIStorageRow: mozIStorageRowType;
    mozIStorageService: mozIStorageServiceType;
    mozIStorageStatement: mozIStorageStatementType;
    mozIStorageStatementCallback: mozIStorageStatementCallbackType;
    mozIStorageVacuumParticipant: mozIStorageVacuumParticipantType;
    mozIStorageValueArray: mozIStorageValueArrayType;
    mozISyncedBookmarksMirrorProgressListener: mozISyncedBookmarksMirrorProgressListenerType;
    mozISyncedBookmarksMirrorCallback: mozISyncedBookmarksMirrorCallbackType;
    mozISyncedBookmarksMirrorLogger: mozISyncedBookmarksMirrorLoggerType;
    mozISyncedBookmarksMerger: mozISyncedBookmarksMergerType;
    mozITXTToHTMLConv: mozITXTToHTMLConvType;
    mozITestInterfaceJS: mozITestInterfaceJSType;
    mozIThirdPartyUtil: mozIThirdPartyUtilType;
    nsIASN1Tree: nsIASN1TreeType;
    nsIAboutModule: nsIAboutModuleType;
    nsIAboutNewTabService: nsIAboutNewTabServiceType;
    nsIInstalledApplication: nsIInstalledApplicationType;
    nsIAboutThirdParty: nsIAboutThirdPartyType;
    nsIAddonPolicyService: nsIAddonPolicyServiceType;
    nsIAddonContentPolicy: nsIAddonContentPolicyType;
    nsIAlertNotificationImageListener: nsIAlertNotificationImageListenerType;
    nsIAlertAction: nsIAlertActionType;
    nsIAlertNotification: nsIAlertNotificationType;
    nsIAlertsService: nsIAlertsServiceType;
    nsIAlertsDoNotDisturb: nsIAlertsDoNotDisturbType;
    nsIAlertsIconData: nsIAlertsIconDataType;
    nsIAlertsIconURI: nsIAlertsIconURIType;
    nsIAndroidEventCallback: nsIAndroidEventCallbackType;
    nsIAndroidEventFinalizer: nsIAndroidEventFinalizerType;
    nsIAndroidEventListener: nsIAndroidEventListenerType;
    nsIAndroidEventDispatcher: nsIAndroidEventDispatcherType;
    nsIAndroidView: nsIAndroidViewType;
    nsIAndroidBridge: nsIAndroidBridgeType;
    nsIAppShell: nsIAppShellType;
    nsIAppShellService: nsIAppShellServiceType;
    nsIAppStartup: nsIAppStartupType;
    nsIAppWindow: nsIAppWindowType;
    nsIApplicationChooserFinishedCallback: nsIApplicationChooserFinishedCallbackType;
    nsIApplicationChooser: nsIApplicationChooserType;
    nsIApplicationReputationService: nsIApplicationReputationServiceType;
    nsIApplicationReputationQuery: nsIApplicationReputationQueryType;
    nsIApplicationReputationCallback: nsIApplicationReputationCallbackType;
    nsIArray: nsIArrayType;
    nsIArrayBufferInputStream: nsIArrayBufferInputStreamType;
    nsIArrayExtensions: nsIArrayExtensionsType;
    nsIAsyncInputStream: nsIAsyncInputStreamType;
    nsIInputStreamCallback: nsIInputStreamCallbackType;
    nsIAsyncOutputStream: nsIAsyncOutputStreamType;
    nsIOutputStreamCallback: nsIOutputStreamCallbackType;
    nsIAsyncShutdownBlocker: nsIAsyncShutdownBlockerType;
    nsIAsyncShutdownClient: nsIAsyncShutdownClientType;
    nsIAsyncShutdownCompletionCallback: nsIAsyncShutdownCompletionCallbackType;
    nsIAsyncShutdownBarrier: nsIAsyncShutdownBarrierType;
    nsIAsyncShutdownService: nsIAsyncShutdownServiceType;
    nsIAsyncStreamCopier: nsIAsyncStreamCopierType;
    nsIAsyncStreamCopier2: nsIAsyncStreamCopier2Type;
    nsIAsyncVerifyRedirectCallback: nsIAsyncVerifyRedirectCallbackType;
    nsISuspendedTypes: nsISuspendedTypesType;
    nsIAudioChannelAgentCallback: nsIAudioChannelAgentCallbackType;
    nsIAudioChannelAgent: nsIAudioChannelAgentType;
    nsIAudioDeviceInfo: nsIAudioDeviceInfoType;
    nsIAuthInformation: nsIAuthInformationType;
    nsIAuthModule: nsIAuthModuleType;
    nsIAuthPrompt: nsIAuthPromptType;
    nsIAuthPrompt2: nsIAuthPrompt2Type;
    nsIAuthPromptAdapterFactory: nsIAuthPromptAdapterFactoryType;
    nsIAuthPromptCallback: nsIAuthPromptCallbackType;
    nsIAuthPromptProvider: nsIAuthPromptProviderType;
    nsIAutoCompleteController: nsIAutoCompleteControllerType;
    nsIAutoCompleteInput: nsIAutoCompleteInputType;
    nsIAutoCompletePopup: nsIAutoCompletePopupType;
    nsIAutoCompleteResult: nsIAutoCompleteResultType;
    nsIAutoCompleteSearch: nsIAutoCompleteSearchType;
    nsIAutoCompleteObserver: nsIAutoCompleteObserverType;
    nsIAutoCompleteSearchDescriptor: nsIAutoCompleteSearchDescriptorType;
    nsIAutoCompleteSimpleResult: nsIAutoCompleteSimpleResultType;
    nsIAutoCompleteSimpleResultListener: nsIAutoCompleteSimpleResultListenerType;
    nsIAutoCompleteSimpleSearch: nsIAutoCompleteSimpleSearchType;
    nsIAutoplay: nsIAutoplayType;
    nsITabUnloader: nsITabUnloaderType;
    nsIAvailableMemoryWatcherBase: nsIAvailableMemoryWatcherBaseType;
    nsIBFCacheEntry: nsIBFCacheEntryType;
    nsIBackgroundChannelRegistrar: nsIBackgroundChannelRegistrarType;
    nsIBackgroundFileSaver: nsIBackgroundFileSaverType;
    nsIBackgroundFileSaverObserver: nsIBackgroundFileSaverObserverType;
    nsIBackgroundTasks: nsIBackgroundTasksType;
    nsIBackgroundTasksManager: nsIBackgroundTasksManagerType;
    nsIBackgroundTasksRunner: nsIBackgroundTasksRunnerType;
    nsIBaseWindow: nsIBaseWindowType;
    nsIBidiKeyboard: nsIBidiKeyboardType;
    nsIBinaryHttpRequest: nsIBinaryHttpRequestType;
    nsIBinaryHttpResponse: nsIBinaryHttpResponseType;
    nsIBinaryHttp: nsIBinaryHttpType;
    nsIBinaryInputStream: nsIBinaryInputStreamType;
    nsIBinaryOutputStream: nsIBinaryOutputStreamType;
    nsIBits: nsIBitsType;
    nsIBitsNewRequestCallback: nsIBitsNewRequestCallbackType;
    nsIBitsRequest: nsIBitsRequestType;
    nsIBitsCallback: nsIBitsCallbackType;
    nsIBlocklistService: nsIBlocklistServiceType;
    nsIBounceTrackingProtection: nsIBounceTrackingProtectionType;
    nsIBrowser: nsIBrowserType;
    nsIBrowserChild: nsIBrowserChildType;
    nsIBrowserController: nsIBrowserControllerType;
    nsIOpenURIInFrameParams: nsIOpenURIInFrameParamsType;
    nsIBrowserDOMWindow: nsIBrowserDOMWindowType;
    nsIBrowserElementAPI: nsIBrowserElementAPIType;
    nsIBrowserHandler: nsIBrowserHandlerType;
    nsIBrowserUsage: nsIBrowserUsageType;
    nsIVisibleTab: nsIVisibleTabType;
    nsIBrowserWindowTracker: nsIBrowserWindowTrackerType;
    nsIBufferedInputStream: nsIBufferedInputStreamType;
    nsIBufferedOutputStream: nsIBufferedOutputStreamType;
    nsIByteRangeRequest: nsIByteRangeRequestType;
    nsICacheEntry: nsICacheEntryType;
    nsICacheEntryMetaDataVisitor: nsICacheEntryMetaDataVisitorType;
    nsICacheEntryDoomCallback: nsICacheEntryDoomCallbackType;
    nsICacheEntryOpenCallback: nsICacheEntryOpenCallbackType;
    nsIInputStreamReceiver: nsIInputStreamReceiverType;
    nsICacheInfoChannel: nsICacheInfoChannelType;
    nsICachePurgeLock: nsICachePurgeLockType;
    nsICacheStorage: nsICacheStorageType;
    nsICacheStorageService: nsICacheStorageServiceType;
    nsICacheStorageConsumptionObserver: nsICacheStorageConsumptionObserverType;
    nsICacheStorageVisitor: nsICacheStorageVisitorType;
    nsICacheTesting: nsICacheTestingType;
    nsICachingChannel: nsICachingChannelType;
    nsICancelable: nsICancelableType;
    nsICaptivePortalCallback: nsICaptivePortalCallbackType;
    nsICaptivePortalDetector: nsICaptivePortalDetectorType;
    nsICaptivePortalServiceCallback: nsICaptivePortalServiceCallbackType;
    nsICaptivePortalService: nsICaptivePortalServiceType;
    nsICascadeFilter: nsICascadeFilterType;
    nsICategoryEntry: nsICategoryEntryType;
    nsICategoryManager: nsICategoryManagerType;
    nsICertOverride: nsICertOverrideType;
    nsICertOverrideService: nsICertOverrideServiceType;
    nsICertStorageCallback: nsICertStorageCallbackType;
    nsIRevocationState: nsIRevocationStateType;
    nsIIssuerAndSerialRevocationState: nsIIssuerAndSerialRevocationStateType;
    nsISubjectAndPubKeyRevocationState: nsISubjectAndPubKeyRevocationStateType;
    nsICRLiteCoverage: nsICRLiteCoverageType;
    nsICRLiteTimestamp: nsICRLiteTimestampType;
    nsICertInfo: nsICertInfoType;
    nsICertStorage: nsICertStorageType;
    nsICertTreeItem: nsICertTreeItemType;
    nsICertTree: nsICertTreeType;
    nsICertificateDialogs: nsICertificateDialogsType;
    nsIChannel: nsIChannelType;
    nsIIdentChannel: nsIIdentChannelType;
    nsIUrlClassifierBlockedChannel: nsIUrlClassifierBlockedChannelType;
    nsIChannelClassifierService: nsIChannelClassifierServiceType;
    nsIChannelEventSink: nsIChannelEventSinkType;
    nsIChildChannel: nsIChildChannelType;
    nsIChromeRegistry: nsIChromeRegistryType;
    nsIXULChromeRegistry: nsIXULChromeRegistryType;
    nsIClassInfo: nsIClassInfoType;
    nsIClassOfService: nsIClassOfServiceType;
    nsIClassifiedChannel: nsIClassifiedChannelType;
    nsIClearDataService: nsIClearDataServiceType;
    nsIClearDataCallback: nsIClearDataCallbackType;
    nsIClickRule: nsIClickRuleType;
    nsIClientAuthDialogCallback: nsIClientAuthDialogCallbackType;
    nsIClientAuthDialogService: nsIClientAuthDialogServiceType;
    nsIClientAuthDialogs: nsIClientAuthDialogsType;
    nsIClientAuthRememberRecord: nsIClientAuthRememberRecordType;
    nsIClientAuthRememberService: nsIClientAuthRememberServiceType;
    nsIAsyncSetClipboardData: nsIAsyncSetClipboardDataType;
    nsIAsyncSetClipboardDataCallback: nsIAsyncSetClipboardDataCallbackType;
    nsIClipboard: nsIClipboardType;
    nsIClipboardHelper: nsIClipboardHelperType;
    nsIClipboardOwner: nsIClipboardOwnerType;
    nsICloneableInputStream: nsICloneableInputStreamType;
    nsICloneableInputStreamWithRange: nsICloneableInputStreamWithRangeType;
    nsICodeCoverage: nsICodeCoverageType;
    nsIColorPickerShownCallback: nsIColorPickerShownCallbackType;
    nsIColorPicker: nsIColorPickerType;
    nsICommandLine: nsICommandLineType;
    nsICommandLineHandler: nsICommandLineHandlerType;
    nsICommandLineRunner: nsICommandLineRunnerType;
    nsICommandLineValidator: nsICommandLineValidatorType;
    nsICommandManager: nsICommandManagerType;
    nsICommandParams: nsICommandParamsType;
    nsIComponentManager: nsIComponentManagerType;
    nsIComponentRegistrar: nsIComponentRegistrarType;
    nsICompressConvStats: nsICompressConvStatsType;
    nsIConsoleAPIStorage: nsIConsoleAPIStorageType;
    nsIConsoleListener: nsIConsoleListenerType;
    nsIConsoleMessage: nsIConsoleMessageType;
    nsIConsoleService: nsIConsoleServiceType;
    nsIContentBlockingAllowList: nsIContentBlockingAllowListType;
    nsIContentDispatchChooser: nsIContentDispatchChooserType;
    nsIContentHandler: nsIContentHandlerType;
    nsIContentPermissionType: nsIContentPermissionTypeType;
    nsIContentPermissionRequest: nsIContentPermissionRequestType;
    nsIContentPermissionPrompt: nsIContentPermissionPromptType;
    nsIContentPolicy: nsIContentPolicyType;
    nsIContentPrefObserver: nsIContentPrefObserverType;
    nsIContentPrefService2: nsIContentPrefService2Type;
    nsIContentPrefCallback2: nsIContentPrefCallback2Type;
    nsIContentPref: nsIContentPrefType;
    nsIContentProcessInfo: nsIContentProcessInfoType;
    nsIContentProcessProvider: nsIContentProcessProviderType;
    nsIContentSecurityManager: nsIContentSecurityManagerType;
    nsIContentSecurityPolicy: nsIContentSecurityPolicyType;
    nsICSPEventListener: nsICSPEventListenerType;
    nsIContentSignatureVerifier: nsIContentSignatureVerifierType;
    nsIContentSniffer: nsIContentSnifferType;
    nsIContentViewer: nsIContentViewerType;
    nsIContentViewerEdit: nsIContentViewerEditType;
    nsIController: nsIControllerType;
    nsICommandController: nsICommandControllerType;
    nsIControllerCommand: nsIControllerCommandType;
    nsIControllerCommandTable: nsIControllerCommandTableType;
    nsIControllerContext: nsIControllerContextType;
    nsIControllers: nsIControllersType;
    nsIConverterInputStream: nsIConverterInputStreamType;
    nsIConverterOutputStream: nsIConverterOutputStreamType;
    nsICookie: nsICookieType;
    nsICookieBannerListService: nsICookieBannerListServiceType;
    nsICookieBannerRule: nsICookieBannerRuleType;
    nsICookieBannerService: nsICookieBannerServiceType;
    nsICookieJarSettings: nsICookieJarSettingsType;
    nsICookieManager: nsICookieManagerType;
    nsICookieNotification: nsICookieNotificationType;
    nsICookiePermission: nsICookiePermissionType;
    nsICookieRule: nsICookieRuleType;
    nsICookieTransactionCallback: nsICookieTransactionCallbackType;
    nsICookieService: nsICookieServiceType;
    nsICrashReporter: nsICrashReporterType;
    nsICrashService: nsICrashServiceType;
    nsICryptoHash: nsICryptoHashType;
    nsICycleCollectorHandler: nsICycleCollectorHandlerType;
    nsICycleCollectorLogSink: nsICycleCollectorLogSinkType;
    nsICycleCollectorListener: nsICycleCollectorListenerType;
    nsIDAPTelemetry: nsIDAPTelemetryType;
    nsIDHCPClient: nsIDHCPClientType;
    nsIDNSAdditionalInfo: nsIDNSAdditionalInfoType;
    nsIDNSByTypeRecord: nsIDNSByTypeRecordType;
    nsIDNSTXTRecord: nsIDNSTXTRecordType;
    nsISVCParam: nsISVCParamType;
    nsISVCParamAlpn: nsISVCParamAlpnType;
    nsISVCParamNoDefaultAlpn: nsISVCParamNoDefaultAlpnType;
    nsISVCParamPort: nsISVCParamPortType;
    nsISVCParamIPv4Hint: nsISVCParamIPv4HintType;
    nsISVCParamEchConfig: nsISVCParamEchConfigType;
    nsISVCParamIPv6Hint: nsISVCParamIPv6HintType;
    nsISVCParamODoHConfig: nsISVCParamODoHConfigType;
    nsISVCBRecord: nsISVCBRecordType;
    nsIDNSHTTPSSVCRecord: nsIDNSHTTPSSVCRecordType;
    nsIDNSListener: nsIDNSListenerType;
    nsIDNSRecord: nsIDNSRecordType;
    nsIDNSAddrRecord: nsIDNSAddrRecordType;
    nsIDNSService: nsIDNSServiceType;
    nsIDOMChromeWindow: nsIDOMChromeWindowType;
    nsIDOMEventListener: nsIDOMEventListenerType;
    nsIDOMGeoPosition: nsIDOMGeoPositionType;
    nsIDOMGeoPositionCallback: nsIDOMGeoPositionCallbackType;
    nsIDOMGeoPositionCoords: nsIDOMGeoPositionCoordsType;
    nsIDOMGeoPositionErrorCallback: nsIDOMGeoPositionErrorCallbackType;
    nsIDOMGlobalPropertyInitializer: nsIDOMGlobalPropertyInitializerType;
    nsIDOMMozBrowserFrame: nsIDOMMozBrowserFrameType;
    nsIDOMProcessChild: nsIDOMProcessChildType;
    nsIDOMProcessParent: nsIDOMProcessParentType;
    nsIDOMRequestService: nsIDOMRequestServiceType;
    nsIDOMStorageManager: nsIDOMStorageManagerType;
    nsIDOMSessionStorageManager: nsIDOMSessionStorageManagerType;
    nsIDOMMozWakeLockListener: nsIDOMMozWakeLockListenerType;
    nsIDOMWindow: nsIDOMWindowType;
    nsIDOMWindowUtils: nsIDOMWindowUtilsType;
    nsITranslationNodeList: nsITranslationNodeListType;
    nsIJSRAIIHelper: nsIJSRAIIHelperType;
    nsIDOMXULButtonElement: nsIDOMXULButtonElementType;
    nsIDOMXULCommandDispatcher: nsIDOMXULCommandDispatcherType;
    nsIDOMXULContainerItemElement: nsIDOMXULContainerItemElementType;
    nsIDOMXULContainerElement: nsIDOMXULContainerElementType;
    nsIDOMXULControlElement: nsIDOMXULControlElementType;
    nsIDOMXULMenuListElement: nsIDOMXULMenuListElementType;
    nsIDOMXULMultiSelectControlElement: nsIDOMXULMultiSelectControlElementType;
    nsIDOMXULRadioGroupElement: nsIDOMXULRadioGroupElementType;
    nsIDOMXULRelatedElement: nsIDOMXULRelatedElementType;
    nsIDOMXULSelectControlElement: nsIDOMXULSelectControlElementType;
    nsIDOMXULSelectControlItemElement: nsIDOMXULSelectControlItemElementType;
    nsINetDashboardCallback: nsINetDashboardCallbackType;
    nsIDashboard: nsIDashboardType;
    nsIDashboardEventNotifier: nsIDashboardEventNotifierType;
    nsIDataStorageManager: nsIDataStorageManagerType;
    nsIDataStorage: nsIDataStorageType;
    nsIDataStorageItem: nsIDataStorageItemType;
    nsIDebug2: nsIDebug2Type;
    nsIDeviceSensorData: nsIDeviceSensorDataType;
    nsIDeviceSensors: nsIDeviceSensorsType;
    nsIDialogParamBlock: nsIDialogParamBlockType;
    nsIDirIndex: nsIDirIndexType;
    nsIDirIndexListener: nsIDirIndexListenerType;
    nsIDirIndexParser: nsIDirIndexParserType;
    nsIDirectTaskDispatcher: nsIDirectTaskDispatcherType;
    nsIDirectoryEnumerator: nsIDirectoryEnumeratorType;
    nsIDirectoryServiceProvider: nsIDirectoryServiceProviderType;
    nsIDirectoryServiceProvider2: nsIDirectoryServiceProvider2Type;
    nsIDirectoryService: nsIDirectoryServiceType;
    nsIDisplayInfo: nsIDisplayInfoType;
    nsIDocShell: nsIDocShellType;
    nsIDocShellTreeItem: nsIDocShellTreeItemType;
    nsIDocShellTreeOwner: nsIDocShellTreeOwnerType;
    nsIDocumentEncoderNodeFixup: nsIDocumentEncoderNodeFixupType;
    nsIDocumentEncoder: nsIDocumentEncoderType;
    nsIDocumentLoader: nsIDocumentLoaderType;
    nsIDocumentLoaderFactory: nsIDocumentLoaderFactoryType;
    nsIDocumentStateListener: nsIDocumentStateListenerType;
    nsIDomainPolicy: nsIDomainPolicyType;
    nsIDomainSet: nsIDomainSetType;
    nsIDownloader: nsIDownloaderType;
    nsIDownloadObserver: nsIDownloadObserverType;
    nsIDragService: nsIDragServiceType;
    nsIDragSession: nsIDragSessionType;
    nsIDroppedLinkItem: nsIDroppedLinkItemType;
    nsIDroppedLinkHandler: nsIDroppedLinkHandlerType;
    nsIE10SUtils: nsIE10SUtilsType;
    nsIEarlyHintObserver: nsIEarlyHintObserverType;
    nsIEdgeMigrationUtils: nsIEdgeMigrationUtilsType;
    nsIEditActionListener: nsIEditActionListenerType;
    nsIEditingSession: nsIEditingSessionType;
    nsIEditor: nsIEditorType;
    nsIEditorMailSupport: nsIEditorMailSupportType;
    nsIEditorSpellCheck: nsIEditorSpellCheckType;
    nsIEditorSpellCheckCallback: nsIEditorSpellCheckCallbackType;
    nsIEffectiveTLDService: nsIEffectiveTLDServiceType;
    nsIEmbeddingSiteWindow: nsIEmbeddingSiteWindowType;
    nsISupports: nsISupportsType;
    nsIEncodedChannel: nsIEncodedChannelType;
    nsIEnterprisePolicies: nsIEnterprisePoliciesType;
    nsIEnvironment: nsIEnvironmentType;
    nsIEventListenerChange: nsIEventListenerChangeType;
    nsIListenerChangeListener: nsIListenerChangeListenerType;
    nsIEventListenerInfo: nsIEventListenerInfoType;
    nsIEventListenerService: nsIEventListenerServiceType;
    nsIEventSourceEventListener: nsIEventSourceEventListenerType;
    nsIEventSourceEventService: nsIEventSourceEventServiceType;
    nsIEventTarget: nsIEventTargetType;
    nsIStackFrame: nsIStackFrameType;
    nsIException: nsIExceptionType;
    nsIExpatSink: nsIExpatSinkType;
    nsIExternalHelperAppService: nsIExternalHelperAppServiceType;
    nsPIExternalAppLauncher: nsPIExternalAppLauncherType;
    nsIHelperAppLauncher: nsIHelperAppLauncherType;
    nsIExternalProtocolHandler: nsIExternalProtocolHandlerType;
    nsIExternalProtocolService: nsIExternalProtocolServiceType;
    nsIFOG: nsIFOGType;
    nsIFactory: nsIFactoryType;
    nsIFaviconService: nsIFaviconServiceType;
    nsIFaviconDataCallback: nsIFaviconDataCallbackType;
    nsIFile: nsIFileType;
    nsIFileChannel: nsIFileChannelType;
    nsIFilePicker: nsIFilePickerType;
    nsIFilePickerShownCallback: nsIFilePickerShownCallbackType;
    nsIFileProtocolHandler: nsIFileProtocolHandlerType;
    nsIFileInputStream: nsIFileInputStreamType;
    nsIFileOutputStream: nsIFileOutputStreamType;
    nsIFileRandomAccessStream: nsIFileRandomAccessStreamType;
    nsIFileMetadata: nsIFileMetadataType;
    nsIAsyncFileMetadata: nsIAsyncFileMetadataType;
    nsIFileMetadataCallback: nsIFileMetadataCallbackType;
    nsIFileURL: nsIFileURLType;
    nsIFileURLMutator: nsIFileURLMutatorType;
    nsIFinalizationWitnessService: nsIFinalizationWitnessServiceType;
    nsIFind: nsIFindType;
    nsIFindService: nsIFindServiceType;
    nsIFocusManager: nsIFocusManagerType;
    nsIFontEnumerator: nsIFontEnumeratorType;
    nsIFontLoadCompleteCallback: nsIFontLoadCompleteCallbackType;
    nsIForcePendingChannel: nsIForcePendingChannelType;
    nsIFormAutoComplete: nsIFormAutoCompleteType;
    nsIFormAutoCompleteObserver: nsIFormAutoCompleteObserverType;
    nsIFormFillController: nsIFormFillControllerType;
    nsIFormPOSTActionChannel: nsIFormPOSTActionChannelType;
    nsIFormatConverter: nsIFormatConverterType;
    nsIGIOMimeApp: nsIGIOMimeAppType;
    nsIGIOService: nsIGIOServiceType;
    nsIGNOMEShellService: nsIGNOMEShellServiceType;
    nsIGSettingsCollection: nsIGSettingsCollectionType;
    nsIGSettingsService: nsIGSettingsServiceType;
    nsIGeolocationUpdate: nsIGeolocationUpdateType;
    nsIGeolocationProvider: nsIGeolocationProviderType;
    nsIGfxInfo: nsIGfxInfoType;
    nsIGfxInfoDebug: nsIGfxInfoDebugType;
    nsIGleanBoolean: nsIGleanBooleanType;
    nsIGleanDatetime: nsIGleanDatetimeType;
    nsIGleanCounter: nsIGleanCounterType;
    nsIGleanTimingDistribution: nsIGleanTimingDistributionType;
    nsIGleanMemoryDistribution: nsIGleanMemoryDistributionType;
    nsIGleanCustomDistribution: nsIGleanCustomDistributionType;
    nsIGleanPingTestCallback: nsIGleanPingTestCallbackType;
    nsIGleanPing: nsIGleanPingType;
    nsIGleanString: nsIGleanStringType;
    nsIGleanStringList: nsIGleanStringListType;
    nsIGleanTimespan: nsIGleanTimespanType;
    nsIGleanUuid: nsIGleanUuidType;
    nsIGleanEvent: nsIGleanEventType;
    nsIGleanQuantity: nsIGleanQuantityType;
    nsIGleanDenominator: nsIGleanDenominatorType;
    nsIGleanNumerator: nsIGleanNumeratorType;
    nsIGleanRate: nsIGleanRateType;
    nsIGleanUrl: nsIGleanUrlType;
    nsIGleanText: nsIGleanTextType;
    nsIGtkTaskbarProgress: nsIGtkTaskbarProgressType;
    nsIHTMLAbsPosEditor: nsIHTMLAbsPosEditorType;
    nsIHTMLEditor: nsIHTMLEditorType;
    nsIHTMLInlineTableEditor: nsIHTMLInlineTableEditorType;
    nsIHTMLObjectResizer: nsIHTMLObjectResizerType;
    nsIHandlerService: nsIHandlerServiceType;
    nsIHangDetails: nsIHangDetailsType;
    nsIHangReport: nsIHangReportType;
    nsIHapticFeedback: nsIHapticFeedbackType;
    nsIHelperAppLauncherDialog: nsIHelperAppLauncherDialogType;
    nsIHttpActivityObserver: nsIHttpActivityObserverType;
    nsIHttpActivityDistributor: nsIHttpActivityDistributorType;
    nsIHttpAuthManager: nsIHttpAuthManagerType;
    nsIHttpAuthenticableChannel: nsIHttpAuthenticableChannelType;
    nsIHttpAuthenticator: nsIHttpAuthenticatorType;
    nsIHttpAuthenticatorCallback: nsIHttpAuthenticatorCallbackType;
    nsIHttpChannel: nsIHttpChannelType;
    nsIHttpChannelAuthProvider: nsIHttpChannelAuthProviderType;
    nsIHttpChannelChild: nsIHttpChannelChildType;
    nsIHttpUpgradeListener: nsIHttpUpgradeListenerType;
    nsIHttpChannelInternal: nsIHttpChannelInternalType;
    nsIHttpHeaderVisitor: nsIHttpHeaderVisitorType;
    nsIHttpProtocolHandler: nsIHttpProtocolHandlerType;
    nsIHttpPushListener: nsIHttpPushListenerType;
    nsIHttpServer: nsIHttpServerType;
    nsIHttpServerStoppedCallback: nsIHttpServerStoppedCallbackType;
    nsIHttpServerIdentity: nsIHttpServerIdentityType;
    nsIHttpRequestHandler: nsIHttpRequestHandlerType;
    nsIHttpRequest: nsIHttpRequestType;
    nsIHttpResponse: nsIHttpResponseType;
    nsIHttpsOnlyModePermission: nsIHttpsOnlyModePermissionType;
    nsIIDBPermissionsRequest: nsIIDBPermissionsRequestType;
    nsIIDNService: nsIIDNServiceType;
    nsIINIParser: nsIINIParserType;
    nsIINIParserWriter: nsIINIParserWriterType;
    nsIINIParserFactory: nsIINIParserFactoryType;
    nsIIOService: nsIIOServiceType;
    nsIIOServiceInternal: nsIIOServiceInternalType;
    nsIIOUtil: nsIIOUtilType;
    nsIMozIconURI: nsIMozIconURIType;
    nsIIdentityCredentialPromptService: nsIIdentityCredentialPromptServiceType;
    nsIIdentityCredentialStorageService: nsIIdentityCredentialStorageServiceType;
    nsIIdlePeriod: nsIIdlePeriodType;
    nsIImageLoadingContent: nsIImageLoadingContentType;
    nsIIncrementalDownload: nsIIncrementalDownloadType;
    nsIIncrementalStreamLoaderObserver: nsIIncrementalStreamLoaderObserverType;
    nsIIncrementalStreamLoader: nsIIncrementalStreamLoaderType;
    nsIInlineSpellChecker: nsIInlineSpellCheckerType;
    nsIInputListAutoComplete: nsIInputListAutoCompleteType;
    nsIInputStream: nsIInputStreamType;
    nsIInputStreamChannel: nsIInputStreamChannelType;
    nsIInputStreamLength: nsIInputStreamLengthType;
    nsIAsyncInputStreamLength: nsIAsyncInputStreamLengthType;
    nsIInputStreamLengthCallback: nsIInputStreamLengthCallbackType;
    nsIInputStreamPriority: nsIInputStreamPriorityType;
    nsIInputStreamPump: nsIInputStreamPumpType;
    nsIInputStreamTee: nsIInputStreamTeeType;
    nsIInterceptionInfo: nsIInterceptionInfoType;
    nsIInterfaceRequestor: nsIInterfaceRequestorType;
    nsIJARChannel: nsIJARChannelType;
    nsIJARURI: nsIJARURIType;
    nsIJARURIMutator: nsIJARURIMutatorType;
    nsIJSInspector: nsIJSInspectorType;
    nsIJumpListCommittedCallback: nsIJumpListCommittedCallbackType;
    nsIJumpListBuilder: nsIJumpListBuilderType;
    nsIJumpListItem: nsIJumpListItemType;
    nsIJumpListSeparator: nsIJumpListSeparatorType;
    nsIJumpListLink: nsIJumpListLinkType;
    nsIJumpListShortcut: nsIJumpListShortcutType;
    nsIKeyValueService: nsIKeyValueServiceType;
    nsIKeyValueDatabase: nsIKeyValueDatabaseType;
    nsIKeyValuePair: nsIKeyValuePairType;
    nsIKeyValueEnumerator: nsIKeyValueEnumeratorType;
    nsIKeyValueDatabaseCallback: nsIKeyValueDatabaseCallbackType;
    nsIKeyValueEnumeratorCallback: nsIKeyValueEnumeratorCallbackType;
    nsIKeyValuePairCallback: nsIKeyValuePairCallbackType;
    nsIKeyValueVariantCallback: nsIKeyValueVariantCallbackType;
    nsIKeyValueVoidCallback: nsIKeyValueVoidCallbackType;
    nsIKeychainMigrationUtils: nsIKeychainMigrationUtilsType;
    nsILayoutDebuggingTools: nsILayoutDebuggingToolsType;
    nsILayoutHistoryState: nsILayoutHistoryStateType;
    nsILineInputStream: nsILineInputStreamType;
    nsILoadContext: nsILoadContextType;
    nsILoadContextInfo: nsILoadContextInfoType;
    nsILoadContextInfoFactory: nsILoadContextInfoFactoryType;
    nsILoadGroup: nsILoadGroupType;
    nsILoadGroupChild: nsILoadGroupChildType;
    nsILoadInfo: nsILoadInfoType;
    nsILoadURIDelegate: nsILoadURIDelegateType;
    nsILocalFileMac: nsILocalFileMacType;
    nsILocalFileWin: nsILocalFileWinType;
    nsILocalStorageManager: nsILocalStorageManagerType;
    nsILoginAutoCompleteSearch: nsILoginAutoCompleteSearchType;
    nsILoginDetectionService: nsILoginDetectionServiceType;
    nsILoginInfo: nsILoginInfoType;
    nsILoginSearchCallback: nsILoginSearchCallbackType;
    nsILoginManager: nsILoginManagerType;
    nsILoginManagerAuthPrompter: nsILoginManagerAuthPrompterType;
    nsILoginManagerCrypto: nsILoginManagerCryptoType;
    nsILoginManagerPrompter: nsILoginManagerPrompterType;
    nsILoginManagerStorage: nsILoginManagerStorageType;
    nsILoginMetaInfo: nsILoginMetaInfoType;
    nsILoginReputationVerdictType: nsILoginReputationVerdictTypeType;
    nsILoginReputationQuery: nsILoginReputationQueryType;
    nsILoginReputationQueryCallback: nsILoginReputationQueryCallbackType;
    nsILoginReputationService: nsILoginReputationServiceType;
    nsIMIMEHeaderParam: nsIMIMEHeaderParamType;
    nsIHandlerInfo: nsIHandlerInfoType;
    nsIMIMEInfo: nsIMIMEInfoType;
    nsIHandlerApp: nsIHandlerAppType;
    nsILocalHandlerApp: nsILocalHandlerAppType;
    nsIWebHandlerApp: nsIWebHandlerAppType;
    nsIDBusHandlerApp: nsIDBusHandlerAppType;
    nsIMIMEInputStream: nsIMIMEInputStreamType;
    nsIMIMEService: nsIMIMEServiceType;
    nsIMacAttributionService: nsIMacAttributionServiceType;
    nsIMacDockSupport: nsIMacDockSupportType;
    nsIMacFinderProgressCanceledCallback: nsIMacFinderProgressCanceledCallbackType;
    nsIMacFinderProgress: nsIMacFinderProgressType;
    nsIMacPreferencesReader: nsIMacPreferencesReaderType;
    nsIMacSharingService: nsIMacSharingServiceType;
    nsIMacShellService: nsIMacShellServiceType;
    nsIMacUserActivityUpdater: nsIMacUserActivityUpdaterType;
    nsITrashAppCallback: nsITrashAppCallbackType;
    nsIMacWebAppUtils: nsIMacWebAppUtilsType;
    nsIMarionette: nsIMarionetteType;
    nsIMediaDevice: nsIMediaDeviceType;
    nsIMediaManagerService: nsIMediaManagerServiceType;
    nsIFinishDumpingCallback: nsIFinishDumpingCallbackType;
    nsIDumpGCAndCCLogsCallback: nsIDumpGCAndCCLogsCallbackType;
    nsIMemoryInfoDumper: nsIMemoryInfoDumperType;
    nsIHandleReportCallback: nsIHandleReportCallbackType;
    nsIMemoryReporter: nsIMemoryReporterType;
    nsIFinishReportingCallback: nsIFinishReportingCallbackType;
    nsIHeapAllocatedCallback: nsIHeapAllocatedCallbackType;
    nsIMemoryReporterManager: nsIMemoryReporterManagerType;
    nsIMessageLoop: nsIMessageLoopType;
    nsIMessageSender: nsIMessageSenderType;
    nsIInProcessContentFrameMessageManager: nsIInProcessContentFrameMessageManagerType;
    nsIMozBrowserFrame: nsIMozBrowserFrameType;
    nsIMultiPartChannel: nsIMultiPartChannelType;
    nsIMultiPartChannelListener: nsIMultiPartChannelListenerType;
    nsIMultiplexInputStream: nsIMultiplexInputStreamType;
    nsIMutableArray: nsIMutableArrayType;
    nsINSSComponent: nsINSSComponentType;
    nsINSSErrorsService: nsINSSErrorsServiceType;
    nsINSSVersion: nsINSSVersionType;
    nsINamed: nsINamedType;
    nsINamedPipeDataObserver: nsINamedPipeDataObserverType;
    nsINamedPipeService: nsINamedPipeServiceType;
    nsINativeAppSupport: nsINativeAppSupportType;
    nsINativeDNSResolverOverride: nsINativeDNSResolverOverrideType;
    nsINativeOSFileResult: nsINativeOSFileResultType;
    nsINativeOSFileSuccessCallback: nsINativeOSFileSuccessCallbackType;
    nsINativeOSFileErrorCallback: nsINativeOSFileErrorCallbackType;
    nsINativeOSFileInternalsService: nsINativeOSFileInternalsServiceType;
    nsINavBookmarksService: nsINavBookmarksServiceType;
    nsINavHistoryResultNode: nsINavHistoryResultNodeType;
    nsINavHistoryContainerResultNode: nsINavHistoryContainerResultNodeType;
    nsINavHistoryQueryResultNode: nsINavHistoryQueryResultNodeType;
    nsINavHistoryResultObserver: nsINavHistoryResultObserverType;
    nsINavHistoryResult: nsINavHistoryResultType;
    nsINavHistoryQuery: nsINavHistoryQueryType;
    nsINavHistoryQueryOptions: nsINavHistoryQueryOptionsType;
    nsINavHistoryService: nsINavHistoryServiceType;
    nsINestedURI: nsINestedURIType;
    nsINestedURIMutator: nsINestedURIMutatorType;
    nsINestedAboutURIMutator: nsINestedAboutURIMutatorType;
    nsIJSURIMutator: nsIJSURIMutatorType;
    nsINetAddr: nsINetAddrType;
    nsINetUtil: nsINetUtilType;
    nsINetworkConnectivityService: nsINetworkConnectivityServiceType;
    nsIListNetworkAddressesListener: nsIListNetworkAddressesListenerType;
    nsIGetHostnameListener: nsIGetHostnameListenerType;
    nsINetworkInfoService: nsINetworkInfoServiceType;
    nsIInterceptedBodyCallback: nsIInterceptedBodyCallbackType;
    nsIInterceptedChannel: nsIInterceptedChannelType;
    nsINetworkInterceptController: nsINetworkInterceptControllerType;
    nsINetworkLinkService: nsINetworkLinkServiceType;
    nsINetworkPredictor: nsINetworkPredictorType;
    nsINetworkPredictorVerifier: nsINetworkPredictorVerifierType;
    nsINotificationStorageCallback: nsINotificationStorageCallbackType;
    nsINotificationStorage: nsINotificationStorageType;
    nsINullChannel: nsINullChannelType;
    nsIOSFileConstantsService: nsIOSFileConstantsServiceType;
    nsIOSKeyStore: nsIOSKeyStoreType;
    nsIOSPermissionRequest: nsIOSPermissionRequestType;
    nsIOSReauthenticator: nsIOSReauthenticatorType;
    nsIObjectInputStream: nsIObjectInputStreamType;
    nsIObjectLoadingContent: nsIObjectLoadingContentType;
    nsIObjectOutputStream: nsIObjectOutputStreamType;
    nsIObliviousHttpClientResponse: nsIObliviousHttpClientResponseType;
    nsIObliviousHttpClientRequest: nsIObliviousHttpClientRequestType;
    nsIObliviousHttpServerResponse: nsIObliviousHttpServerResponseType;
    nsIObliviousHttpServer: nsIObliviousHttpServerType;
    nsIObliviousHttp: nsIObliviousHttpType;
    nsIObliviousHttpService: nsIObliviousHttpServiceType;
    nsIObserver: nsIObserverType;
    nsIObserverService: nsIObserverServiceType;
    nsIBrowsingContextReadyCallback: nsIBrowsingContextReadyCallbackType;
    nsIOpenWindowInfo: nsIOpenWindowInfoType;
    nsIOutputStream: nsIOutputStreamType;
    nsIPK11Token: nsIPK11TokenType;
    nsIPK11TokenDB: nsIPK11TokenDBType;
    nsIPKCS11Module: nsIPKCS11ModuleType;
    nsIPKCS11ModuleDB: nsIPKCS11ModuleDBType;
    nsIPKCS11Slot: nsIPKCS11SlotType;
    nsIPageThumbsStorageService: nsIPageThumbsStorageServiceType;
    nsIPaper: nsIPaperType;
    nsIPaperMargin: nsIPaperMarginType;
    nsIParentChannel: nsIParentChannelType;
    nsIAsyncVerifyRedirectReadyCallback: nsIAsyncVerifyRedirectReadyCallbackType;
    nsIParentRedirectingChannel: nsIParentRedirectingChannelType;
    nsIParentalControlsService: nsIParentalControlsServiceType;
    nsIParserUtils: nsIParserUtilsType;
    nsIPartitioningExceptionListObserver: nsIPartitioningExceptionListObserverType;
    nsIPartitioningExceptionListService: nsIPartitioningExceptionListServiceType;
    nsIPaymentResponseData: nsIPaymentResponseDataType;
    nsIGeneralResponseData: nsIGeneralResponseDataType;
    nsIBasicCardResponseData: nsIBasicCardResponseDataType;
    nsIPaymentActionResponse: nsIPaymentActionResponseType;
    nsIPaymentCanMakeActionResponse: nsIPaymentCanMakeActionResponseType;
    nsIPaymentShowActionResponse: nsIPaymentShowActionResponseType;
    nsIPaymentAbortActionResponse: nsIPaymentAbortActionResponseType;
    nsIPaymentCompleteActionResponse: nsIPaymentCompleteActionResponseType;
    nsIMethodChangeDetails: nsIMethodChangeDetailsType;
    nsIGeneralChangeDetails: nsIGeneralChangeDetailsType;
    nsIBasicCardChangeDetails: nsIBasicCardChangeDetailsType;
    nsIPaymentAddress: nsIPaymentAddressType;
    nsIPaymentMethodData: nsIPaymentMethodDataType;
    nsIPaymentCurrencyAmount: nsIPaymentCurrencyAmountType;
    nsIPaymentItem: nsIPaymentItemType;
    nsIPaymentDetailsModifier: nsIPaymentDetailsModifierType;
    nsIPaymentShippingOption: nsIPaymentShippingOptionType;
    nsIPaymentDetails: nsIPaymentDetailsType;
    nsIPaymentOptions: nsIPaymentOptionsType;
    nsIPaymentRequest: nsIPaymentRequestType;
    nsIPaymentRequestService: nsIPaymentRequestServiceType;
    nsIPaymentUIService: nsIPaymentUIServiceType;
    nsIPermission: nsIPermissionType;
    nsIPermissionDelegateHandler: nsIPermissionDelegateHandlerType;
    nsIPermissionManager: nsIPermissionManagerType;
    nsIPropertyElement: nsIPropertyElementType;
    nsIPersistentProperties: nsIPersistentPropertiesType;
    nsIPipe: nsIPipeType;
    nsISearchableInputStream: nsISearchableInputStreamType;
    nsIPlacesPreviewsHelperService: nsIPlacesPreviewsHelperServiceType;
    nsIPlatformInfo: nsIPlatformInfoType;
    nsIPluginTag: nsIPluginTagType;
    nsIFakePluginTag: nsIFakePluginTagType;
    nsIPowerManagerService: nsIPowerManagerServiceType;
    nsIPrefBranch: nsIPrefBranchType;
    nsIPrefLocalizedString: nsIPrefLocalizedStringType;
    nsIPrefStatsCallback: nsIPrefStatsCallbackType;
    nsIPrefObserver: nsIPrefObserverType;
    nsIPrefService: nsIPrefServiceType;
    nsIPrefetchService: nsIPrefetchServiceType;
    nsIPreloadedStyleSheet: nsIPreloadedStyleSheetType;
    nsIPrincipal: nsIPrincipalType;
    nsIExpandedPrincipal: nsIExpandedPrincipalType;
    nsIPrintDialogService: nsIPrintDialogServiceType;
    nsIPrintPreviewNavigation: nsIPrintPreviewNavigationType;
    nsIPrintSettings: nsIPrintSettingsType;
    nsIPrintSettingsService: nsIPrintSettingsServiceType;
    nsIPrintSettingsWin: nsIPrintSettingsWinType;
    nsIPrinterInfo: nsIPrinterInfoType;
    nsIPrinter: nsIPrinterType;
    nsIPrinterList: nsIPrinterListType;
    nsIPrivacyTransitionObserver: nsIPrivacyTransitionObserverType;
    nsIPrivateBrowsingChannel: nsIPrivateBrowsingChannelType;
    nsIProcess: nsIProcessType;
    nsIProcessToolsService: nsIProcessToolsServiceType;
    nsIProfileStartup: nsIProfileStartupType;
    nsIProfileMigrator: nsIProfileMigratorType;
    nsIProfileUnlocker: nsIProfileUnlockerType;
    nsIProfilerStartParams: nsIProfilerStartParamsType;
    nsIProfiler: nsIProfilerType;
    nsIProgressEventSink: nsIProgressEventSinkType;
    nsIPrompt: nsIPromptType;
    nsIPromptCollection: nsIPromptCollectionType;
    nsIPromptFactory: nsIPromptFactoryType;
    nsIPromptInstance: nsIPromptInstanceType;
    nsIPromptService: nsIPromptServiceType;
    nsIProperties: nsIPropertiesType;
    nsIProperty: nsIPropertyType;
    nsIPropertyBag: nsIPropertyBagType;
    nsIPropertyBag2: nsIPropertyBag2Type;
    nsIProtectedAuthThread: nsIProtectedAuthThreadType;
    nsIProtocolHandlerWithDynamicFlags: nsIProtocolHandlerWithDynamicFlagsType;
    nsIProtocolHandler: nsIProtocolHandlerType;
    nsIProtocolProxyCallback: nsIProtocolProxyCallbackType;
    nsIProxyProtocolFilterResult: nsIProxyProtocolFilterResultType;
    nsIProtocolProxyFilter: nsIProtocolProxyFilterType;
    nsIProtocolProxyChannelFilter: nsIProtocolProxyChannelFilterType;
    nsIProxyConfigChangedCallback: nsIProxyConfigChangedCallbackType;
    nsIProtocolProxyService: nsIProtocolProxyServiceType;
    nsIProtocolProxyService2: nsIProtocolProxyService2Type;
    nsIProxiedChannel: nsIProxiedChannelType;
    nsIProxiedProtocolHandler: nsIProxiedProtocolHandlerType;
    nsIProxyInfo: nsIProxyInfoType;
    nsIPublicKeyPinningService: nsIPublicKeyPinningServiceType;
    nsIPurgeTrackerService: nsIPurgeTrackerServiceType;
    nsIPushErrorReporter: nsIPushErrorReporterType;
    nsIPushNotifier: nsIPushNotifierType;
    nsIPushData: nsIPushDataType;
    nsIPushMessage: nsIPushMessageType;
    nsIPushSubscription: nsIPushSubscriptionType;
    nsIPushSubscriptionCallback: nsIPushSubscriptionCallbackType;
    nsIUnsubscribeResultCallback: nsIUnsubscribeResultCallbackType;
    nsIPushClearResultCallback: nsIPushClearResultCallbackType;
    nsIPushService: nsIPushServiceType;
    nsIPushQuotaManager: nsIPushQuotaManagerType;
    nsIQueryContentEventResult: nsIQueryContentEventResultType;
    nsIQuotaUsageCallback: nsIQuotaUsageCallbackType;
    nsIQuotaCallback: nsIQuotaCallbackType;
    nsIQuotaManagerService: nsIQuotaManagerServiceType;
    nsIQuotaRequestBase: nsIQuotaRequestBaseType;
    nsIQuotaUsageRequest: nsIQuotaUsageRequestType;
    nsIQuotaRequest: nsIQuotaRequestType;
    nsIQuotaFullOriginMetadataResult: nsIQuotaFullOriginMetadataResultType;
    nsIQuotaUsageResult: nsIQuotaUsageResultType;
    nsIQuotaOriginUsageResult: nsIQuotaOriginUsageResultType;
    nsIQuotaEstimateResult: nsIQuotaEstimateResultType;
    nsIRaceCacheWithNetwork: nsIRaceCacheWithNetworkType;
    nsIRandomAccessStream: nsIRandomAccessStreamType;
    nsIRandomGenerator: nsIRandomGeneratorType;
    nsIRddProcessTest: nsIRddProcessTestType;
    nsIRedirectChannelRegistrar: nsIRedirectChannelRegistrarType;
    nsIRedirectHistoryEntry: nsIRedirectHistoryEntryType;
    nsIRedirectResultListener: nsIRedirectResultListenerType;
    nsIReferrerInfo: nsIReferrerInfoType;
    nsIReflowObserver: nsIReflowObserverType;
    nsIRefreshURI: nsIRefreshURIType;
    nsIRegion: nsIRegionType;
    nsIRelativeFilePref: nsIRelativeFilePrefType;
    nsIRemoteAgent: nsIRemoteAgentType;
    nsIRemoteTab: nsIRemoteTabType;
    nsIRequest: nsIRequestType;
    nsIRequestTailUnblockCallback: nsIRequestTailUnblockCallbackType;
    nsIRequestContext: nsIRequestContextType;
    nsIRequestContextService: nsIRequestContextServiceType;
    nsIRequestObserver: nsIRequestObserverType;
    nsIRequestObserverProxy: nsIRequestObserverProxyType;
    nsIResProtocolHandler: nsIResProtocolHandlerType;
    nsIResumableChannel: nsIResumableChannelType;
    nsIRunnable: nsIRunnableType;
    nsIRunnablePriority: nsIRunnablePriorityType;
    nsIRunnableIPCMessageType: nsIRunnableIPCMessageTypeType;
    nsISDBCallback: nsISDBCallbackType;
    nsISDBCloseCallback: nsISDBCloseCallbackType;
    nsISDBConnection: nsISDBConnectionType;
    nsISDBRequest: nsISDBRequestType;
    nsISDBResult: nsISDBResultType;
    nsISHEntry: nsISHEntryType;
    nsISHistory: nsISHistoryType;
    nsISHistoryListener: nsISHistoryListenerType;
    nsISafeOutputStream: nsISafeOutputStreamType;
    nsIScreen: nsIScreenType;
    nsIScreenManager: nsIScreenManagerType;
    nsIScriptChannel: nsIScriptChannelType;
    nsIScriptErrorNote: nsIScriptErrorNoteType;
    nsIScriptError: nsIScriptErrorType;
    nsIScriptLoaderObserver: nsIScriptLoaderObserverType;
    nsIScriptSecurityManager: nsIScriptSecurityManagerType;
    nsIScriptableBase64Encoder: nsIScriptableBase64EncoderType;
    nsIScriptableContentIterator: nsIScriptableContentIteratorType;
    nsIScriptableInputStream: nsIScriptableInputStreamType;
    nsIScriptableUnicodeConverter: nsIScriptableUnicodeConverterType;
    nsISearchSubmission: nsISearchSubmissionType;
    nsISearchEngine: nsISearchEngineType;
    nsISearchParseSubmissionResult: nsISearchParseSubmissionResultType;
    nsISearchService: nsISearchServiceType;
    nsISecCheckWrapChannel: nsISecCheckWrapChannelType;
    nsISecretDecoderRing: nsISecretDecoderRingType;
    nsISecureBrowserUI: nsISecureBrowserUIType;
    nsISecurityConsoleMessage: nsISecurityConsoleMessageType;
    nsISecurityUITelemetry: nsISecurityUITelemetryType;
    nsISeekableStream: nsISeekableStreamType;
    nsISelectionController: nsISelectionControllerType;
    nsISelectionDisplay: nsISelectionDisplayType;
    nsISelectionListener: nsISelectionListenerType;
    nsISensitiveInfoHiddenURI: nsISensitiveInfoHiddenURIType;
    nsISerialEventTarget: nsISerialEventTargetType;
    nsISerializable: nsISerializableType;
    nsISerializationHelper: nsISerializationHelperType;
    nsIServerSocket: nsIServerSocketType;
    nsIServerSocketListener: nsIServerSocketListenerType;
    nsIServiceManager: nsIServiceManagerType;
    nsIServiceWorkerUnregisterCallback: nsIServiceWorkerUnregisterCallbackType;
    nsIServiceWorkerInfo: nsIServiceWorkerInfoType;
    nsIServiceWorkerRegistrationInfoListener: nsIServiceWorkerRegistrationInfoListenerType;
    nsIServiceWorkerRegistrationInfo: nsIServiceWorkerRegistrationInfoType;
    nsIServiceWorkerManagerListener: nsIServiceWorkerManagerListenerType;
    nsIServiceWorkerManager: nsIServiceWorkerManagerType;
    nsISessionStorageService: nsISessionStorageServiceType;
    nsISessionStoreRestoreData: nsISessionStoreRestoreDataType;
    nsISharePicker: nsISharePickerType;
    nsISharingHandlerApp: nsISharingHandlerAppType;
    nsIShellService: nsIShellServiceType;
    nsIJSEnumerator: nsIJSEnumeratorType;
    nsISimpleEnumeratorBase: nsISimpleEnumeratorBaseType;
    nsISimpleEnumerator: nsISimpleEnumeratorType;
    nsISimpleStreamListener: nsISimpleStreamListenerType;
    nsISimpleURIMutator: nsISimpleURIMutatorType;
    nsISiteSecurityService: nsISiteSecurityServiceType;
    nsISlowScriptDebugCallback: nsISlowScriptDebugCallbackType;
    nsISlowScriptDebuggerStartupCallback: nsISlowScriptDebuggerStartupCallbackType;
    nsISlowScriptDebugRemoteCallback: nsISlowScriptDebugRemoteCallbackType;
    nsISlowScriptDebug: nsISlowScriptDebugType;
    nsISocketFilter: nsISocketFilterType;
    nsISocketFilterHandler: nsISocketFilterHandlerType;
    nsISocketProvider: nsISocketProviderType;
    nsISocketProviderService: nsISocketProviderServiceType;
    nsISocketTransport: nsISocketTransportType;
    nsISTSShutdownObserver: nsISTSShutdownObserverType;
    nsISocketTransportService: nsISocketTransportServiceType;
    nsIRoutedSocketTransportService: nsIRoutedSocketTransportServiceType;
    nsISound: nsISoundType;
    nsISpeculativeConnect: nsISpeculativeConnectType;
    nsISpeculativeConnectionOverrider: nsISpeculativeConnectionOverriderType;
    nsISpeechGrammarCompilationCallback: nsISpeechGrammarCompilationCallbackType;
    nsISpeechRecognitionService: nsISpeechRecognitionServiceType;
    nsISpeechTaskCallback: nsISpeechTaskCallbackType;
    nsISpeechTask: nsISpeechTaskType;
    nsISpeechService: nsISpeechServiceType;
    nsIStandaloneNativeMenu: nsIStandaloneNativeMenuType;
    nsIStandardURL: nsIStandardURLType;
    nsIStandardURLMutator: nsIStandardURLMutatorType;
    nsIStartupCacheInfo: nsIStartupCacheInfoType;
    nsIStorageActivityService: nsIStorageActivityServiceType;
    nsIStorageStream: nsIStorageStreamType;
    nsIStreamBufferAccess: nsIStreamBufferAccessType;
    nsIStreamConverter: nsIStreamConverterType;
    nsIStreamConverterService: nsIStreamConverterServiceType;
    nsIStreamListener: nsIStreamListenerType;
    nsIStreamListenerTee: nsIStreamListenerTeeType;
    nsIStreamLoaderObserver: nsIStreamLoaderObserverType;
    nsIStreamLoader: nsIStreamLoaderType;
    nsIStreamTransportService: nsIStreamTransportServiceType;
    nsIInputAvailableCallback: nsIInputAvailableCallbackType;
    nsIStringBundle: nsIStringBundleType;
    nsIStringBundleService: nsIStringBundleServiceType;
    nsIStringEnumeratorBase: nsIStringEnumeratorBaseType;
    nsIStringEnumerator: nsIStringEnumeratorType;
    nsIUTF8StringEnumerator: nsIUTF8StringEnumeratorType;
    nsIStringInputStream: nsIStringInputStreamType;
    nsIStructuredCloneContainer: nsIStructuredCloneContainerType;
    nsISFVBareItem: nsISFVBareItemType;
    nsISFVInteger: nsISFVIntegerType;
    nsISFVString: nsISFVStringType;
    nsISFVBool: nsISFVBoolType;
    nsISFVDecimal: nsISFVDecimalType;
    nsISFVToken: nsISFVTokenType;
    nsISFVByteSeq: nsISFVByteSeqType;
    nsISFVParams: nsISFVParamsType;
    nsISFVParametrizable: nsISFVParametrizableType;
    nsISFVItemOrInnerList: nsISFVItemOrInnerListType;
    nsISFVSerialize: nsISFVSerializeType;
    nsISFVItem: nsISFVItemType;
    nsISFVInnerList: nsISFVInnerListType;
    nsISFVList: nsISFVListType;
    nsISFVDictionary: nsISFVDictionaryType;
    nsISFVService: nsISFVServiceType;
    nsIStyleSheetService: nsIStyleSheetServiceType;
    nsISubstitutingProtocolHandler: nsISubstitutingProtocolHandlerType;
    nsIOutputIterator: nsIOutputIteratorType;
    nsIInputIterator: nsIInputIteratorType;
    nsIForwardIterator: nsIForwardIteratorType;
    nsIBidirectionalIterator: nsIBidirectionalIteratorType;
    nsIRandomAccessIterator: nsIRandomAccessIteratorType;
    nsISupportsPrimitive: nsISupportsPrimitiveType;
    nsISupportsID: nsISupportsIDType;
    nsISupportsCString: nsISupportsCStringType;
    nsISupportsString: nsISupportsStringType;
    nsISupportsPRBool: nsISupportsPRBoolType;
    nsISupportsPRUint8: nsISupportsPRUint8Type;
    nsISupportsPRUint16: nsISupportsPRUint16Type;
    nsISupportsPRUint32: nsISupportsPRUint32Type;
    nsISupportsPRUint64: nsISupportsPRUint64Type;
    nsISupportsPRTime: nsISupportsPRTimeType;
    nsISupportsChar: nsISupportsCharType;
    nsISupportsPRInt16: nsISupportsPRInt16Type;
    nsISupportsPRInt32: nsISupportsPRInt32Type;
    nsISupportsPRInt64: nsISupportsPRInt64Type;
    nsISupportsFloat: nsISupportsFloatType;
    nsISupportsDouble: nsISupportsDoubleType;
    nsISupportsInterfacePointer: nsISupportsInterfacePointerType;
    nsISupportsPriority: nsISupportsPriorityType;
    nsISyncStreamListener: nsISyncStreamListenerType;
    nsISynthVoiceRegistry: nsISynthVoiceRegistryType;
    nsISystemInfo: nsISystemInfoType;
    nsISystemProxySettings: nsISystemProxySettingsType;
    nsISystemStatusBar: nsISystemStatusBarType;
    nsITCPSocketCallback: nsITCPSocketCallbackType;
    nsITLSServerSocket: nsITLSServerSocketType;
    nsITLSClientStatus: nsITLSClientStatusType;
    nsITLSServerConnectionInfo: nsITLSServerConnectionInfoType;
    nsITLSServerSecurityObserver: nsITLSServerSecurityObserverType;
    nsITLSSocketControl: nsITLSSocketControlType;
    nsITRRSkipReason: nsITRRSkipReasonType;
    nsITXTToHTMLConv: nsITXTToHTMLConvType;
    nsITableEditor: nsITableEditorType;
    nsITaggingService: nsITaggingServiceType;
    nsITaskbarOverlayIconController: nsITaskbarOverlayIconControllerType;
    nsITaskbarPreview: nsITaskbarPreviewType;
    nsITaskbarPreviewButton: nsITaskbarPreviewButtonType;
    nsITaskbarPreviewCallback: nsITaskbarPreviewCallbackType;
    nsITaskbarPreviewController: nsITaskbarPreviewControllerType;
    nsITaskbarProgress: nsITaskbarProgressType;
    nsITaskbarTabPreview: nsITaskbarTabPreviewType;
    nsITaskbarWindowPreview: nsITaskbarWindowPreviewType;
    nsIFetchTelemetryDataCallback: nsIFetchTelemetryDataCallbackType;
    nsITelemetry: nsITelemetryType;
    nsITellableStream: nsITellableStreamType;
    nsITextInputProcessor: nsITextInputProcessorType;
    nsITextInputProcessorNotification: nsITextInputProcessorNotificationType;
    nsITextInputProcessorCallback: nsITextInputProcessorCallbackType;
    nsITextToSubURI: nsITextToSubURIType;
    nsIThread: nsIThreadType;
    nsIThreadInternal: nsIThreadInternalType;
    nsIThreadObserver: nsIThreadObserverType;
    nsINestedEventLoopCondition: nsINestedEventLoopConditionType;
    nsIThreadManager: nsIThreadManagerType;
    nsIThreadPoolListener: nsIThreadPoolListenerType;
    nsIThreadPool: nsIThreadPoolType;
    nsIThreadRetargetableRequest: nsIThreadRetargetableRequestType;
    nsIThreadRetargetableStreamListener: nsIThreadRetargetableStreamListenerType;
    nsIThreadShutdown: nsIThreadShutdownType;
    nsIInputChannelThrottleQueue: nsIInputChannelThrottleQueueType;
    nsIThrottledInputChannel: nsIThrottledInputChannelType;
    nsIServerTiming: nsIServerTimingType;
    nsITimedChannel: nsITimedChannelType;
    nsITimerCallback: nsITimerCallbackType;
    nsITimer: nsITimerType;
    nsITimerManager: nsITimerManagerType;
    nsITlsHandshakeCallbackListener: nsITlsHandshakeCallbackListenerType;
    nsITokenDialogs: nsITokenDialogsType;
    nsITokenPasswordDialogs: nsITokenPasswordDialogsType;
    nsIToolkitChromeRegistry: nsIToolkitChromeRegistryType;
    nsIProfileLock: nsIProfileLockType;
    nsIToolkitProfile: nsIToolkitProfileType;
    nsIToolkitProfileService: nsIToolkitProfileServiceType;
    nsIToolkitShellService: nsIToolkitShellServiceType;
    nsITooltipListener: nsITooltipListenerType;
    nsITooltipTextProvider: nsITooltipTextProviderType;
    nsITouchBarHelper: nsITouchBarHelperType;
    nsITouchBarInputCallback: nsITouchBarInputCallbackType;
    nsITouchBarInput: nsITouchBarInputType;
    nsITouchBarUpdater: nsITouchBarUpdaterType;
    nsITraceableChannel: nsITraceableChannelType;
    nsITrackingDBService: nsITrackingDBServiceType;
    nsITransaction: nsITransactionType;
    nsITransactionManager: nsITransactionManagerType;
    nsITransfer: nsITransferType;
    nsIFlavorDataProvider: nsIFlavorDataProviderType;
    nsITransferable: nsITransferableType;
    nsITransport: nsITransportType;
    nsITransportEventSink: nsITransportEventSinkType;
    nsITransportProvider: nsITransportProviderType;
    nsITransportSecurityInfo: nsITransportSecurityInfoType;
    nsITreeSelection: nsITreeSelectionType;
    nsINativeTreeSelection: nsINativeTreeSelectionType;
    nsITreeView: nsITreeViewType;
    nsITypeAheadFind: nsITypeAheadFindType;
    nsIU2FTokenManager: nsIU2FTokenManagerType;
    nsIUDPSocket: nsIUDPSocketType;
    nsIUDPSocketListener: nsIUDPSocketListenerType;
    nsIUDPMessage: nsIUDPMessageType;
    nsIUDPSocketSyncListener: nsIUDPSocketSyncListenerType;
    nsIUDPSocketInternal: nsIUDPSocketInternalType;
    nsIURI: nsIURIType;
    nsIURIClassifierCallback: nsIURIClassifierCallbackType;
    nsIURIClassifier: nsIURIClassifierType;
    nsIURIContentListener: nsIURIContentListenerType;
    nsIURIFixupInfo: nsIURIFixupInfoType;
    nsIURIFixup: nsIURIFixupType;
    nsIURILoader: nsIURILoaderType;
    nsIURISetSpec: nsIURISetSpecType;
    nsIURISetters: nsIURISettersType;
    nsIURIMutator: nsIURIMutatorType;
    nsIURIWithSpecialOrigin: nsIURIWithSpecialOriginType;
    nsIURL: nsIURLType;
    nsIURLMutator: nsIURLMutatorType;
    nsIURLDecorationAnnotationsService: nsIURLDecorationAnnotationsServiceType;
    nsIURLFormatter: nsIURLFormatterType;
    nsIURLParser: nsIURLParserType;
    nsIURLQueryStringStripper: nsIURLQueryStringStripperType;
    nsIURLQueryStrippingListObserver: nsIURLQueryStrippingListObserverType;
    nsIURLQueryStrippingListService: nsIURLQueryStrippingListServiceType;
    nsIUUIDGenerator: nsIUUIDGeneratorType;
    nsIUnicharInputStream: nsIUnicharInputStreamType;
    nsIUnicharLineInputStream: nsIUnicharLineInputStreamType;
    nsIUnicharOutputStream: nsIUnicharOutputStreamType;
    nsIUpdatePatch: nsIUpdatePatchType;
    nsIUpdate: nsIUpdateType;
    nsIUpdateCheckResult: nsIUpdateCheckResultType;
    nsIUpdateCheck: nsIUpdateCheckType;
    nsIUpdateChecker: nsIUpdateCheckerType;
    nsIApplicationUpdateService: nsIApplicationUpdateServiceType;
    nsIUpdateProcessor: nsIUpdateProcessorType;
    nsIUpdateSyncManager: nsIUpdateSyncManagerType;
    nsIUpdateManager: nsIUpdateManagerType;
    nsIUpdateTimerManager: nsIUpdateTimerManagerType;
    nsIUploadChannel: nsIUploadChannelType;
    nsIUploadChannel2: nsIUploadChannel2Type;
    nsIUrlClassifierCallback: nsIUrlClassifierCallbackType;
    nsIUrlClassifierUpdateObserver: nsIUrlClassifierUpdateObserverType;
    nsIUrlClassifierDBService: nsIUrlClassifierDBServiceType;
    nsIUrlClassifierLookupCallback: nsIUrlClassifierLookupCallbackType;
    nsIUrlClassifierClassifyCallback: nsIUrlClassifierClassifyCallbackType;
    nsIUrlClassifierExceptionListObserver: nsIUrlClassifierExceptionListObserverType;
    nsIUrlClassifierExceptionListService: nsIUrlClassifierExceptionListServiceType;
    nsIUrlClassifierFeature: nsIUrlClassifierFeatureType;
    nsIUrlClassifierFeatureResult: nsIUrlClassifierFeatureResultType;
    nsIUrlClassifierFeatureCallback: nsIUrlClassifierFeatureCallbackType;
    nsIFullHashMatch: nsIFullHashMatchType;
    nsIUrlClassifierHashCompleterCallback: nsIUrlClassifierHashCompleterCallbackType;
    nsIUrlClassifierHashCompleter: nsIUrlClassifierHashCompleterType;
    nsIUrlClassifierPositiveCacheEntry: nsIUrlClassifierPositiveCacheEntryType;
    nsIUrlClassifierCacheEntry: nsIUrlClassifierCacheEntryType;
    nsIUrlClassifierCacheInfo: nsIUrlClassifierCacheInfoType;
    nsIUrlClassifierGetCacheCallback: nsIUrlClassifierGetCacheCallbackType;
    nsIUrlClassifierInfo: nsIUrlClassifierInfoType;
    nsIUrlClassifierPrefixSet: nsIUrlClassifierPrefixSetType;
    nsIUrlClassifierRemoteSettingsService: nsIUrlClassifierRemoteSettingsServiceType;
    nsIUrlClassifierStreamUpdater: nsIUrlClassifierStreamUpdaterType;
    nsIUrlClassifierParseFindFullHashCallback: nsIUrlClassifierParseFindFullHashCallbackType;
    nsIUrlClassifierUtils: nsIUrlClassifierUtilsType;
    nsIUrlListManager: nsIUrlListManagerType;
    nsIUserIdleService: nsIUserIdleServiceType;
    nsIUserIdleServiceInternal: nsIUserIdleServiceInternalType;
    nsIUtilityProcessTest: nsIUtilityProcessTestType;
    nsIVariant: nsIVariantType;
    nsIWritableVariant: nsIWritableVariantType;
    nsIVersionComparator: nsIVersionComparatorType;
    nsIViewSourceChannel: nsIViewSourceChannelType;
    nsIWakeLock: nsIWakeLockType;
    nsIWeakReference: nsIWeakReferenceType;
    nsISupportsWeakReference: nsISupportsWeakReferenceType;
    nsICtapRegisterArgs: nsICtapRegisterArgsType;
    nsICtapSignArgs: nsICtapSignArgsType;
    nsICtapRegisterResult: nsICtapRegisterResultType;
    nsIWebAuthnAttObj: nsIWebAuthnAttObjType;
    nsICtapSignResult: nsICtapSignResultType;
    nsIWebAuthnController: nsIWebAuthnControllerType;
    nsICredentialParameters: nsICredentialParametersType;
    nsIWebAuthnTransport: nsIWebAuthnTransportType;
    nsIWebBrowser: nsIWebBrowserType;
    nsIWebBrowserChrome: nsIWebBrowserChromeType;
    nsIWebBrowserChromeFocus: nsIWebBrowserChromeFocusType;
    nsIWebBrowserFind: nsIWebBrowserFindType;
    nsIWebBrowserFindInFrames: nsIWebBrowserFindInFramesType;
    nsIWebBrowserPersist: nsIWebBrowserPersistType;
    nsIWebBrowserPersistURIMap: nsIWebBrowserPersistURIMapType;
    nsIWebBrowserPersistDocument: nsIWebBrowserPersistDocumentType;
    nsIWebBrowserPersistResourceVisitor: nsIWebBrowserPersistResourceVisitorType;
    nsIWebBrowserPersistWriteCompletion: nsIWebBrowserPersistWriteCompletionType;
    nsIWebBrowserPersistDocumentReceiver: nsIWebBrowserPersistDocumentReceiverType;
    nsIWebBrowserPrint: nsIWebBrowserPrintType;
    nsIWebNavigation: nsIWebNavigationType;
    nsIWebNavigationInfo: nsIWebNavigationInfoType;
    nsIWebPageDescriptor: nsIWebPageDescriptorType;
    nsIWebProgress: nsIWebProgressType;
    nsIWebProgressListener: nsIWebProgressListenerType;
    nsIWebProgressListener2: nsIWebProgressListener2Type;
    nsIWebProtocolHandlerRegistrar: nsIWebProtocolHandlerRegistrarType;
    nsIWebSocketChannel: nsIWebSocketChannelType;
    nsIWebSocketFrame: nsIWebSocketFrameType;
    nsIWebSocketEventListener: nsIWebSocketEventListenerType;
    nsIWebSocketEventService: nsIWebSocketEventServiceType;
    nsIWebSocketImpl: nsIWebSocketImplType;
    nsIWebSocketListener: nsIWebSocketListenerType;
    nsIWebTransport: nsIWebTransportType;
    WebTransportSessionEventListener: WebTransportSessionEventListenerType;
    nsIWebTransportStreamCallback: nsIWebTransportStreamCallbackType;
    nsIWebTransportSendStreamStats: nsIWebTransportSendStreamStatsType;
    nsIWebTransportReceiveStreamStats: nsIWebTransportReceiveStreamStatsType;
    nsIWebTransportStreamStatsCallback: nsIWebTransportStreamStatsCallbackType;
    nsIWebTransportReceiveStream: nsIWebTransportReceiveStreamType;
    nsIWebTransportSendStream: nsIWebTransportSendStreamType;
    nsIWebTransportBidirectionalStream: nsIWebTransportBidirectionalStreamType;
    nsIWebVTTListener: nsIWebVTTListenerType;
    nsIWebVTTParserWrapper: nsIWebVTTParserWrapperType;
    nsIWellKnownOpportunisticUtils: nsIWellKnownOpportunisticUtilsType;
    nsIWifiAccessPoint: nsIWifiAccessPointType;
    nsIWifiListener: nsIWifiListenerType;
    nsIWifiMonitor: nsIWifiMonitorType;
    nsIWinAppHelper: nsIWinAppHelperType;
    nsIWinTaskSchedulerService: nsIWinTaskSchedulerServiceType;
    nsIWinTaskbar: nsIWinTaskbarType;
    nsIWindowCreator: nsIWindowCreatorType;
    nsIWindowMediator: nsIWindowMediatorType;
    nsIWindowMediatorListener: nsIWindowMediatorListenerType;
    nsIWindowProvider: nsIWindowProviderType;
    nsIWindowWatcher: nsIWindowWatcherType;
    nsIWindowlessBrowser: nsIWindowlessBrowserType;
    nsIWindowsAlertsService: nsIWindowsAlertsServiceType;
    nsIWindowsPackageManager: nsIWindowsPackageManagerType;
    nsIWindowsRegKey: nsIWindowsRegKeyType;
    nsIWindowsShellService: nsIWindowsShellServiceType;
    nsIWindowsUIUtils: nsIWindowsUIUtilsType;
    nsIWorkerChannelLoadInfo: nsIWorkerChannelLoadInfoType;
    nsIWorkerChannelInfo: nsIWorkerChannelInfoType;
    nsIWorkerDebuggerListener: nsIWorkerDebuggerListenerType;
    nsIWorkerDebugger: nsIWorkerDebuggerType;
    nsIWorkerDebuggerManagerListener: nsIWorkerDebuggerManagerListenerType;
    nsIWorkerDebuggerManager: nsIWorkerDebuggerManagerType;
    nsIWritablePropertyBag: nsIWritablePropertyBagType;
    nsIWritablePropertyBag2: nsIWritablePropertyBag2Type;
    nsIX509Cert: nsIX509CertType;
    nsIOpenSignedAppFileCallback: nsIOpenSignedAppFileCallbackType;
    nsIAsyncBoolCallback: nsIAsyncBoolCallbackType;
    nsICertVerificationCallback: nsICertVerificationCallbackType;
    nsIX509CertDB: nsIX509CertDBType;
    nsIX509CertValidity: nsIX509CertValidityType;
    nsIXPCScriptable: nsIXPCScriptableType;
    nsIXREDirProvider: nsIXREDirProviderType;
    nsIXULAppInfo: nsIXULAppInfoType;
    nsIXULBrowserWindow: nsIXULBrowserWindowType;
    nsIXULRuntime: nsIXULRuntimeType;
    nsIXULStore: nsIXULStoreType;
    nsIZipEntry: nsIZipEntryType;
    nsIZipReader: nsIZipReaderType;
    nsIZipReaderCache: nsIZipReaderCacheType;
    nsIZipWriter: nsIZipWriterType;
    nsPIDNSService: nsPIDNSServiceType;
    nsPIPromptService: nsPIPromptServiceType;
    nsPISocketTransportService: nsPISocketTransportServiceType;
    nsPIWidgetCocoa: nsPIWidgetCocoaType;
    nsPIWindowWatcher: nsPIWindowWatcherType;
    txIEXSLTFunctions: txIEXSLTFunctionsType;
    xpcIJSWeakReference: xpcIJSWeakReferenceType;
    nsIXPCComponents_Interfaces: nsIXPCComponents_InterfacesType;
    nsIXPCComponents_Classes: nsIXPCComponents_ClassesType;
    nsIXPCComponents_Results: nsIXPCComponents_ResultsType;
    nsIXPCComponents_ID: nsIXPCComponents_IDType;
    nsIXPCComponents_Exception: nsIXPCComponents_ExceptionType;
    nsIXPCComponents_Constructor: nsIXPCComponents_ConstructorType;
    nsIXPCComponents_utils_Sandbox: nsIXPCComponents_utils_SandboxType;
    nsIScheduledGCCallback: nsIScheduledGCCallbackType;
    nsIXPCComponents_Utils: nsIXPCComponents_UtilsType;
    nsIXPCComponents: nsIXPCComponentsType;
    nsIXPCTestObjectReadOnly: nsIXPCTestObjectReadOnlyType;
    nsIXPCTestObjectReadWrite: nsIXPCTestObjectReadWriteType;
    nsIXPCTestBug809674: nsIXPCTestBug809674Type;
    nsIXPCTestCEnums: nsIXPCTestCEnumsType;
    nsIXPCTestESMReturnCodeParent: nsIXPCTestESMReturnCodeParentType;
    nsIXPCTestESMReturnCodeChild: nsIXPCTestESMReturnCodeChildType;
    nsIXPCTestInterfaceA: nsIXPCTestInterfaceAType;
    nsIXPCTestInterfaceB: nsIXPCTestInterfaceBType;
    nsIXPCTestInterfaceC: nsIXPCTestInterfaceCType;
    nsIXPCTestParams: nsIXPCTestParamsType;
    nsIXPCTestReturnCodeParent: nsIXPCTestReturnCodeParentType;
    nsIXPCTestReturnCodeChild: nsIXPCTestReturnCodeChildType;
    nsIXPCTestFunctionInterface: nsIXPCTestFunctionInterfaceType;
    nsIXPCTestUtils: nsIXPCTestUtilsType;
}

interface CiType {
    IJSDebugger: {
        readonly name: 'IJSDebugger';
        readonly number: 'a36fa816-31da-4b23-bc97-6412771f0867';
    };
    IPeerConnectionObserver: {
        readonly name: 'IPeerConnectionObserver';
        readonly number: 'd7dfe148-0416-446b-a128-66a7c71ae8d3';
    };
    IPeerConnection: {
        readonly name: 'IPeerConnection';
        readonly number: '14afc8e7-e421-4d0c-99a5-69308d871481';
        readonly kHintAudio: 0x00000001;
        readonly kHintVideo: 0x00000002;
        readonly kActionNone;
        readonly kActionOffer: 0;
        readonly kActionAnswer: 1;
        readonly kActionPRAnswer: 2;
        readonly kActionRollback: 3;
        readonly kIceGathering: 0;
        readonly kIceWaiting: 1;
        readonly kIceChecking: 2;
        readonly kIceConnected: 3;
        readonly kIceFailed: 4;
        readonly kNew: 0;
        readonly kNegotiating: 1;
        readonly kActive: 2;
        readonly kClosing: 3;
        readonly kClosed: 4;
        readonly kDataChannelReliable: 0;
        readonly kDataChannelPartialReliableRexmit: 1;
        readonly kDataChannelPartialReliableTimed: 2;
        readonly kNoError: 0;
        readonly kInvalidCandidate: 2;
        readonly kInvalidMediastreamTrack: 3;
        readonly kInvalidState: 4;
        readonly kInvalidSessionDescription: 5;
        readonly kIncompatibleSessionDescription: 6;
        readonly kIncompatibleMediaStreamTrack: 8;
        readonly kInternalError: 9;
        readonly kTypeError: 10;
        readonly kOperationError: 11;
        readonly kMaxErrorType: 11;
    };
    IUrlClassifierUITelemetry: {
        readonly name: 'IUrlClassifierUITelemetry';
        readonly number: 'a6c62ce5-3a95-41bb-b0f1-8cd4f4ca00e3';
        readonly WARNING_MALWARE_PAGE_TOP: 1;
        readonly WARNING_MALWARE_PAGE_TOP_WHY_BLOCKED: 2;
        readonly WARNING_MALWARE_PAGE_TOP_GET_ME_OUT_OF_HERE: 3;
        readonly WARNING_MALWARE_PAGE_TOP_IGNORE_WARNING: 4;
        readonly WARNING_MALWARE_PAGE_FRAME: 5;
        readonly WARNING_MALWARE_PAGE_FRAME_WHY_BLOCKED: 6;
        readonly WARNING_MALWARE_PAGE_FRAME_GET_ME_OUT_OF_HERE: 7;
        readonly WARNING_MALWARE_PAGE_FRAME_IGNORE_WARNING: 8;
        readonly WARNING_PHISHING_PAGE_TOP: 9;
        readonly WARNING_PHISHING_PAGE_TOP_WHY_BLOCKED: 10;
        readonly WARNING_PHISHING_PAGE_TOP_GET_ME_OUT_OF_HERE: 11;
        readonly WARNING_PHISHING_PAGE_TOP_IGNORE_WARNING: 12;
        readonly WARNING_PHISHING_PAGE_FRAME: 13;
        readonly WARNING_PHISHING_PAGE_FRAME_WHY_BLOCKED: 14;
        readonly WARNING_PHISHING_PAGE_FRAME_GET_ME_OUT_OF_HERE: 15;
        readonly WARNING_PHISHING_PAGE_FRAME_IGNORE_WARNING: 16;
        readonly WARNING_UNWANTED_PAGE_TOP: 17;
        readonly WARNING_UNWANTED_PAGE_TOP_WHY_BLOCKED: 18;
        readonly WARNING_UNWANTED_PAGE_TOP_GET_ME_OUT_OF_HERE: 19;
        readonly WARNING_UNWANTED_PAGE_TOP_IGNORE_WARNING: 20;
        readonly WARNING_UNWANTED_PAGE_FRAME: 21;
        readonly WARNING_UNWANTED_PAGE_FRAME_WHY_BLOCKED: 22;
        readonly WARNING_UNWANTED_PAGE_FRAME_GET_ME_OUT_OF_HERE: 23;
        readonly WARNING_UNWANTED_PAGE_FRAME_IGNORE_WARNING: 24;
        readonly WARNING_HARMFUL_PAGE_TOP: 25;
        readonly WARNING_HARMFUL_PAGE_TOP_WHY_BLOCKED: 26;
        readonly WARNING_HARMFUL_PAGE_TOP_GET_ME_OUT_OF_HERE: 27;
        readonly WARNING_HARMFUL_PAGE_TOP_IGNORE_WARNING: 28;
        readonly WARNING_HARMFUL_PAGE_FRAME: 29;
        readonly WARNING_HARMFUL_PAGE_FRAME_WHY_BLOCKED: 30;
        readonly WARNING_HARMFUL_PAGE_FRAME_GET_ME_OUT_OF_HERE: 31;
        readonly WARNING_HARMFUL_PAGE_FRAME_IGNORE_WARNING: 32;
    };
    nsIScriptableOK: {
        readonly name: 'nsIScriptableOK';
        readonly number: '93142a4f-e4cf-424a-b833-e638f87d2607';
    };
    nsIScriptableWithNotXPCOM: {
        readonly name: 'nsIScriptableWithNotXPCOM';
        readonly number: '237d01a3-771e-4c6e-adf9-c97f9aab2950';
    };
    nsISessionStoreFunctions: {
        readonly name: 'nsISessionStoreFunctions';
        readonly number: '1A060FBA-A19D-11E9-B7EB-580D0EDD8E6F';
    };
    amIAddonManagerStartup: {
        readonly name: 'amIAddonManagerStartup';
        readonly number: '01dfa47b-87e4-4135-877b-586d033e1b5d';
    };
    amIWebInstallPrompt: {
        readonly name: 'amIWebInstallPrompt';
        readonly number: '386906f1-4d18-45bf-bc81-5dcd68e42c3b';
    };
    extIWebNavigation: {
        readonly name: 'extIWebNavigation';
        readonly number: '5cc10dac-cab3-41dd-b4ce-55e27c43cc40';
    };
    imgICache: {
        readonly name: 'imgICache';
        readonly number: '';
    };
    imgIContainer: {
        readonly name: 'imgIContainer';
        readonly number: '';
        readonly TYPE_RASTER: 0;
        readonly TYPE_VECTOR: 1;
        readonly TYPE_REQUEST: 2;
        readonly FLAG_NONE: 0x0;
        readonly FLAG_SYNC_DECODE: 0x1;
        readonly FLAG_SYNC_DECODE_IF_FAST: 0x2;
        readonly FLAG_ASYNC_NOTIFY: 0x4;
        readonly FLAG_DECODE_NO_PREMULTIPLY_ALPHA: 0x8;
        readonly FLAG_DECODE_NO_COLORSPACE_CONVERSION: 0x10;
        readonly FLAG_CLAMP: 0x20;
        readonly FLAG_HIGH_QUALITY_SCALING: 0x40;
        readonly FLAG_BYPASS_SURFACE_CACHE: 0x80;
        readonly FLAG_FORCE_PRESERVEASPECTRATIO_NONE: 0x100;
        readonly FLAG_FORCE_UNIFORM_SCALING: 0x200;
        readonly FLAG_AVOID_REDECODE_FOR_SIZE: 0x400;
        readonly FLAG_DECODE_TO_SRGB_COLORSPACE: 0x800;
        readonly FLAG_RECORD_BLOB: 0x1000;
        readonly DECODE_FLAGS_DEFAULT: 0;
        readonly DECODE_FLAGS_FOR_REENCODE;
        readonly FRAME_FIRST: 0;
        readonly FRAME_CURRENT: 1;
        readonly FRAME_MAX_VALUE: 1;
        readonly kNormalAnimMode: 0;
        readonly kDontAnimMode: 1;
        readonly kLoopOnceAnimMode: 2;
    };
    imgIContainerDebug: {
        readonly name: 'imgIContainerDebug';
        readonly number: '52cbb839-6e63-4a70-b21a-1db4ca706c49';
    };
    imgIEncoder: {
        readonly name: 'imgIEncoder';
        readonly number: '4baa2d6e-fee7-42df-ae3f-5fbebc0c267c';
        readonly INPUT_FORMAT_RGB: 0;
        readonly INPUT_FORMAT_RGBA: 1;
        readonly INPUT_FORMAT_HOSTARGB: 2;
    };
    imgILoader: {
        readonly name: 'imgILoader';
        readonly number: '';
        readonly LOAD_CORS_ANONYMOUS;
        readonly LOAD_CORS_USE_CREDENTIALS;
    };
    imgINotificationObserver: {
        readonly name: 'imgINotificationObserver';
        readonly number: '';
        readonly SIZE_AVAILABLE: 1;
        readonly FRAME_UPDATE: 2;
        readonly FRAME_COMPLETE: 3;
        readonly LOAD_COMPLETE: 4;
        readonly DECODE_COMPLETE: 5;
        readonly DISCARD: 6;
        readonly UNLOCKED_DRAW: 7;
        readonly IS_ANIMATED: 8;
        readonly HAS_TRANSPARENCY: 9;
    };
    imgIRequest: {
        readonly name: 'imgIRequest';
        readonly number: '';
        readonly STATUS_NONE: 0x0;
        readonly STATUS_SIZE_AVAILABLE: 0x1;
        readonly STATUS_LOAD_COMPLETE: 0x2;
        readonly STATUS_ERROR: 0x4;
        readonly STATUS_FRAME_COMPLETE: 0x8;
        readonly STATUS_DECODE_COMPLETE: 0x10;
        readonly STATUS_IS_ANIMATED: 0x20;
        readonly STATUS_HAS_TRANSPARENCY: 0x40;
        readonly CATEGORY_FRAME_INIT;
        readonly CATEGORY_FRAME_STYLE;
        readonly CATEGORY_SIZE_QUERY;
        readonly CATEGORY_DISPLAY;
    };
    imgIScriptedNotificationObserver: {
        readonly name: 'imgIScriptedNotificationObserver';
        readonly number: '';
    };
    imgITools: {
        readonly name: 'imgITools';
        readonly number: '4c2383a4-931c-484d-8c4a-973590f66e3f';
    };
    imgIContainerCallback: {
        readonly name: 'imgIContainerCallback';
        readonly number: 'f195772c-a4c0-47ae-80ca-211e001c67be';
    };
    inIDeepTreeWalker: {
        readonly name: 'inIDeepTreeWalker';
        readonly number: '6657e8eb-b646-48e7-993e-cfa6e96415b4';
    };
    mozIAppServicesLogger: {
        readonly name: 'mozIAppServicesLogger';
        readonly number: '446dd837-fbb0-41e4-8221-f740f672b20d';
    };
    mozIVisitInfo: {
        readonly name: 'mozIVisitInfo';
        readonly number: '41e4ccc9-f0c8-4cd7-9753-7a38514b8488';
    };
    mozIPlaceInfo: {
        readonly name: 'mozIPlaceInfo';
        readonly number: 'ad83e137-c92a-4b7b-b67e-0a318811f91e';
    };
    mozIVisitInfoCallback: {
        readonly name: 'mozIVisitInfoCallback';
        readonly number: '1f266877-2859-418b-a11b-ec3ae4f4f93d';
    };
    mozIVisitedStatusCallback: {
        readonly name: 'mozIVisitedStatusCallback';
        readonly number: '994092bf-936f-449b-8dd6-0941e024360d';
    };
    mozIAsyncHistory: {
        readonly name: 'mozIAsyncHistory';
        readonly number: '1643EFD2-A329-4733-A39D-17069C8D3B2D';
    };
    mozIBridgedSyncEngineCallback: {
        readonly name: 'mozIBridgedSyncEngineCallback';
        readonly number: '9b7dd2a3-df99-4469-9ea9-61b222098695';
    };
    mozIBridgedSyncEngineApplyCallback: {
        readonly name: 'mozIBridgedSyncEngineApplyCallback';
        readonly number: '2776cdd5-799a-4009-b2f3-356d940a5244';
    };
    mozIBridgedSyncEngine: {
        readonly name: 'mozIBridgedSyncEngine';
        readonly number: '3b2b80be-c30e-4498-8065-01809cfe8d47';
    };
    mozIDOMWindow: {
        readonly name: 'mozIDOMWindow';
        readonly number: '';
    };
    mozIDOMWindowProxy: {
        readonly name: 'mozIDOMWindowProxy';
        readonly number: '';
    };
    mozIDownloadPlatform: {
        readonly name: 'mozIDownloadPlatform';
        readonly number: '9f556e4a-d9b3-46c3-9f8f-d0db1ac6c8c1';
        readonly ZONE_MY_COMPUTER: 0;
        readonly ZONE_INTRANET: 1;
        readonly ZONE_TRUSTED: 2;
        readonly ZONE_INTERNET: 3;
        readonly ZONE_RESTRICTED: 4;
    };
    mozIExtensionServiceWorkerInfo: {
        readonly name: 'mozIExtensionServiceWorkerInfo';
        readonly number: 'e6862533-8844-4207-a6ab-04748a29d859';
    };
    mozIExtensionListenerCallOptions: {
        readonly name: 'mozIExtensionListenerCallOptions';
        readonly number: '876d45db-5c1b-4c9b-9148-1c86b33d120b';
    };
    mozIExtensionEventListener: {
        readonly name: 'mozIExtensionEventListener';
        readonly number: 'e68e3c19-1b35-4112-8faa-5c5b84086a5b';
    };
    mozIExtensionAPIRequest: {
        readonly name: 'mozIExtensionAPIRequest';
        readonly number: '0fee1c8f-e363-46a6-bd0c-d3c3338e2534';
    };
    mozIExtensionAPIRequestResult: {
        readonly name: 'mozIExtensionAPIRequestResult';
        readonly number: '59fd4097-d88e-40fd-8664-fedd8ab67ab6';
    };
    mozIExtensionAPIRequestHandler: {
        readonly name: 'mozIExtensionAPIRequestHandler';
        readonly number: '0c61bd33-0557-43a2-9497-96c449f39e33';
    };
    mozIExtensionProcessScript: {
        readonly name: 'mozIExtensionProcessScript';
        readonly number: '6b09dc51-6caa-4ca7-9d6d-30c87258a630';
    };
    mozIExtensionStorageArea: {
        readonly name: 'mozIExtensionStorageArea';
        readonly number: 'd8eb3ff1-9b4b-435a-99ca-5b8cbaba2420';
        readonly SYNC_QUOTA_BYTES: 102400;
        readonly SYNC_QUOTA_BYTES_PER_ITEM: 8192;
        readonly SYNC_MAX_ITEMS: 512;
    };
    mozIConfigurableExtensionStorageArea: {
        readonly name: 'mozIConfigurableExtensionStorageArea';
        readonly number: '2b008295-1bcc-4610-84f1-ad4cab2fa9ee';
    };
    mozISyncedExtensionStorageArea: {
        readonly name: 'mozISyncedExtensionStorageArea';
        readonly number: '6dac82c9-1d8a-4893-8c0f-6e626aef802c';
    };
    mozIExtensionStorageListener: {
        readonly name: 'mozIExtensionStorageListener';
        readonly number: '8cb3c7e4-d0ca-4353-bccd-2673b4e11510';
    };
    mozIExtensionStorageCallback: {
        readonly name: 'mozIExtensionStorageCallback';
        readonly number: '870dca40-6602-4748-8493-c4253eb7f322';
    };
    mozIGeckoMediaPluginChromeService: {
        readonly name: 'mozIGeckoMediaPluginChromeService';
        readonly number: '32d35d21-181f-4630-8caa-a431e2ebad72';
    };
    mozIGeckoMediaPluginService: {
        readonly name: 'mozIGeckoMediaPluginService';
        readonly number: '44d362ae-937a-4803-bee6-f2512a0149d1';
    };
    mozIInterruptible: {
        readonly name: 'mozIInterruptible';
        readonly number: '1c06bfd3-76b1-46fa-a64a-db682d478374';
    };
    mozIJSSubScriptLoader: {
        readonly name: 'mozIJSSubScriptLoader';
        readonly number: '19533e7b-f321-4ef1-bc59-6e812dc2a733';
    };
    mozILocaleService: {
        readonly name: 'mozILocaleService';
        readonly number: 'C27F8983-B48B-4D1A-92D7-FEB8106F212D';
        readonly langNegStrategyFiltering: 0;
        readonly langNegStrategyMatching: 1;
        readonly langNegStrategyLookup: 2;
    };
    mozIMozIntl: {
        readonly name: 'mozIMozIntl';
        readonly number: '7f63279a-1a29-4ae6-9e7a-dc9684a23530';
    };
    mozIMozIntlHelper: {
        readonly name: 'mozIMozIntlHelper';
        readonly number: '189eaa7d-b29a-43a9-b1fb-7658990df940';
    };
    mozIOSPreferences: {
        readonly name: 'mozIOSPreferences';
        readonly number: '65944815-e9ae-48bd-a2bf-f1108720950c';
        readonly dateTimeFormatStyleNone: 0;
        readonly dateTimeFormatStyleShort: 1;
        readonly dateTimeFormatStyleMedium: 2;
        readonly dateTimeFormatStyleLong: 3;
        readonly dateTimeFormatStyleFull: 4;
    };
    mozIPersonalDictionary: {
        readonly name: 'mozIPersonalDictionary';
        readonly number: '';
    };
    mozIPlacesAutoComplete: {
        readonly name: 'mozIPlacesAutoComplete';
        readonly number: '61b6348a-09e1-4810-8057-f8cb3cec6ef8';
        readonly MATCH_ANYWHERE: 0;
        readonly MATCH_BOUNDARY_ANYWHERE: 1;
        readonly MATCH_BOUNDARY: 2;
        readonly MATCH_BEGINNING: 3;
        readonly MATCH_ANYWHERE_UNMODIFIED: 4;
        readonly MATCH_BEGINNING_CASE_SENSITIVE: 5;
        readonly BEHAVIOR_HISTORY;
        readonly BEHAVIOR_BOOKMARK;
        readonly BEHAVIOR_TAG;
        readonly BEHAVIOR_TITLE;
        readonly BEHAVIOR_URL;
        readonly BEHAVIOR_TYPED;
        readonly BEHAVIOR_JAVASCRIPT;
        readonly BEHAVIOR_OPENPAGE;
        readonly BEHAVIOR_RESTRICT;
        readonly BEHAVIOR_SEARCH;
    };
    mozIPlacesPendingOperation: {
        readonly name: 'mozIPlacesPendingOperation';
        readonly number: '';
    };
    mozIRemoteLazyInputStream: {
        readonly name: 'mozIRemoteLazyInputStream';
        readonly number: '4125585f-b0c2-4964-a83c-4b0d99f26d49';
    };
    mozISandboxReport: {
        readonly name: 'mozISandboxReport';
        readonly number: 'ed1e84d3-3346-42e1-b28c-e76a77f549f0';
    };
    mozISandboxReportArray: {
        readonly name: 'mozISandboxReportArray';
        readonly number: '6e8ff6e5-05c9-42d3-853d-40523fd86a50';
    };
    mozISandboxReporter: {
        readonly name: 'mozISandboxReporter';
        readonly number: '8535bdf7-6d9e-4853-acf9-a146449c4a3b';
    };
    mozISandboxSettings: {
        readonly name: 'mozISandboxSettings';
        readonly number: '5516303d-9007-45a0-94b9-940ef134a6e2';
    };
    mozISandboxTest: {
        readonly name: 'mozISandboxTest';
        readonly number: '2306c118-3544-4674-9222-670b88dc07a9';
    };
    mozIServicesLogSink: {
        readonly name: 'mozIServicesLogSink';
        readonly number: 'c92bfe0d-50b7-4a7f-9686-fe5335a696b9';
        readonly LEVEL_OFF: 0;
        readonly LEVEL_ERROR: 1;
        readonly LEVEL_WARN: 2;
        readonly LEVEL_INFO: 3;
        readonly LEVEL_DEBUG: 4;
        readonly LEVEL_TRACE: 5;
    };
    mozISpellCheckingEngine: {
        readonly name: 'mozISpellCheckingEngine';
        readonly number: '8ba643a4-7ddc-4662-b976-7ec123843f10';
    };
    mozIStorageAsyncConnection: {
        readonly name: 'mozIStorageAsyncConnection';
        readonly number: '';
        readonly TRANSACTION_DEFAULT;
        readonly TRANSACTION_DEFERRED: 0;
        readonly TRANSACTION_IMMEDIATE: 1;
        readonly TRANSACTION_EXCLUSIVE: 2;
    };
    mozIStorageAsyncStatement: {
        readonly name: 'mozIStorageAsyncStatement';
        readonly number: '';
    };
    mozIStorageBaseStatement: {
        readonly name: 'mozIStorageBaseStatement';
        readonly number: '';
        readonly MOZ_STORAGE_STATEMENT_INVALID: 0;
        readonly MOZ_STORAGE_STATEMENT_READY: 1;
        readonly MOZ_STORAGE_STATEMENT_EXECUTING: 2;
    };
    mozIStorageBindingParams: {
        readonly name: 'mozIStorageBindingParams';
        readonly number: '';
    };
    mozIStorageBindingParamsArray: {
        readonly name: 'mozIStorageBindingParamsArray';
        readonly number: '67eea5c3-4881-41ff-b0fe-09f2356aeadb';
    };
    mozIStorageCompletionCallback: {
        readonly name: 'mozIStorageCompletionCallback';
        readonly number: '';
    };
    mozIStorageConnection: {
        readonly name: 'mozIStorageConnection';
        readonly number: '';
    };
    mozIStorageError: {
        readonly name: 'mozIStorageError';
        readonly number: '';
        readonly ERROR: 1;
        readonly INTERNAL: 2;
        readonly PERM: 3;
        readonly ABORT: 4;
        readonly BUSY: 5;
        readonly LOCKED: 6;
        readonly NOMEM: 7;
        readonly READONLY: 8;
        readonly INTERRUPT: 9;
        readonly IOERR: 10;
        readonly CORRUPT: 11;
        readonly FULL: 13;
        readonly CANTOPEN: 14;
        readonly EMPTY: 16;
        readonly SCHEMA: 17;
        readonly TOOBIG: 18;
        readonly CONSTRAINT: 19;
        readonly MISMATCH: 20;
        readonly MISUSE: 21;
        readonly NOLFS: 22;
        readonly AUTH: 23;
        readonly FORMAT: 24;
        readonly RANGE: 25;
        readonly NOTADB: 26;
    };
    mozIStorageFunction: {
        readonly name: 'mozIStorageFunction';
        readonly number: '9ff02465-21cb-49f3-b975-7d5b38ceec73';
    };
    mozIStoragePendingStatement: {
        readonly name: 'mozIStoragePendingStatement';
        readonly number: '';
    };
    mozIStorageProgressHandler: {
        readonly name: 'mozIStorageProgressHandler';
        readonly number: 'a3a6fcd4-bf89-4208-a837-bf2a73afd30c';
    };
    mozIStorageResultSet: {
        readonly name: 'mozIStorageResultSet';
        readonly number: '';
    };
    mozIStorageRow: {
        readonly name: 'mozIStorageRow';
        readonly number: '62d1b6bd-cbfe-4f9b-aee1-0ead4af4e6dc';
    };
    mozIStorageService: {
        readonly name: 'mozIStorageService';
        readonly number: '07b6b2f5-6d97-47b4-9584-e65bc467fe9e';
        readonly OPEN_DEFAULT: 0;
        readonly OPEN_SHARED;
        readonly OPEN_READONLY;
        readonly OPEN_IGNORE_LOCKING_MODE;
        readonly CONNECTION_DEFAULT: 0;
        readonly CONNECTION_INTERRUPTIBLE;
    };
    mozIStorageStatement: {
        readonly name: 'mozIStorageStatement';
        readonly number: '5f567c35-6c32-4140-828c-683ea49cfd3a';
        readonly VALUE_TYPE_NULL: 0;
        readonly VALUE_TYPE_INTEGER: 1;
        readonly VALUE_TYPE_FLOAT: 2;
        readonly VALUE_TYPE_TEXT: 3;
        readonly VALUE_TYPE_BLOB: 4;
    };
    mozIStorageStatementCallback: {
        readonly name: 'mozIStorageStatementCallback';
        readonly number: '';
        readonly REASON_FINISHED: 0;
        readonly REASON_CANCELED: 1;
        readonly REASON_ERROR: 2;
    };
    mozIStorageVacuumParticipant: {
        readonly name: 'mozIStorageVacuumParticipant';
        readonly number: '8f367508-1d9a-4d3f-be0c-ac11b6dd7dbf';
    };
    mozIStorageValueArray: {
        readonly name: 'mozIStorageValueArray';
        readonly number: '6e6306f4-ffa7-40f5-96ca-36159ce8f431';
        readonly VALUE_TYPE_NULL: 0;
        readonly VALUE_TYPE_INTEGER: 1;
        readonly VALUE_TYPE_FLOAT: 2;
        readonly VALUE_TYPE_TEXT: 3;
        readonly VALUE_TYPE_BLOB: 4;
    };
    mozISyncedBookmarksMirrorProgressListener: {
        readonly name: 'mozISyncedBookmarksMirrorProgressListener';
        readonly number: '6239ffe3-6ffd-49ac-8b1d-958407395bf9';
    };
    mozISyncedBookmarksMirrorCallback: {
        readonly name: 'mozISyncedBookmarksMirrorCallback';
        readonly number: 'd23fdfea-92c8-409d-a516-08ae395d578f';
    };
    mozISyncedBookmarksMirrorLogger: {
        readonly name: 'mozISyncedBookmarksMirrorLogger';
        readonly number: '37485984-a6ab-46e3-9b0c-e8b613413ef3';
        readonly LEVEL_OFF: 0;
        readonly LEVEL_ERROR: 1;
        readonly LEVEL_WARN: 2;
        readonly LEVEL_DEBUG: 3;
        readonly LEVEL_TRACE: 4;
    };
    mozISyncedBookmarksMerger: {
        readonly name: 'mozISyncedBookmarksMerger';
        readonly number: 'f0a6217d-8344-4e68-9995-bbf5554be86e';
        readonly KIND_BOOKMARK: 1;
        readonly KIND_QUERY: 2;
        readonly KIND_FOLDER: 3;
        readonly KIND_LIVEMARK: 4;
        readonly KIND_SEPARATOR: 5;
        readonly VALIDITY_VALID: 1;
        readonly VALIDITY_REUPLOAD: 2;
        readonly VALIDITY_REPLACE: 3;
    };
    mozITXTToHTMLConv: {
        readonly name: 'mozITXTToHTMLConv';
        readonly number: '77c0e42a-1dd2-11b2-8ebf-edc6606f2f4b';
        readonly kEntities: 0;
        readonly kURLs;
        readonly kGlyphSubstitution;
        readonly kStructPhrase;
    };
    mozITestInterfaceJS: {
        readonly name: 'mozITestInterfaceJS';
        readonly number: '9eeb2c12-ddd9-4734-8cfb-c0cdfb136e07';
    };
    mozIThirdPartyUtil: {
        readonly name: 'mozIThirdPartyUtil';
        readonly number: 'fd82700e-ffb4-4932-b7d6-08f0b5697dda';
    };
    nsIASN1Tree: {
        readonly name: 'nsIASN1Tree';
        readonly number: 'de142307-7b88-4e0a-b232-250f310e25d8';
    };
    nsIAboutModule: {
        readonly name: 'nsIAboutModule';
        readonly number: 'c0c19db9-1b5a-4ac5-b656-ed6f8149fa48';
        readonly URI_SAFE_FOR_UNTRUSTED_CONTENT;
        readonly ALLOW_SCRIPT;
        readonly HIDE_FROM_ABOUTABOUT;
        readonly ENABLE_INDEXED_DB;
        readonly URI_CAN_LOAD_IN_CHILD;
        readonly URI_MUST_LOAD_IN_CHILD;
        readonly MAKE_UNLINKABLE;
        readonly MAKE_LINKABLE;
        readonly URI_CAN_LOAD_IN_PRIVILEGEDABOUT_PROCESS;
        readonly URI_MUST_LOAD_IN_EXTENSION_PROCESS;
        readonly ALLOW_UNSANITIZED_CONTENT;
        readonly IS_SECURE_CHROME_UI;
    };
    nsIAboutNewTabService: {
        readonly name: 'nsIAboutNewTabService';
        readonly number: 'dfcd2adc-7867-4d3a-ba70-17501f208142';
    };
    nsIInstalledApplication: {
        readonly name: 'nsIInstalledApplication';
        readonly number: '063813a0-85d8-4e77-80ea-b61292c0493d';
    };
    nsIAboutThirdParty: {
        readonly name: 'nsIAboutThirdParty';
        readonly number: 'd33ff086-b328-4ae6-aaf5-52d41aa5df38';
        readonly ModuleType_Unknown;
        readonly ModuleType_IME;
        readonly ModuleType_ShellExtension;
        readonly ModuleType_BlockedByUser;
        readonly ModuleType_BlockedByUserAtLaunch;
    };
    nsIAddonPolicyService: {
        readonly name: 'nsIAddonPolicyService';
        readonly number: '8a034ef9-9d14-4c5d-8319-06c1ab574baa';
    };
    nsIAddonContentPolicy: {
        readonly name: 'nsIAddonContentPolicy';
        readonly number: '7a4fe60b-9131-45f5-83f3-dc63b5d71a5d';
        readonly CSP_ALLOW_ANY: 0xFFFF;
        readonly CSP_ALLOW_LOCALHOST;
        readonly CSP_ALLOW_EVAL;
        readonly CSP_ALLOW_REMOTE;
        readonly CSP_ALLOW_WASM;
    };
    nsIAlertNotificationImageListener: {
        readonly name: 'nsIAlertNotificationImageListener';
        readonly number: 'a71a637d-de1d-47c6-a8d2-c60b2596f471';
    };
    nsIAlertAction: {
        readonly name: 'nsIAlertAction';
        readonly number: 'a054c2c9-2787-4686-859c-45609d790056';
    };
    nsIAlertNotification: {
        readonly name: 'nsIAlertNotification';
        readonly number: 'cf2e4cb6-4b8f-4eca-aea9-d51a8f9f7a50';
    };
    nsIAlertsService: {
        readonly name: 'nsIAlertsService';
        readonly number: 'f7a36392-d98b-4141-a7d7-4e46642684e3';
    };
    nsIAlertsDoNotDisturb: {
        readonly name: 'nsIAlertsDoNotDisturb';
        readonly number: 'c5d63e3a-259d-45a8-b964-8377967cb4d2';
    };
    nsIAlertsIconData: {
        readonly name: 'nsIAlertsIconData';
        readonly number: 'fc6d7f0a-0cf6-4268-8c71-ab640842b9b1';
    };
    nsIAlertsIconURI: {
        readonly name: 'nsIAlertsIconURI';
        readonly number: 'f3c82915-bf60-41ea-91ce-6c46b22e381a';
    };
    nsIAndroidEventCallback: {
        readonly name: 'nsIAndroidEventCallback';
        readonly number: 'e64c39b8-b8ec-477d-aef5-89d517ff9219';
    };
    nsIAndroidEventFinalizer: {
        readonly name: 'nsIAndroidEventFinalizer';
        readonly number: '819ee2db-d3b8-46dd-a476-40f89c49133c';
    };
    nsIAndroidEventListener: {
        readonly name: 'nsIAndroidEventListener';
        readonly number: '73569a75-78eb-4c7f-82b9-2d4f5ccf44c3';
    };
    nsIAndroidEventDispatcher: {
        readonly name: 'nsIAndroidEventDispatcher';
        readonly number: 'e98bf792-4145-411e-b298-8219d9b03817';
    };
    nsIAndroidView: {
        readonly name: 'nsIAndroidView';
        readonly number: '60a78a94-6117-432f-9d49-304913a931c5';
    };
    nsIAndroidBridge: {
        readonly name: 'nsIAndroidBridge';
        readonly number: '1beb70d3-70f3-4742-98cc-a3d301b26c0c';
    };
    nsIAppShell: {
        readonly name: 'nsIAppShell';
        readonly number: '';
    };
    nsIAppShellService: {
        readonly name: 'nsIAppShellService';
        readonly number: '19266025-354c-4bb9-986b-3483b2b1cdef';
        readonly SIZE_TO_CONTENT;
    };
    nsIAppStartup: {
        readonly name: 'nsIAppStartup';
        readonly number: '6621f6d5-6c04-4a0e-9e74-447db221484e';
        readonly eConsiderQuit: 0x01;
        readonly eAttemptQuit: 0x02;
        readonly eForceQuit: 0x03;
        readonly eRestart: 0x10;
        readonly eSilently: 0x100;
    };
    nsIAppWindow: {
        readonly name: 'nsIAppWindow';
        readonly number: '';
        readonly lowestZ: 0;
        readonly loweredZ: 4;
        readonly normalZ: 5;
        readonly raisedZ: 6;
        readonly highestZ: 9;
    };
    nsIApplicationChooserFinishedCallback: {
        readonly name: 'nsIApplicationChooserFinishedCallback';
        readonly number: '8144404d-e6c7-4861-bcca-47de912ee811';
    };
    nsIApplicationChooser: {
        readonly name: 'nsIApplicationChooser';
        readonly number: 'f7a149da-612a-46ba-8a2f-54786fc28791';
    };
    nsIApplicationReputationService: {
        readonly name: 'nsIApplicationReputationService';
        readonly number: 'c9f03479-fd68-4393-acb2-c88d4f563174';
        readonly VERDICT_SAFE: 0;
        readonly VERDICT_DANGEROUS: 1;
        readonly VERDICT_UNCOMMON: 2;
        readonly VERDICT_POTENTIALLY_UNWANTED: 3;
        readonly VERDICT_DANGEROUS_HOST: 4;
    };
    nsIApplicationReputationQuery: {
        readonly name: 'nsIApplicationReputationQuery';
        readonly number: '812d7509-a9a3-446e-a66f-3ed8cc91ebd0';
    };
    nsIApplicationReputationCallback: {
        readonly name: 'nsIApplicationReputationCallback';
        readonly number: '9a228470-cfe5-11e2-8b8b-0800200c9a66';
    };
    nsIArray: {
        readonly name: 'nsIArray';
        readonly number: '';
    };
    nsIArrayBufferInputStream: {
        readonly name: 'nsIArrayBufferInputStream';
        readonly number: '3014dde6-aa1c-41db-87d0-48764a3710f6';
    };
    nsIArrayExtensions: {
        readonly name: 'nsIArrayExtensions';
        readonly number: '261d442e-050c-453d-8aaa-b3f23bcc528b';
    };
    nsIAsyncInputStream: {
        readonly name: 'nsIAsyncInputStream';
        readonly number: '';
        readonly WAIT_CLOSURE_ONLY;
    };
    nsIInputStreamCallback: {
        readonly name: 'nsIInputStreamCallback';
        readonly number: '';
    };
    nsIAsyncOutputStream: {
        readonly name: 'nsIAsyncOutputStream';
        readonly number: '';
        readonly WAIT_CLOSURE_ONLY;
    };
    nsIOutputStreamCallback: {
        readonly name: 'nsIOutputStreamCallback';
        readonly number: '40dbcdff-9053-42c5-a57c-3ec910d0f148';
    };
    nsIAsyncShutdownBlocker: {
        readonly name: 'nsIAsyncShutdownBlocker';
        readonly number: '4ef43f29-6715-4b57-a750-2ff83695ddce';
    };
    nsIAsyncShutdownClient: {
        readonly name: 'nsIAsyncShutdownClient';
        readonly number: '';
    };
    nsIAsyncShutdownCompletionCallback: {
        readonly name: 'nsIAsyncShutdownCompletionCallback';
        readonly number: '910c9309-1da0-4dd0-8bdb-a325a38c604e';
    };
    nsIAsyncShutdownBarrier: {
        readonly name: 'nsIAsyncShutdownBarrier';
        readonly number: '50fa8a86-9c91-4256-8389-17d310adec90';
    };
    nsIAsyncShutdownService: {
        readonly name: 'nsIAsyncShutdownService';
        readonly number: 'db365c78-c860-4e64-9a63-25b73f89a016';
    };
    nsIAsyncStreamCopier: {
        readonly name: 'nsIAsyncStreamCopier';
        readonly number: '5a19ca27-e041-4aca-8287-eb248d4c50c0';
    };
    nsIAsyncStreamCopier2: {
        readonly name: 'nsIAsyncStreamCopier2';
        readonly number: 'a5b2decf-4ede-4801-8b38-e5fe5db46bf2';
    };
    nsIAsyncVerifyRedirectCallback: {
        readonly name: 'nsIAsyncVerifyRedirectCallback';
        readonly number: '';
    };
    nsISuspendedTypes: {
        readonly name: 'nsISuspendedTypes';
        readonly number: '2822a840-f009-11e5-a837-0800200c9a66';
        readonly NONE_SUSPENDED: 0;
        readonly SUSPENDED_BLOCK: 1;
    };
    nsIAudioChannelAgentCallback: {
        readonly name: 'nsIAudioChannelAgentCallback';
        readonly number: '15c05894-408e-4798-b527-a8c32d9c5f8c';
    };
    nsIAudioChannelAgent: {
        readonly name: 'nsIAudioChannelAgent';
        readonly number: '4d212770-5d7b-446f-9394-632e351d96ee';
        readonly AUDIO_AGENT_STATE_NORMAL: 0;
        readonly AUDIO_AGENT_STATE_MUTED: 1;
        readonly AUDIO_AGENT_STATE_FADED: 2;
    };
    nsIAudioDeviceInfo: {
        readonly name: 'nsIAudioDeviceInfo';
        readonly number: 'feb979a8-f8cc-4522-9dff-6c055ca50762';
        readonly TYPE_UNKNOWN: 0;
        readonly TYPE_INPUT: 1;
        readonly TYPE_OUTPUT: 2;
        readonly STATE_DISABLED: 0;
        readonly STATE_UNPLUGGED: 1;
        readonly STATE_ENABLED: 2;
        readonly PREF_NONE: 0x00;
        readonly PREF_MULTIMEDIA: 0x01;
        readonly PREF_VOICE: 0x02;
        readonly PREF_NOTIFICATION: 0x04;
        readonly PREF_ALL: 0x0F;
        readonly FMT_S16LE: 0x0010;
        readonly FMT_S16BE: 0x0020;
        readonly FMT_F32LE: 0x1000;
        readonly FMT_F32BE: 0x2000;
    };
    nsIAuthInformation: {
        readonly name: 'nsIAuthInformation';
        readonly number: '';
        readonly AUTH_HOST: 1;
        readonly AUTH_PROXY: 2;
        readonly NEED_DOMAIN: 4;
        readonly ONLY_PASSWORD: 8;
        readonly PREVIOUS_FAILED: 16;
        readonly CROSS_ORIGIN_SUB_RESOURCE: 32;
    };
    nsIAuthModule: {
        readonly name: 'nsIAuthModule';
        readonly number: '6e35dbc0-49ef-4e2c-b1ea-b72ec64450a2';
        readonly REQ_DEFAULT: 0;
        readonly REQ_MUTUAL_AUTH;
        readonly REQ_DELEGATE;
        readonly REQ_PROXY_AUTH;
        readonly NTLM_MODULE_SAMBA_AUTH_PROXY: 0;
        readonly NTLM_MODULE_SAMBA_AUTH_DIRECT: 1;
        readonly NTLM_MODULE_WIN_API_PROXY: 2;
        readonly NTLM_MODULE_WIN_API_DIRECT: 3;
        readonly NTLM_MODULE_GENERIC_PROXY: 4;
        readonly NTLM_MODULE_GENERIC_DIRECT: 5;
        readonly NTLM_MODULE_KERBEROS_PROXY: 6;
        readonly NTLM_MODULE_KERBEROS_DIRECT: 7;
    };
    nsIAuthPrompt: {
        readonly name: 'nsIAuthPrompt';
        readonly number: '';
        readonly SAVE_PASSWORD_NEVER: 0;
        readonly SAVE_PASSWORD_FOR_SESSION: 1;
        readonly SAVE_PASSWORD_PERMANENTLY: 2;
    };
    nsIAuthPrompt2: {
        readonly name: 'nsIAuthPrompt2';
        readonly number: '';
        readonly LEVEL_NONE: 0;
        readonly LEVEL_PW_ENCRYPTED: 1;
        readonly LEVEL_SECURE: 2;
    };
    nsIAuthPromptAdapterFactory: {
        readonly name: 'nsIAuthPromptAdapterFactory';
        readonly number: '60e46383-bb9a-4860-8962-80d9c5c05ddc';
    };
    nsIAuthPromptCallback: {
        readonly name: 'nsIAuthPromptCallback';
        readonly number: '';
    };
    nsIAuthPromptProvider: {
        readonly name: 'nsIAuthPromptProvider';
        readonly number: 'bd9dc0fa-68ce-47d0-8859-6418c2ae8576';
        readonly PROMPT_NORMAL: 0;
        readonly PROMPT_PROXY: 1;
    };
    nsIAutoCompleteController: {
        readonly name: 'nsIAutoCompleteController';
        readonly number: 'ff9f8465-204a-47a6-b3c9-0628b3856684';
        readonly STATUS_NONE: 1;
        readonly STATUS_SEARCHING: 2;
        readonly STATUS_COMPLETE_NO_MATCH: 3;
        readonly STATUS_COMPLETE_MATCH: 4;
    };
    nsIAutoCompleteInput: {
        readonly name: 'nsIAutoCompleteInput';
        readonly number: '';
    };
    nsIAutoCompletePopup: {
        readonly name: 'nsIAutoCompletePopup';
        readonly number: '';
        readonly INVALIDATE_REASON_NEW_RESULT: 0;
        readonly INVALIDATE_REASON_DELETE: 1;
    };
    nsIAutoCompleteResult: {
        readonly name: 'nsIAutoCompleteResult';
        readonly number: '';
        readonly RESULT_IGNORED: 1;
        readonly RESULT_FAILURE: 2;
        readonly RESULT_NOMATCH: 3;
        readonly RESULT_SUCCESS: 4;
        readonly RESULT_NOMATCH_ONGOING: 5;
        readonly RESULT_SUCCESS_ONGOING: 6;
    };
    nsIAutoCompleteSearch: {
        readonly name: 'nsIAutoCompleteSearch';
        readonly number: 'DE8DB85F-C1DE-4d87-94BA-7844890F91FE';
    };
    nsIAutoCompleteObserver: {
        readonly name: 'nsIAutoCompleteObserver';
        readonly number: '8bd1dbbc-dcce-4007-9afa-b551eb687b61';
    };
    nsIAutoCompleteSearchDescriptor: {
        readonly name: 'nsIAutoCompleteSearchDescriptor';
        readonly number: '4c3e7462-fbfb-4310-8f4b-239238392b75';
        readonly SEARCH_TYPE_DELAYED: 0;
        readonly SEARCH_TYPE_IMMEDIATE: 1;
    };
    nsIAutoCompleteSimpleResult: {
        readonly name: 'nsIAutoCompleteSimpleResult';
        readonly number: '23de9c96-becb-4d0d-a9bb-1d131ce361b5';
    };
    nsIAutoCompleteSimpleResultListener: {
        readonly name: 'nsIAutoCompleteSimpleResultListener';
        readonly number: '004efdc5-1989-4874-8a7a-345bf2fa33af';
    };
    nsIAutoCompleteSimpleSearch: {
        readonly name: 'nsIAutoCompleteSimpleSearch';
        readonly number: 'dc185a77-ba88-4caa-8f16-465253f7599a';
    };
    nsIAutoplay: {
        readonly name: 'nsIAutoplay';
        readonly number: '048a24f6-c4d6-47bc-bea2-f6038d1db80a';
        readonly ALLOWED: 0;
        readonly BLOCKED: 1;
        readonly BLOCKED_ALL: 5;
    };
    nsITabUnloader: {
        readonly name: 'nsITabUnloader';
        readonly number: '2e530956-6054-464f-9f4c-0ae6f8de5523';
    };
    nsIAvailableMemoryWatcherBase: {
        readonly name: 'nsIAvailableMemoryWatcherBase';
        readonly number: 'b0b5701e-239d-49db-9009-37e89f86441c';
    };
    nsIBFCacheEntry: {
        readonly name: 'nsIBFCacheEntry';
        readonly number: '';
    };
    nsIBackgroundChannelRegistrar: {
        readonly name: 'nsIBackgroundChannelRegistrar';
        readonly number: '8acaa9b1-f0c4-4ade-baeb-39b0d4b96e5b';
    };
    nsIBackgroundFileSaver: {
        readonly name: 'nsIBackgroundFileSaver';
        readonly number: 'c43544a4-682c-4262-b407-2453d26e660d';
    };
    nsIBackgroundFileSaverObserver: {
        readonly name: 'nsIBackgroundFileSaverObserver';
        readonly number: 'ee7058c3-6e54-4411-b76b-3ce87b76fcb6';
    };
    nsIBackgroundTasks: {
        readonly name: 'nsIBackgroundTasks';
        readonly number: '353dccb8-a863-49e4-941b-007382eac168';
    };
    nsIBackgroundTasksManager: {
        readonly name: 'nsIBackgroundTasksManager';
        readonly number: '4d48c536-e16f-4699-8f9c-add4f28f92f0';
    };
    nsIBackgroundTasksRunner: {
        readonly name: 'nsIBackgroundTasksRunner';
        readonly number: '8cd92fce-1ec3-470a-ad09-c0de9d98497e';
    };
    nsIBaseWindow: {
        readonly name: 'nsIBaseWindow';
        readonly number: '';
        readonly eRepaint: 1;
        readonly eDelayResize: 2;
    };
    nsIBidiKeyboard: {
        readonly name: 'nsIBidiKeyboard';
        readonly number: '288dae24-76e2-43a3-befe-9d9fabe8014e';
    };
    nsIBinaryHttpRequest: {
        readonly name: 'nsIBinaryHttpRequest';
        readonly number: 'f6f899cc-683a-43da-9206-0eb0c09cc758';
    };
    nsIBinaryHttpResponse: {
        readonly name: 'nsIBinaryHttpResponse';
        readonly number: '6ca85d9c-cdc5-45d4-9adc-005abedce9c9';
    };
    nsIBinaryHttp: {
        readonly name: 'nsIBinaryHttp';
        readonly number: 'b43b3f73-8160-4ab2-9f5d-4129a9708081';
    };
    nsIBinaryInputStream: {
        readonly name: 'nsIBinaryInputStream';
        readonly number: '899b826b-2eb3-469c-8b31-4c29f5d341a6';
    };
    nsIBinaryOutputStream: {
        readonly name: 'nsIBinaryOutputStream';
        readonly number: '204ee610-8765-11d3-90cf-0040056a906e';
    };
    nsIBits: {
        readonly name: 'nsIBits';
        readonly number: '495d6f3d-9748-4d30-8ce5-0290c0001edf';
        readonly ERROR_TYPE_SUCCESS: 0;
        readonly ERROR_TYPE_UNKNOWN: 1;
        readonly ERROR_TYPE_METHOD_THREW: 2;
        readonly ERROR_TYPE_METHOD_TIMEOUT: 3;
        readonly ERROR_TYPE_NULL_ARGUMENT: 4;
        readonly ERROR_TYPE_INVALID_ARGUMENT: 5;
        readonly ERROR_TYPE_NOT_INITIALIZED: 6;
        readonly ERROR_TYPE_NO_UTF8_CONVERSION: 7;
        readonly ERROR_TYPE_INVALID_GUID: 8;
        readonly ERROR_TYPE_PIPE_NOT_CONNECTED: 9;
        readonly ERROR_TYPE_PIPE_TIMEOUT: 10;
        readonly ERROR_TYPE_PIPE_BAD_WRITE_COUNT: 11;
        readonly ERROR_TYPE_PIPE_API_ERROR: 12;
        readonly ERROR_TYPE_FAILED_TO_CREATE_BITS_JOB: 13;
        readonly ERROR_TYPE_FAILED_TO_ADD_FILE_TO_JOB: 14;
        readonly ERROR_TYPE_FAILED_TO_APPLY_BITS_JOB_SETTINGS: 15;
        readonly ERROR_TYPE_FAILED_TO_RESUME_BITS_JOB: 16;
        readonly ERROR_TYPE_OTHER_BITS_ERROR: 17;
        readonly ERROR_TYPE_OTHER_BITS_CLIENT_ERROR: 18;
        readonly ERROR_TYPE_BITS_JOB_NOT_FOUND: 19;
        readonly ERROR_TYPE_FAILED_TO_GET_BITS_JOB: 20;
        readonly ERROR_TYPE_FAILED_TO_SUSPEND_BITS_JOB: 21;
        readonly ERROR_TYPE_FAILED_TO_COMPLETE_BITS_JOB: 22;
        readonly ERROR_TYPE_PARTIALLY_COMPLETED_BITS_JOB: 23;
        readonly ERROR_TYPE_FAILED_TO_CANCEL_BITS_JOB: 24;
        readonly ERROR_TYPE_MISSING_RESULT_DATA: 25;
        readonly ERROR_TYPE_MISSING_CALLBACK: 26;
        readonly ERROR_TYPE_CALLBACK_ON_WRONG_THREAD: 27;
        readonly ERROR_TYPE_MISSING_BITS_SERVICE: 28;
        readonly ERROR_TYPE_BITS_SERVICE_ON_WRONG_THREAD: 29;
        readonly ERROR_TYPE_MISSING_BITS_REQUEST: 30;
        readonly ERROR_TYPE_BITS_REQUEST_ON_WRONG_THREAD: 31;
        readonly ERROR_TYPE_MISSING_OBSERVER: 32;
        readonly ERROR_TYPE_OBSERVER_ON_WRONG_THREAD: 33;
        readonly ERROR_TYPE_MISSING_CONTEXT: 34;
        readonly ERROR_TYPE_CONTEXT_ON_WRONG_THREAD: 35;
        readonly ERROR_TYPE_FAILED_TO_START_THREAD: 36;
        readonly ERROR_TYPE_FAILED_TO_CONSTRUCT_TASK_RUNNABLE: 37;
        readonly ERROR_TYPE_FAILED_TO_DISPATCH_RUNNABLE: 38;
        readonly ERROR_TYPE_TRANSFER_ALREADY_COMPLETE: 39;
        readonly ERROR_TYPE_OPERATION_ALREADY_IN_PROGRESS: 40;
        readonly ERROR_TYPE_MISSING_BITS_CLIENT: 41;
        readonly ERROR_TYPE_FAILED_TO_GET_JOB_STATUS: 42;
        readonly ERROR_TYPE_BITS_STATE_ERROR: 43;
        readonly ERROR_TYPE_BITS_STATE_TRANSIENT_ERROR: 44;
        readonly ERROR_TYPE_BITS_STATE_CANCELLED: 45;
        readonly ERROR_TYPE_BITS_STATE_UNEXPECTED: 46;
        readonly ERROR_TYPE_VERIFICATION_FAILURE: 47;
        readonly ERROR_TYPE_ACCESS_DENIED_EXPECTED: 48;
        readonly ERROR_TYPE_FAILED_TO_CONNECT_TO_BCM: 49;
        readonly ERROR_TYPE_USE_AFTER_REQUEST_SHUTDOWN: 50;
        readonly ERROR_TYPE_BROWSER_SHUTTING_DOWN: 51;
        readonly ERROR_ACTION_UNKNOWN: 1;
        readonly ERROR_ACTION_NONE: 2;
        readonly ERROR_ACTION_START_DOWNLOAD: 3;
        readonly ERROR_ACTION_MONITOR_DOWNLOAD: 4;
        readonly ERROR_ACTION_CHANGE_MONITOR_INTERVAL: 5;
        readonly ERROR_ACTION_CANCEL: 6;
        readonly ERROR_ACTION_SET_PRIORITY: 7;
        readonly ERROR_ACTION_COMPLETE: 8;
        readonly ERROR_ACTION_SUSPEND: 9;
        readonly ERROR_ACTION_RESUME: 10;
        readonly ERROR_ACTION_SET_NO_PROGRESS_TIMEOUT: 11;
        readonly ERROR_STAGE_UNKNOWN: 1;
        readonly ERROR_STAGE_PRETASK: 2;
        readonly ERROR_STAGE_COMMAND_THREAD: 3;
        readonly ERROR_STAGE_AGENT_COMMUNICATION: 4;
        readonly ERROR_STAGE_BITS_CLIENT: 5;
        readonly ERROR_STAGE_MAIN_THREAD: 6;
        readonly ERROR_STAGE_MONITOR: 7;
        readonly ERROR_STAGE_VERIFICATION: 8;
        readonly ERROR_CODE_TYPE_NONE: 1;
        readonly ERROR_CODE_TYPE_NSRESULT: 2;
        readonly ERROR_CODE_TYPE_HRESULT: 3;
        readonly ERROR_CODE_TYPE_STRING: 4;
        readonly ERROR_CODE_TYPE_EXCEPTION: 5;
        readonly PROXY_NONE: 1;
        readonly PROXY_PRECONFIG: 2;
        readonly PROXY_AUTODETECT: 3;
    };
    nsIBitsNewRequestCallback: {
        readonly name: 'nsIBitsNewRequestCallback';
        readonly number: 'aa12e433-5b9f-452d-b5c9-840a9541328b';
    };
    nsIBitsRequest: {
        readonly name: 'nsIBitsRequest';
        readonly number: 'ab9da0e9-06bf-4e73-bb1b-c0f2ea9ecc3e';
    };
    nsIBitsCallback: {
        readonly name: 'nsIBitsCallback';
        readonly number: 'ea657e66-6bad-4e41-84d9-c6d107e9799d';
    };
    nsIBlocklistService: {
        readonly name: 'nsIBlocklistService';
        readonly number: 'a6dcc76e-9f62-4cc1-a470-b483a1a6f096';
        readonly STATE_NOT_BLOCKED: 0;
        readonly STATE_SOFTBLOCKED: 1;
        readonly STATE_BLOCKED: 2;
        readonly STATE_MAX: 3;
    };
    nsIBounceTrackingProtection: {
        readonly name: 'nsIBounceTrackingProtection';
        readonly number: '4866F748-29DA-4C10-8EAA-ED2F7851E6B1';
    };
    nsIBrowser: {
        readonly name: 'nsIBrowser';
        readonly number: '';
    };
    nsIBrowserChild: {
        readonly name: 'nsIBrowserChild';
        readonly number: '';
    };
    nsIBrowserController: {
        readonly name: 'nsIBrowserController';
        readonly number: '5bb3d56b-e733-4a2c-8a53-058123df65e2';
    };
    nsIOpenURIInFrameParams: {
        readonly name: 'nsIOpenURIInFrameParams';
        readonly number: 'e774db14-79ac-4156-a7a3-aa3fd0a22c10';
    };
    nsIBrowserDOMWindow: {
        readonly name: 'nsIBrowserDOMWindow';
        readonly number: '';
        readonly OPEN_DEFAULTWINDOW: 0;
        readonly OPEN_CURRENTWINDOW: 1;
        readonly OPEN_NEWWINDOW: 2;
        readonly OPEN_NEWTAB: 3;
        readonly OPEN_PRINT_BROWSER: 4;
        readonly OPEN_NEW: 0x0;
        readonly OPEN_EXTERNAL: 0x1;
        readonly OPEN_NO_OPENER: 0x4;
        readonly OPEN_NO_REFERRER: 0x8;
    };
    nsIBrowserElementAPI: {
        readonly name: 'nsIBrowserElementAPI';
        readonly number: '57758c10-6036-11e5-a837-0800200c9a66';
    };
    nsIBrowserHandler: {
        readonly name: 'nsIBrowserHandler';
        readonly number: '8D3F5A9D-118D-4548-A137-CF7718679069';
    };
    nsIBrowserUsage: {
        readonly name: 'nsIBrowserUsage';
        readonly number: '2703b5ed-a41f-42be-8764-b795eb67ed25';
    };
    nsIVisibleTab: {
        readonly name: 'nsIVisibleTab';
        readonly number: 'f6190951-69d0-4ce5-b503-d2535d9de98c';
    };
    nsIBrowserWindowTracker: {
        readonly name: 'nsIBrowserWindowTracker';
        readonly number: '846ff245-ccbf-4c7a-807e-060f02927651';
    };
    nsIBufferedInputStream: {
        readonly name: 'nsIBufferedInputStream';
        readonly number: '616f5b48-da09-11d3-8cda-0060b0fc14a3';
    };
    nsIBufferedOutputStream: {
        readonly name: 'nsIBufferedOutputStream';
        readonly number: '6476378a-da09-11d3-8cda-0060b0fc14a3';
    };
    nsIByteRangeRequest: {
        readonly name: 'nsIByteRangeRequest';
        readonly number: 'C1B1F426-7E83-4759-9F88-0E1B17F49366';
    };
    nsICacheEntry: {
        readonly name: 'nsICacheEntry';
        readonly number: '';
        readonly CONTENT_TYPE_UNKNOWN: 0;
        readonly CONTENT_TYPE_OTHER: 1;
        readonly CONTENT_TYPE_JAVASCRIPT: 2;
        readonly CONTENT_TYPE_IMAGE: 3;
        readonly CONTENT_TYPE_MEDIA: 4;
        readonly CONTENT_TYPE_STYLESHEET: 5;
        readonly CONTENT_TYPE_WASM: 6;
        readonly CONTENT_TYPE_LAST: 7;
        readonly NO_EXPIRATION_TIME: 0xFFFFFFFF;
    };
    nsICacheEntryMetaDataVisitor: {
        readonly name: 'nsICacheEntryMetaDataVisitor';
        readonly number: 'fea3e276-6ba5-4ceb-a581-807d1f43f6d0';
    };
    nsICacheEntryDoomCallback: {
        readonly name: 'nsICacheEntryDoomCallback';
        readonly number: '';
    };
    nsICacheEntryOpenCallback: {
        readonly name: 'nsICacheEntryOpenCallback';
        readonly number: '';
        readonly ENTRY_WANTED: 0;
        readonly RECHECK_AFTER_WRITE_FINISHED: 1;
        readonly ENTRY_NEEDS_REVALIDATION: 2;
        readonly ENTRY_NOT_WANTED: 3;
    };
    nsIInputStreamReceiver: {
        readonly name: 'nsIInputStreamReceiver';
        readonly number: '1fb8ccf2-5fa5-45ec-bc57-8c8022a5d0d3';
    };
    nsICacheInfoChannel: {
        readonly name: 'nsICacheInfoChannel';
        readonly number: '';
    };
    nsICachePurgeLock: {
        readonly name: 'nsICachePurgeLock';
        readonly number: '8abb21e3-c6a0-4b4d-9333-cc0d72f2c23b';
    };
    nsICacheStorage: {
        readonly name: 'nsICacheStorage';
        readonly number: '';
        readonly OPEN_NORMALLY: 0;
        readonly OPEN_TRUNCATE;
        readonly OPEN_READONLY;
        readonly OPEN_PRIORITY;
        readonly OPEN_BYPASS_IF_BUSY;
        readonly CHECK_MULTITHREADED;
        readonly OPEN_SECRETLY;
        readonly OPEN_INTERCEPTED;
    };
    nsICacheStorageService: {
        readonly name: 'nsICacheStorageService';
        readonly number: 'ae29c44b-fbc3-4552-afaf-0a157ce771e7';
        readonly PURGE_DISK_DATA_ONLY: 1;
        readonly PURGE_DISK_ALL: 2;
        readonly PURGE_EVERYTHING: 3;
    };
    nsICacheStorageConsumptionObserver: {
        readonly name: 'nsICacheStorageConsumptionObserver';
        readonly number: '7728ab5b-4c01-4483-a606-32bf5b8136cb';
    };
    nsICacheStorageVisitor: {
        readonly name: 'nsICacheStorageVisitor';
        readonly number: '6cc7c253-93b6-482b-8e9d-1e04d8e9d655';
    };
    nsICacheTesting: {
        readonly name: 'nsICacheTesting';
        readonly number: '4e8ba935-92e1-4a74-944b-b1a2f02a7480';
    };
    nsICachingChannel: {
        readonly name: 'nsICachingChannel';
        readonly number: 'dd1d6122-5ecf-4fe4-8f0f-995e7ab3121a';
        readonly LOAD_NO_NETWORK_IO;
        readonly LOAD_BYPASS_LOCAL_CACHE;
        readonly LOAD_BYPASS_LOCAL_CACHE_IF_BUSY;
        readonly LOAD_ONLY_FROM_CACHE;
        readonly LOAD_ONLY_IF_MODIFIED;
    };
    nsICancelable: {
        readonly name: 'nsICancelable';
        readonly number: '';
    };
    nsICaptivePortalCallback: {
        readonly name: 'nsICaptivePortalCallback';
        readonly number: '593fdeec-6284-4de8-b416-8e63cbdc695e';
    };
    nsICaptivePortalDetector: {
        readonly name: 'nsICaptivePortalDetector';
        readonly number: '2f827c5a-f551-477f-af09-71adbfbd854a';
    };
    nsICaptivePortalServiceCallback: {
        readonly name: 'nsICaptivePortalServiceCallback';
        readonly number: 'b5fd5629-d04c-4138-9529-9311f291ecd4';
    };
    nsICaptivePortalService: {
        readonly name: 'nsICaptivePortalService';
        readonly number: 'bdbe0555-fc3d-4f7b-9205-c309ceb2d641';
        readonly UNKNOWN: 0;
        readonly NOT_CAPTIVE: 1;
        readonly UNLOCKED_PORTAL: 2;
        readonly LOCKED_PORTAL: 3;
    };
    nsICascadeFilter: {
        readonly name: 'nsICascadeFilter';
        readonly number: 'c8d0b0b3-17f8-458b-9264-7b67b288fe79';
    };
    nsICategoryEntry: {
        readonly name: 'nsICategoryEntry';
        readonly number: 'de021d54-57a3-4025-ae63-4c8eedbe74c0';
    };
    nsICategoryManager: {
        readonly name: 'nsICategoryManager';
        readonly number: '3275b2cd-af6d-429a-80d7-f0c5120342ac';
    };
    nsICertOverride: {
        readonly name: 'nsICertOverride';
        readonly number: 'ed735e24-fa55-4163-906d-17fb78851fe1';
    };
    nsICertOverrideService: {
        readonly name: 'nsICertOverrideService';
        readonly number: 'be019e47-22fc-4355-9f16-9ab047d6742d';
    };
    nsICertStorageCallback: {
        readonly name: 'nsICertStorageCallback';
        readonly number: '3f8fe26a-a436-4ad4-9c1c-a53c60973c31';
    };
    nsIRevocationState: {
        readonly name: 'nsIRevocationState';
        readonly number: '96db6fd7-6b64-4a5a-955d-310bd9ca4234';
    };
    nsIIssuerAndSerialRevocationState: {
        readonly name: 'nsIIssuerAndSerialRevocationState';
        readonly number: '23ce3546-f1b9-46f6-8de3-77704da5702f';
    };
    nsISubjectAndPubKeyRevocationState: {
        readonly name: 'nsISubjectAndPubKeyRevocationState';
        readonly number: 'e78b51b4-6fa4-41e2-92ce-e9404f541e96';
    };
    nsICRLiteCoverage: {
        readonly name: 'nsICRLiteCoverage';
        readonly number: '416453f7-29bd-4820-a039-9c2e055d3715';
    };
    nsICRLiteTimestamp: {
        readonly name: 'nsICRLiteTimestamp';
        readonly number: '9676cfc4-6e84-11ec-a30d-d3cd0af86e01';
    };
    nsICertInfo: {
        readonly name: 'nsICertInfo';
        readonly number: '27b66f5e-0faf-403b-95b4-bc11691ac50d';
    };
    nsICertStorage: {
        readonly name: 'nsICertStorage';
        readonly number: '327100a7-3401-45ef-b160-bf880f1016fd';
        readonly DATA_TYPE_REVOCATION: 1;
        readonly DATA_TYPE_CERTIFICATE: 2;
        readonly DATA_TYPE_CRLITE: 3;
        readonly DATA_TYPE_CRLITE_FILTER_FULL: 4;
        readonly DATA_TYPE_CRLITE_FILTER_INCREMENTAL: 5;
        readonly STATE_UNSET: 0;
        readonly STATE_ENFORCE: 1;
        readonly STATE_NOT_ENROLLED: 2;
        readonly STATE_NOT_COVERED: 3;
        readonly STATE_NO_FILTER: 4;
        readonly TRUST_INHERIT: 0;
        readonly TRUST_ANCHOR: 1;
    };
    nsICertTreeItem: {
        readonly name: 'nsICertTreeItem';
        readonly number: 'd0180863-606e-49e6-8324-cf45ed4dd891';
    };
    nsICertTree: {
        readonly name: 'nsICertTree';
        readonly number: '55d5ad6b-5572-47fe-941c-f01fe723659e';
    };
    nsICertificateDialogs: {
        readonly name: 'nsICertificateDialogs';
        readonly number: 'da871dab-f69e-4173-ab26-99fcd47b0e85';
    };
    nsIChannel: {
        readonly name: 'nsIChannel';
        readonly number: '';
        readonly LOAD_DOCUMENT_URI;
        readonly LOAD_RETARGETED_DOCUMENT_URI;
        readonly LOAD_REPLACE;
        readonly LOAD_INITIAL_DOCUMENT_URI;
        readonly LOAD_TARGETED;
        readonly LOAD_CALL_CONTENT_SNIFFERS;
        readonly LOAD_BYPASS_URL_CLASSIFIER;
        readonly LOAD_MEDIA_SNIFFER_OVERRIDES_CONTENT_TYPE;
        readonly LOAD_EXPLICIT_CREDENTIALS;
        readonly LOAD_BYPASS_SERVICE_WORKER;
        readonly DISPOSITION_INLINE: 0;
        readonly DISPOSITION_ATTACHMENT: 1;
        readonly DISPOSITION_FORCE_INLINE: 2;
    };
    nsIIdentChannel: {
        readonly name: 'nsIIdentChannel';
        readonly number: '1ebbff64-d742-4f4a-aad5-4df2d1eb937a';
    };
    nsIUrlClassifierBlockedChannel: {
        readonly name: 'nsIUrlClassifierBlockedChannel';
        readonly number: '9b0353a7-ab46-4914-9178-2215ee221e4e';
        readonly TRACKING_PROTECTION: 0;
        readonly SOCIAL_TRACKING_PROTECTION: 1;
        readonly FINGERPRINTING_PROTECTION: 2;
        readonly CRYPTOMINING_PROTECTION: 3;
    };
    nsIChannelClassifierService: {
        readonly name: 'nsIChannelClassifierService';
        readonly number: '9411409c-5dac-40b9-ba36-2738a7237a4c';
    };
    nsIChannelEventSink: {
        readonly name: 'nsIChannelEventSink';
        readonly number: '0197720d-37ed-4e75-8956-d0d296e4d8a6';
        readonly REDIRECT_TEMPORARY;
        readonly REDIRECT_PERMANENT;
        readonly REDIRECT_INTERNAL;
        readonly REDIRECT_STS_UPGRADE;
    };
    nsIChildChannel: {
        readonly name: 'nsIChildChannel';
        readonly number: 'c45b92ae-4f07-41dd-b0ef-aa044eeabb1e';
    };
    nsIChromeRegistry: {
        readonly name: 'nsIChromeRegistry';
        readonly number: '249fb5ad-ae29-4e2c-a728-ba5cf464d188';
        readonly NONE: 0;
        readonly PARTIAL: 1;
        readonly FULL: 2;
    };
    nsIXULChromeRegistry: {
        readonly name: 'nsIXULChromeRegistry';
        readonly number: '93251ddf-5e85-4172-ac2a-31780562974f';
    };
    nsIClassInfo: {
        readonly name: 'nsIClassInfo';
        readonly number: '';
        readonly SINGLETON;
        readonly THREADSAFE;
        readonly SINGLETON_CLASSINFO;
        readonly RESERVED;
    };
    nsIClassOfService: {
        readonly name: 'nsIClassOfService';
        readonly number: '1ccb58ec-5e07-4cf9-a30d-ac5490d23b41';
        readonly Leader;
        readonly Follower;
        readonly Speculative;
        readonly Background;
        readonly Unblocked;
        readonly Throttleable;
        readonly UrgentStart;
        readonly DontThrottle;
        readonly Tail;
        readonly TailAllowed;
        readonly TailForbidden;
    };
    nsIClassifiedChannel: {
        readonly name: 'nsIClassifiedChannel';
        readonly number: '70cf6091-a1de-4aa8-8224-058f8964be31';
    };
    nsIClearDataService: {
        readonly name: 'nsIClearDataService';
        readonly number: '6ef3ef16-a502-4576-9fb4-919f1c40bf61';
        readonly CLEAR_COOKIES;
        readonly CLEAR_NETWORK_CACHE;
        readonly CLEAR_IMAGE_CACHE;
        readonly CLEAR_DOWNLOADS;
        readonly CLEAR_PASSWORDS;
        readonly CLEAR_MEDIA_DEVICES;
        readonly CLEAR_DOM_QUOTA;
        readonly CLEAR_PREDICTOR_NETWORK_DATA;
        readonly CLEAR_DOM_PUSH_NOTIFICATIONS;
        readonly CLEAR_HISTORY;
        readonly CLEAR_SESSION_HISTORY;
        readonly CLEAR_AUTH_TOKENS;
        readonly CLEAR_AUTH_CACHE;
        readonly CLEAR_PERMISSIONS;
        readonly CLEAR_CONTENT_PREFERENCES;
        readonly CLEAR_HSTS;
        readonly CLEAR_EME;
        readonly CLEAR_REPORTS;
        readonly CLEAR_STORAGE_ACCESS;
        readonly CLEAR_CERT_EXCEPTIONS;
        readonly CLEAR_CONTENT_BLOCKING_RECORDS;
        readonly CLEAR_CSS_CACHE;
        readonly CLEAR_PREFLIGHT_CACHE;
        readonly CLEAR_CLIENT_AUTH_REMEMBER_SERVICE;
        readonly CLEAR_CREDENTIAL_MANAGER_STATE;
        readonly CLEAR_ALL: 0xFFFFFFFF;
        readonly CLEAR_ALL_CACHES;
        readonly CLEAR_DOM_STORAGES;
        readonly CLEAR_FORGET_ABOUT_SITE;
    };
    nsIClearDataCallback: {
        readonly name: 'nsIClearDataCallback';
        readonly number: 'e225517b-24c5-498a-b9fb-9993e341a398';
    };
    nsIClickRule: {
        readonly name: 'nsIClickRule';
        readonly number: '7e104b32-b6db-43f3-b887-573c01acef39';
    };
    nsIClientAuthDialogCallback: {
        readonly name: 'nsIClientAuthDialogCallback';
        readonly number: '6b00d96d-fb8a-4c9f-9632-c9e1235befce';
    };
    nsIClientAuthDialogService: {
        readonly name: 'nsIClientAuthDialogService';
        readonly number: 'fa4c7520-1433-11d5-ba24-00108303b117';
    };
    nsIClientAuthDialogs: {
        readonly name: 'nsIClientAuthDialogs';
        readonly number: 'fa4c7520-1433-11d5-ba24-00108303b117';
    };
    nsIClientAuthRememberRecord: {
        readonly name: 'nsIClientAuthRememberRecord';
        readonly number: 'e92825af-7e81-4b5c-b412-8e1dd36d14fe';
    };
    nsIClientAuthRememberService: {
        readonly name: 'nsIClientAuthRememberService';
        readonly number: '1dbc6eb6-0972-4bdb-9dc4-acd0abf72369';
    };
    nsIAsyncSetClipboardData: {
        readonly name: 'nsIAsyncSetClipboardData';
        readonly number: '801e2318-c8fa-11ed-afa1-0242ac120002';
    };
    nsIAsyncSetClipboardDataCallback: {
        readonly name: 'nsIAsyncSetClipboardDataCallback';
        readonly number: '78f7c18e-c8fa-11ed-afa1-0242ac120002';
    };
    nsIClipboard: {
        readonly name: 'nsIClipboard';
        readonly number: 'ceaa0047-647f-4b8e-ad1c-aff9fa62aa51';
        readonly kSelectionClipboard: 0;
        readonly kGlobalClipboard: 1;
        readonly kFindClipboard: 2;
        readonly kSelectionCache: 3;
    };
    nsIClipboardHelper: {
        readonly name: 'nsIClipboardHelper';
        readonly number: '438307fd-0c68-4d79-922a-f6cc9550cd02';
    };
    nsIClipboardOwner: {
        readonly name: 'nsIClipboardOwner';
        readonly number: '5A31C7A1-E122-11d2-9A57-000064657374';
    };
    nsICloneableInputStream: {
        readonly name: 'nsICloneableInputStream';
        readonly number: '8149be1f-44d3-4f14-8b65-a57a5fbbeb97';
    };
    nsICloneableInputStreamWithRange: {
        readonly name: 'nsICloneableInputStreamWithRange';
        readonly number: 'ece853c3-aded-4cef-8f51-0d1493d60bd5';
    };
    nsICodeCoverage: {
        readonly name: 'nsICodeCoverage';
        readonly number: '57d92056-37b4-4d0a-a52f-deb8f6dac8bc';
    };
    nsIColorPickerShownCallback: {
        readonly name: 'nsIColorPickerShownCallback';
        readonly number: 'd2ce78d1-40b5-49d1-b66d-5801fcb9a385';
    };
    nsIColorPicker: {
        readonly name: 'nsIColorPicker';
        readonly number: 'de229d37-a8a6-46f1-969a-0c1de33d0ad7';
    };
    nsICommandLine: {
        readonly name: 'nsICommandLine';
        readonly number: '';
        readonly STATE_INITIAL_LAUNCH: 0;
        readonly STATE_REMOTE_AUTO: 1;
        readonly STATE_REMOTE_EXPLICIT: 2;
    };
    nsICommandLineHandler: {
        readonly name: 'nsICommandLineHandler';
        readonly number: 'd4b123df-51ee-48b1-a663-002180e60d3b';
    };
    nsICommandLineRunner: {
        readonly name: 'nsICommandLineRunner';
        readonly number: 'c9f2996c-b25a-4d3d-821f-4cd0c4bc8afb';
    };
    nsICommandLineValidator: {
        readonly name: 'nsICommandLineValidator';
        readonly number: '5ecaa593-7660-4a3a-957a-92d5770671c7';
    };
    nsICommandManager: {
        readonly name: 'nsICommandManager';
        readonly number: 'bb5a1730-d83b-4fa2-831b-35b9d5842e84';
    };
    nsICommandParams: {
        readonly name: 'nsICommandParams';
        readonly number: '';
        readonly eNoType: 0;
        readonly eBooleanType: 1;
        readonly eLongType: 2;
        readonly eDoubleType: 3;
        readonly eWStringType: 4;
        readonly eISupportsType: 5;
        readonly eStringType: 6;
    };
    nsIComponentManager: {
        readonly name: 'nsIComponentManager';
        readonly number: '';
    };
    nsIComponentRegistrar: {
        readonly name: 'nsIComponentRegistrar';
        readonly number: '2417cbfe-65ad-48a6-b4b6-eb84db174392';
    };
    nsICompressConvStats: {
        readonly name: 'nsICompressConvStats';
        readonly number: '58172ad0-46a9-4893-8fde-cd909c10792a';
    };
    nsIConsoleAPIStorage: {
        readonly name: 'nsIConsoleAPIStorage';
        readonly number: '9e32a7b6-c4d1-4d9a-87b9-1ef6b75c27a9';
    };
    nsIConsoleListener: {
        readonly name: 'nsIConsoleListener';
        readonly number: '';
    };
    nsIConsoleMessage: {
        readonly name: 'nsIConsoleMessage';
        readonly number: '';
        readonly debug: 0;
        readonly info: 1;
        readonly warn: 2;
        readonly error: 3;
    };
    nsIConsoleService: {
        readonly name: 'nsIConsoleService';
        readonly number: '0eb81d20-c37e-42d4-82a8-ca9ae96bdf52';
    };
    nsIContentBlockingAllowList: {
        readonly name: 'nsIContentBlockingAllowList';
        readonly number: '00ed5d73-9de5-42cf-868c-e739a94f6b37';
    };
    nsIContentDispatchChooser: {
        readonly name: 'nsIContentDispatchChooser';
        readonly number: '456ca3b2-02be-4f97-89a2-08c08d3ad88f';
    };
    nsIContentHandler: {
        readonly name: 'nsIContentHandler';
        readonly number: '49439df2-b3d2-441c-bf62-866bdaf56fd2';
    };
    nsIContentPermissionType: {
        readonly name: 'nsIContentPermissionType';
        readonly number: 'ef4db3b8-ca9c-4b1d-8f81-fd88ec32af13';
    };
    nsIContentPermissionRequest: {
        readonly name: 'nsIContentPermissionRequest';
        readonly number: '';
    };
    nsIContentPermissionPrompt: {
        readonly name: 'nsIContentPermissionPrompt';
        readonly number: 'F72DE90D-E954-4E69-9A61-917303029301';
    };
    nsIContentPolicy: {
        readonly name: 'nsIContentPolicy';
        readonly number: 'caad4f1f-d047-46ac-ae9d-dc598e4fb91b';
        readonly REJECT_REQUEST;
        readonly REJECT_TYPE;
        readonly REJECT_SERVER;
        readonly REJECT_OTHER;
        readonly REJECT_POLICY;
        readonly ACCEPT: 1;
    };
    nsIContentPrefObserver: {
        readonly name: 'nsIContentPrefObserver';
        readonly number: '43635c53-b445-4c4e-8cc5-562697299b55';
    };
    nsIContentPrefService2: {
        readonly name: 'nsIContentPrefService2';
        readonly number: 'bed98666-d995-470f-bebd-62476d318576';
        readonly GROUP_NAME_MAX_LENGTH: 2000;
    };
    nsIContentPrefCallback2: {
        readonly name: 'nsIContentPrefCallback2';
        readonly number: '1a12cf41-79e8-4d0f-9899-2f7b27c5d9a1';
        readonly COMPLETE_OK: 0;
        readonly COMPLETE_ERROR: 1;
    };
    nsIContentPref: {
        readonly name: 'nsIContentPref';
        readonly number: '9f24948d-24b5-4b1b-b554-7dbd58c1d792';
    };
    nsIContentProcessInfo: {
        readonly name: 'nsIContentProcessInfo';
        readonly number: '456f58be-29dd-4973-885b-95aece1c9a8a';
    };
    nsIContentProcessProvider: {
        readonly name: 'nsIContentProcessProvider';
        readonly number: '83ffb063-5f65-4c45-ae07-3f553e0809bb';
        readonly NEW_PROCESS;
    };
    nsIContentSecurityManager: {
        readonly name: 'nsIContentSecurityManager';
        readonly number: '3a9a1818-2ae8-4ec5-a340-8b29d31fca3b';
    };
    nsIContentSecurityPolicy: {
        readonly name: 'nsIContentSecurityPolicy';
        readonly number: '';
        readonly VIOLATION_TYPE_EVAL: 1;
        readonly VIOLATION_TYPE_WASM_EVAL: 2;
    };
    nsICSPEventListener: {
        readonly name: 'nsICSPEventListener';
        readonly number: '';
    };
    nsIContentSignatureVerifier: {
        readonly name: 'nsIContentSignatureVerifier';
        readonly number: '45a5fe2f-c350-4b86-962d-02d5aaaa955a';
        readonly ContentSignatureProdRoot: 1;
        readonly ContentSignatureStageRoot: 2;
        readonly ContentSignatureDevRoot: 3;
        readonly ContentSignatureLocalRoot: 4;
    };
    nsIContentSniffer: {
        readonly name: 'nsIContentSniffer';
        readonly number: 'a5772d1b-fc63-495e-a169-96e8d3311af0';
    };
    nsIContentViewer: {
        readonly name: 'nsIContentViewer';
        readonly number: '';
        readonly eDelayResize: 1;
    };
    nsIContentViewerEdit: {
        readonly name: 'nsIContentViewerEdit';
        readonly number: '35BE2D7E-F29B-48EC-BF7E-80A30A724DE3';
        readonly COPY_IMAGE_TEXT: 0x0001;
        readonly COPY_IMAGE_HTML: 0x0002;
        readonly COPY_IMAGE_DATA: 0x0004;
        readonly COPY_IMAGE_ALL;
    };
    nsIController: {
        readonly name: 'nsIController';
        readonly number: '';
    };
    nsICommandController: {
        readonly name: 'nsICommandController';
        readonly number: 'EEC0B435-7F53-44FE-B00A-CF3EED65C01A';
    };
    nsIControllerCommand: {
        readonly name: 'nsIControllerCommand';
        readonly number: '0eae9a46-1dd2-11b2-aca0-9176f05fe9db';
    };
    nsIControllerCommandTable: {
        readonly name: 'nsIControllerCommandTable';
        readonly number: 'c847f90e-b8f3-49db-a4df-8867831f2800';
    };
    nsIControllerContext: {
        readonly name: 'nsIControllerContext';
        readonly number: '47B82B60-A36F-4167-8072-6F421151ED50';
    };
    nsIControllers: {
        readonly name: 'nsIControllers';
        readonly number: '';
    };
    nsIConverterInputStream: {
        readonly name: 'nsIConverterInputStream';
        readonly number: 'FC66FFB6-5404-4908-A4A3-27F92FA0579D';
        readonly DEFAULT_REPLACEMENT_CHARACTER: 0xFFFD;
        readonly ERRORS_ARE_FATAL: 0;
    };
    nsIConverterOutputStream: {
        readonly name: 'nsIConverterOutputStream';
        readonly number: '4b71113a-cb0d-479f-8ed5-01daeba2e8d4';
    };
    nsICookie: {
        readonly name: 'nsICookie';
        readonly number: '';
        readonly SAMESITE_NONE: 0;
        readonly SAMESITE_LAX: 1;
        readonly SAMESITE_STRICT: 2;
    };
    nsICookieBannerListService: {
        readonly name: 'nsICookieBannerListService';
        readonly number: '1d8d9470-97d3-4885-a108-44a5c4fb36e2';
    };
    nsICookieBannerRule: {
        readonly name: 'nsICookieBannerRule';
        readonly number: 'eb1904db-e0d1-4760-a721-db76b1ca3e94';
    };
    nsICookieBannerService: {
        readonly name: 'nsICookieBannerService';
        readonly number: 'eac9cdc4-ecee-49f2-91da-7627e15c1f3c';
    };
    nsICookieJarSettings: {
        readonly name: 'nsICookieJarSettings';
        readonly number: '';
    };
    nsICookieManager: {
        readonly name: 'nsICookieManager';
        readonly number: 'AAAB6710-0F2C-11d5-A53B-0010A401EB10';
    };
    nsICookieNotification: {
        readonly name: 'nsICookieNotification';
        readonly number: '5b3490f2-75f0-4e36-9f3d-47c857ecdfbb';
    };
    nsICookiePermission: {
        readonly name: 'nsICookiePermission';
        readonly number: '11ddd4ed-8f5b-40b3-b2a0-27c20ea1c88d';
        readonly ACCESS_DEFAULT: 0;
        readonly ACCESS_ALLOW: 1;
        readonly ACCESS_DENY: 2;
        readonly ACCESS_SESSION: 8;
    };
    nsICookieRule: {
        readonly name: 'nsICookieRule';
        readonly number: 'bf049b1e-8a05-481f-a120-332ea1bd65ef';
    };
    nsICookieTransactionCallback: {
        readonly name: 'nsICookieTransactionCallback';
        readonly number: '0fc41ffb-f1b7-42d9-9a42-8dc420c158c1';
    };
    nsICookieService: {
        readonly name: 'nsICookieService';
        readonly number: '1e94e283-2811-4f43-b947-d22b1549d824';
        readonly BEHAVIOR_ACCEPT: 0;
        readonly BEHAVIOR_REJECT_FOREIGN: 1;
        readonly BEHAVIOR_REJECT: 2;
        readonly BEHAVIOR_LIMIT_FOREIGN: 3;
        readonly BEHAVIOR_REJECT_TRACKER: 4;
        readonly BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN: 5;
        readonly BEHAVIOR_LAST: 5;
    };
    nsICrashReporter: {
        readonly name: 'nsICrashReporter';
        readonly number: '4b74c39a-cf69-4a8a-8e63-169d81ad1ecf';
    };
    nsICrashService: {
        readonly name: 'nsICrashService';
        readonly number: '70bd93ff-88fa-4600-8af8-57c8d002dbac';
        readonly CRASH_TYPE_CRASH: 0;
        readonly CRASH_TYPE_HANG: 1;
    };
    nsICryptoHash: {
        readonly name: 'nsICryptoHash';
        readonly number: '1e5b7c43-4688-45ce-92e1-77ed931e3bbe';
        readonly MD5: 2;
        readonly SHA1: 3;
        readonly SHA256: 4;
        readonly SHA384: 5;
        readonly SHA512: 6;
    };
    nsICycleCollectorHandler: {
        readonly name: 'nsICycleCollectorHandler';
        readonly number: '7f093367-1492-4b89-87af-c01dbc831246';
    };
    nsICycleCollectorLogSink: {
        readonly name: 'nsICycleCollectorLogSink';
        readonly number: '';
    };
    nsICycleCollectorListener: {
        readonly name: 'nsICycleCollectorListener';
        readonly number: '';
    };
    nsIDAPTelemetry: {
        readonly name: 'nsIDAPTelemetry';
        readonly number: '58a4c579-d2dd-46b7-9c3b-6881a1c36c6a';
    };
    nsIDHCPClient: {
        readonly name: 'nsIDHCPClient';
        readonly number: 'aee75dc0-be1a-46b9-9e0c-31a6899c175c';
    };
    nsIDNSAdditionalInfo: {
        readonly name: 'nsIDNSAdditionalInfo';
        readonly number: '';
    };
    nsIDNSByTypeRecord: {
        readonly name: 'nsIDNSByTypeRecord';
        readonly number: '';
    };
    nsIDNSTXTRecord: {
        readonly name: 'nsIDNSTXTRecord';
        readonly number: '2a71750d-cb21-45f1-9e1c-666d18dd7645';
    };
    nsISVCParam: {
        readonly name: 'nsISVCParam';
        readonly number: '2979ceaa-9c7e-49de-84b8-ea81c16aebf1';
    };
    nsISVCParamAlpn: {
        readonly name: 'nsISVCParamAlpn';
        readonly number: '0dc58309-4d67-4fc4-a4e3-38dbde9d9f4c';
    };
    nsISVCParamNoDefaultAlpn: {
        readonly name: 'nsISVCParamNoDefaultAlpn';
        readonly number: 'b3ed89c3-2ae6-4c92-8176-b76bc2437fcb';
    };
    nsISVCParamPort: {
        readonly name: 'nsISVCParamPort';
        readonly number: 'a37c7bcb-bfcd-4ab4-b826-cc583859ba73';
    };
    nsISVCParamIPv4Hint: {
        readonly name: 'nsISVCParamIPv4Hint';
        readonly number: 'd3163d2f-0bbe-47d4-bcac-db3fb1433b39';
    };
    nsISVCParamEchConfig: {
        readonly name: 'nsISVCParamEchConfig';
        readonly number: '1f31e41d-b6d8-4796-b12a-82ef8d2b0e43';
    };
    nsISVCParamIPv6Hint: {
        readonly name: 'nsISVCParamIPv6Hint';
        readonly number: '5100bce4-9d3b-42e1-a3c9-0f386bbc9dad';
    };
    nsISVCParamODoHConfig: {
        readonly name: 'nsISVCParamODoHConfig';
        readonly number: 'bdcef040-452e-11eb-b378-0242ac130002';
    };
    nsISVCBRecord: {
        readonly name: 'nsISVCBRecord';
        readonly number: 'a4da5645-2160-4439-bd11-540a2d26c989';
    };
    nsIDNSHTTPSSVCRecord: {
        readonly name: 'nsIDNSHTTPSSVCRecord';
        readonly number: '5b649e95-e0d3-422b-99a6-79d70a041387';
    };
    nsIDNSListener: {
        readonly name: 'nsIDNSListener';
        readonly number: '';
    };
    nsIDNSRecord: {
        readonly name: 'nsIDNSRecord';
        readonly number: '';
    };
    nsIDNSAddrRecord: {
        readonly name: 'nsIDNSAddrRecord';
        readonly number: 'cb260e20-943f-4309-953b-78c90d3a7638';
    };
    nsIDNSService: {
        readonly name: 'nsIDNSService';
        readonly number: 'de5642c6-61fc-4fcf-9a47-03226b0d4e21';
    };
    nsIDOMChromeWindow: {
        readonly name: 'nsIDOMChromeWindow';
        readonly number: '78bdcb41-1efa-409f-aaba-70842213f80f';
    };
    nsIDOMEventListener: {
        readonly name: 'nsIDOMEventListener';
        readonly number: 'df31c120-ded6-11d1-bd85-00805f8ae3f4';
    };
    nsIDOMGeoPosition: {
        readonly name: 'nsIDOMGeoPosition';
        readonly number: '';
    };
    nsIDOMGeoPositionCallback: {
        readonly name: 'nsIDOMGeoPositionCallback';
        readonly number: '527E8B53-6F29-4B6A-8D04-5C1666A4C4C1';
    };
    nsIDOMGeoPositionCoords: {
        readonly name: 'nsIDOMGeoPositionCoords';
        readonly number: 'B31702D0-6DAC-4FA0-B93B-F043E71C8F9A';
    };
    nsIDOMGeoPositionErrorCallback: {
        readonly name: 'nsIDOMGeoPositionErrorCallback';
        readonly number: '7D9B09D9-4843-43EB-A7A7-67F7DDA6B3C4';
    };
    nsIDOMGlobalPropertyInitializer: {
        readonly name: 'nsIDOMGlobalPropertyInitializer';
        readonly number: '5842e275-797f-4afb-b7e0-e29f0cb312ae';
    };
    nsIDOMMozBrowserFrame: {
        readonly name: 'nsIDOMMozBrowserFrame';
        readonly number: '4CAFE116-581B-4194-B0DE-7F02378FC51D';
    };
    nsIDOMProcessChild: {
        readonly name: 'nsIDOMProcessChild';
        readonly number: 'b0c6e5f3-02f1-4f11-a0af-336fc231f3bf';
    };
    nsIDOMProcessParent: {
        readonly name: 'nsIDOMProcessParent';
        readonly number: '81fc08b9-c901-471f-ab0d-876362eba770';
    };
    nsIDOMRequestService: {
        readonly name: 'nsIDOMRequestService';
        readonly number: '9a57e5de-ce93-45fa-8145-755722834f7c';
    };
    nsIDOMStorageManager: {
        readonly name: 'nsIDOMStorageManager';
        readonly number: 'a20c742e-3ed1-44fb-b897-4080a75b1662';
    };
    nsIDOMSessionStorageManager: {
        readonly name: 'nsIDOMSessionStorageManager';
        readonly number: 'b3bfbbd0-e738-4cbf-b0f0-b65f25265e82';
    };
    nsIDOMMozWakeLockListener: {
        readonly name: 'nsIDOMMozWakeLockListener';
        readonly number: '';
    };
    nsIDOMWindow: {
        readonly name: 'nsIDOMWindow';
        readonly number: '';
    };
    nsIDOMWindowUtils: {
        readonly name: 'nsIDOMWindowUtils';
        readonly number: '4d6732ca-9da7-4176-b8a1-8dde15cd0bf9';
        readonly MODIFIER_ALT: 0x0001;
        readonly MODIFIER_CONTROL: 0x0002;
        readonly MODIFIER_SHIFT: 0x0004;
        readonly MODIFIER_META: 0x0008;
        readonly MODIFIER_ALTGRAPH: 0x0010;
        readonly MODIFIER_CAPSLOCK: 0x0020;
        readonly MODIFIER_FN: 0x0040;
        readonly MODIFIER_FNLOCK: 0x0080;
        readonly MODIFIER_NUMLOCK: 0x0100;
        readonly MODIFIER_SCROLLLOCK: 0x0200;
        readonly MODIFIER_SYMBOL: 0x0400;
        readonly MODIFIER_SYMBOLLOCK: 0x0800;
        readonly WHEEL_EVENT_CAUSED_BY_NO_LINE_OR_PAGE_DELTA_DEVICE: 0x0001;
        readonly WHEEL_EVENT_CAUSED_BY_MOMENTUM: 0x0002;
        readonly WHEEL_EVENT_CUSTOMIZED_BY_USER_PREFS: 0x0004;
        readonly WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_ZERO: 0x0010;
        readonly WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_POSITIVE: 0x0020;
        readonly WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_NEGATIVE: 0x0040;
        readonly WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_ZERO: 0x0100;
        readonly WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_POSITIVE: 0x0200;
        readonly WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_NEGATIVE: 0x0400;
        readonly NATIVE_MODIFIER_CAPS_LOCK: 0x00000001;
        readonly NATIVE_MODIFIER_NUM_LOCK: 0x00000002;
        readonly NATIVE_MODIFIER_SHIFT_LEFT: 0x00000100;
        readonly NATIVE_MODIFIER_SHIFT_RIGHT: 0x00000200;
        readonly NATIVE_MODIFIER_CONTROL_LEFT: 0x00000400;
        readonly NATIVE_MODIFIER_CONTROL_RIGHT: 0x00000800;
        readonly NATIVE_MODIFIER_ALT_LEFT: 0x00001000;
        readonly NATIVE_MODIFIER_ALT_RIGHT: 0x00002000;
        readonly NATIVE_MODIFIER_COMMAND_LEFT: 0x00004000;
        readonly NATIVE_MODIFIER_COMMAND_RIGHT: 0x00008000;
        readonly NATIVE_MODIFIER_HELP: 0x00010000;
        readonly NATIVE_MODIFIER_ALT_GRAPH: 0x00020000;
        readonly NATIVE_MODIFIER_FUNCTION: 0x00100000;
        readonly NATIVE_MODIFIER_NUMERIC_KEY_PAD: 0x01000000;
        readonly NATIVE_MOUSE_MESSAGE_BUTTON_DOWN: 0x00000001;
        readonly NATIVE_MOUSE_MESSAGE_BUTTON_UP: 0x00000002;
        readonly NATIVE_MOUSE_MESSAGE_MOVE: 0x00000003;
        readonly NATIVE_MOUSE_MESSAGE_ENTER_WINDOW: 0x00000004;
        readonly NATIVE_MOUSE_MESSAGE_LEAVE_WINDOW: 0x00000005;
        readonly MOUSESCROLL_PREFER_WIDGET_AT_POINT: 0x00000001;
        readonly MOUSESCROLL_SCROLL_LINES: 0x00000002;
        readonly MOUSESCROLL_WIN_SCROLL_LPARAM_NOT_NULL: 0x00010000;
        readonly TOUCH_HOVER: 0x01;
        readonly TOUCH_CONTACT: 0x02;
        readonly TOUCH_REMOVE: 0x04;
        readonly TOUCH_CANCEL: 0x08;
        readonly PHASE_BEGIN: 0;
        readonly PHASE_UPDATE: 1;
        readonly PHASE_END: 2;
        readonly UPDATE_TYPE_RESTORE: 0;
        readonly UPDATE_TYPE_MAIN_THREAD: 1;
        readonly SCROLL_MODE_INSTANT: 0;
        readonly SCROLL_MODE_SMOOTH: 1;
        readonly FLUSH_NONE;
        readonly FLUSH_STYLE: 0;
        readonly FLUSH_LAYOUT: 1;
        readonly FLUSH_DISPLAY: 2;
        readonly IME_STATUS_DISABLED: 0;
        readonly IME_STATUS_ENABLED: 1;
        readonly IME_STATUS_PASSWORD: 2;
        readonly INPUT_CONTEXT_ORIGIN_MAIN: 0;
        readonly INPUT_CONTEXT_ORIGIN_CONTENT: 1;
        readonly QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK: 0x0000;
        readonly QUERY_CONTENT_FLAG_USE_XP_LINE_BREAK: 0x0001;
        readonly QUERY_CONTENT_FLAG_SELECTION_SPELLCHECK: 0x0002;
        readonly QUERY_CONTENT_FLAG_SELECTION_IME_RAWINPUT: 0x0004;
        readonly QUERY_CONTENT_FLAG_SELECTION_IME_SELECTEDRAWTEXT: 0x0008;
        readonly QUERY_CONTENT_FLAG_SELECTION_IME_CONVERTEDTEXT: 0x0010;
        readonly QUERY_CONTENT_FLAG_SELECTION_IME_SELECTEDCONVERTEDTEXT: 0x0020;
        readonly QUERY_CONTENT_FLAG_SELECTION_ACCESSIBILITY: 0x0040;
        readonly QUERY_CONTENT_FLAG_SELECTION_FIND: 0x0080;
        readonly QUERY_CONTENT_FLAG_SELECTION_URLSECONDARY: 0x0100;
        readonly QUERY_CONTENT_FLAG_SELECTION_URLSTRIKEOUT: 0x0200;
        readonly QUERY_CONTENT_FLAG_OFFSET_RELATIVE_TO_INSERTION_POINT: 0x0400;
        readonly QUERY_SELECTED_TEXT: 3200;
        readonly QUERY_TEXT_CONTENT: 3201;
        readonly QUERY_CARET_RECT: 3203;
        readonly QUERY_TEXT_RECT: 3204;
        readonly QUERY_EDITOR_RECT: 3205;
        readonly QUERY_CHARACTER_AT_POINT: 3208;
        readonly QUERY_TEXT_RECT_ARRAY: 3209;
        readonly SELECTION_SET_FLAG_USE_NATIVE_LINE_BREAK: 0x0000;
        readonly SELECTION_SET_FLAG_USE_XP_LINE_BREAK: 0x0001;
        readonly SELECTION_SET_FLAG_REVERSE: 0x0002;
        readonly SELECT_CHARACTER: 0;
        readonly SELECT_CLUSTER: 1;
        readonly SELECT_WORD: 2;
        readonly SELECT_LINE: 3;
        readonly SELECT_BEGINLINE: 4;
        readonly SELECT_ENDLINE: 5;
        readonly SELECT_PARAGRAPH: 6;
        readonly SELECT_WORDNOSPACE: 7;
        readonly AUDIO_INPUT: 0;
        readonly AUDIO_OUTPUT: 1;
        readonly AGENT_SHEET: 0;
        readonly USER_SHEET: 1;
        readonly AUTHOR_SHEET: 2;
        readonly WR_CAPTURE_SCENE: 0x1;
        readonly WR_CAPTURE_FRAME: 0x2;
        readonly WR_CAPTURE_TILE_CACHE: 0x4;
        readonly WR_CAPTURE_EXTERNAL_RESOURCES: 0x8;
        readonly DEFAULT_MOUSE_POINTER_ID: 0;
        readonly DEFAULT_PEN_POINTER_ID: 1;
        readonly DEFAULT_TOUCH_POINTER_ID: 2;
        readonly MOUSE_BUTTON_LEFT_BUTTON: 0;
        readonly MOUSE_BUTTON_MIDDLE_BUTTON: 1;
        readonly MOUSE_BUTTON_RIGHT_BUTTON: 2;
        readonly MOUSE_BUTTONS_NO_BUTTON: 0x00;
        readonly MOUSE_BUTTONS_LEFT_BUTTON: 0x01;
        readonly MOUSE_BUTTONS_RIGHT_BUTTON: 0x02;
        readonly MOUSE_BUTTONS_MIDDLE_BUTTON: 0x04;
        readonly MOUSE_BUTTONS_4TH_BUTTON: 0x08;
        readonly MOUSE_BUTTONS_5TH_BUTTON: 0x10;
        readonly MOUSE_BUTTONS_NOT_SPECIFIED;
        readonly DIRECTION_LTR: 0;
        readonly DIRECTION_RTL: 1;
        readonly DIRECTION_NOT_SET: 2;
    };
    nsITranslationNodeList: {
        readonly name: 'nsITranslationNodeList';
        readonly number: 'c694e359-7227-4392-a138-33c0cc1f15a6';
    };
    nsIJSRAIIHelper: {
        readonly name: 'nsIJSRAIIHelper';
        readonly number: '52e5a996-d0a9-4efc-a6fa-24489c532b19';
    };
    nsIDOMXULButtonElement: {
        readonly name: 'nsIDOMXULButtonElement';
        readonly number: '6ed53cfb-9e59-424c-af8d-e74582381951';
    };
    nsIDOMXULCommandDispatcher: {
        readonly name: 'nsIDOMXULCommandDispatcher';
        readonly number: 'a9fa9fd3-8d62-4f94-9ed8-3ea9c3cf0773';
    };
    nsIDOMXULContainerItemElement: {
        readonly name: 'nsIDOMXULContainerItemElement';
        readonly number: '800a68c7-b854-4597-a436-3055ce5c5c96';
    };
    nsIDOMXULContainerElement: {
        readonly name: 'nsIDOMXULContainerElement';
        readonly number: 'b2bc96b8-31fc-42f4-937a-bd27291af40b';
    };
    nsIDOMXULControlElement: {
        readonly name: 'nsIDOMXULControlElement';
        readonly number: 'bdc1d047-6d22-4813-bc50-638ccb349c7d';
    };
    nsIDOMXULMenuListElement: {
        readonly name: 'nsIDOMXULMenuListElement';
        readonly number: '36c16a17-c0e9-4b35-951b-81a147314ef1';
    };
    nsIDOMXULMultiSelectControlElement: {
        readonly name: 'nsIDOMXULMultiSelectControlElement';
        readonly number: '40654a10-8204-4f06-9f21-7baa31c7b1dd';
    };
    nsIDOMXULRadioGroupElement: {
        readonly name: 'nsIDOMXULRadioGroupElement';
        readonly number: '2cc1d24b-ec9f-4e18-aa34-a298a9007f23';
    };
    nsIDOMXULRelatedElement: {
        readonly name: 'nsIDOMXULRelatedElement';
        readonly number: '9fbac05a-fb27-470d-8e5f-028b2dc54ad0';
    };
    nsIDOMXULSelectControlElement: {
        readonly name: 'nsIDOMXULSelectControlElement';
        readonly number: '';
    };
    nsIDOMXULSelectControlItemElement: {
        readonly name: 'nsIDOMXULSelectControlItemElement';
        readonly number: '5c6be58f-17df-4750-88a5-4a59ac28adc9';
    };
    nsINetDashboardCallback: {
        readonly name: 'nsINetDashboardCallback';
        readonly number: '19d7f24f-a95a-4fd9-87e2-d96e9e4b1f6d';
    };
    nsIDashboard: {
        readonly name: 'nsIDashboard';
        readonly number: 'c79eb3c6-091a-45a6-8544-5a8d1ab79537';
    };
    nsIDashboardEventNotifier: {
        readonly name: 'nsIDashboardEventNotifier';
        readonly number: '24fdfcbe-54cb-4997-8392-3c476126ea3b';
    };
    nsIDataStorageManager: {
        readonly name: 'nsIDataStorageManager';
        readonly number: '71b49926-fd4e-43e2-ab8d-d9b049413c0b';
    };
    nsIDataStorage: {
        readonly name: 'nsIDataStorage';
        readonly number: 'fcbb5ec4-7134-4069-91c6-9378eff51e03';
    };
    nsIDataStorageItem: {
        readonly name: 'nsIDataStorageItem';
        readonly number: '4501f984-0e3a-4199-a67e-7753649e93f1';
    };
    nsIDebug2: {
        readonly name: 'nsIDebug2';
        readonly number: '9641dc15-10fb-42e3-a285-18be90a5c10b';
    };
    nsIDeviceSensorData: {
        readonly name: 'nsIDeviceSensorData';
        readonly number: '0462247e-fe8c-4aa5-b675-3752547e485f';
        readonly TYPE_ORIENTATION: 0;
        readonly TYPE_ACCELERATION: 1;
        readonly TYPE_PROXIMITY: 2;
        readonly TYPE_LINEAR_ACCELERATION: 3;
        readonly TYPE_GYROSCOPE: 4;
        readonly TYPE_LIGHT: 5;
        readonly TYPE_ROTATION_VECTOR: 6;
        readonly TYPE_GAME_ROTATION_VECTOR: 7;
    };
    nsIDeviceSensors: {
        readonly name: 'nsIDeviceSensors';
        readonly number: 'e46e47c7-55ff-44c4-abce-21b14ba07f86';
    };
    nsIDialogParamBlock: {
        readonly name: 'nsIDialogParamBlock';
        readonly number: '';
    };
    nsIDirIndex: {
        readonly name: 'nsIDirIndex';
        readonly number: '';
        readonly TYPE_UNKNOWN: 0;
        readonly TYPE_DIRECTORY: 1;
        readonly TYPE_FILE: 2;
        readonly TYPE_SYMLINK: 3;
    };
    nsIDirIndexListener: {
        readonly name: 'nsIDirIndexListener';
        readonly number: 'fae4e9a8-1dd1-11b2-b53c-8f3aa1bbf8f5';
    };
    nsIDirIndexParser: {
        readonly name: 'nsIDirIndexParser';
        readonly number: '38e3066c-1dd2-11b2-9b59-8be515c1ee3f';
    };
    nsIDirectTaskDispatcher: {
        readonly name: 'nsIDirectTaskDispatcher';
        readonly number: 'e05bf0fe-94b7-4e28-8462-a8368da9c136';
    };
    nsIDirectoryEnumerator: {
        readonly name: 'nsIDirectoryEnumerator';
        readonly number: '31f7f4ae-6916-4f2d-a81e-926a4e3022ee';
    };
    nsIDirectoryServiceProvider: {
        readonly name: 'nsIDirectoryServiceProvider';
        readonly number: 'bbf8cab0-d43a-11d3-8cc2-00609792278c';
    };
    nsIDirectoryServiceProvider2: {
        readonly name: 'nsIDirectoryServiceProvider2';
        readonly number: '2f977d4b-5485-11d4-87e2-0010a4e75ef2';
    };
    nsIDirectoryService: {
        readonly name: 'nsIDirectoryService';
        readonly number: '57a66a60-d43a-11d3-8cc2-00609792278c';
    };
    nsIDisplayInfo: {
        readonly name: 'nsIDisplayInfo';
        readonly number: '615bc23d-6346-4b15-9c10-add002f140b6';
    };
    nsIDocShell: {
        readonly name: 'nsIDocShell';
        readonly number: '';
    };
    nsIDocShellTreeItem: {
        readonly name: 'nsIDocShellTreeItem';
        readonly number: '';
        readonly typeChrome: 0;
        readonly typeContent: 1;
        readonly typeContentWrapper: 2;
        readonly typeChromeWrapper: 3;
        readonly typeAll: 0x7FFFFFFF;
    };
    nsIDocShellTreeOwner: {
        readonly name: 'nsIDocShellTreeOwner';
        readonly number: '0e3dc4b1-4cea-4a37-af71-79f0afd07574';
    };
    nsIDocumentEncoderNodeFixup: {
        readonly name: 'nsIDocumentEncoderNodeFixup';
        readonly number: '3d9371d8-a2ad-403e-8b0e-8885ad3562e3';
    };
    nsIDocumentEncoder: {
        readonly name: 'nsIDocumentEncoder';
        readonly number: '';
        readonly OutputSelectionOnly;
        readonly OutputFormatted;
        readonly OutputRaw;
        readonly OutputBodyOnly;
        readonly OutputPreformatted;
        readonly OutputWrap;
        readonly OutputFormatFlowed;
        readonly OutputAbsoluteLinks;
        readonly OutputCRLineBreak;
        readonly OutputLFLineBreak;
        readonly OutputNoScriptContent;
        readonly OutputNoFramesContent;
        readonly OutputNoFormattingInPre;
        readonly OutputEncodeBasicEntities;
        readonly OutputPersistNBSP;
        readonly OutputDontRewriteEncodingDeclaration;
        readonly SkipInvisibleContent;
        readonly OutputFormatDelSp;
        readonly OutputDropInvisibleBreak;
        readonly OutputIgnoreMozDirty;
        readonly OutputForPlainTextClipboardCopy;
        readonly OutputRubyAnnotation;
        readonly OutputDisallowLineBreaking;
        readonly RequiresReinitAfterOutput;
    };
    nsIDocumentLoader: {
        readonly name: 'nsIDocumentLoader';
        readonly number: 'bbe961ee-59e9-42bb-be50-0331979bb79f';
    };
    nsIDocumentLoaderFactory: {
        readonly name: 'nsIDocumentLoaderFactory';
        readonly number: 'e795239e-9d3c-47c4-b063-9e600fb3b287';
    };
    nsIDocumentStateListener: {
        readonly name: 'nsIDocumentStateListener';
        readonly number: '';
    };
    nsIDomainPolicy: {
        readonly name: 'nsIDomainPolicy';
        readonly number: '';
    };
    nsIDomainSet: {
        readonly name: 'nsIDomainSet';
        readonly number: '665c981b-0a0f-4229-ac06-a826e02d4f69';
    };
    nsIDownloader: {
        readonly name: 'nsIDownloader';
        readonly number: 'fafe41a9-a531-4d6d-89bc-588a6522fb4e';
    };
    nsIDownloadObserver: {
        readonly name: 'nsIDownloadObserver';
        readonly number: '44b3153e-a54e-4077-a527-b0325e40924e';
    };
    nsIDragService: {
        readonly name: 'nsIDragService';
        readonly number: 'ebd6b3a2-af16-43af-a698-3091a087dd62';
        readonly DRAGDROP_ACTION_NONE: 0;
        readonly DRAGDROP_ACTION_COPY: 1;
        readonly DRAGDROP_ACTION_MOVE: 2;
        readonly DRAGDROP_ACTION_LINK: 4;
        readonly DRAGDROP_ACTION_UNINITIALIZED: 64;
    };
    nsIDragSession: {
        readonly name: 'nsIDragSession';
        readonly number: '25bce737-73f0-43c7-bc20-c71044a73c5a';
    };
    nsIDroppedLinkItem: {
        readonly name: 'nsIDroppedLinkItem';
        readonly number: '69E14F91-2E09-4CA6-A511-A715C99A2804';
    };
    nsIDroppedLinkHandler: {
        readonly name: 'nsIDroppedLinkHandler';
        readonly number: '21B5C25A-28A9-47BD-8431-FA9116305DED';
    };
    nsIE10SUtils: {
        readonly name: 'nsIE10SUtils';
        readonly number: '1e18680e-052d-4509-a17e-678f5c495e02';
    };
    nsIEarlyHintObserver: {
        readonly name: 'nsIEarlyHintObserver';
        readonly number: '';
    };
    nsIEdgeMigrationUtils: {
        readonly name: 'nsIEdgeMigrationUtils';
        readonly number: '9c7b7436-a17c-4c03-ba66-aeb5ae070126';
    };
    nsIEditActionListener: {
        readonly name: 'nsIEditActionListener';
        readonly number: '';
    };
    nsIEditingSession: {
        readonly name: 'nsIEditingSession';
        readonly number: '24f963d1-e6fc-43ea-a206-99ac5fcc5265';
        readonly eEditorOK: 0;
        readonly eEditorCreationInProgress: 1;
        readonly eEditorErrorCantEditMimeType: 2;
        readonly eEditorErrorFileNotFound: 3;
        readonly eEditorErrorCantEditFramesets: 8;
        readonly eEditorErrorUnknown: 9;
    };
    nsIEditor: {
        readonly name: 'nsIEditor';
        readonly number: '';
        readonly eNone: 0;
        readonly eNext: 1;
        readonly ePrevious: 2;
        readonly eNextWord: 3;
        readonly ePreviousWord: 4;
        readonly eToBeginningOfLine: 5;
        readonly eToEndOfLine: 6;
        readonly eStrip: 0;
        readonly eNoStrip: 1;
        readonly eEditorPlaintextMask: 0x0001;
        readonly eEditorSingleLineMask: 0x0002;
        readonly eEditorPasswordMask: 0x0004;
        readonly eEditorReadonlyMask: 0x0008;
        readonly eEditorMailMask: 0x0020;
        readonly eEditorEnableWrapHackMask: 0x0040;
        readonly eEditorAllowInteraction: 0x0200;
        readonly eEditorRightToLeft: 0x0800;
        readonly eEditorLeftToRight: 0x1000;
        readonly eEditorSkipSpellCheck: 0x2000;
        readonly eNewlinesPasteIntact: 0;
        readonly eNewlinesPasteToFirst: 1;
        readonly eNewlinesReplaceWithSpaces: 2;
        readonly eNewlinesStrip: 3;
        readonly eNewlinesReplaceWithCommas: 4;
        readonly eNewlinesStripSurroundingWhitespace: 5;
    };
    nsIEditorMailSupport: {
        readonly name: 'nsIEditorMailSupport';
        readonly number: 'fdf23301-4a94-11d3-9ce4-9960496c41bc';
    };
    nsIEditorSpellCheck: {
        readonly name: 'nsIEditorSpellCheck';
        readonly number: '';
        readonly FILTERTYPE_NORMAL: 1;
        readonly FILTERTYPE_MAIL: 2;
    };
    nsIEditorSpellCheckCallback: {
        readonly name: 'nsIEditorSpellCheckCallback';
        readonly number: '5f0a4bab-8538-4074-89d3-2f0e866a1c0b';
    };
    nsIEffectiveTLDService: {
        readonly name: 'nsIEffectiveTLDService';
        readonly number: '68067eb5-ad8d-43cb-a043-1cc85ebe06e7';
    };
    nsIEmbeddingSiteWindow: {
        readonly name: 'nsIEmbeddingSiteWindow';
        readonly number: '0b976267-4aaa-4f36-a2d4-27b5ca8d73bb';
        readonly DIM_FLAGS_POSITION: 1;
        readonly DIM_FLAGS_SIZE_INNER: 2;
        readonly DIM_FLAGS_SIZE_OUTER: 4;
        readonly DIM_FLAGS_IGNORE_X: 8;
        readonly DIM_FLAGS_IGNORE_Y: 16;
        readonly DIM_FLAGS_IGNORE_CX: 32;
        readonly DIM_FLAGS_IGNORE_CY: 64;
    };
    nsISupports: {
        readonly name: 'nsISupports';
        readonly number: '00000000-0000-0000-c000-000000000046';
    };
    nsIEncodedChannel: {
        readonly name: 'nsIEncodedChannel';
        readonly number: '29c29ce6-8ce4-45e6-8d60-36c8fa3e255b';
    };
    nsIEnterprisePolicies: {
        readonly name: 'nsIEnterprisePolicies';
        readonly number: '6a568972-cc91-4bf5-963e-3768f3319b8a';
        readonly UNINITIALIZED;
        readonly INACTIVE: 0;
        readonly ACTIVE: 1;
        readonly FAILED: 2;
    };
    nsIEnvironment: {
        readonly name: 'nsIEnvironment';
        readonly number: '101d5941-d820-4e85-a266-9a3469940807';
    };
    nsIEventListenerChange: {
        readonly name: 'nsIEventListenerChange';
        readonly number: '07222b02-da12-4cf4-b2f7-761da007a8d8';
    };
    nsIListenerChangeListener: {
        readonly name: 'nsIListenerChangeListener';
        readonly number: 'aa7c95f6-d3b5-44b3-9597-1d9f19b9c5f2';
    };
    nsIEventListenerInfo: {
        readonly name: 'nsIEventListenerInfo';
        readonly number: '11ba5fd7-8db2-4b1a-9f67-342cfa11afad';
    };
    nsIEventListenerService: {
        readonly name: 'nsIEventListenerService';
        readonly number: '77aab5f7-213d-4db4-9f22-e46dfb774f15';
    };
    nsIEventSourceEventListener: {
        readonly name: 'nsIEventSourceEventListener';
        readonly number: 'd2cc6222-b7f2-490d-adc2-497d89878fa2';
    };
    nsIEventSourceEventService: {
        readonly name: 'nsIEventSourceEventService';
        readonly number: 'c0378840-8a74-4b0a-9225-c3a0ac1fac41';
    };
    nsIEventTarget: {
        readonly name: 'nsIEventTarget';
        readonly number: '';
        readonly DISPATCH_NORMAL: 0;
        readonly DISPATCH_AT_END: 2;
        readonly DISPATCH_EVENT_MAY_BLOCK: 4;
        readonly DISPATCH_IGNORE_BLOCK_DISPATCH: 8;
    };
    nsIStackFrame: {
        readonly name: 'nsIStackFrame';
        readonly number: '';
    };
    nsIException: {
        readonly name: 'nsIException';
        readonly number: '4371b5bf-6845-487f-8d9d-3f1e4a9badd2';
    };
    nsIExpatSink: {
        readonly name: 'nsIExpatSink';
        readonly number: '01f681af-0f22-4725-a914-0d396114daf0';
    };
    nsIExternalHelperAppService: {
        readonly name: 'nsIExternalHelperAppService';
        readonly number: '1E4F3AE1-B737-431F-A95D-31FA8DA70199';
    };
    nsPIExternalAppLauncher: {
        readonly name: 'nsPIExternalAppLauncher';
        readonly number: '6613e2e7-feab-4e3a-bb1f-b03200d544ec';
    };
    nsIHelperAppLauncher: {
        readonly name: 'nsIHelperAppLauncher';
        readonly number: '';
    };
    nsIExternalProtocolHandler: {
        readonly name: 'nsIExternalProtocolHandler';
        readonly number: '0e61f3b2-34d7-4c79-bfdc-4860bc7341b7';
    };
    nsIExternalProtocolService: {
        readonly name: 'nsIExternalProtocolService';
        readonly number: '70f93b7a-3ec6-4bcb-b093-92d9984c9f83';
    };
    nsIFOG: {
        readonly name: 'nsIFOG';
        readonly number: '98d0e975-9cad-4ce3-ae2f-f878b8be6307';
    };
    nsIFactory: {
        readonly name: 'nsIFactory';
        readonly number: '1bb40a56-9223-41e6-97d4-da97bdeb6a4d';
    };
    nsIFaviconService: {
        readonly name: 'nsIFaviconService';
        readonly number: 'e81e0b0c-b9f1-4c2e-8f3c-b809933cf73c';
        readonly FAVICON_LOAD_PRIVATE: 1;
        readonly FAVICON_LOAD_NON_PRIVATE: 2;
        readonly MAX_FAVICON_BUFFER_SIZE: 65536;
    };
    nsIFaviconDataCallback: {
        readonly name: 'nsIFaviconDataCallback';
        readonly number: 'c85e5c82-b70f-4621-9528-beb2aa47fb44';
    };
    nsIFile: {
        readonly name: 'nsIFile';
        readonly number: '';
        readonly NORMAL_FILE_TYPE: 0;
        readonly DIRECTORY_TYPE: 1;
        readonly OS_READAHEAD: 0x40000000;
        readonly DELETE_ON_CLOSE: 0x80000000;
    };
    nsIFileChannel: {
        readonly name: 'nsIFileChannel';
        readonly number: '06169120-136d-45a5-b535-498f1f755ab7';
    };
    nsIFilePicker: {
        readonly name: 'nsIFilePicker';
        readonly number: '9285b984-02d3-46b4-9514-7da8c471a747';
        readonly filterAll: 0x001;
        readonly filterHTML: 0x002;
        readonly filterText: 0x004;
        readonly filterImages: 0x008;
        readonly filterXML: 0x010;
        readonly filterXUL: 0x020;
        readonly filterApps: 0x040;
        readonly filterAllowURLs: 0x080;
        readonly filterAudio: 0x100;
        readonly filterVideo: 0x200;
        readonly filterPDF: 0x400;
    };
    nsIFilePickerShownCallback: {
        readonly name: 'nsIFilePickerShownCallback';
        readonly number: '0d79adad-b244-49A5-9997-2a8cad93fc44';
    };
    nsIFileProtocolHandler: {
        readonly name: 'nsIFileProtocolHandler';
        readonly number: '1fb25bd5-4354-4dcd-8d97-621b7b3ed2e4';
    };
    nsIFileInputStream: {
        readonly name: 'nsIFileInputStream';
        readonly number: 'e3d56a20-c7ec-11d3-8cda-0060b0fc14a3';
        readonly CLOSE_ON_EOF;
        readonly REOPEN_ON_REWIND;
        readonly DEFER_OPEN;
        readonly SHARE_DELETE;
    };
    nsIFileOutputStream: {
        readonly name: 'nsIFileOutputStream';
        readonly number: 'e734cac9-1295-4e6f-9684-3ac4e1f91063';
        readonly DEFER_OPEN;
    };
    nsIFileRandomAccessStream: {
        readonly name: 'nsIFileRandomAccessStream';
        readonly number: '82cf605a-8393-4550-83ab-43cd5578e006';
        readonly DEFER_OPEN;
    };
    nsIFileMetadata: {
        readonly name: 'nsIFileMetadata';
        readonly number: '07f679e4-9601-4bd1-b510-cd3852edb881';
    };
    nsIAsyncFileMetadata: {
        readonly name: 'nsIAsyncFileMetadata';
        readonly number: 'de15b80b-29ba-4b7f-9220-a3d75b17ae8c';
    };
    nsIFileMetadataCallback: {
        readonly name: 'nsIFileMetadataCallback';
        readonly number: 'd01c7ead-7ba3-4726-b399-618ec8ec7057';
    };
    nsIFileURL: {
        readonly name: 'nsIFileURL';
        readonly number: 'e91ac988-27c2-448b-b1a1-3822e1ef1987';
    };
    nsIFileURLMutator: {
        readonly name: 'nsIFileURLMutator';
        readonly number: 'a588b6f2-d2b9-4024-84c7-be3368546b57';
    };
    nsIFinalizationWitnessService: {
        readonly name: 'nsIFinalizationWitnessService';
        readonly number: '15686f9d-483e-4361-98cd-37f1e8f1e61d';
    };
    nsIFind: {
        readonly name: 'nsIFind';
        readonly number: '40aba110-2a56-4678-be90-e2c17a9ae7d7';
    };
    nsIFindService: {
        readonly name: 'nsIFindService';
        readonly number: '5060b801-340e-11d5-be5b-b3e063ec6a3c';
    };
    nsIFocusManager: {
        readonly name: 'nsIFocusManager';
        readonly number: '86e1f1e1-365d-493b-b52a-a649f3f311dc';
        readonly FLAG_RAISE: 1;
        readonly FLAG_NOSCROLL: 2;
        readonly FLAG_NOSWITCHFRAME: 4;
        readonly FLAG_NOPARENTFRAME: 8;
        readonly FLAG_NONSYSTEMCALLER: 16;
        readonly FLAG_BYMOUSE: 0x1000;
        readonly FLAG_BYKEY: 0x2000;
        readonly FLAG_BYMOVEFOCUS: 0x4000;
        readonly FLAG_NOSHOWRING: 0x8000;
        readonly FLAG_SHOWRING: 0x100000;
        readonly FLAG_BYTOUCH: 0x200000;
        readonly FLAG_BYJS: 0x400000;
        readonly FLAG_BYLONGPRESS: 0x800000;
        readonly METHOD_MASK;
        readonly METHODANDRING_MASK;
        readonly MOVEFOCUS_FORWARD: 1;
        readonly MOVEFOCUS_BACKWARD: 2;
        readonly MOVEFOCUS_FORWARDDOC: 3;
        readonly MOVEFOCUS_BACKWARDDOC: 4;
        readonly MOVEFOCUS_FIRST: 5;
        readonly MOVEFOCUS_LAST: 6;
        readonly MOVEFOCUS_ROOT: 7;
        readonly MOVEFOCUS_CARET: 8;
        readonly MOVEFOCUS_FIRSTDOC: 9;
        readonly MOVEFOCUS_LASTDOC: 10;
    };
    nsIFontEnumerator: {
        readonly name: 'nsIFontEnumerator';
        readonly number: '924d98d9-3518-4cb4-8708-c74fe8e3ec3c';
    };
    nsIFontLoadCompleteCallback: {
        readonly name: 'nsIFontLoadCompleteCallback';
        readonly number: '302dbf09-079b-4648-8a06-a0486c1749c0';
    };
    nsIForcePendingChannel: {
        readonly name: 'nsIForcePendingChannel';
        readonly number: '2ac3e1ca-049f-44c3-a519-f0681f51e9b1';
    };
    nsIFormAutoComplete: {
        readonly name: 'nsIFormAutoComplete';
        readonly number: 'bfd9b82b-0ab3-4b6b-9e54-aa961ff4b732';
    };
    nsIFormAutoCompleteObserver: {
        readonly name: 'nsIFormAutoCompleteObserver';
        readonly number: '';
    };
    nsIFormFillController: {
        readonly name: 'nsIFormFillController';
        readonly number: '07f0a0dc-f6e9-4cdd-a55f-56d770523a4c';
    };
    nsIFormPOSTActionChannel: {
        readonly name: 'nsIFormPOSTActionChannel';
        readonly number: 'fc826b53-0db8-42b4-aa6a-5dd2cfca52a4';
    };
    nsIFormatConverter: {
        readonly name: 'nsIFormatConverter';
        readonly number: '948A0023-E3A7-11d2-96CF-0060B0FB9956';
    };
    nsIGIOMimeApp: {
        readonly name: 'nsIGIOMimeApp';
        readonly number: 'ca6bad0c-8a48-48ac-82c7-27bb8f510fbe';
        readonly EXPECTS_URIS: 0;
        readonly EXPECTS_PATHS: 1;
        readonly EXPECTS_URIS_FOR_NON_FILES: 2;
    };
    nsIGIOService: {
        readonly name: 'nsIGIOService';
        readonly number: 'eda22a30-84e1-4e16-9ca0-cd1553c2b34a';
    };
    nsIGNOMEShellService: {
        readonly name: 'nsIGNOMEShellService';
        readonly number: '2ce5c803-edcd-443d-98eb-ceba86d02d13';
    };
    nsIGSettingsCollection: {
        readonly name: 'nsIGSettingsCollection';
        readonly number: '16d5b0ed-e756-4f1b-a8ce-9132e869acd8';
    };
    nsIGSettingsService: {
        readonly name: 'nsIGSettingsService';
        readonly number: '849c088b-57d1-4f24-b7b2-3dc4acb04c0a';
    };
    nsIGeolocationUpdate: {
        readonly name: 'nsIGeolocationUpdate';
        readonly number: '643dc5e9-b911-4b2c-8d44-603162696baf';
    };
    nsIGeolocationProvider: {
        readonly name: 'nsIGeolocationProvider';
        readonly number: 'AC4A133B-9F92-4F7C-B369-D40CB6B17650';
    };
    nsIGfxInfo: {
        readonly name: 'nsIGfxInfo';
        readonly number: '1accd618-4c80-4703-9d29-ecf257d397c8';
        readonly FEATURE_DIRECT2D: 1;
        readonly FEATURE_DIRECT3D_9_LAYERS: 2;
        readonly FEATURE_DIRECT3D_10_LAYERS: 3;
        readonly FEATURE_DIRECT3D_10_1_LAYERS: 4;
        readonly FEATURE_OPENGL_LAYERS: 5;
        readonly FEATURE_WEBGL_OPENGL: 6;
        readonly FEATURE_WEBGL_ANGLE: 7;
        readonly UNUSED_FEATURE_WEBGL_MSAA: 8;
        readonly FEATURE_STAGEFRIGHT: 9;
        readonly FEATURE_WEBRTC_HW_ACCELERATION_H264: 10;
        readonly FEATURE_DIRECT3D_11_LAYERS: 11;
        readonly FEATURE_HARDWARE_VIDEO_DECODING: 12;
        readonly FEATURE_DIRECT3D_11_ANGLE: 13;
        readonly FEATURE_WEBRTC_HW_ACCELERATION_ENCODE: 14;
        readonly FEATURE_WEBRTC_HW_ACCELERATION_DECODE: 15;
        readonly FEATURE_CANVAS2D_ACCELERATION: 16;
        readonly FEATURE_VP8_HW_DECODE: 17;
        readonly FEATURE_VP9_HW_DECODE: 18;
        readonly FEATURE_DX_INTEROP2: 19;
        readonly FEATURE_GPU_PROCESS: 20;
        readonly FEATURE_WEBGL2: 21;
        readonly FEATURE_D3D11_KEYED_MUTEX: 22;
        readonly FEATURE_WEBRENDER: 23;
        readonly FEATURE_DX_NV12: 24;
        readonly FEATURE_DX_P010: 25;
        readonly FEATURE_DX_P016: 26;
        readonly FEATURE_GL_SWIZZLE: 27;
        readonly FEATURE_WEBRENDER_COMPOSITOR: 28;
        readonly FEATURE_WEBRENDER_SCISSORED_CACHE_CLEARS: 29;
        readonly FEATURE_ALLOW_WEBGL_OUT_OF_PROCESS: 30;
        readonly FEATURE_THREADSAFE_GL: 31;
        readonly FEATURE_WEBRENDER_OPTIMIZED_SHADERS: 32;
        readonly FEATURE_X11_EGL: 33;
        readonly FEATURE_DMABUF: 34;
        readonly FEATURE_WEBRENDER_SHADER_CACHE: 35;
        readonly FEATURE_WEBRENDER_PARTIAL_PRESENT: 36;
        readonly FEATURE_WEBGPU: 37;
        readonly FEATURE_VIDEO_OVERLAY: 38;
        readonly FEATURE_HW_DECODED_VIDEO_ZERO_COPY: 39;
        readonly FEATURE_DMABUF_SURFACE_EXPORT: 40;
        readonly FEATURE_REUSE_DECODER_DEVICE: 41;
        readonly FEATURE_BACKDROP_FILTER: 42;
        readonly FEATURE_ACCELERATED_CANVAS2D: 43;
        readonly FEATURE_H264_HW_DECODE: 44;
        readonly FEATURE_AV1_HW_DECODE: 45;
        readonly FEATURE_VIDEO_SOFTWARE_OVERLAY: 46;
        readonly FEATURE_MAX_VALUE: "FEATURE_VIDEO_SOFTWARE_OVERLAY";
        readonly FEATURE_STATUS_OK: 1;
        readonly FEATURE_STATUS_UNKNOWN: 2;
        readonly FEATURE_BLOCKED_DRIVER_VERSION: 3;
        readonly FEATURE_BLOCKED_DEVICE: 4;
        readonly FEATURE_DISCOURAGED: 5;
        readonly FEATURE_BLOCKED_OS_VERSION: 6;
        readonly FEATURE_BLOCKED_MISMATCHED_VERSION: 7;
        readonly FEATURE_DENIED: 8;
        readonly FEATURE_ALLOW_ALWAYS: 9;
        readonly FEATURE_ALLOW_QUALIFIED: 10;
        readonly FEATURE_BLOCKED_PLATFORM_TEST: 11;
    };
    nsIGfxInfoDebug: {
        readonly name: 'nsIGfxInfoDebug';
        readonly number: 'ca7b0bc7-c67c-4b79-8270-ed7ba002af08';
    };
    nsIGleanBoolean: {
        readonly name: 'nsIGleanBoolean';
        readonly number: 'd3180fe0-19fa-11eb-8b6f-0800200c9a66';
    };
    nsIGleanDatetime: {
        readonly name: 'nsIGleanDatetime';
        readonly number: 'aa15fd20-1e8a-11eb-9bec-0800200c9a66';
    };
    nsIGleanCounter: {
        readonly name: 'nsIGleanCounter';
        readonly number: '05b89d2a-d57c-11ea-82da-3f63399a6f5a';
    };
    nsIGleanTimingDistribution: {
        readonly name: 'nsIGleanTimingDistribution';
        readonly number: '92e14730-9b5f-45a1-b018-f588d0b964d8';
    };
    nsIGleanMemoryDistribution: {
        readonly name: 'nsIGleanMemoryDistribution';
        readonly number: 'eea5ed46-16ba-46cd-bb1f-504581987fe1';
    };
    nsIGleanCustomDistribution: {
        readonly name: 'nsIGleanCustomDistribution';
        readonly number: '45cc016f-c1d5-4d54-aaa5-a802cf65f23b';
    };
    nsIGleanPingTestCallback: {
        readonly name: 'nsIGleanPingTestCallback';
        readonly number: 'e5447f62-4b03-497c-81e9-6ab683d20380';
    };
    nsIGleanPing: {
        readonly name: 'nsIGleanPing';
        readonly number: '5223a48b-687d-47ff-a629-fd4a72d1ecfa';
    };
    nsIGleanString: {
        readonly name: 'nsIGleanString';
        readonly number: 'd84a3555-46f1-48c1-9122-e8e88b069d2b';
    };
    nsIGleanStringList: {
        readonly name: 'nsIGleanStringList';
        readonly number: '46751205-2ac7-47dc-91d2-ef4a95ef2af9';
    };
    nsIGleanTimespan: {
        readonly name: 'nsIGleanTimespan';
        readonly number: '2586530c-030f-11eb-93cb-cbf30d25225a';
    };
    nsIGleanUuid: {
        readonly name: 'nsIGleanUuid';
        readonly number: '395700e7-06f6-46be-adcc-ea58977fda6d';
    };
    nsIGleanEvent: {
        readonly name: 'nsIGleanEvent';
        readonly number: '1b01424a-1f55-11eb-92a5-0754f6c3f240';
    };
    nsIGleanQuantity: {
        readonly name: 'nsIGleanQuantity';
        readonly number: '0558c1b2-2cb1-4e21-a0a0-6a91a35ef219';
    };
    nsIGleanDenominator: {
        readonly name: 'nsIGleanDenominator';
        readonly number: '394d9d3b-9e7e-48cc-b76c-a89a51830da3';
    };
    nsIGleanNumerator: {
        readonly name: 'nsIGleanNumerator';
        readonly number: '153fff71-7edd-49b4-a166-4697aa89c7a1';
    };
    nsIGleanRate: {
        readonly name: 'nsIGleanRate';
        readonly number: '920cf631-2b1e-4efe-ae2e-f03277c3112a';
    };
    nsIGleanUrl: {
        readonly name: 'nsIGleanUrl';
        readonly number: 'a59672c4-bc48-4bfe-8f9c-6f408a59d819';
    };
    nsIGleanText: {
        readonly name: 'nsIGleanText';
        readonly number: 'fafceafb-c3a0-4424-b3b9-b7bd487f6bb4';
    };
    nsIGtkTaskbarProgress: {
        readonly name: 'nsIGtkTaskbarProgress';
        readonly number: '39f6fc5a-2386-4bc6-941c-d7479253bc3f';
    };
    nsIHTMLAbsPosEditor: {
        readonly name: 'nsIHTMLAbsPosEditor';
        readonly number: '91375f52-20e6-4757-9835-eb04fabe5498';
    };
    nsIHTMLEditor: {
        readonly name: 'nsIHTMLEditor';
        readonly number: '87ee993e-985f-4a43-a974-0d9512da2fb0';
        readonly eLeft: 0;
        readonly eCenter: 1;
        readonly eRight: 2;
        readonly eJustify: 3;
    };
    nsIHTMLInlineTableEditor: {
        readonly name: 'nsIHTMLInlineTableEditor';
        readonly number: 'eda2e65c-a758-451f-9b05-77cb8de74ed2';
    };
    nsIHTMLObjectResizer: {
        readonly name: 'nsIHTMLObjectResizer';
        readonly number: '8b396020-69d3-451f-80c1-1a96a7da25a9';
        readonly eTopLeft: 0;
        readonly eTop: 1;
        readonly eTopRight: 2;
        readonly eLeft: 3;
        readonly eRight: 4;
        readonly eBottomLeft: 5;
        readonly eBottom: 6;
        readonly eBottomRight: 7;
    };
    nsIHandlerService: {
        readonly name: 'nsIHandlerService';
        readonly number: '53f0ad17-ec62-46a1-adbc-efccc06babcd';
    };
    nsIHangDetails: {
        readonly name: 'nsIHangDetails';
        readonly number: '23d63fff-38d6-4003-9c57-2c90aca1180a';
    };
    nsIHangReport: {
        readonly name: 'nsIHangReport';
        readonly number: '5fcffbb9-be62-49b1-b8a1-36e820787a74';
    };
    nsIHapticFeedback: {
        readonly name: 'nsIHapticFeedback';
        readonly number: '91917c98-a8f3-4c98-8f10-4afb872f54c7';
        readonly ShortPress: 0;
        readonly LongPress: 1;
    };
    nsIHelperAppLauncherDialog: {
        readonly name: 'nsIHelperAppLauncherDialog';
        readonly number: 'bfc739f3-8d75-4034-a6f8-1039a5996bad';
        readonly REASON_CANTHANDLE: 0;
        readonly REASON_SERVERREQUEST: 1;
        readonly REASON_TYPESNIFFED: 2;
    };
    nsIHttpActivityObserver: {
        readonly name: 'nsIHttpActivityObserver';
        readonly number: '412880C8-6C36-48d8-BF8F-84F91F892503';
        readonly ACTIVITY_TYPE_SOCKET_TRANSPORT: 0x0001;
        readonly ACTIVITY_TYPE_HTTP_TRANSACTION: 0x0002;
        readonly ACTIVITY_TYPE_HTTP_CONNECTION: 0x0003;
        readonly ACTIVITY_SUBTYPE_REQUEST_HEADER: 0x5001;
        readonly ACTIVITY_SUBTYPE_REQUEST_BODY_SENT: 0x5002;
        readonly ACTIVITY_SUBTYPE_RESPONSE_START: 0x5003;
        readonly ACTIVITY_SUBTYPE_RESPONSE_HEADER: 0x5004;
        readonly ACTIVITY_SUBTYPE_RESPONSE_COMPLETE: 0x5005;
        readonly ACTIVITY_SUBTYPE_TRANSACTION_CLOSE: 0x5006;
        readonly ACTIVITY_SUBTYPE_PROXY_RESPONSE_HEADER: 0x5007;
        readonly ACTIVITY_SUBTYPE_DNSANDSOCKET_CREATED: 0x5008;
        readonly ACTIVITY_SUBTYPE_SPECULATIVE_DNSANDSOCKET_CREATED: 0x5009;
        readonly ACTIVITY_SUBTYPE_ECH_SET: 0x500A;
        readonly ACTIVITY_SUBTYPE_CONNECTION_CREATED: 0x500B;
    };
    nsIHttpActivityDistributor: {
        readonly name: 'nsIHttpActivityDistributor';
        readonly number: '7C512CB8-582A-4625-B5B6-8639755271B5';
    };
    nsIHttpAuthManager: {
        readonly name: 'nsIHttpAuthManager';
        readonly number: '54f90444-c52b-4d2d-8916-c59a2bb25938';
    };
    nsIHttpAuthenticableChannel: {
        readonly name: 'nsIHttpAuthenticableChannel';
        readonly number: '';
    };
    nsIHttpAuthenticator: {
        readonly name: 'nsIHttpAuthenticator';
        readonly number: 'fef7db8a-a4e2-49d1-9685-19ed7e309b7d';
        readonly USING_INTERNAL_IDENTITY;
        readonly REQUEST_BASED;
        readonly CONNECTION_BASED;
        readonly REUSABLE_CREDENTIALS;
        readonly REUSABLE_CHALLENGE;
        readonly IDENTITY_IGNORED;
        readonly IDENTITY_INCLUDES_DOMAIN;
        readonly IDENTITY_ENCRYPTED;
    };
    nsIHttpAuthenticatorCallback: {
        readonly name: 'nsIHttpAuthenticatorCallback';
        readonly number: 'd989cb03-e446-4086-b9e6-46842cb97bd5';
    };
    nsIHttpChannel: {
        readonly name: 'nsIHttpChannel';
        readonly number: '';
    };
    nsIHttpChannelAuthProvider: {
        readonly name: 'nsIHttpChannelAuthProvider';
        readonly number: '788f331b-2e1f-436c-b405-4f88a31a105b';
    };
    nsIHttpChannelChild: {
        readonly name: 'nsIHttpChannelChild';
        readonly number: 'd02b96ed-2789-4f42-a25c-7abe63de7c18';
    };
    nsIHttpUpgradeListener: {
        readonly name: 'nsIHttpUpgradeListener';
        readonly number: '';
    };
    nsIHttpChannelInternal: {
        readonly name: 'nsIHttpChannelInternal';
        readonly number: '4e28263d-1e03-46f4-aa5c-9512f91957f9';
        readonly THIRD_PARTY_FORCE_ALLOW;
        readonly REDIRECT_MODE_FOLLOW: 0;
        readonly REDIRECT_MODE_ERROR: 1;
        readonly REDIRECT_MODE_MANUAL: 2;
        readonly FETCH_CACHE_MODE_DEFAULT: 0;
        readonly FETCH_CACHE_MODE_NO_STORE: 1;
        readonly FETCH_CACHE_MODE_RELOAD: 2;
        readonly FETCH_CACHE_MODE_NO_CACHE: 3;
        readonly FETCH_CACHE_MODE_FORCE_CACHE: 4;
        readonly FETCH_CACHE_MODE_ONLY_IF_CACHED: 5;
    };
    nsIHttpHeaderVisitor: {
        readonly name: 'nsIHttpHeaderVisitor';
        readonly number: '35412859-b9d9-423c-8866-2d4559fdd2be';
    };
    nsIHttpProtocolHandler: {
        readonly name: 'nsIHttpProtocolHandler';
        readonly number: 'c48126d9-2ddd-485b-a51a-378e917e75f8';
    };
    nsIHttpPushListener: {
        readonly name: 'nsIHttpPushListener';
        readonly number: '0d6ce59c-ad5d-4520-b4d3-09664868f279';
    };
    nsIHttpServer: {
        readonly name: 'nsIHttpServer';
        readonly number: 'cea8812e-faa6-4013-9396-f9936cbb74ec';
    };
    nsIHttpServerStoppedCallback: {
        readonly name: 'nsIHttpServerStoppedCallback';
        readonly number: '925a6d33-9937-4c63-abe1-a1c56a986455';
    };
    nsIHttpServerIdentity: {
        readonly name: 'nsIHttpServerIdentity';
        readonly number: 'a89de175-ae8e-4c46-91a5-0dba99bbd284';
    };
    nsIHttpRequestHandler: {
        readonly name: 'nsIHttpRequestHandler';
        readonly number: '2bbb4db7-d285-42b3-a3ce-142b8cc7e139';
    };
    nsIHttpRequest: {
        readonly name: 'nsIHttpRequest';
        readonly number: '978cf30e-ad73-42ee-8f22-fe0aaf1bf5d2';
    };
    nsIHttpResponse: {
        readonly name: 'nsIHttpResponse';
        readonly number: '1acd16c2-dc59-42fa-9160-4f26c43c1c21';
    };
    nsIHttpsOnlyModePermission: {
        readonly name: 'nsIHttpsOnlyModePermission';
        readonly number: '73f4f039-d6ff-41a7-9eb3-00db57b0b7f4';
        readonly LOAD_INSECURE_DEFAULT: 0;
        readonly LOAD_INSECURE_ALLOW: 1;
        readonly LOAD_INSECURE_BLOCK: 2;
        readonly LOAD_INSECURE_ALLOW_SESSION: 9;
    };
    nsIIDBPermissionsRequest: {
        readonly name: 'nsIIDBPermissionsRequest';
        readonly number: 'c3493c65-0530-496e-995c-bcd38dbfce21';
    };
    nsIIDNService: {
        readonly name: 'nsIIDNService';
        readonly number: 'a592a60e-3621-4f19-a318-2bf233cfad3e';
    };
    nsIINIParser: {
        readonly name: 'nsIINIParser';
        readonly number: '7eb955f6-3e78-4d39-b72f-c1bf12a94bce';
    };
    nsIINIParserWriter: {
        readonly name: 'nsIINIParserWriter';
        readonly number: 'b67bb24b-31a3-4a6a-a5d9-0485c9af5a04';
    };
    nsIINIParserFactory: {
        readonly name: 'nsIINIParserFactory';
        readonly number: 'ccae7ea5-1218-4b51-aecb-c2d8ecd46af9';
    };
    nsIIOService: {
        readonly name: 'nsIIOService';
        readonly number: '4286de5a-b2ea-446f-8f70-e2a461f42694';
    };
    nsIIOServiceInternal: {
        readonly name: 'nsIIOServiceInternal';
        readonly number: '6633c0bf-d97a-428f-8ece-cb6a655fb95a';
    };
    nsIIOUtil: {
        readonly name: 'nsIIOUtil';
        readonly number: 'e8152f7f-4209-4c63-ad23-c3d2aa0c5a49';
    };
    nsIMozIconURI: {
        readonly name: 'nsIMozIconURI';
        readonly number: 'f8fe5ef2-5f2b-43f3-857d-5b64d192c427';
    };
    nsIIdentityCredentialPromptService: {
        readonly name: 'nsIIdentityCredentialPromptService';
        readonly number: '936007db-a957-4f1d-a23d-f7d9403223e6';
    };
    nsIIdentityCredentialStorageService: {
        readonly name: 'nsIIdentityCredentialStorageService';
        readonly number: '029823d0-0448-46c5-af1f-25cd4501d0d7';
    };
    nsIIdlePeriod: {
        readonly name: 'nsIIdlePeriod';
        readonly number: '21dd35a2-eae9-4bd8-b470-0dfa35a0e3b9';
    };
    nsIImageLoadingContent: {
        readonly name: 'nsIImageLoadingContent';
        readonly number: '0357123d-9224-4d12-a47e-868c32689777';
        readonly UNKNOWN_REQUEST;
        readonly CURRENT_REQUEST: 0;
        readonly PENDING_REQUEST: 1;
    };
    nsIIncrementalDownload: {
        readonly name: 'nsIIncrementalDownload';
        readonly number: '6687823f-56c4-461d-93a1-7f6cb7dfbfba';
    };
    nsIIncrementalStreamLoaderObserver: {
        readonly name: 'nsIIncrementalStreamLoaderObserver';
        readonly number: '07c3d2cc-5454-4618-9f4f-cd93de9504a4';
    };
    nsIIncrementalStreamLoader: {
        readonly name: 'nsIIncrementalStreamLoader';
        readonly number: 'a023b060-ba23-431a-b449-2dd63e220554';
    };
    nsIInlineSpellChecker: {
        readonly name: 'nsIInlineSpellChecker';
        readonly number: 'b7b7a77c-40c4-4196-b0b7-b0338243b3fe';
    };
    nsIInputListAutoComplete: {
        readonly name: 'nsIInputListAutoComplete';
        readonly number: '0e33de3e-4faf-4a1a-b96e-24115b8bfd45';
    };
    nsIInputStream: {
        readonly name: 'nsIInputStream';
        readonly number: '';
    };
    nsIInputStreamChannel: {
        readonly name: 'nsIInputStreamChannel';
        readonly number: 'ea730238-4bfd-4015-8489-8f264d05b343';
    };
    nsIInputStreamLength: {
        readonly name: 'nsIInputStreamLength';
        readonly number: '452d059f-9a9c-4434-8839-e10d1405647c';
    };
    nsIAsyncInputStreamLength: {
        readonly name: 'nsIAsyncInputStreamLength';
        readonly number: 'b63f9ecf-4668-44a3-93bd-72dbc65a6125';
    };
    nsIInputStreamLengthCallback: {
        readonly name: 'nsIInputStreamLengthCallback';
        readonly number: '9c0c13b9-1b33-445d-8adb-a8a7866a6c06';
    };
    nsIInputStreamPriority: {
        readonly name: 'nsIInputStreamPriority';
        readonly number: 'daa45b24-98ee-4eb2-9cec-aad0bc023e9d';
    };
    nsIInputStreamPump: {
        readonly name: 'nsIInputStreamPump';
        readonly number: '400F5468-97E7-4d2b-9C65-A82AECC7AE82';
    };
    nsIInputStreamTee: {
        readonly name: 'nsIInputStreamTee';
        readonly number: '90a9d790-3bca-421e-a73b-98f68e13c917';
    };
    nsIInterceptionInfo: {
        readonly name: 'nsIInterceptionInfo';
        readonly number: '8b9cd81f-3cd1-4f6a-9086-92a9bbf055f4';
    };
    nsIInterfaceRequestor: {
        readonly name: 'nsIInterfaceRequestor';
        readonly number: '';
    };
    nsIJARChannel: {
        readonly name: 'nsIJARChannel';
        readonly number: 'e72b179b-d5df-4d87-b5de-fd73a65c60f6';
    };
    nsIJARURI: {
        readonly name: 'nsIJARURI';
        readonly number: '646a508c-f786-4e14-be6d-8dda2a633c60';
    };
    nsIJARURIMutator: {
        readonly name: 'nsIJARURIMutator';
        readonly number: 'd66df117-eda7-4324-b4e4-1f670ff6718e';
    };
    nsIJSInspector: {
        readonly name: 'nsIJSInspector';
        readonly number: '6758d0d7-e96a-4c5c-bca8-3bcbe5a15943';
    };
    nsIJumpListCommittedCallback: {
        readonly name: 'nsIJumpListCommittedCallback';
        readonly number: '5131a62a-e99f-4631-9138-751f8aad1ae4';
    };
    nsIJumpListBuilder: {
        readonly name: 'nsIJumpListBuilder';
        readonly number: '';
        readonly JUMPLIST_CATEGORY_TASKS: 0;
        readonly JUMPLIST_CATEGORY_RECENT: 1;
        readonly JUMPLIST_CATEGORY_FREQUENT: 2;
        readonly JUMPLIST_CATEGORY_CUSTOMLIST: 3;
    };
    nsIJumpListItem: {
        readonly name: 'nsIJumpListItem';
        readonly number: 'ACB8FB3C-E1B0-4044-8A50-E52C3E7C1057';
        readonly JUMPLIST_ITEM_EMPTY: 0;
        readonly JUMPLIST_ITEM_SEPARATOR: 1;
        readonly JUMPLIST_ITEM_LINK: 2;
        readonly JUMPLIST_ITEM_SHORTCUT: 3;
    };
    nsIJumpListSeparator: {
        readonly name: 'nsIJumpListSeparator';
        readonly number: '69A2D5C5-14DC-47da-925D-869E0BD64D27';
    };
    nsIJumpListLink: {
        readonly name: 'nsIJumpListLink';
        readonly number: '76EA47B1-C797-49b3-9F18-5E740A688524';
    };
    nsIJumpListShortcut: {
        readonly name: 'nsIJumpListShortcut';
        readonly number: 'CBE3A37C-BCE1-4fec-80A5-5FFBC7F33EEA';
    };
    nsIKeyValueService: {
        readonly name: 'nsIKeyValueService';
        readonly number: '46c893dd-4c14-4de0-b33d-a1be18c6d062';
    };
    nsIKeyValueDatabase: {
        readonly name: 'nsIKeyValueDatabase';
        readonly number: 'c449398e-174c-425b-8195-da6aa0ccd9a5';
    };
    nsIKeyValuePair: {
        readonly name: 'nsIKeyValuePair';
        readonly number: 'bc37b06a-23b5-4b32-8281-4b8479601c7e';
    };
    nsIKeyValueEnumerator: {
        readonly name: 'nsIKeyValueEnumerator';
        readonly number: 'b9ba7116-b7ff-4717-9a28-a08e6879b199';
    };
    nsIKeyValueDatabaseCallback: {
        readonly name: 'nsIKeyValueDatabaseCallback';
        readonly number: '2becc1f8-2d80-4b63-92a8-24ee8f79ee45';
    };
    nsIKeyValueEnumeratorCallback: {
        readonly name: 'nsIKeyValueEnumeratorCallback';
        readonly number: 'b7ea2183-880b-4424-ab24-5aa1555b775d';
    };
    nsIKeyValuePairCallback: {
        readonly name: 'nsIKeyValuePairCallback';
        readonly number: '50f65485-ec1e-4307-812b-b8a15e1f382e';
    };
    nsIKeyValueVariantCallback: {
        readonly name: 'nsIKeyValueVariantCallback';
        readonly number: '174ebfa1-74ea-42a7-aa90-85bbaf1da4bf';
    };
    nsIKeyValueVoidCallback: {
        readonly name: 'nsIKeyValueVoidCallback';
        readonly number: '0c17497a-ccf8-451a-838d-9dfa7f846379';
    };
    nsIKeychainMigrationUtils: {
        readonly name: 'nsIKeychainMigrationUtils';
        readonly number: '647bf80c-cd35-4ce6-b904-fd586b97ae48';
    };
    nsILayoutDebuggingTools: {
        readonly name: 'nsILayoutDebuggingTools';
        readonly number: 'f336d8d3-9721-4ad3-85d0-a7018c0a3383';
    };
    nsILayoutHistoryState: {
        readonly name: 'nsILayoutHistoryState';
        readonly number: '';
    };
    nsILineInputStream: {
        readonly name: 'nsILineInputStream';
        readonly number: 'c97b466c-1e6e-4773-a4ab-2b2b3190a7a6';
    };
    nsILoadContext: {
        readonly name: 'nsILoadContext';
        readonly number: '';
    };
    nsILoadContextInfo: {
        readonly name: 'nsILoadContextInfo';
        readonly number: '555e2f8a-a1f6-41dd-88ca-ed4ed6b98a22';
    };
    nsILoadContextInfoFactory: {
        readonly name: 'nsILoadContextInfoFactory';
        readonly number: 'c1c7023d-4318-4f99-8307-b5ccf0558793';
    };
    nsILoadGroup: {
        readonly name: 'nsILoadGroup';
        readonly number: '';
    };
    nsILoadGroupChild: {
        readonly name: 'nsILoadGroupChild';
        readonly number: '02efe8e2-fbbc-4718-a299-b8a09c60bf6b';
    };
    nsILoadInfo: {
        readonly name: 'nsILoadInfo';
        readonly number: '';
        readonly SEC_ONLY_FOR_EXPLICIT_CONTENTSEC_CHECK: 0;
        readonly SEC_REQUIRE_SAME_ORIGIN_INHERITS_SEC_CONTEXT;
        readonly SEC_REQUIRE_SAME_ORIGIN_DATA_IS_BLOCKED;
        readonly SEC_ALLOW_CROSS_ORIGIN_INHERITS_SEC_CONTEXT;
        readonly SEC_ALLOW_CROSS_ORIGIN_SEC_CONTEXT_IS_NULL;
        readonly SEC_REQUIRE_CORS_INHERITS_SEC_CONTEXT;
        readonly SEC_COOKIES_DEFAULT;
        readonly SEC_COOKIES_INCLUDE;
        readonly SEC_COOKIES_SAME_ORIGIN;
        readonly SEC_COOKIES_OMIT;
        readonly SEC_FORCE_INHERIT_PRINCIPAL;
        readonly SEC_ABOUT_BLANK_INHERITS;
        readonly SEC_ALLOW_CHROME;
        readonly SEC_DISALLOW_SCRIPT;
        readonly SEC_DONT_FOLLOW_REDIRECTS;
        readonly SEC_LOAD_ERROR_PAGE;
        readonly SEC_FORCE_INHERIT_PRINCIPAL_OVERRULE_OWNER;
        readonly HTTPS_ONLY_UNINITIALIZED;
        readonly HTTPS_ONLY_UPGRADED_LISTENER_NOT_REGISTERED;
        readonly HTTPS_ONLY_UPGRADED_LISTENER_REGISTERED;
        readonly HTTPS_ONLY_EXEMPT;
        readonly HTTPS_ONLY_TOP_LEVEL_LOAD_IN_PROGRESS;
        readonly HTTPS_ONLY_DOWNLOAD_IN_PROGRESS;
        readonly HTTPS_ONLY_DO_NOT_LOG_TO_CONSOLE;
        readonly HTTPS_ONLY_UPGRADED_HTTPS_FIRST;
        readonly HTTPS_ONLY_BYPASS_ORB;
        readonly HTTPS_FIRST_EXEMPT_NEXT_LOAD;
        readonly TAINTING_BASIC: 0;
        readonly TAINTING_CORS: 1;
        readonly TAINTING_OPAQUE: 2;
        readonly BLOCKING_REASON_NONE: 0;
        readonly BLOCKING_REASON_CORSDISABLED: 1001;
        readonly BLOCKING_REASON_CORSDIDNOTSUCCEED: 1002;
        readonly BLOCKING_REASON_CORSREQUESTNOTHTTP: 1003;
        readonly BLOCKING_REASON_CORSMULTIPLEALLOWORIGINNOTALLOWED: 1004;
        readonly BLOCKING_REASON_CORSMISSINGALLOWORIGIN: 1005;
        readonly BLOCKING_REASON_CORSNOTSUPPORTINGCREDENTIALS: 1006;
        readonly BLOCKING_REASON_CORSALLOWORIGINNOTMATCHINGORIGIN: 1007;
        readonly BLOCKING_REASON_CORSMISSINGALLOWCREDENTIALS: 1008;
        readonly BLOCKING_REASON_CORSORIGINHEADERNOTADDED: 1009;
        readonly BLOCKING_REASON_CORSEXTERNALREDIRECTNOTALLOWED: 1010;
        readonly BLOCKING_REASON_CORSPREFLIGHTDIDNOTSUCCEED: 1011;
        readonly BLOCKING_REASON_CORSINVALIDALLOWMETHOD: 1012;
        readonly BLOCKING_REASON_CORSMETHODNOTFOUND: 1013;
        readonly BLOCKING_REASON_CORSINVALIDALLOWHEADER: 1014;
        readonly BLOCKING_REASON_CORSMISSINGALLOWHEADERFROMPREFLIGHT: 1015;
        readonly BLOCKING_REASON_CLASSIFY_MALWARE_URI: 2001;
        readonly BLOCKING_REASON_CLASSIFY_PHISHING_URI: 2002;
        readonly BLOCKING_REASON_CLASSIFY_UNWANTED_URI: 2003;
        readonly BLOCKING_REASON_CLASSIFY_TRACKING_URI: 2004;
        readonly BLOCKING_REASON_CLASSIFY_BLOCKED_URI: 2005;
        readonly BLOCKING_REASON_CLASSIFY_HARMFUL_URI: 2006;
        readonly BLOCKING_REASON_CLASSIFY_CRYPTOMINING_URI: 2007;
        readonly BLOCKING_REASON_CLASSIFY_FINGERPRINTING_URI: 2008;
        readonly BLOCKING_REASON_CLASSIFY_SOCIALTRACKING_URI: 2009;
        readonly BLOCKING_REASON_CLASSIFY_EMAILTRACKING_URI: 2010;
        readonly BLOCKING_REASON_MIXED_BLOCKED: 3001;
        readonly BLOCKING_REASON_CONTENT_POLICY_GENERAL: 4000;
        readonly BLOCKING_REASON_CONTENT_POLICY_NO_DATA_PROTOCOL: 4001;
        readonly BLOCKING_REASON_CONTENT_POLICY_WEBEXT: 4002;
        readonly BLOCKING_REASON_CONTENT_POLICY_CONTENT_BLOCKED: 4003;
        readonly BLOCKING_REASON_CONTENT_POLICY_DATA_DOCUMENT: 4004;
        readonly BLOCKING_REASON_CONTENT_POLICY_WEB_BROWSER: 4005;
        readonly BLOCKING_REASON_CONTENT_POLICY_PRELOAD: 4006;
        readonly BLOCKING_REASON_NOT_SAME_ORIGIN: 5000;
        readonly BLOCKING_REASON_EXTENSION_WEBREQUEST: 6000;
    };
    nsILoadURIDelegate: {
        readonly name: 'nsILoadURIDelegate';
        readonly number: '78e42d37-a34c-4d96-b901-25385669aba4';
    };
    nsILocalFileMac: {
        readonly name: 'nsILocalFileMac';
        readonly number: '623eca5b-c25d-4e27-be5a-789a66c4b2f7';
    };
    nsILocalFileWin: {
        readonly name: 'nsILocalFileWin';
        readonly number: 'e7a3a954-384b-4aeb-a5f7-55626b0de9be';
    };
    nsILocalStorageManager: {
        readonly name: 'nsILocalStorageManager';
        readonly number: 'd4f534da-2744-4db3-8774-8b187c64ade9';
    };
    nsILoginAutoCompleteSearch: {
        readonly name: 'nsILoginAutoCompleteSearch';
        readonly number: '2bdac17c-53f1-4896-a521-682ccdeef3a8';
    };
    nsILoginDetectionService: {
        readonly name: 'nsILoginDetectionService';
        readonly number: '4c3c9a82-722a-4b0b-9c7d-36ef90135537';
    };
    nsILoginInfo: {
        readonly name: 'nsILoginInfo';
        readonly number: '';
    };
    nsILoginSearchCallback: {
        readonly name: 'nsILoginSearchCallback';
        readonly number: '43429075-ede6-41eb-ac69-a8cd4376b041';
    };
    nsILoginManager: {
        readonly name: 'nsILoginManager';
        readonly number: '38c7f6af-7df9-49c7-b558-2776b24e6cc1';
    };
    nsILoginManagerAuthPrompter: {
        readonly name: 'nsILoginManagerAuthPrompter';
        readonly number: '425f73b9-b2db-4e8a-88c5-9ac2512934ce';
    };
    nsILoginManagerCrypto: {
        readonly name: 'nsILoginManagerCrypto';
        readonly number: '2030770e-542e-40cd-8061-cd9d4ad4227f';
        readonly ENCTYPE_BASE64: 0;
        readonly ENCTYPE_SDR: 1;
    };
    nsILoginManagerPrompter: {
        readonly name: 'nsILoginManagerPrompter';
        readonly number: 'c47ff942-9678-44a5-bc9b-05e0d676c79c';
    };
    nsILoginManagerStorage: {
        readonly name: 'nsILoginManagerStorage';
        readonly number: '5df81a93-25e6-4b45-a696-089479e15c7d';
    };
    nsILoginMetaInfo: {
        readonly name: 'nsILoginMetaInfo';
        readonly number: '20d8eb40-c494-497f-b2a6-aaa32f807ebd';
    };
    nsILoginReputationVerdictType: {
        readonly name: 'nsILoginReputationVerdictType';
        readonly number: '6219f9da-297e-446d-8d47-ccdd8e72a1d5';
        readonly UNSPECIFIED: 0;
        readonly SAFE: 1;
        readonly LOW_REPUTATION: 2;
        readonly PHISHING: 3;
    };
    nsILoginReputationQuery: {
        readonly name: 'nsILoginReputationQuery';
        readonly number: 'c21ffe59-595f-46c8-9052-fefb639e196e';
    };
    nsILoginReputationQueryCallback: {
        readonly name: 'nsILoginReputationQueryCallback';
        readonly number: 'b527be1e-8fbb-41d9-bee4-267a71236368';
    };
    nsILoginReputationService: {
        readonly name: 'nsILoginReputationService';
        readonly number: '1b3f1dfe-ce3a-486b-953e-ce5ac863eff9';
    };
    nsIMIMEHeaderParam: {
        readonly name: 'nsIMIMEHeaderParam';
        readonly number: '9c9252a1-fdaf-40a2-9c2b-a3dc45e28dde';
    };
    nsIHandlerInfo: {
        readonly name: 'nsIHandlerInfo';
        readonly number: '325e56a7-3762-4312-aec7-f1fcf84b4145';
        readonly saveToDisk: 0;
        readonly alwaysAsk: 1;
        readonly useHelperApp: 2;
        readonly handleInternally: 3;
        readonly useSystemDefault: 4;
    };
    nsIMIMEInfo: {
        readonly name: 'nsIMIMEInfo';
        readonly number: '';
    };
    nsIHandlerApp: {
        readonly name: 'nsIHandlerApp';
        readonly number: '8BDF20A4-9170-4548-AF52-78311A44F920';
    };
    nsILocalHandlerApp: {
        readonly name: 'nsILocalHandlerApp';
        readonly number: 'D36B6329-52AE-4f45-80F4-B2536AE5F8B2';
    };
    nsIWebHandlerApp: {
        readonly name: 'nsIWebHandlerApp';
        readonly number: '7521a093-c498-45ce-b462-df7ba0d882f6';
    };
    nsIDBusHandlerApp: {
        readonly name: 'nsIDBusHandlerApp';
        readonly number: '1ffc274b-4cbf-4bb5-a635-05ad2cbb6534';
    };
    nsIMIMEInputStream: {
        readonly name: 'nsIMIMEInputStream';
        readonly number: 'dcbce63c-1dd1-11b2-b94d-91f6d49a3161';
    };
    nsIMIMEService: {
        readonly name: 'nsIMIMEService';
        readonly number: '5b3675a1-02db-4f8f-a560-b34736635f47';
        readonly VALIDATE_DEFAULT: 0;
        readonly VALIDATE_SANITIZE_ONLY: 1;
        readonly VALIDATE_DONT_COLLAPSE_WHITESPACE: 2;
        readonly VALIDATE_DONT_TRUNCATE: 4;
        readonly VALIDATE_GUESS_FROM_EXTENSION: 8;
        readonly VALIDATE_ALLOW_EMPTY: 16;
        readonly VALIDATE_NO_DEFAULT_FILENAME: 32;
        readonly VALIDATE_FORCE_APPEND_EXTENSION: 64;
        readonly VALIDATE_ALLOW_INVALID_FILENAMES: 128;
    };
    nsIMacAttributionService: {
        readonly name: 'nsIMacAttributionService';
        readonly number: '6FC66A78-6CBC-4B3F-B7BA-379289B29276';
    };
    nsIMacDockSupport: {
        readonly name: 'nsIMacDockSupport';
        readonly number: '8BE66B0C-5F71-4B74-98CF-6C2551B999B1';
    };
    nsIMacFinderProgressCanceledCallback: {
        readonly name: 'nsIMacFinderProgressCanceledCallback';
        readonly number: '6BAE6D1C-7FFD-4354-8D7B-64697E98A801';
    };
    nsIMacFinderProgress: {
        readonly name: 'nsIMacFinderProgress';
        readonly number: '25A0B01F-54D4-4AEF-B2BF-C5764CDC68A8';
    };
    nsIMacPreferencesReader: {
        readonly name: 'nsIMacPreferencesReader';
        readonly number: 'b0f20595-88ce-4738-a1a4-24de78eb8051';
    };
    nsIMacSharingService: {
        readonly name: 'nsIMacSharingService';
        readonly number: 'de59fe1a-46c8-490f-b04d-34545acb06c9';
    };
    nsIMacShellService: {
        readonly name: 'nsIMacShellService';
        readonly number: '387fdc80-0077-4b60-a0d9-d9e80a83ba64';
    };
    nsIMacUserActivityUpdater: {
        readonly name: 'nsIMacUserActivityUpdater';
        readonly number: '29046c8f-cba6-4ffa-9141-1685e96c4ea0';
    };
    nsITrashAppCallback: {
        readonly name: 'nsITrashAppCallback';
        readonly number: '8c899c4f-58c1-4b74-9034-3bb64e484b68';
    };
    nsIMacWebAppUtils: {
        readonly name: 'nsIMacWebAppUtils';
        readonly number: 'c69cf343-ea41-428b-b161-4655fd54d8e7';
    };
    nsIMarionette: {
        readonly name: 'nsIMarionette';
        readonly number: '13fa7d76-f976-4711-a00c-29ac9c1881e1';
    };
    nsIMediaDevice: {
        readonly name: 'nsIMediaDevice';
        readonly number: '';
    };
    nsIMediaManagerService: {
        readonly name: 'nsIMediaManagerService';
        readonly number: '24b23e01-33fd-401f-ba25-6e52658750b0';
        readonly STATE_NOCAPTURE: 0;
        readonly STATE_CAPTURE_ENABLED: 1;
        readonly STATE_CAPTURE_DISABLED: 2;
    };
    nsIFinishDumpingCallback: {
        readonly name: 'nsIFinishDumpingCallback';
        readonly number: '2dea18fc-fbfa-4bf7-ad45-0efaf5495f5e';
    };
    nsIDumpGCAndCCLogsCallback: {
        readonly name: 'nsIDumpGCAndCCLogsCallback';
        readonly number: 'dc1b2b24-65bd-441b-b6bd-cb5825a7ed14';
    };
    nsIMemoryInfoDumper: {
        readonly name: 'nsIMemoryInfoDumper';
        readonly number: '48541b74-47ee-4a62-9557-7f4b809bda5c';
    };
    nsIHandleReportCallback: {
        readonly name: 'nsIHandleReportCallback';
        readonly number: '62ef0e1c-dbd6-11e3-aa75-3c970e9f4238';
    };
    nsIMemoryReporter: {
        readonly name: 'nsIMemoryReporter';
        readonly number: '92a36db1-46bd-4fe6-988e-47db47236d8b';
        readonly KIND_NONHEAP: 0;
        readonly KIND_HEAP: 1;
        readonly KIND_OTHER: 2;
        readonly UNITS_BYTES: 0;
        readonly UNITS_COUNT: 1;
        readonly UNITS_COUNT_CUMULATIVE: 2;
        readonly UNITS_PERCENTAGE: 3;
    };
    nsIFinishReportingCallback: {
        readonly name: 'nsIFinishReportingCallback';
        readonly number: '548b3909-c04d-4ca6-8466-b8bee3837457';
    };
    nsIHeapAllocatedCallback: {
        readonly name: 'nsIHeapAllocatedCallback';
        readonly number: '1a80cd0f-0d9e-4397-be69-68ad28fe5175';
    };
    nsIMemoryReporterManager: {
        readonly name: 'nsIMemoryReporterManager';
        readonly number: '2998574d-8993-407a-b1a5-8ad7417653e1';
    };
    nsIMessageLoop: {
        readonly name: 'nsIMessageLoop';
        readonly number: '3E8C58E8-E52C-43E0-8E66-669CA788FF5F';
    };
    nsIMessageSender: {
        readonly name: 'nsIMessageSender';
        readonly number: 'bb5d79e4-e73c-45e7-9651-4d718f4b994c';
    };
    nsIInProcessContentFrameMessageManager: {
        readonly name: 'nsIInProcessContentFrameMessageManager';
        readonly number: 'b39a3324-b574-4f85-8cdb-274d04f807ef';
    };
    nsIMozBrowserFrame: {
        readonly name: 'nsIMozBrowserFrame';
        readonly number: '0c0a862c-1a47-43c0-ae9e-d51835e3e1a6';
    };
    nsIMultiPartChannel: {
        readonly name: 'nsIMultiPartChannel';
        readonly number: '4fefb490-5567-11e5-a837-0800200c9a66';
    };
    nsIMultiPartChannelListener: {
        readonly name: 'nsIMultiPartChannelListener';
        readonly number: 'b084959a-4fb9-41a5-88a0-d0f045ce75cf';
    };
    nsIMultiplexInputStream: {
        readonly name: 'nsIMultiplexInputStream';
        readonly number: 'a076fd12-1dd1-11b2-b19a-d53b5dffaade';
    };
    nsIMutableArray: {
        readonly name: 'nsIMutableArray';
        readonly number: '';
    };
    nsINSSComponent: {
        readonly name: 'nsINSSComponent';
        readonly number: 'a0a8f52b-ea18-4abc-a3ca-eccf704ffe63';
    };
    nsINSSErrorsService: {
        readonly name: 'nsINSSErrorsService';
        readonly number: '12f60021-e14b-4020-99d1-ed2c795be66a';
        readonly ERROR_CLASS_SSL_PROTOCOL: 1;
        readonly ERROR_CLASS_BAD_CERT: 2;
        readonly NSS_SEC_ERROR_BASE;
        readonly NSS_SEC_ERROR_LIMIT;
        readonly NSS_SSL_ERROR_BASE;
        readonly NSS_SSL_ERROR_LIMIT;
        readonly MOZILLA_PKIX_ERROR_BASE;
        readonly MOZILLA_PKIX_ERROR_LIMIT;
    };
    nsINSSVersion: {
        readonly name: 'nsINSSVersion';
        readonly number: 'a8a53a2b-75cc-4c68-a9bb-9791dbddaa00';
    };
    nsINamed: {
        readonly name: 'nsINamed';
        readonly number: '0c5fe7de-7e83-4d0d-a8a6-4a6518b9a7b3';
    };
    nsINamedPipeDataObserver: {
        readonly name: 'nsINamedPipeDataObserver';
        readonly number: 'de4f460b-94fd-442c-9002-1637beb2185a';
    };
    nsINamedPipeService: {
        readonly name: 'nsINamedPipeService';
        readonly number: '1bf19133-5625-4ac8-836a-80b1c215f72b';
    };
    nsINativeAppSupport: {
        readonly name: 'nsINativeAppSupport';
        readonly number: '5fdf8480-1f98-11d4-8077-00600811a9c3';
    };
    nsINativeDNSResolverOverride: {
        readonly name: 'nsINativeDNSResolverOverride';
        readonly number: '8e38d536-5501-48c0-a412-6c450040c8c8';
    };
    nsINativeOSFileResult: {
        readonly name: 'nsINativeOSFileResult';
        readonly number: '08B4CF29-3D65-4E79-B522-A694C322ED07';
    };
    nsINativeOSFileSuccessCallback: {
        readonly name: 'nsINativeOSFileSuccessCallback';
        readonly number: '2C1922CA-CA1B-4099-8B61-EC23CFF49412';
    };
    nsINativeOSFileErrorCallback: {
        readonly name: 'nsINativeOSFileErrorCallback';
        readonly number: 'F612E0FC-6736-4D24-AA50-FD661B3B40B6';
    };
    nsINativeOSFileInternalsService: {
        readonly name: 'nsINativeOSFileInternalsService';
        readonly number: '913362AD-1526-4623-9E6B-A2EB08AFBBB9';
    };
    nsINavBookmarksService: {
        readonly name: 'nsINavBookmarksService';
        readonly number: '24533891-afa6-4663-b72d-3143d03f1b04';
        readonly DEFAULT_INDEX;
        readonly TYPE_BOOKMARK: 1;
        readonly TYPE_FOLDER: 2;
        readonly TYPE_SEPARATOR: 3;
        readonly TYPE_DYNAMIC_CONTAINER: 4;
        readonly SOURCE_DEFAULT: 0;
        readonly SOURCE_SYNC: 1;
        readonly SOURCE_IMPORT: 2;
        readonly SOURCE_SYNC_REPARENT_REMOVED_FOLDER_CHILDREN: 4;
        readonly SOURCE_RESTORE: 5;
        readonly SOURCE_RESTORE_ON_STARTUP: 6;
        readonly SYNC_STATUS_UNKNOWN: 0;
        readonly SYNC_STATUS_NEW: 1;
        readonly SYNC_STATUS_NORMAL: 2;
    };
    nsINavHistoryResultNode: {
        readonly name: 'nsINavHistoryResultNode';
        readonly number: '91d104bb-17ef-404b-9f9a-d9ed8de6824c';
        readonly RESULT_TYPE_URI: 0;
        readonly RESULT_TYPE_QUERY: 5;
        readonly RESULT_TYPE_FOLDER: 6;
        readonly RESULT_TYPE_SEPARATOR: 7;
        readonly RESULT_TYPE_FOLDER_SHORTCUT: 9;
    };
    nsINavHistoryContainerResultNode: {
        readonly name: 'nsINavHistoryContainerResultNode';
        readonly number: '3E9CC95F-0D93-45F1-894F-908EEB9866D7';
        readonly STATE_CLOSED: 0;
        readonly STATE_LOADING: 1;
        readonly STATE_OPENED: 2;
    };
    nsINavHistoryQueryResultNode: {
        readonly name: 'nsINavHistoryQueryResultNode';
        readonly number: '62817759-4FEE-44A3-B58C-3E2F5AFC9D0A';
    };
    nsINavHistoryResultObserver: {
        readonly name: 'nsINavHistoryResultObserver';
        readonly number: 'f62d8b6b-3c4e-4a9f-a897-db605d0b7a0f';
    };
    nsINavHistoryResult: {
        readonly name: 'nsINavHistoryResult';
        readonly number: 'c2229ce3-2159-4001-859c-7013c52f7619';
    };
    nsINavHistoryQuery: {
        readonly name: 'nsINavHistoryQuery';
        readonly number: 'dc87ae79-22f1-4dcf-975b-852b01d210cb';
        readonly TIME_RELATIVE_EPOCH: 0;
        readonly TIME_RELATIVE_TODAY: 1;
        readonly TIME_RELATIVE_NOW: 2;
    };
    nsINavHistoryQueryOptions: {
        readonly name: 'nsINavHistoryQueryOptions';
        readonly number: '8198dfa7-8061-4766-95cb-fa86b3c00a47';
        readonly SORT_BY_NONE: 0;
        readonly SORT_BY_TITLE_ASCENDING: 1;
        readonly SORT_BY_TITLE_DESCENDING: 2;
        readonly SORT_BY_DATE_ASCENDING: 3;
        readonly SORT_BY_DATE_DESCENDING: 4;
        readonly SORT_BY_URI_ASCENDING: 5;
        readonly SORT_BY_URI_DESCENDING: 6;
        readonly SORT_BY_VISITCOUNT_ASCENDING: 7;
        readonly SORT_BY_VISITCOUNT_DESCENDING: 8;
        readonly SORT_BY_DATEADDED_ASCENDING: 11;
        readonly SORT_BY_DATEADDED_DESCENDING: 12;
        readonly SORT_BY_LASTMODIFIED_ASCENDING: 13;
        readonly SORT_BY_LASTMODIFIED_DESCENDING: 14;
        readonly SORT_BY_TAGS_ASCENDING: 17;
        readonly SORT_BY_TAGS_DESCENDING: 18;
        readonly SORT_BY_FRECENCY_ASCENDING: 21;
        readonly SORT_BY_FRECENCY_DESCENDING: 22;
        readonly RESULTS_AS_URI: 0;
        readonly RESULTS_AS_VISIT: 1;
        readonly RESULTS_AS_DATE_QUERY: 3;
        readonly RESULTS_AS_SITE_QUERY: 4;
        readonly RESULTS_AS_DATE_SITE_QUERY: 5;
        readonly RESULTS_AS_TAGS_ROOT: 6;
        readonly RESULTS_AS_TAG_CONTENTS: 7;
        readonly RESULTS_AS_ROOTS_QUERY: 8;
        readonly RESULTS_AS_LEFT_PANE_QUERY: 9;
        readonly QUERY_TYPE_HISTORY: 0;
        readonly QUERY_TYPE_BOOKMARKS: 1;
    };
    nsINavHistoryService: {
        readonly name: 'nsINavHistoryService';
        readonly number: '20c974ff-ee16-4828-9326-1b7c9e036622';
        readonly DATABASE_SCHEMA_VERSION: 75;
        readonly TRANSITION_LINK: 1;
        readonly TRANSITION_TYPED: 2;
        readonly TRANSITION_BOOKMARK: 3;
        readonly TRANSITION_EMBED: 4;
        readonly TRANSITION_REDIRECT_PERMANENT: 5;
        readonly TRANSITION_REDIRECT_TEMPORARY: 6;
        readonly TRANSITION_DOWNLOAD: 7;
        readonly TRANSITION_FRAMED_LINK: 8;
        readonly TRANSITION_RELOAD: 9;
        readonly DATABASE_STATUS_OK: 0;
        readonly DATABASE_STATUS_CREATE: 1;
        readonly DATABASE_STATUS_CORRUPT: 2;
        readonly DATABASE_STATUS_UPGRADED: 3;
        readonly DATABASE_STATUS_LOCKED: 4;
        readonly VISIT_SOURCE_ORGANIC: 0;
        readonly VISIT_SOURCE_SPONSORED: 1;
        readonly VISIT_SOURCE_BOOKMARKED: 2;
        readonly VISIT_SOURCE_SEARCHED: 3;
    };
    nsINestedURI: {
        readonly name: 'nsINestedURI';
        readonly number: '6de2c874-796c-46bf-b57f-0d7bd7d6cab0';
    };
    nsINestedURIMutator: {
        readonly name: 'nsINestedURIMutator';
        readonly number: 'ca3d6c03-4eee-4271-a97a-d16c0a0b2c5c';
    };
    nsINestedAboutURIMutator: {
        readonly name: 'nsINestedAboutURIMutator';
        readonly number: 'c6357a3b-c2bb-4b4b-9278-513377398a38';
    };
    nsIJSURIMutator: {
        readonly name: 'nsIJSURIMutator';
        readonly number: '3bd44535-08ea-478f-99b9-85fa1084e820';
    };
    nsINetAddr: {
        readonly name: 'nsINetAddr';
        readonly number: '';
        readonly FAMILY_INET: 1;
        readonly FAMILY_INET6: 2;
        readonly FAMILY_LOCAL: 3;
    };
    nsINetUtil: {
        readonly name: 'nsINetUtil';
        readonly number: 'fe2625ec-b884-4df1-b39c-9e830e47aa94';
        readonly ESCAPE_ALL: 0;
        readonly ESCAPE_XALPHAS: 1;
        readonly ESCAPE_XPALPHAS: 2;
        readonly ESCAPE_URL_PATH: 4;
        readonly ESCAPE_URL_APPLE_EXTRA: 8;
        readonly ESCAPE_URL_SCHEME: 1;
        readonly ESCAPE_URL_USERNAME;
        readonly ESCAPE_URL_PASSWORD;
        readonly ESCAPE_URL_HOST;
        readonly ESCAPE_URL_DIRECTORY;
        readonly ESCAPE_URL_FILE_BASENAME;
        readonly ESCAPE_URL_FILE_EXTENSION;
        readonly ESCAPE_URL_PARAM;
        readonly ESCAPE_URL_QUERY;
        readonly ESCAPE_URL_REF;
        readonly ESCAPE_URL_FILEPATH;
        readonly ESCAPE_URL_MINIMAL;
        readonly ESCAPE_URL_FORCED;
        readonly ESCAPE_URL_ONLY_ASCII;
        readonly ESCAPE_URL_ONLY_NONASCII;
        readonly ESCAPE_URL_COLON;
        readonly ESCAPE_URL_SKIP_CONTROL;
        readonly ESCAPE_URL_EXT_HANDLER;
    };
    nsINetworkConnectivityService: {
        readonly name: 'nsINetworkConnectivityService';
        readonly number: '2693457e-3ba5-4455-991f-5350946adb12';
    };
    nsIListNetworkAddressesListener: {
        readonly name: 'nsIListNetworkAddressesListener';
        readonly number: 'c4bdaac1-3ab1-4fdb-9a16-17cbed794603';
    };
    nsIGetHostnameListener: {
        readonly name: 'nsIGetHostnameListener';
        readonly number: '3ebdcb62-2df4-4042-8864-3fa81abd4693';
    };
    nsINetworkInfoService: {
        readonly name: 'nsINetworkInfoService';
        readonly number: '55fc8dae-4a58-4e0f-a49b-901cbabae809';
    };
    nsIInterceptedBodyCallback: {
        readonly name: 'nsIInterceptedBodyCallback';
        readonly number: '51039eb6-bea0-40c7-b523-ccab56cc4fde';
    };
    nsIInterceptedChannel: {
        readonly name: 'nsIInterceptedChannel';
        readonly number: '';
    };
    nsINetworkInterceptController: {
        readonly name: 'nsINetworkInterceptController';
        readonly number: '70d2b4fe-a552-48cd-8d93-1d8437a56b53';
    };
    nsINetworkLinkService: {
        readonly name: 'nsINetworkLinkService';
        readonly number: '103e5293-77b3-4b70-af59-6e9e4a1f994a';
        readonly LINK_TYPE_UNKNOWN: 0;
        readonly LINK_TYPE_ETHERNET: 1;
        readonly LINK_TYPE_USB: 2;
        readonly LINK_TYPE_WIFI: 3;
        readonly LINK_TYPE_WIMAX: 4;
        readonly LINK_TYPE_MOBILE: 9;
        readonly NONE_DETECTED: 0;
        readonly VPN_DETECTED;
        readonly PROXY_DETECTED;
        readonly NRPT_DETECTED;
    };
    nsINetworkPredictor: {
        readonly name: 'nsINetworkPredictor';
        readonly number: 'acc88e7c-3f39-42c7-ac31-6377c2c3d73e';
        readonly PREDICT_LINK: 0;
        readonly PREDICT_LOAD: 1;
        readonly PREDICT_STARTUP: 2;
        readonly LEARN_LOAD_TOPLEVEL: 0;
        readonly LEARN_LOAD_SUBRESOURCE: 1;
        readonly LEARN_LOAD_REDIRECT: 2;
        readonly LEARN_STARTUP: 3;
    };
    nsINetworkPredictorVerifier: {
        readonly name: 'nsINetworkPredictorVerifier';
        readonly number: '2e43bb32-dabf-4494-9f90-2b3195b1c73d';
    };
    nsINotificationStorageCallback: {
        readonly name: 'nsINotificationStorageCallback';
        readonly number: 'c1622232-259c-43b0-b52e-89c39dcd9796';
    };
    nsINotificationStorage: {
        readonly name: 'nsINotificationStorage';
        readonly number: '17f85e52-fe57-440e-9ba1-5c312ca02b95';
    };
    nsINullChannel: {
        readonly name: 'nsINullChannel';
        readonly number: '4610b901-df41-4bb4-bd3f-fd4d6b6d8d68';
    };
    nsIOSFileConstantsService: {
        readonly name: 'nsIOSFileConstantsService';
        readonly number: 'd6dd239f-34d6-4b34-baa1-f69ab4a20bc4';
    };
    nsIOSKeyStore: {
        readonly name: 'nsIOSKeyStore';
        readonly number: '57972956-5718-42d2-8070-b3fc72212eaf';
    };
    nsIOSPermissionRequest: {
        readonly name: 'nsIOSPermissionRequest';
        readonly number: '95790842-75a0-430d-98bf-f5ce3788ea6d';
        readonly PERMISSION_STATE_NOTDETERMINED: 0;
        readonly PERMISSION_STATE_RESTRICTED: 1;
        readonly PERMISSION_STATE_DENIED: 2;
        readonly PERMISSION_STATE_AUTHORIZED: 3;
    };
    nsIOSReauthenticator: {
        readonly name: 'nsIOSReauthenticator';
        readonly number: '4fe082ae-6ff0-4b41-b24f-eaa664f6e46a';
    };
    nsIObjectInputStream: {
        readonly name: 'nsIObjectInputStream';
        readonly number: '';
    };
    nsIObjectLoadingContent: {
        readonly name: 'nsIObjectLoadingContent';
        readonly number: '2eb3195e-3eea-4083-bb1d-d2d70fa35ccb';
        readonly TYPE_LOADING: 0;
        readonly TYPE_IMAGE: 1;
        readonly TYPE_FALLBACK: 2;
        readonly TYPE_FAKE_PLUGIN: 3;
        readonly TYPE_DOCUMENT: 4;
        readonly TYPE_NULL: 5;
        readonly PLUGIN_ACTIVE: 0xFF;
        readonly PLUGIN_PERMISSION_PROMPT_ACTION_QUIET: 8;
    };
    nsIObjectOutputStream: {
        readonly name: 'nsIObjectOutputStream';
        readonly number: '';
    };
    nsIObliviousHttpClientResponse: {
        readonly name: 'nsIObliviousHttpClientResponse';
        readonly number: 'f2a4aaa4-046a-439e-beef-893b15a90cff';
    };
    nsIObliviousHttpClientRequest: {
        readonly name: 'nsIObliviousHttpClientRequest';
        readonly number: '403af7f9-4a76-49fc-a622-38d6ba3ee496';
    };
    nsIObliviousHttpServerResponse: {
        readonly name: 'nsIObliviousHttpServerResponse';
        readonly number: '105deb62-45b4-407a-b330-550433279111';
    };
    nsIObliviousHttpServer: {
        readonly name: 'nsIObliviousHttpServer';
        readonly number: 'fb1abc56-b525-4e1a-a4c6-341a9b32084e';
    };
    nsIObliviousHttp: {
        readonly name: 'nsIObliviousHttp';
        readonly number: 'd581149e-3319-4563-b95e-46c64af5c4e8';
    };
    nsIObliviousHttpService: {
        readonly name: 'nsIObliviousHttpService';
        readonly number: 'b1f08d56-fca6-4290-9500-d5168dc9d8c3';
    };
    nsIObserver: {
        readonly name: 'nsIObserver';
        readonly number: '';
    };
    nsIObserverService: {
        readonly name: 'nsIObserverService';
        readonly number: 'D07F5192-E3D1-11d2-8ACD-00105A1B8860';
    };
    nsIBrowsingContextReadyCallback: {
        readonly name: 'nsIBrowsingContextReadyCallback';
        readonly number: '0524ee06-7f4c-4cd3-ab80-084562745cad';
    };
    nsIOpenWindowInfo: {
        readonly name: 'nsIOpenWindowInfo';
        readonly number: '';
    };
    nsIOutputStream: {
        readonly name: 'nsIOutputStream';
        readonly number: '';
    };
    nsIPK11Token: {
        readonly name: 'nsIPK11Token';
        readonly number: '';
    };
    nsIPK11TokenDB: {
        readonly name: 'nsIPK11TokenDB';
        readonly number: '4ee28c82-1dd2-11b2-aabf-bb4017abe395';
    };
    nsIPKCS11Module: {
        readonly name: 'nsIPKCS11Module';
        readonly number: '';
    };
    nsIPKCS11ModuleDB: {
        readonly name: 'nsIPKCS11ModuleDB';
        readonly number: 'ff9fbcd7-9517-4334-b97a-ceed78909974';
    };
    nsIPKCS11Slot: {
        readonly name: 'nsIPKCS11Slot';
        readonly number: 'c2d4f296-ee60-11d4-998b-00b0d02354a0';
        readonly SLOT_DISABLED: 0;
        readonly SLOT_NOT_PRESENT: 1;
        readonly SLOT_UNINITIALIZED: 2;
        readonly SLOT_NOT_LOGGED_IN: 3;
        readonly SLOT_LOGGED_IN: 4;
        readonly SLOT_READY: 5;
    };
    nsIPageThumbsStorageService: {
        readonly name: 'nsIPageThumbsStorageService';
        readonly number: '97943eec-0e48-49ef-b7b7-cf4aa0109bb6';
    };
    nsIPaper: {
        readonly name: 'nsIPaper';
        readonly number: 'a4dd9675-6311-45a9-a547-44e0127304a6';
    };
    nsIPaperMargin: {
        readonly name: 'nsIPaperMargin';
        readonly number: '0858d1a7-b646-4b15-a1e8-7eb5ab572d0a';
    };
    nsIParentChannel: {
        readonly name: 'nsIParentChannel';
        readonly number: '';
    };
    nsIAsyncVerifyRedirectReadyCallback: {
        readonly name: 'nsIAsyncVerifyRedirectReadyCallback';
        readonly number: '01987690-48cf-45de-bae3-e143c2adc2a8';
    };
    nsIParentRedirectingChannel: {
        readonly name: 'nsIParentRedirectingChannel';
        readonly number: '3ed1d288-5324-46ee-8a98-33ac37d1080b';
    };
    nsIParentalControlsService: {
        readonly name: 'nsIParentalControlsService';
        readonly number: '2e97e5dd-467b-4aea-a1bb-6773c0f2beb0';
        readonly DOWNLOAD: 1;
        readonly INSTALL_EXTENSION: 2;
        readonly INSTALL_APP: 3;
        readonly BROWSE: 4;
        readonly SHARE: 5;
        readonly BOOKMARK: 6;
        readonly ADD_CONTACT: 7;
        readonly SET_IMAGE: 8;
        readonly MODIFY_ACCOUNTS: 9;
        readonly REMOTE_DEBUGGING: 10;
        readonly IMPORT_SETTINGS: 11;
        readonly PRIVATE_BROWSING: 12;
        readonly DATA_CHOICES: 13;
        readonly CLEAR_HISTORY: 14;
        readonly MASTER_PASSWORD: 15;
        readonly GUEST_BROWSING: 16;
        readonly ADVANCED_SETTINGS: 17;
        readonly CAMERA_MICROPHONE: 18;
        readonly BLOCK_LIST: 19;
        readonly TELEMETRY: 20;
        readonly HEALTH_REPORT: 21;
        readonly DEFAULT_THEME: 22;
        readonly ePCLog_URIVisit: 1;
        readonly ePCLog_FileDownload: 2;
    };
    nsIParserUtils: {
        readonly name: 'nsIParserUtils';
        readonly number: 'a1101145-0025-411e-8873-fdf57bf28128';
        readonly SanitizerAllowComments;
        readonly SanitizerAllowStyle;
        readonly SanitizerCidEmbedsOnly;
        readonly SanitizerDropNonCSSPresentation;
        readonly SanitizerDropForms;
        readonly SanitizerDropMedia;
        readonly SanitizerLogRemovals;
    };
    nsIPartitioningExceptionListObserver: {
        readonly name: 'nsIPartitioningExceptionListObserver';
        readonly number: 'd8db1086-7b59-44d3-9f88-f31a7e642637';
    };
    nsIPartitioningExceptionListService: {
        readonly name: 'nsIPartitioningExceptionListService';
        readonly number: 'cf83a9af-dd3f-43a2-88bb-489a22bca124';
    };
    nsIPaymentResponseData: {
        readonly name: 'nsIPaymentResponseData';
        readonly number: '2a338575-c688-40ee-a157-7488ab292ef2';
        readonly GENERAL_RESPONSE: 0;
        readonly BASICCARD_RESPONSE: 1;
    };
    nsIGeneralResponseData: {
        readonly name: 'nsIGeneralResponseData';
        readonly number: 'b986773e-2b30-4ed2-b8fe-6a96631c8000';
    };
    nsIBasicCardResponseData: {
        readonly name: 'nsIBasicCardResponseData';
        readonly number: '0d55a5e6-d185-44f0-b992-a8e1321e4bce';
    };
    nsIPaymentActionResponse: {
        readonly name: 'nsIPaymentActionResponse';
        readonly number: 'a607c095-ef60-4a9b-a3d0-0506c60728b3';
        readonly NO_TYPE: 0;
        readonly CANMAKE_ACTION: 2;
        readonly SHOW_ACTION: 3;
        readonly ABORT_ACTION: 4;
        readonly COMPLETE_ACTION: 5;
        readonly ABORT_SUCCEEDED: 1;
        readonly ABORT_FAILED: 0;
        readonly PAYMENT_REJECTED: 0;
        readonly PAYMENT_ACCEPTED: 1;
        readonly PAYMENT_NOTSUPPORTED: 2;
        readonly COMPLETE_SUCCEEDED: 1;
        readonly COMPLETE_FAILED: 0;
    };
    nsIPaymentCanMakeActionResponse: {
        readonly name: 'nsIPaymentCanMakeActionResponse';
        readonly number: '52fc3f9f-c0cb-4874-b3d4-ee4b6e9cbe9c';
    };
    nsIPaymentShowActionResponse: {
        readonly name: 'nsIPaymentShowActionResponse';
        readonly number: '184385cb-2d35-4b99-a9a3-7c780bf66b9b';
    };
    nsIPaymentAbortActionResponse: {
        readonly name: 'nsIPaymentAbortActionResponse';
        readonly number: '8c72bcdb-0c37-4786-a9e5-510afa2f8ede';
    };
    nsIPaymentCompleteActionResponse: {
        readonly name: 'nsIPaymentCompleteActionResponse';
        readonly number: '62c01e69-9ca4-4060-99e4-b95f628c8e6d';
    };
    nsIMethodChangeDetails: {
        readonly name: 'nsIMethodChangeDetails';
        readonly number: '2035e0a9-c9ab-4c9f-b8e9-28b2ed61548c';
        readonly GENERAL_DETAILS: 0;
        readonly BASICCARD_DETAILS: 1;
    };
    nsIGeneralChangeDetails: {
        readonly name: 'nsIGeneralChangeDetails';
        readonly number: 'e031267e-bec8-4f3c-b0b1-396b77ca260c';
    };
    nsIBasicCardChangeDetails: {
        readonly name: 'nsIBasicCardChangeDetails';
        readonly number: '5296f79e-15ea-40c3-8196-19cfa64d328c';
    };
    nsIPaymentAddress: {
        readonly name: 'nsIPaymentAddress';
        readonly number: '49a02241-7e48-477a-9345-9f246925dcb3';
    };
    nsIPaymentMethodData: {
        readonly name: 'nsIPaymentMethodData';
        readonly number: '2fe296cc-d917-4820-b492-aa42df23f9b4';
    };
    nsIPaymentCurrencyAmount: {
        readonly name: 'nsIPaymentCurrencyAmount';
        readonly number: 'd22a6f5f-767b-4fea-bf92-68b0b8003eba';
    };
    nsIPaymentItem: {
        readonly name: 'nsIPaymentItem';
        readonly number: '4f78a59f-b5ff-4fb5-ab48-3b37d0101b02';
    };
    nsIPaymentDetailsModifier: {
        readonly name: 'nsIPaymentDetailsModifier';
        readonly number: '74259861-c318-40e8-b3d5-518e701bed80';
    };
    nsIPaymentShippingOption: {
        readonly name: 'nsIPaymentShippingOption';
        readonly number: '68341551-3605-4381-b936-41e830aa88fb';
    };
    nsIPaymentDetails: {
        readonly name: 'nsIPaymentDetails';
        readonly number: '73a5a3f1-45b9-4605-a6e6-7aa60daa9039';
    };
    nsIPaymentOptions: {
        readonly name: 'nsIPaymentOptions';
        readonly number: 'd53f9f20-138e-47cc-9fd5-db16a3f6d301';
    };
    nsIPaymentRequest: {
        readonly name: 'nsIPaymentRequest';
        readonly number: '2fa36783-d684-4487-b7a8-9def6ae3128f';
    };
    nsIPaymentRequestService: {
        readonly name: 'nsIPaymentRequestService';
        readonly number: 'cccd665f-edf3-41fc-ab9b-fc55b37340aa';
    };
    nsIPaymentUIService: {
        readonly name: 'nsIPaymentUIService';
        readonly number: '01f8bd55-9017-438b-85ec-7c15d2b35cdc';
    };
    nsIPermission: {
        readonly name: 'nsIPermission';
        readonly number: '';
    };
    nsIPermissionDelegateHandler: {
        readonly name: 'nsIPermissionDelegateHandler';
        readonly number: '07611dc6-bf4d-4d8a-a64b-f3a5904dddc7';
    };
    nsIPermissionManager: {
        readonly name: 'nsIPermissionManager';
        readonly number: '4dcb3851-eba2-4e42-b236-82d2596fca22';
        readonly UNKNOWN_ACTION: 0;
        readonly ALLOW_ACTION: 1;
        readonly DENY_ACTION: 2;
        readonly PROMPT_ACTION: 3;
        readonly EXPIRE_NEVER: 0;
        readonly EXPIRE_SESSION: 1;
        readonly EXPIRE_TIME: 2;
        readonly EXPIRE_POLICY: 3;
    };
    nsIPropertyElement: {
        readonly name: 'nsIPropertyElement';
        readonly number: '283EE646-1AEF-11D4-98B3-00C04fA0CE9A';
    };
    nsIPersistentProperties: {
        readonly name: 'nsIPersistentProperties';
        readonly number: '';
    };
    nsIPipe: {
        readonly name: 'nsIPipe';
        readonly number: '25d0de93-685e-4ea4-95d3-d884e31df63c';
    };
    nsISearchableInputStream: {
        readonly name: 'nsISearchableInputStream';
        readonly number: '8C39EF62-F7C9-11d4-98F5-001083010E9B';
    };
    nsIPlacesPreviewsHelperService: {
        readonly name: 'nsIPlacesPreviewsHelperService';
        readonly number: 'bd0a4d3b-ff26-4d4d-9a62-a513e1c1bf92';
    };
    nsIPlatformInfo: {
        readonly name: 'nsIPlatformInfo';
        readonly number: 'ab6650cf-0806-4aea-b8f2-40fdae74f1cc';
    };
    nsIPluginTag: {
        readonly name: 'nsIPluginTag';
        readonly number: '5daa99d5-265a-4397-b429-c943803e2619';
        readonly STATE_DISABLED: 0;
        readonly STATE_CLICKTOPLAY: 1;
        readonly STATE_ENABLED: 2;
    };
    nsIFakePluginTag: {
        readonly name: 'nsIFakePluginTag';
        readonly number: '6d22c968-226d-4156-b230-da6ad6bbf6e8';
    };
    nsIPowerManagerService: {
        readonly name: 'nsIPowerManagerService';
        readonly number: 'ba7ca4c1-9d92-4425-a83b-85dd7fa953f7';
    };
    nsIPrefBranch: {
        readonly name: 'nsIPrefBranch';
        readonly number: '55d25e49-793f-4727-a69f-de8b15f4b985';
        readonly PREF_INVALID: 0;
        readonly PREF_STRING: 32;
        readonly PREF_INT: 64;
        readonly PREF_BOOL: 128;
    };
    nsIPrefLocalizedString: {
        readonly name: 'nsIPrefLocalizedString';
        readonly number: 'ae419e24-1dd1-11b2-b39a-d3e5e7073802';
    };
    nsIPrefStatsCallback: {
        readonly name: 'nsIPrefStatsCallback';
        readonly number: 'c3f0cedc-e244-4316-b33a-80306a1c35a1';
    };
    nsIPrefObserver: {
        readonly name: 'nsIPrefObserver';
        readonly number: '0a2dbc02-2218-4687-b151-33d890676e00';
    };
    nsIPrefService: {
        readonly name: 'nsIPrefService';
        readonly number: '1f84fd56-3956-40df-b86a-1ea01402ee96';
    };
    nsIPrefetchService: {
        readonly name: 'nsIPrefetchService';
        readonly number: '422a1807-4e7f-463d-b8d7-ca2ceb9b5d53';
    };
    nsIPreloadedStyleSheet: {
        readonly name: 'nsIPreloadedStyleSheet';
        readonly number: '';
    };
    nsIPrincipal: {
        readonly name: 'nsIPrincipal';
        readonly number: '';
    };
    nsIExpandedPrincipal: {
        readonly name: 'nsIExpandedPrincipal';
        readonly number: 'f3e177Df-6a5e-489f-80a7-2dd1481471d8';
    };
    nsIPrintDialogService: {
        readonly name: 'nsIPrintDialogService';
        readonly number: '88af6712-a9fd-4393-9af3-3ffbb1f2caaf';
    };
    nsIPrintPreviewNavigation: {
        readonly name: 'nsIPrintPreviewNavigation';
        readonly number: '8148E3F1-2E8B-11d5-A86C-00105A183419';
    };
    nsIPrintSettings: {
        readonly name: 'nsIPrintSettings';
        readonly number: '';
        readonly kInitSaveHeaderLeft: 0x00000002;
        readonly kInitSaveHeaderCenter: 0x00000004;
        readonly kInitSaveHeaderRight: 0x00000008;
        readonly kInitSaveFooterLeft: 0x00000010;
        readonly kInitSaveFooterCenter: 0x00000020;
        readonly kInitSaveFooterRight: 0x00000040;
        readonly kInitSaveBGColors: 0x00000080;
        readonly kInitSaveBGImages: 0x00000100;
        readonly kInitSavePaperSize: 0x00000200;
        readonly kInitSaveDuplex: 0x00000800;
        readonly kInitSaveUnwriteableMargins: 0x00004000;
        readonly kInitSaveEdges: 0x00008000;
        readonly kInitSaveReversed: 0x00010000;
        readonly kInitSaveInColor: 0x00020000;
        readonly kInitSaveOrientation: 0x00040000;
        readonly kInitSavePrinterName: 0x00100000;
        readonly kInitSavePrintToFile: 0x00200000;
        readonly kInitSaveToFileName: 0x00400000;
        readonly kInitSavePageDelay: 0x00800000;
        readonly kInitSaveMargins: 0x01000000;
        readonly kInitSaveShrinkToFit: 0x08000000;
        readonly kInitSaveScaling: 0x10000000;
        readonly kInitSaveAll: 0xFFFFFFFF;
        readonly kGlobalSettings;
        readonly kPrintDialogPersistSettings;
        readonly kJustLeft: 0;
        readonly kJustCenter: 1;
        readonly kJustRight: 2;
        readonly kPaperSizeInches: 0;
        readonly kPaperSizeMillimeters: 1;
        readonly kPortraitOrientation: 0;
        readonly kLandscapeOrientation: 1;
        readonly kOutputFormatNative: 0;
        readonly kOutputFormatPDF: 2;
        readonly kDuplexNone: 0;
        readonly kDuplexFlipOnLongEdge: 1;
        readonly kDuplexFlipOnShortEdge: 2;
    };
    nsIPrintSettingsService: {
        readonly name: 'nsIPrintSettingsService';
        readonly number: '841387C8-72E6-484b-9296-BF6EEA80D58A';
    };
    nsIPrintSettingsWin: {
        readonly name: 'nsIPrintSettingsWin';
        readonly number: 'c63eed41-6ac5-459e-8a64-033eb9ad770a';
    };
    nsIPrinterInfo: {
        readonly name: 'nsIPrinterInfo';
        readonly number: '855ae9dd-62a4-64aa-9c60-b1078ff028f1';
    };
    nsIPrinter: {
        readonly name: 'nsIPrinter';
        readonly number: 'd2dde9bb-df86-469c-bfcc-fd95a44b1db8';
    };
    nsIPrinterList: {
        readonly name: 'nsIPrinterList';
        readonly number: '5e738fff-404c-4c94-9189-e8f2cce93e94';
    };
    nsIPrivacyTransitionObserver: {
        readonly name: 'nsIPrivacyTransitionObserver';
        readonly number: 'b4b1449d-0ef0-47f5-b62e-adc57fd49702';
    };
    nsIPrivateBrowsingChannel: {
        readonly name: 'nsIPrivateBrowsingChannel';
        readonly number: 'df702bb0-55b8-11e2-bcfd-0800200c9a66';
    };
    nsIProcess: {
        readonly name: 'nsIProcess';
        readonly number: '609610de-9954-4a63-8a7c-346350a86403';
    };
    nsIProcessToolsService: {
        readonly name: 'nsIProcessToolsService';
        readonly number: '1341f571-ebed-4305-b264-4d8fc3b6b11c';
    };
    nsIProfileStartup: {
        readonly name: 'nsIProfileStartup';
        readonly number: '048e5ca1-0eb7-4bb1-a9a2-a36f7d4e0e3c';
    };
    nsIProfileMigrator: {
        readonly name: 'nsIProfileMigrator';
        readonly number: '3df284a5-2258-4d46-a664-761ecdc04c22';
    };
    nsIProfileUnlocker: {
        readonly name: 'nsIProfileUnlocker';
        readonly number: '';
        readonly ATTEMPT_QUIT: 0;
        readonly FORCE_QUIT: 1;
    };
    nsIProfilerStartParams: {
        readonly name: 'nsIProfilerStartParams';
        readonly number: '0a175ba7-8fcf-4ce9-9c4b-ccc6272f4425';
    };
    nsIProfiler: {
        readonly name: 'nsIProfiler';
        readonly number: 'ead3f75c-0e0e-4fbb-901c-1e5392ef5b2a';
    };
    nsIProgressEventSink: {
        readonly name: 'nsIProgressEventSink';
        readonly number: '';
    };
    nsIPrompt: {
        readonly name: 'nsIPrompt';
        readonly number: '';
        readonly BUTTON_POS_0: 1;
        readonly BUTTON_POS_1;
        readonly BUTTON_POS_2;
        readonly BUTTON_TITLE_OK: 1;
        readonly BUTTON_TITLE_CANCEL: 2;
        readonly BUTTON_TITLE_YES: 3;
        readonly BUTTON_TITLE_NO: 4;
        readonly BUTTON_TITLE_SAVE: 5;
        readonly BUTTON_TITLE_DONT_SAVE: 6;
        readonly BUTTON_TITLE_REVERT: 7;
        readonly BUTTON_TITLE_IS_STRING: 127;
        readonly BUTTON_POS_0_DEFAULT;
        readonly BUTTON_POS_1_DEFAULT;
        readonly BUTTON_POS_2_DEFAULT;
        readonly BUTTON_DELAY_ENABLE;
        readonly STD_OK_CANCEL_BUTTONS;
        readonly STD_YES_NO_BUTTONS;
        readonly MODAL_TYPE_CONTENT: 1;
        readonly MODAL_TYPE_TAB: 2;
        readonly MODAL_TYPE_WINDOW: 3;
        readonly MODAL_TYPE_INTERNAL_WINDOW: 4;
    };
    nsIPromptCollection: {
        readonly name: 'nsIPromptCollection';
        readonly number: '7913837c-9623-11ea-bb37-0242ac130002';
    };
    nsIPromptFactory: {
        readonly name: 'nsIPromptFactory';
        readonly number: '2803541c-c96a-4ff1-bd7c-9cb566d46aeb';
    };
    nsIPromptInstance: {
        readonly name: 'nsIPromptInstance';
        readonly number: '889842e9-052c-46c9-99f3-f4a426571e38';
    };
    nsIPromptService: {
        readonly name: 'nsIPromptService';
        readonly number: '404ebfa2-d8f4-4c94-8416-e65a55f9df5a';
        readonly BUTTON_POS_0: 1;
        readonly BUTTON_POS_1;
        readonly BUTTON_POS_2;
        readonly BUTTON_TITLE_OK: 1;
        readonly BUTTON_TITLE_CANCEL: 2;
        readonly BUTTON_TITLE_YES: 3;
        readonly BUTTON_TITLE_NO: 4;
        readonly BUTTON_TITLE_SAVE: 5;
        readonly BUTTON_TITLE_DONT_SAVE: 6;
        readonly BUTTON_TITLE_REVERT: 7;
        readonly BUTTON_TITLE_IS_STRING: 127;
        readonly BUTTON_POS_0_DEFAULT: 0;
        readonly BUTTON_POS_1_DEFAULT;
        readonly BUTTON_POS_2_DEFAULT;
        readonly BUTTON_DELAY_ENABLE;
        readonly STD_OK_CANCEL_BUTTONS;
        readonly STD_YES_NO_BUTTONS;
        readonly MODAL_TYPE_CONTENT: 1;
        readonly MODAL_TYPE_TAB: 2;
        readonly MODAL_TYPE_WINDOW: 3;
        readonly MODAL_TYPE_INTERNAL_WINDOW: 4;
    };
    nsIProperties: {
        readonly name: 'nsIProperties';
        readonly number: '78650582-4e93-4b60-8e85-26ebd3eb14ca';
    };
    nsIProperty: {
        readonly name: 'nsIProperty';
        readonly number: '6dcf9030-a49f-11d5-910d-0010a4e73d9a';
    };
    nsIPropertyBag: {
        readonly name: 'nsIPropertyBag';
        readonly number: 'bfcd37b0-a49f-11d5-910d-0010a4e73d9a';
    };
    nsIPropertyBag2: {
        readonly name: 'nsIPropertyBag2';
        readonly number: '625cfd1e-da1e-4417-9ee9-dbc8e0b3fd79';
    };
    nsIProtectedAuthThread: {
        readonly name: 'nsIProtectedAuthThread';
        readonly number: '';
    };
    nsIProtocolHandlerWithDynamicFlags: {
        readonly name: 'nsIProtocolHandlerWithDynamicFlags';
        readonly number: '65a8e823-0591-4fc0-a56a-03265e0a4ce8';
    };
    nsIProtocolHandler: {
        readonly name: 'nsIProtocolHandler';
        readonly number: 'a87210e6-7c8c-41f7-864d-df809015193e';
        readonly URI_STD: 0;
        readonly URI_NORELATIVE;
        readonly URI_NOAUTH;
        readonly ALLOWS_PROXY;
        readonly ALLOWS_PROXY_HTTP;
        readonly URI_INHERITS_SECURITY_CONTEXT;
        readonly URI_FORBIDS_AUTOMATIC_DOCUMENT_REPLACEMENT;
        readonly URI_LOADABLE_BY_ANYONE;
        readonly URI_DANGEROUS_TO_LOAD;
        readonly URI_IS_UI_RESOURCE;
        readonly URI_IS_LOCAL_FILE;
        readonly URI_LOADABLE_BY_SUBSUMERS;
        readonly URI_DOES_NOT_RETURN_DATA;
        readonly URI_IS_LOCAL_RESOURCE;
        readonly URI_OPENING_EXECUTES_SCRIPT;
        readonly URI_NON_PERSISTABLE;
        readonly URI_CROSS_ORIGIN_NEEDS_WEBAPPS_PERM;
        readonly URI_SYNC_LOAD_IS_OK;
        readonly URI_IS_POTENTIALLY_TRUSTWORTHY;
        readonly URI_FETCHABLE_BY_ANYONE;
        readonly ORIGIN_IS_FULL_SPEC;
        readonly URI_SCHEME_NOT_SELF_LINKABLE;
        readonly URI_LOADABLE_BY_EXTENSIONS;
        readonly URI_DISALLOW_IN_PRIVATE_CONTEXT;
        readonly URI_FORBIDS_COOKIE_ACCESS;
        readonly WEBEXT_URI_WEB_ACCESSIBLE;
        readonly DYNAMIC_URI_FLAGS;
    };
    nsIProtocolProxyCallback: {
        readonly name: 'nsIProtocolProxyCallback';
        readonly number: '';
    };
    nsIProxyProtocolFilterResult: {
        readonly name: 'nsIProxyProtocolFilterResult';
        readonly number: '009E6C3F-FB64-40C5-8093-F1495C64773E';
    };
    nsIProtocolProxyFilter: {
        readonly name: 'nsIProtocolProxyFilter';
        readonly number: '';
    };
    nsIProtocolProxyChannelFilter: {
        readonly name: 'nsIProtocolProxyChannelFilter';
        readonly number: '';
    };
    nsIProxyConfigChangedCallback: {
        readonly name: 'nsIProxyConfigChangedCallback';
        readonly number: '77984234-aad5-47fc-a412-03398c2134a5';
    };
    nsIProtocolProxyService: {
        readonly name: 'nsIProtocolProxyService';
        readonly number: 'ef57c8b6-e09d-4cd4-9222-2a5d2402e15d';
        readonly RESOLVE_PREFER_SOCKS_PROXY;
        readonly RESOLVE_IGNORE_URI_SCHEME;
        readonly RESOLVE_PREFER_HTTPS_PROXY;
        readonly RESOLVE_ALWAYS_TUNNEL;
        readonly PROXYCONFIG_DIRECT: 0;
        readonly PROXYCONFIG_MANUAL: 1;
        readonly PROXYCONFIG_PAC: 2;
        readonly PROXYCONFIG_WPAD: 4;
        readonly PROXYCONFIG_SYSTEM: 5;
    };
    nsIProtocolProxyService2: {
        readonly name: 'nsIProtocolProxyService2';
        readonly number: 'b2e5b2c0-e21e-4845-b336-be6d60a38951';
    };
    nsIProxiedChannel: {
        readonly name: 'nsIProxiedChannel';
        readonly number: '6238f134-8c3f-4354-958f-dfd9d54a4446';
    };
    nsIProxiedProtocolHandler: {
        readonly name: 'nsIProxiedProtocolHandler';
        readonly number: '3756047a-fa2b-4b45-9948-3b5f8fc375e7';
    };
    nsIProxyInfo: {
        readonly name: 'nsIProxyInfo';
        readonly number: '';
        readonly TRANSPARENT_PROXY_RESOLVES_HOST;
    };
    nsIPublicKeyPinningService: {
        readonly name: 'nsIPublicKeyPinningService';
        readonly number: 'f64432b9-e8c6-41b4-b2da-8eb004344bba';
    };
    nsIPurgeTrackerService: {
        readonly name: 'nsIPurgeTrackerService';
        readonly number: 'cd68d61e-9a44-402d-9671-838ac0872176';
    };
    nsIPushErrorReporter: {
        readonly name: 'nsIPushErrorReporter';
        readonly number: 'b58249f9-1a04-48cc-bc20-2c992d64c73e';
        readonly ACK_DELIVERED: 0;
        readonly ACK_DECRYPTION_ERROR: 1;
        readonly ACK_NOT_DELIVERED: 2;
        readonly UNSUBSCRIBE_MANUAL: 3;
        readonly UNSUBSCRIBE_QUOTA_EXCEEDED: 4;
        readonly UNSUBSCRIBE_PERMISSION_REVOKED: 5;
        readonly DELIVERY_UNCAUGHT_EXCEPTION: 6;
        readonly DELIVERY_UNHANDLED_REJECTION: 7;
        readonly DELIVERY_INTERNAL_ERROR: 8;
    };
    nsIPushNotifier: {
        readonly name: 'nsIPushNotifier';
        readonly number: 'b00dfdeb-14e5-425b-adc7-b531442e3216';
    };
    nsIPushData: {
        readonly name: 'nsIPushData';
        readonly number: 'dfc4f151-cead-40df-8eb7-7a7a67c54b16';
    };
    nsIPushMessage: {
        readonly name: 'nsIPushMessage';
        readonly number: 'b9d063ca-0e3f-4fee-be4b-ea9103263433';
    };
    nsIPushSubscription: {
        readonly name: 'nsIPushSubscription';
        readonly number: '1de32d5c-ea88-4c9e-9626-b032bd87f415';
    };
    nsIPushSubscriptionCallback: {
        readonly name: 'nsIPushSubscriptionCallback';
        readonly number: '1799c074-9d52-46b0-ab3c-c09790732f6f';
    };
    nsIUnsubscribeResultCallback: {
        readonly name: 'nsIUnsubscribeResultCallback';
        readonly number: 'd574118f-61a9-4270-b1f6-4461aa85c4f5';
    };
    nsIPushClearResultCallback: {
        readonly name: 'nsIPushClearResultCallback';
        readonly number: 'bd47b38e-8bfa-4f92-834e-832a4431e05e';
    };
    nsIPushService: {
        readonly name: 'nsIPushService';
        readonly number: '678ef584-bf25-47aa-ac84-03efc0865b68';
    };
    nsIPushQuotaManager: {
        readonly name: 'nsIPushQuotaManager';
        readonly number: 'a2555e70-46f8-4b52-bf02-d978b979d143';
    };
    nsIQueryContentEventResult: {
        readonly name: 'nsIQueryContentEventResult';
        readonly number: 'e2c39e0e-345f-451a-a7b2-e0230d555847';
    };
    nsIQuotaUsageCallback: {
        readonly name: 'nsIQuotaUsageCallback';
        readonly number: '';
    };
    nsIQuotaCallback: {
        readonly name: 'nsIQuotaCallback';
        readonly number: '';
    };
    nsIQuotaManagerService: {
        readonly name: 'nsIQuotaManagerService';
        readonly number: '1b3d0a38-8151-4cf9-89fa-4f92c2ef0e7e';
    };
    nsIQuotaRequestBase: {
        readonly name: 'nsIQuotaRequestBase';
        readonly number: '9af54222-0407-48fd-a4ab-9457c986fc49';
    };
    nsIQuotaUsageRequest: {
        readonly name: 'nsIQuotaUsageRequest';
        readonly number: '166e28e6-cf6d-4927-a6d7-b51bca9d3469';
    };
    nsIQuotaRequest: {
        readonly name: 'nsIQuotaRequest';
        readonly number: '22890e3e-ff25-4372-9684-d901060e2f6c';
    };
    nsIQuotaFullOriginMetadataResult: {
        readonly name: 'nsIQuotaFullOriginMetadataResult';
        readonly number: '4d8def75-014e-404d-bf30-e2f0Bfcf4d89';
    };
    nsIQuotaUsageResult: {
        readonly name: 'nsIQuotaUsageResult';
        readonly number: 'd8c9328b-9aa8-4f5d-90e6-482de4a6d5b8';
    };
    nsIQuotaOriginUsageResult: {
        readonly name: 'nsIQuotaOriginUsageResult';
        readonly number: '96df03d2-116a-493f-bb0b-118c212a6b32';
    };
    nsIQuotaEstimateResult: {
        readonly name: 'nsIQuotaEstimateResult';
        readonly number: '9827fc69-7ea9-48ef-b30d-2e2ae0451ec0';
    };
    nsIRaceCacheWithNetwork: {
        readonly name: 'nsIRaceCacheWithNetwork';
        readonly number: '4d963475-8b16-4c58-b804-8a23d49436c5';
    };
    nsIRandomAccessStream: {
        readonly name: 'nsIRandomAccessStream';
        readonly number: '9b5904a8-886a-420f-a1d8-847de8ffc133';
    };
    nsIRandomGenerator: {
        readonly name: 'nsIRandomGenerator';
        readonly number: '2362d97a-747a-4576-8863-697667309209';
    };
    nsIRddProcessTest: {
        readonly name: 'nsIRddProcessTest';
        readonly number: '12f7d302-5368-412d-bdc9-26d151518e6c';
    };
    nsIRedirectChannelRegistrar: {
        readonly name: 'nsIRedirectChannelRegistrar';
        readonly number: 'efa36ea2-5b07-46fc-9534-a5acb8b77b72';
    };
    nsIRedirectHistoryEntry: {
        readonly name: 'nsIRedirectHistoryEntry';
        readonly number: '133b2905-0eba-411c-a8bb-f59787142aa2';
    };
    nsIRedirectResultListener: {
        readonly name: 'nsIRedirectResultListener';
        readonly number: '85cd2640-e91e-41ac-bdca-1dbf10dc131e';
    };
    nsIReferrerInfo: {
        readonly name: 'nsIReferrerInfo';
        readonly number: '';
    };
    nsIReflowObserver: {
        readonly name: 'nsIReflowObserver';
        readonly number: '832e692c-c4a6-11e2-8fd1-dce678957a39';
    };
    nsIRefreshURI: {
        readonly name: 'nsIRefreshURI';
        readonly number: 'a5e61a3c-51bd-45be-ac0c-e87b71860656';
    };
    nsIRegion: {
        readonly name: 'nsIRegion';
        readonly number: '21e6d094-e016-41a4-80cd-76d2e20871aa';
    };
    nsIRelativeFilePref: {
        readonly name: 'nsIRelativeFilePref';
        readonly number: '2f977d4e-5485-11d4-87e2-0010a4e75ef2';
    };
    nsIRemoteAgent: {
        readonly name: 'nsIRemoteAgent';
        readonly number: '8f685a9d-8181-46d6-a71d-869289099c6d';
    };
    nsIRemoteTab: {
        readonly name: 'nsIRemoteTab';
        readonly number: '';
    };
    nsIRequest: {
        readonly name: 'nsIRequest';
        readonly number: '';
        readonly LOAD_REQUESTMASK: 0xFFFF;
        readonly LOAD_NORMAL: 0;
        readonly LOAD_BACKGROUND;
        readonly LOAD_HTML_OBJECT_DATA;
        readonly LOAD_DOCUMENT_NEEDS_COOKIE;
        readonly LOAD_TRR_MASK;
        readonly LOAD_TRR_DISABLED_MODE;
        readonly LOAD_TRR_FIRST_MODE;
        readonly LOAD_TRR_ONLY_MODE;
        readonly LOAD_ANONYMOUS_ALLOW_CLIENT_CERT;
        readonly INHIBIT_CACHING;
        readonly INHIBIT_PERSISTENT_CACHING;
        readonly LOAD_BYPASS_CACHE;
        readonly LOAD_FROM_CACHE;
        readonly VALIDATE_ALWAYS;
        readonly VALIDATE_NEVER;
        readonly VALIDATE_ONCE_PER_SESSION;
        readonly LOAD_ANONYMOUS;
        readonly LOAD_FRESH_CONNECTION;
    };
    nsIRequestTailUnblockCallback: {
        readonly name: 'nsIRequestTailUnblockCallback';
        readonly number: '7EB361D4-37A5-42C9-AFAE-F6C88FE7C394';
    };
    nsIRequestContext: {
        readonly name: 'nsIRequestContext';
        readonly number: '658e3e6e-8633-4b1a-8d66-fa9f72293e63';
    };
    nsIRequestContextService: {
        readonly name: 'nsIRequestContextService';
        readonly number: '7fcbf4da-d828-4acc-b144-e5435198f727';
    };
    nsIRequestObserver: {
        readonly name: 'nsIRequestObserver';
        readonly number: '';
    };
    nsIRequestObserverProxy: {
        readonly name: 'nsIRequestObserverProxy';
        readonly number: 'c2b06151-1bf8-4eef-aea9-1532f12f5a10';
    };
    nsIResProtocolHandler: {
        readonly name: 'nsIResProtocolHandler';
        readonly number: '241d34ac-9ed5-46d7-910c-7a9d914aa0c5';
    };
    nsIResumableChannel: {
        readonly name: 'nsIResumableChannel';
        readonly number: '4ad136fa-83af-4a22-a76e-503642c0f4a8';
    };
    nsIRunnable: {
        readonly name: 'nsIRunnable';
        readonly number: '';
    };
    nsIRunnablePriority: {
        readonly name: 'nsIRunnablePriority';
        readonly number: 'e75aa42a-80a9-11e6-afb5-e89d87348e2c';
        readonly PRIORITY_IDLE: 0;
        readonly PRIORITY_DEFERRED_TIMERS: 1;
        readonly PRIORITY_LOW: 2;
        readonly PRIORITY_NORMAL: 4;
        readonly PRIORITY_MEDIUMHIGH: 5;
        readonly PRIORITY_INPUT_HIGH: 6;
        readonly PRIORITY_VSYNC: 7;
        readonly PRIORITY_RENDER_BLOCKING: 9;
        readonly PRIORITY_CONTROL: 10;
    };
    nsIRunnableIPCMessageType: {
        readonly name: 'nsIRunnableIPCMessageType';
        readonly number: '3114c36c-a482-4c6e-9523-1dcfc6f605b9';
    };
    nsISDBCallback: {
        readonly name: 'nsISDBCallback';
        readonly number: '';
    };
    nsISDBCloseCallback: {
        readonly name: 'nsISDBCloseCallback';
        readonly number: '';
    };
    nsISDBConnection: {
        readonly name: 'nsISDBConnection';
        readonly number: 'ea420fdd-548f-44f9-9286-59aad6a40f01';
    };
    nsISDBRequest: {
        readonly name: 'nsISDBRequest';
        readonly number: '13f05bcf-715c-427e-aac8-df9b2c1ec1e3';
    };
    nsISDBResult: {
        readonly name: 'nsISDBResult';
        readonly number: 'bca19e01-b34e-4a48-8875-2f4cb871febf';
    };
    nsISHEntry: {
        readonly name: 'nsISHEntry';
        readonly number: '';
    };
    nsISHistory: {
        readonly name: 'nsISHistory';
        readonly number: '';
    };
    nsISHistoryListener: {
        readonly name: 'nsISHistoryListener';
        readonly number: '125c0833-746a-400e-9b89-d2d18545c08a';
    };
    nsISafeOutputStream: {
        readonly name: 'nsISafeOutputStream';
        readonly number: '5f914307-5c34-4e1f-8e32-ec749d25b27a';
    };
    nsIScreen: {
        readonly name: 'nsIScreen';
        readonly number: '826e80c8-d70f-42e2-8aa9-82c05f2a370a';
    };
    nsIScreenManager: {
        readonly name: 'nsIScreenManager';
        readonly number: 'e8a96e60-6b61-4a14-bacc-53891604b502';
    };
    nsIScriptChannel: {
        readonly name: 'nsIScriptChannel';
        readonly number: '33234b99-9588-4c7d-9da6-86b8b7cba565';
        readonly NO_EXECUTION: 0;
        readonly EXECUTE_NORMAL: 2;
    };
    nsIScriptErrorNote: {
        readonly name: 'nsIScriptErrorNote';
        readonly number: 'e8933fc9-c302-4e12-a55b-4f88611d9c6c';
    };
    nsIScriptError: {
        readonly name: 'nsIScriptError';
        readonly number: '63eb4d3e-7d99-4150-b4f3-11314f9d82a9';
        readonly errorFlag: 0x0;
        readonly warningFlag: 0x1;
        readonly infoFlag: 0x8;
    };
    nsIScriptLoaderObserver: {
        readonly name: 'nsIScriptLoaderObserver';
        readonly number: '7b787204-76fb-4764-96f1-fb7a666db4f4';
    };
    nsIScriptSecurityManager: {
        readonly name: 'nsIScriptSecurityManager';
        readonly number: '51daad87-3a0c-44cc-b620-7356801c9022';
        readonly STANDARD: 0;
        readonly LOAD_IS_AUTOMATIC_DOCUMENT_REPLACEMENT;
        readonly ALLOW_CHROME;
        readonly DISALLOW_INHERIT_PRINCIPAL;
        readonly DISALLOW_SCRIPT_OR_DATA: "DISALLOW_INHERIT_PRINCIPAL";
        readonly DISALLOW_SCRIPT;
        readonly DONT_REPORT_ERRORS;
        readonly DEFAULT_USER_CONTEXT_ID: 0;
        readonly DEFAULT_PRIVATE_BROWSING_ID: 0;
    };
    nsIScriptableBase64Encoder: {
        readonly name: 'nsIScriptableBase64Encoder';
        readonly number: '9479c864-d1f9-45ab-b7b9-28b907bd2ba9';
    };
    nsIScriptableContentIterator: {
        readonly name: 'nsIScriptableContentIterator';
        readonly number: '9f25fb2a-265f-44f9-a122-62bbf443239e';
    };
    nsIScriptableInputStream: {
        readonly name: 'nsIScriptableInputStream';
        readonly number: '3fce9015-472a-4080-ac3e-cd875dbe361e';
    };
    nsIScriptableUnicodeConverter: {
        readonly name: 'nsIScriptableUnicodeConverter';
        readonly number: 'f36ee324-5c1c-437f-ba10-2b4db7a18031';
    };
    nsISearchSubmission: {
        readonly name: 'nsISearchSubmission';
        readonly number: '5799251f-5b55-4df7-a9e7-0c27812c469a';
    };
    nsISearchEngine: {
        readonly name: 'nsISearchEngine';
        readonly number: '620bd920-0491-48c8-99a8-d6047e64802d';
    };
    nsISearchParseSubmissionResult: {
        readonly name: 'nsISearchParseSubmissionResult';
        readonly number: '0dc93e51-a7bf-4a16-862d-4b3469ff6206';
    };
    nsISearchService: {
        readonly name: 'nsISearchService';
        readonly number: '0301834b-2630-440e-8b98-db8dc55f34b9';
        readonly ERROR_DOWNLOAD_FAILURE: 0x1;
        readonly ERROR_DUPLICATE_ENGINE: 0x2;
        readonly ERROR_ENGINE_CORRUPTED: 0x3;
        readonly CHANGE_REASON_UNKNOWN: 0x0;
        readonly CHANGE_REASON_USER: 0x1;
        readonly CHANGE_REASON_USER_PRIVATE_SPLIT: 0x2;
        readonly CHANGE_REASON_USER_SEARCHBAR: 0x3;
        readonly CHANGE_REASON_USER_SEARCHBAR_CONTEXT: 0x4;
        readonly CHANGE_REASON_ADDON_INSTALL: 0x5;
        readonly CHANGE_REASON_ADDON_UNINSTALL: 0x6;
        readonly CHANGE_REASON_CONFIG: 0x7;
        readonly CHANGE_REASON_LOCALE: 0x8;
        readonly CHANGE_REASON_REGION: 0x9;
        readonly CHANGE_REASON_EXPERIMENT: 0xA;
        readonly CHANGE_REASON_ENTERPRISE: 0xB;
        readonly CHANGE_REASON_UITOUR: 0xC;
    };
    nsISecCheckWrapChannel: {
        readonly name: 'nsISecCheckWrapChannel';
        readonly number: '9446c5d5-c9fb-4a6e-acf9-ca4fc666efe0';
    };
    nsISecretDecoderRing: {
        readonly name: 'nsISecretDecoderRing';
        readonly number: '0EC80360-075C-11d4-9FD4-00C04F1B83D8';
    };
    nsISecureBrowserUI: {
        readonly name: 'nsISecureBrowserUI';
        readonly number: '718c662a-f810-4a80-a6c9-0b1810ecade2';
    };
    nsISecurityConsoleMessage: {
        readonly name: 'nsISecurityConsoleMessage';
        readonly number: 'FE9FC9B6-DDE2-11E2-A8F1-0A326188709B';
    };
    nsISecurityUITelemetry: {
        readonly name: 'nsISecurityUITelemetry';
        readonly number: '5d1acf82-223a-46fb-a8f3-a1b16e2ceb04';
        readonly WARNING_ADDON_ASKING_PREVENTED: 1;
        readonly WARNING_ADDON_ASKING_PREVENTED_CLICK_THROUGH: 2;
        readonly WARNING_CONFIRM_ADDON_INSTALL: 3;
        readonly WARNING_CONFIRM_ADDON_INSTALL_CLICK_THROUGH: 4;
        readonly WARNING_CONFIRM_POST_TO_INSECURE_FROM_SECURE: 9;
        readonly WARNING_CONFIRM_POST_TO_INSECURE_FROM_SECURE_CLICK_THROUGH: 10;
    };
    nsISeekableStream: {
        readonly name: 'nsISeekableStream';
        readonly number: '8429d350-1040-4661-8b71-f2a6ba455980';
        readonly NS_SEEK_SET: 0;
        readonly NS_SEEK_CUR: 1;
        readonly NS_SEEK_END: 2;
    };
    nsISelectionController: {
        readonly name: 'nsISelectionController';
        readonly number: '3801c9d4-8e69-4bfc-9edb-b58278621f8f';
        readonly SELECTION_NONE: 0;
        readonly SELECTION_NORMAL: 1;
        readonly SELECTION_SPELLCHECK: 2;
        readonly SELECTION_IME_RAWINPUT: 3;
        readonly SELECTION_IME_SELECTEDRAWTEXT: 4;
        readonly SELECTION_IME_CONVERTEDTEXT: 5;
        readonly SELECTION_IME_SELECTEDCONVERTEDTEXT: 6;
        readonly SELECTION_ACCESSIBILITY: 7;
        readonly SELECTION_FIND: 8;
        readonly SELECTION_URLSECONDARY: 9;
        readonly SELECTION_URLSTRIKEOUT: 10;
        readonly SELECTION_HIGHLIGHT: 11;
        readonly NUM_SELECTIONTYPES: 12;
        readonly SELECTION_ANCHOR_REGION: 0;
        readonly SELECTION_FOCUS_REGION: 1;
        readonly SELECTION_WHOLE_SELECTION: 2;
        readonly NUM_SELECTION_REGIONS: 3;
        readonly SELECTION_OFF: 0;
        readonly SELECTION_HIDDEN: 1;
        readonly SELECTION_ON: 2;
        readonly SELECTION_DISABLED: 3;
        readonly SELECTION_ATTENTION: 4;
        readonly SCROLL_SYNCHRONOUS;
        readonly SCROLL_FIRST_ANCESTOR_ONLY;
        readonly SCROLL_CENTER_VERTICALLY;
        readonly SCROLL_OVERFLOW_HIDDEN;
        readonly SCROLL_FOR_CARET_MOVE;
        readonly MOVE_LEFT: 0;
        readonly MOVE_RIGHT: 1;
        readonly MOVE_UP: 2;
        readonly MOVE_DOWN: 3;
    };
    nsISelectionDisplay: {
        readonly name: 'nsISelectionDisplay';
        readonly number: '0DDF9E1C-1DD2-11B2-A183-908A08AA75AE';
        readonly DISPLAY_TEXT: 1;
        readonly DISPLAY_IMAGES: 2;
        readonly DISPLAY_FRAMES: 4;
        readonly DISPLAY_ALL: 7;
    };
    nsISelectionListener: {
        readonly name: 'nsISelectionListener';
        readonly number: '45686299-ae2b-46bc-9502-c56c35691ab9';
        readonly NO_REASON: 0;
        readonly DRAG_REASON: 1;
        readonly MOUSEDOWN_REASON: 2;
        readonly MOUSEUP_REASON: 4;
        readonly KEYPRESS_REASON: 8;
        readonly SELECTALL_REASON: 16;
        readonly COLLAPSETOSTART_REASON: 32;
        readonly COLLAPSETOEND_REASON: 64;
        readonly IME_REASON: 128;
        readonly JS_REASON: 256;
        readonly CHARACTER_AMOUNT: 0;
        readonly CLUSTER_AMOUNT: 1;
        readonly WORD_AMOUNT: 2;
        readonly WORDNOSPACE_AMOUNT: 3;
        readonly LINE_AMOUNT: 4;
        readonly BEGINLINE_AMOUNT: 5;
        readonly ENDLINE_AMOUNT: 6;
        readonly NO_AMOUNT: 7;
        readonly PARAGRAPH_AMOUNT: 8;
    };
    nsISensitiveInfoHiddenURI: {
        readonly name: 'nsISensitiveInfoHiddenURI';
        readonly number: 'a5761968-6e1a-4f2d-8191-ec749602b178';
    };
    nsISerialEventTarget: {
        readonly name: 'nsISerialEventTarget';
        readonly number: '';
    };
    nsISerializable: {
        readonly name: 'nsISerializable';
        readonly number: '';
    };
    nsISerializationHelper: {
        readonly name: 'nsISerializationHelper';
        readonly number: '31654c0f-35f3-44c6-b31e-37a11516e6bc';
    };
    nsIServerSocket: {
        readonly name: 'nsIServerSocket';
        readonly number: '7a9c39cb-a13f-4eef-9bdf-a74301628742';
        readonly LoopbackOnly: 0x00000001;
        readonly KeepWhenOffline: 0x00000002;
    };
    nsIServerSocketListener: {
        readonly name: 'nsIServerSocketListener';
        readonly number: '836d98ec-fee2-4bde-b609-abd5e966eabd';
    };
    nsIServiceManager: {
        readonly name: 'nsIServiceManager';
        readonly number: '8bb35ed9-e332-462d-9155-4a002ab5c958';
    };
    nsIServiceWorkerUnregisterCallback: {
        readonly name: 'nsIServiceWorkerUnregisterCallback';
        readonly number: '52ee2c9d-ee87-4caf-9588-23ae77ff8798';
    };
    nsIServiceWorkerInfo: {
        readonly name: 'nsIServiceWorkerInfo';
        readonly number: '76e357ed-208d-4e4c-9165-1c4059707879';
        readonly STATE_PARSED: 0;
        readonly STATE_INSTALLING: 1;
        readonly STATE_INSTALLED: 2;
        readonly STATE_ACTIVATING: 3;
        readonly STATE_ACTIVATED: 4;
        readonly STATE_REDUNDANT: 5;
        readonly STATE_UNKNOWN: 6;
    };
    nsIServiceWorkerRegistrationInfoListener: {
        readonly name: 'nsIServiceWorkerRegistrationInfoListener';
        readonly number: '87e63548-d440-4b8a-b158-65ad1de0211E';
    };
    nsIServiceWorkerRegistrationInfo: {
        readonly name: 'nsIServiceWorkerRegistrationInfo';
        readonly number: 'ddbc1fd4-2f2e-4fca-a395-6e010bbedfe3';
        readonly UPDATE_VIA_CACHE_IMPORTS: 0;
        readonly UPDATE_VIA_CACHE_ALL: 1;
        readonly UPDATE_VIA_CACHE_NONE: 2;
    };
    nsIServiceWorkerManagerListener: {
        readonly name: 'nsIServiceWorkerManagerListener';
        readonly number: '9e523e7c-ad6f-4df0-8077-c74aebbc679d';
    };
    nsIServiceWorkerManager: {
        readonly name: 'nsIServiceWorkerManager';
        readonly number: '7404c8e8-4d47-4449-8ed1-47d1261d4e33';
    };
    nsISessionStorageService: {
        readonly name: 'nsISessionStorageService';
        readonly number: '3b95dd6c-0293-4e06-baeb-2affaefc9e74';
    };
    nsISessionStoreRestoreData: {
        readonly name: 'nsISessionStoreRestoreData';
        readonly number: 'cd9f33c5-460d-4bbf-a459-f375ca9566d8';
    };
    nsISharePicker: {
        readonly name: 'nsISharePicker';
        readonly number: '1201d357-8417-4926-a694-e6408fbedcf8';
    };
    nsISharingHandlerApp: {
        readonly name: 'nsISharingHandlerApp';
        readonly number: '7111f769-53ec-41fd-b314-613661d5b6ba';
    };
    nsIShellService: {
        readonly name: 'nsIShellService';
        readonly number: '2d1a95e4-5bd8-4eeb-b0a8-c1455fd2a357';
        readonly BACKGROUND_TILE: 1;
        readonly BACKGROUND_STRETCH: 2;
        readonly BACKGROUND_CENTER: 3;
        readonly BACKGROUND_FILL: 4;
        readonly BACKGROUND_FIT: 5;
        readonly BACKGROUND_SPAN: 6;
    };
    nsIJSEnumerator: {
        readonly name: 'nsIJSEnumerator';
        readonly number: '';
    };
    nsISimpleEnumeratorBase: {
        readonly name: 'nsISimpleEnumeratorBase';
        readonly number: '796f340d-0a2a-490b-9c60-640765e99782';
    };
    nsISimpleEnumerator: {
        readonly name: 'nsISimpleEnumerator';
        readonly number: '';
    };
    nsISimpleStreamListener: {
        readonly name: 'nsISimpleStreamListener';
        readonly number: 'a9b84f6a-0824-4278-bae6-bfca0570a26e';
    };
    nsISimpleURIMutator: {
        readonly name: 'nsISimpleURIMutator';
        readonly number: 'e055bddd-f3c2-404b-adec-db9304e93be2';
    };
    nsISiteSecurityService: {
        readonly name: 'nsISiteSecurityService';
        readonly number: '275127f8-dbd7-4681-afbf-6df0c6587a01';
        readonly Success: 0;
        readonly ERROR_UNKNOWN: 1;
        readonly ERROR_COULD_NOT_PARSE_HEADER: 3;
        readonly ERROR_NO_MAX_AGE: 4;
        readonly ERROR_MULTIPLE_MAX_AGES: 5;
        readonly ERROR_INVALID_MAX_AGE: 6;
        readonly ERROR_MULTIPLE_INCLUDE_SUBDOMAINS: 7;
        readonly ERROR_INVALID_INCLUDE_SUBDOMAINS: 8;
        readonly ERROR_COULD_NOT_SAVE_STATE: 13;
    };
    nsISlowScriptDebugCallback: {
        readonly name: 'nsISlowScriptDebugCallback';
        readonly number: 'f7dbb80c-5d1e-4fd9-b55c-a9ffda4a75b1';
    };
    nsISlowScriptDebuggerStartupCallback: {
        readonly name: 'nsISlowScriptDebuggerStartupCallback';
        readonly number: 'b1c6ecd0-8fa4-11e4-b4a9-0800200c9a66';
    };
    nsISlowScriptDebugRemoteCallback: {
        readonly name: 'nsISlowScriptDebugRemoteCallback';
        readonly number: 'dbee14b0-8fa0-11e4-b4a9-0800200c9a66';
    };
    nsISlowScriptDebug: {
        readonly name: 'nsISlowScriptDebug';
        readonly number: 'f75d4164-3aa7-4395-ba44-a5f95b2e8427';
    };
    nsISocketFilter: {
        readonly name: 'nsISocketFilter';
        readonly number: 'afe2c40c-b9b9-4207-b898-e5cde18c6139';
        readonly SF_INCOMING: 0;
        readonly SF_OUTGOING: 1;
    };
    nsISocketFilterHandler: {
        readonly name: 'nsISocketFilterHandler';
        readonly number: '81ee76c6-4753-4125-9c8c-290ed9ba62fb';
    };
    nsISocketProvider: {
        readonly name: 'nsISocketProvider';
        readonly number: '';
        readonly PROXY_RESOLVES_HOST;
        readonly ANONYMOUS_CONNECT;
        readonly NO_PERMANENT_STORAGE;
        readonly BE_CONSERVATIVE;
        readonly ANONYMOUS_CONNECT_ALLOW_CLIENT_CERT;
        readonly IS_SPECULATIVE_CONNECTION;
        readonly DONT_TRY_ECH;
        readonly IS_RETRY;
        readonly USED_PRIVATE_DNS;
    };
    nsISocketProviderService: {
        readonly name: 'nsISocketProviderService';
        readonly number: '8f8a23d0-5472-11d3-bbc8-0000861d1237';
    };
    nsISocketTransport: {
        readonly name: 'nsISocketTransport';
        readonly number: '';
        readonly TIMEOUT_CONNECT: 0;
        readonly TIMEOUT_READ_WRITE: 1;
        readonly STATUS_RESOLVING: 0x4b0003;
        readonly STATUS_RESOLVED: 0x4b000b;
        readonly STATUS_CONNECTING_TO: 0x4b0007;
        readonly STATUS_CONNECTED_TO: 0x4b0004;
        readonly STATUS_SENDING_TO: 0x4b0005;
        readonly STATUS_WAITING_FOR: 0x4b000a;
        readonly STATUS_RECEIVING_FROM: 0x4b0006;
        readonly STATUS_TLS_HANDSHAKE_STARTING: 0x4b000c;
        readonly STATUS_TLS_HANDSHAKE_ENDED: 0x4b000d;
        readonly BYPASS_CACHE;
        readonly ANONYMOUS_CONNECT;
        readonly DISABLE_IPV6;
        readonly NO_PERMANENT_STORAGE;
        readonly DISABLE_IPV4;
        readonly DISABLE_RFC1918;
        readonly BE_CONSERVATIVE;
        readonly DISABLE_TRR;
        readonly REFRESH_CACHE;
        readonly RETRY_WITH_DIFFERENT_IP_FAMILY;
        readonly DONT_TRY_ECH;
        readonly TRR_MODE_FLAGS;
        readonly USE_IP_HINT_ADDRESS;
        readonly ANONYMOUS_CONNECT_ALLOW_CLIENT_CERT;
        readonly IS_RETRY;
        readonly IS_SPECULATIVE_CONNECTION;
    };
    nsISTSShutdownObserver: {
        readonly name: 'nsISTSShutdownObserver';
        readonly number: '338947df-2f3b-4d24-9ce4-ecf161c1b7df';
    };
    nsISocketTransportService: {
        readonly name: 'nsISocketTransportService';
        readonly number: 'ad56b25f-e6bb-4db3-9f7b-5b7db33fd2b1';
    };
    nsIRoutedSocketTransportService: {
        readonly name: 'nsIRoutedSocketTransportService';
        readonly number: 'c5204623-5b58-4a16-8b2e-67c34dd02e3f';
    };
    nsISound: {
        readonly name: 'nsISound';
        readonly number: 'C3C28D92-A17F-43DF-976D-4EEAE6F995FC';
        readonly EVENT_NEW_MAIL_RECEIVED: 0;
        readonly EVENT_ALERT_DIALOG_OPEN: 1;
        readonly EVENT_CONFIRM_DIALOG_OPEN: 2;
        readonly EVENT_PROMPT_DIALOG_OPEN: 3;
        readonly EVENT_SELECT_DIALOG_OPEN: 4;
        readonly EVENT_MENU_EXECUTE: 5;
        readonly EVENT_MENU_POPUP: 6;
        readonly EVENT_EDITOR_MAX_LEN: 7;
    };
    nsISpeculativeConnect: {
        readonly name: 'nsISpeculativeConnect';
        readonly number: 'd74a17ac-5b8a-4824-a309-b1f04a3c4aed';
    };
    nsISpeculativeConnectionOverrider: {
        readonly name: 'nsISpeculativeConnectionOverrider';
        readonly number: '1040ebe3-6ed1-45a6-8587-995e082518d7';
    };
    nsISpeechGrammarCompilationCallback: {
        readonly name: 'nsISpeechGrammarCompilationCallback';
        readonly number: '6fcb6ee8-a6db-49ba-9f06-355d7ee18ea7';
    };
    nsISpeechRecognitionService: {
        readonly name: 'nsISpeechRecognitionService';
        readonly number: '8e97f287-f322-44e8-8888-8344fa408ef8';
    };
    nsISpeechTaskCallback: {
        readonly name: 'nsISpeechTaskCallback';
        readonly number: 'c576de0c-8a3d-4570-be7e-9876d3e5bed2';
    };
    nsISpeechTask: {
        readonly name: 'nsISpeechTask';
        readonly number: 'ad59949c-2437-4b35-8eeb-d760caab75c5';
    };
    nsISpeechService: {
        readonly name: 'nsISpeechService';
        readonly number: '';
    };
    nsIStandaloneNativeMenu: {
        readonly name: 'nsIStandaloneNativeMenu';
        readonly number: '7F7201EB-510C-4CEF-BDF0-04A15A7A4A8C';
    };
    nsIStandardURL: {
        readonly name: 'nsIStandardURL';
        readonly number: 'babd6cca-ebe7-4329-967c-d6b9e33caa81';
        readonly URLTYPE_STANDARD: 1;
        readonly URLTYPE_AUTHORITY: 2;
        readonly URLTYPE_NO_AUTHORITY: 3;
    };
    nsIStandardURLMutator: {
        readonly name: 'nsIStandardURLMutator';
        readonly number: 'fc894e98-23a1-43cd-a7fe-72876f8ea2ee';
    };
    nsIStartupCacheInfo: {
        readonly name: 'nsIStartupCacheInfo';
        readonly number: 'a6b2f8b0-7438-11ea-bc55-0242ac130003';
    };
    nsIStorageActivityService: {
        readonly name: 'nsIStorageActivityService';
        readonly number: 'fd1310ba-d1be-4327-988e-92b39fcff6f4';
    };
    nsIStorageStream: {
        readonly name: 'nsIStorageStream';
        readonly number: '44a200fe-6c2b-4b41-b4e3-63e8c14e7c0d';
    };
    nsIStreamBufferAccess: {
        readonly name: 'nsIStreamBufferAccess';
        readonly number: 'ac923b72-ac87-4892-ac7a-ca385d429435';
    };
    nsIStreamConverter: {
        readonly name: 'nsIStreamConverter';
        readonly number: '0b6e2c69-5cf5-48b0-9dfd-c95950e2cc7b';
    };
    nsIStreamConverterService: {
        readonly name: 'nsIStreamConverterService';
        readonly number: 'f2b1ab53-f0bd-4adb-9365-e59b1701a258';
    };
    nsIStreamListener: {
        readonly name: 'nsIStreamListener';
        readonly number: '';
    };
    nsIStreamListenerTee: {
        readonly name: 'nsIStreamListenerTee';
        readonly number: '62b27fc1-6e8c-4225-8ad0-b9d44252973a';
    };
    nsIStreamLoaderObserver: {
        readonly name: 'nsIStreamLoaderObserver';
        readonly number: '359F7990-D4E9-11d3-A1A5-0050041CAF44';
    };
    nsIStreamLoader: {
        readonly name: 'nsIStreamLoader';
        readonly number: '323bcff1-7513-4e1f-a541-1c9213c2ed1b';
    };
    nsIStreamTransportService: {
        readonly name: 'nsIStreamTransportService';
        readonly number: '5e0adf7d-9785-45c3-a193-04f25a75da8f';
    };
    nsIInputAvailableCallback: {
        readonly name: 'nsIInputAvailableCallback';
        readonly number: 'ff2da731-44d0-4dd9-8236-c99387fec721';
    };
    nsIStringBundle: {
        readonly name: 'nsIStringBundle';
        readonly number: 'D85A17C2-AA7C-11d2-9B8C-00805F8A16D9';
    };
    nsIStringBundleService: {
        readonly name: 'nsIStringBundleService';
        readonly number: 'D85A17C0-AA7C-11d2-9B8C-00805F8A16D9';
    };
    nsIStringEnumeratorBase: {
        readonly name: 'nsIStringEnumeratorBase';
        readonly number: 'f5213d15-a4d1-4fb7-8a48-d69ccb7fb0eb';
    };
    nsIStringEnumerator: {
        readonly name: 'nsIStringEnumerator';
        readonly number: '';
    };
    nsIUTF8StringEnumerator: {
        readonly name: 'nsIUTF8StringEnumerator';
        readonly number: '';
    };
    nsIStringInputStream: {
        readonly name: 'nsIStringInputStream';
        readonly number: '450cd2d4-f0fd-424d-b365-b1251f80fd53';
    };
    nsIStructuredCloneContainer: {
        readonly name: 'nsIStructuredCloneContainer';
        readonly number: 'c664aae7-0d67-4155-a2dd-a3861778626f';
    };
    nsISFVBareItem: {
        readonly name: 'nsISFVBareItem';
        readonly number: '7072853f-215b-4a8a-92e5-9732bccc377b';
        readonly BOOL: 1;
        readonly STRING: 2;
        readonly DECIMAL: 3;
        readonly INTEGER: 4;
        readonly TOKEN: 5;
        readonly BYTE_SEQUENCE: 6;
    };
    nsISFVInteger: {
        readonly name: 'nsISFVInteger';
        readonly number: '843eea44-990a-422c-bbf2-2aa4ba9ee4d2';
    };
    nsISFVString: {
        readonly name: 'nsISFVString';
        readonly number: 'df6a0787-7caa-4fef-b145-08c1104c2fde';
    };
    nsISFVBool: {
        readonly name: 'nsISFVBool';
        readonly number: 'd263c6d7-4123-4c39-a121-ccf874a19012';
    };
    nsISFVDecimal: {
        readonly name: 'nsISFVDecimal';
        readonly number: '1098da8b-b4df-4526-b985-53dbd4160ad2';
    };
    nsISFVToken: {
        readonly name: 'nsISFVToken';
        readonly number: '8ad33d52-b9b2-4a17-8aa8-991250fc1214';
    };
    nsISFVByteSeq: {
        readonly name: 'nsISFVByteSeq';
        readonly number: '887eaef0-19fe-42bc-9a42-9ff773aa8fea';
    };
    nsISFVParams: {
        readonly name: 'nsISFVParams';
        readonly number: 'b1a397d7-3333-43e7-993a-fbe8ab90ee96';
    };
    nsISFVParametrizable: {
        readonly name: 'nsISFVParametrizable';
        readonly number: '6c0399f8-01de-4b25-b339-68e35e8d2e49';
    };
    nsISFVItemOrInnerList: {
        readonly name: 'nsISFVItemOrInnerList';
        readonly number: '99ac1b56-b5b3-44e7-ad96-db7444aae4b2';
    };
    nsISFVSerialize: {
        readonly name: 'nsISFVSerialize';
        readonly number: '28b9215d-c131-413c-9482-0004a371a5ec';
    };
    nsISFVItem: {
        readonly name: 'nsISFVItem';
        readonly number: 'abe8826b-6af7-4e54-bd2c-46ab231700ce';
    };
    nsISFVInnerList: {
        readonly name: 'nsISFVInnerList';
        readonly number: 'b2e52be2-8488-41b2-9ee2-3c48d92d095c';
    };
    nsISFVList: {
        readonly name: 'nsISFVList';
        readonly number: '02bb92a6-d1de-449c-b54f-d137f30c613d';
    };
    nsISFVDictionary: {
        readonly name: 'nsISFVDictionary';
        readonly number: '6642a7fe-7026-4eba-b730-05e230ee3437';
    };
    nsISFVService: {
        readonly name: 'nsISFVService';
        readonly number: '049f4be1-2f22-4438-a8da-518552ed390c';
    };
    nsIStyleSheetService: {
        readonly name: 'nsIStyleSheetService';
        readonly number: '4de68896-e8eb-41de-8237-a797b570ac4a';
        readonly AGENT_SHEET: 0;
        readonly USER_SHEET: 1;
        readonly AUTHOR_SHEET: 2;
    };
    nsISubstitutingProtocolHandler: {
        readonly name: 'nsISubstitutingProtocolHandler';
        readonly number: '154c64fd-a69e-4105-89f8-bd7dfe621372';
        readonly ALLOW_CONTENT_ACCESS;
        readonly RESOLVE_JAR_URI;
    };
    nsIOutputIterator: {
        readonly name: 'nsIOutputIterator';
        readonly number: '7330650e-1dd2-11b2-a0c2-9ff86ee97bed';
    };
    nsIInputIterator: {
        readonly name: 'nsIInputIterator';
        readonly number: '85585e12-1dd2-11b2-a930-f6929058269a';
    };
    nsIForwardIterator: {
        readonly name: 'nsIForwardIterator';
        readonly number: '8da01646-1dd2-11b2-98a7-c7009045be7e';
    };
    nsIBidirectionalIterator: {
        readonly name: 'nsIBidirectionalIterator';
        readonly number: '948defaa-1dd1-11b2-89f6-8ce81f5ebda9';
    };
    nsIRandomAccessIterator: {
        readonly name: 'nsIRandomAccessIterator';
        readonly number: '9bd6fdb0-1dd1-11b2-9101-d15375968230';
    };
    nsISupportsPrimitive: {
        readonly name: 'nsISupportsPrimitive';
        readonly number: 'd0d4b136-1dd1-11b2-9371-f0727ef827c0';
        readonly TYPE_ID: 1;
        readonly TYPE_CSTRING: 2;
        readonly TYPE_STRING: 3;
        readonly TYPE_PRBOOL: 4;
        readonly TYPE_PRUINT8: 5;
        readonly TYPE_PRUINT16: 6;
        readonly TYPE_PRUINT32: 7;
        readonly TYPE_PRUINT64: 8;
        readonly TYPE_PRTIME: 9;
        readonly TYPE_CHAR: 10;
        readonly TYPE_PRINT16: 11;
        readonly TYPE_PRINT32: 12;
        readonly TYPE_PRINT64: 13;
        readonly TYPE_FLOAT: 14;
        readonly TYPE_DOUBLE: 15;
        readonly TYPE_INTERFACE_POINTER: 17;
    };
    nsISupportsID: {
        readonly name: 'nsISupportsID';
        readonly number: 'd18290a0-4a1c-11d3-9890-006008962422';
    };
    nsISupportsCString: {
        readonly name: 'nsISupportsCString';
        readonly number: 'd65ff270-4a1c-11d3-9890-006008962422';
    };
    nsISupportsString: {
        readonly name: 'nsISupportsString';
        readonly number: 'd79dc970-4a1c-11d3-9890-006008962422';
    };
    nsISupportsPRBool: {
        readonly name: 'nsISupportsPRBool';
        readonly number: 'ddc3b490-4a1c-11d3-9890-006008962422';
    };
    nsISupportsPRUint8: {
        readonly name: 'nsISupportsPRUint8';
        readonly number: 'dec2e4e0-4a1c-11d3-9890-006008962422';
    };
    nsISupportsPRUint16: {
        readonly name: 'nsISupportsPRUint16';
        readonly number: 'dfacb090-4a1c-11d3-9890-006008962422';
    };
    nsISupportsPRUint32: {
        readonly name: 'nsISupportsPRUint32';
        readonly number: 'e01dc470-4a1c-11d3-9890-006008962422';
    };
    nsISupportsPRUint64: {
        readonly name: 'nsISupportsPRUint64';
        readonly number: 'e13567c0-4a1c-11d3-9890-006008962422';
    };
    nsISupportsPRTime: {
        readonly name: 'nsISupportsPRTime';
        readonly number: 'e2563630-4a1c-11d3-9890-006008962422';
    };
    nsISupportsChar: {
        readonly name: 'nsISupportsChar';
        readonly number: 'e2b05e40-4a1c-11d3-9890-006008962422';
    };
    nsISupportsPRInt16: {
        readonly name: 'nsISupportsPRInt16';
        readonly number: 'e30d94b0-4a1c-11d3-9890-006008962422';
    };
    nsISupportsPRInt32: {
        readonly name: 'nsISupportsPRInt32';
        readonly number: 'e36c5250-4a1c-11d3-9890-006008962422';
    };
    nsISupportsPRInt64: {
        readonly name: 'nsISupportsPRInt64';
        readonly number: 'e3cb0ff0-4a1c-11d3-9890-006008962422';
    };
    nsISupportsFloat: {
        readonly name: 'nsISupportsFloat';
        readonly number: 'abeaa390-4ac0-11d3-baea-00805f8a5dd7';
    };
    nsISupportsDouble: {
        readonly name: 'nsISupportsDouble';
        readonly number: 'b32523a0-4ac0-11d3-baea-00805f8a5dd7';
    };
    nsISupportsInterfacePointer: {
        readonly name: 'nsISupportsInterfacePointer';
        readonly number: '995ea724-1dd1-11b2-9211-c21bdd3e7ed0';
    };
    nsISupportsPriority: {
        readonly name: 'nsISupportsPriority';
        readonly number: 'aa578b44-abd5-4c19-8b14-36d4de6fdc36';
        readonly PRIORITY_HIGHEST;
        readonly PRIORITY_HIGH;
        readonly PRIORITY_NORMAL: 0;
        readonly PRIORITY_LOW: 10;
        readonly PRIORITY_LOWEST: 20;
    };
    nsISyncStreamListener: {
        readonly name: 'nsISyncStreamListener';
        readonly number: '7e1aa658-6e3f-4521-9946-9685a169f764';
    };
    nsISynthVoiceRegistry: {
        readonly name: 'nsISynthVoiceRegistry';
        readonly number: '5d7a0b38-77e5-4ee5-897c-ce5db9b85d44';
    };
    nsISystemInfo: {
        readonly name: 'nsISystemInfo';
        readonly number: '09a0502b-cedc-4cae-bf7c-35662dbd1249';
    };
    nsISystemProxySettings: {
        readonly name: 'nsISystemProxySettings';
        readonly number: '971591cd-277e-409a-bbf6-0a79879cd307';
    };
    nsISystemStatusBar: {
        readonly name: 'nsISystemStatusBar';
        readonly number: '24493180-ee81-4b7c-8b17-9e69480b7b8a';
    };
    nsITCPSocketCallback: {
        readonly name: 'nsITCPSocketCallback';
        readonly number: 'ac2c4b69-cb79-4767-b1ce-bcf62945cd39';
        readonly BUFFER_SIZE: 65536;
    };
    nsITLSServerSocket: {
        readonly name: 'nsITLSServerSocket';
        readonly number: 'cc2c30f9-cfaa-4b8a-bd44-c24881981b74';
        readonly REQUEST_NEVER: 0;
        readonly REQUEST_FIRST_HANDSHAKE: 1;
        readonly REQUEST_ALWAYS: 2;
        readonly REQUIRE_FIRST_HANDSHAKE: 3;
        readonly REQUIRE_ALWAYS: 4;
    };
    nsITLSClientStatus: {
        readonly name: 'nsITLSClientStatus';
        readonly number: '19668ea4-e5ad-4182-9698-7e890d48f327';
        readonly SSL_VERSION_3: 0x0300;
        readonly TLS_VERSION_1: 0x0301;
        readonly TLS_VERSION_1_1: 0x0302;
        readonly TLS_VERSION_1_2: 0x0303;
        readonly TLS_VERSION_1_3: 0x0304;
        readonly TLS_VERSION_UNKNOWN;
    };
    nsITLSServerConnectionInfo: {
        readonly name: 'nsITLSServerConnectionInfo';
        readonly number: '8a93f5d5-eddd-4c62-a4bd-bfd297653184';
    };
    nsITLSServerSecurityObserver: {
        readonly name: 'nsITLSServerSecurityObserver';
        readonly number: '1f62e1ae-e546-4a38-8917-d428472ed736';
    };
    nsITLSSocketControl: {
        readonly name: 'nsITLSSocketControl';
        readonly number: '418265c8-654e-4fbb-ba62-4eed27de1f03';
        readonly KEY_EXCHANGE_UNKNOWN;
        readonly SSL_VERSION_3: 0x0300;
        readonly TLS_VERSION_1: 0x0301;
        readonly TLS_VERSION_1_1: 0x0302;
        readonly TLS_VERSION_1_2: 0x0303;
        readonly TLS_VERSION_1_3: 0x0304;
        readonly SSL_VERSION_UNKNOWN;
        readonly SSL_MAC_UNKNOWN;
        readonly SSL_MAC_NULL: 0;
        readonly SSL_MAC_MD5: 1;
        readonly SSL_MAC_SHA: 2;
        readonly SSL_HMAC_MD5: 3;
        readonly SSL_HMAC_SHA: 4;
        readonly SSL_HMAC_SHA256: 5;
        readonly SSL_MAC_AEAD: 6;
    };
    nsITRRSkipReason: {
        readonly name: 'nsITRRSkipReason';
        readonly number: 'e61b5d39-f6d6-4ed3-aead-1213b24c6f27';
    };
    nsITXTToHTMLConv: {
        readonly name: 'nsITXTToHTMLConv';
        readonly number: '933355f6-1dd2-11b2-a9b0-d335b9e35983';
    };
    nsITableEditor: {
        readonly name: 'nsITableEditor';
        readonly number: '4805e684-49b9-11d3-9ce4-ed60bd6cb5bc';
        readonly eNoSearch: 0;
        readonly ePreviousColumn: 1;
        readonly ePreviousRow: 2;
    };
    nsITaggingService: {
        readonly name: 'nsITaggingService';
        readonly number: '9759bd0e-78e2-4421-9ed1-c676e1af3513';
    };
    nsITaskbarOverlayIconController: {
        readonly name: 'nsITaskbarOverlayIconController';
        readonly number: '';
    };
    nsITaskbarPreview: {
        readonly name: 'nsITaskbarPreview';
        readonly number: '';
    };
    nsITaskbarPreviewButton: {
        readonly name: 'nsITaskbarPreviewButton';
        readonly number: '';
    };
    nsITaskbarPreviewCallback: {
        readonly name: 'nsITaskbarPreviewCallback';
        readonly number: 'f3744696-320d-4804-9c27-6a84c29acaa6';
    };
    nsITaskbarPreviewController: {
        readonly name: 'nsITaskbarPreviewController';
        readonly number: '';
    };
    nsITaskbarProgress: {
        readonly name: 'nsITaskbarProgress';
        readonly number: '';
        readonly STATE_NO_PROGRESS: 0;
        readonly STATE_INDETERMINATE: 1;
        readonly STATE_NORMAL: 2;
        readonly STATE_ERROR: 3;
        readonly STATE_PAUSED: 4;
    };
    nsITaskbarTabPreview: {
        readonly name: 'nsITaskbarTabPreview';
        readonly number: '';
    };
    nsITaskbarWindowPreview: {
        readonly name: 'nsITaskbarWindowPreview';
        readonly number: '';
        readonly NUM_TOOLBAR_BUTTONS: 7;
    };
    nsIFetchTelemetryDataCallback: {
        readonly name: 'nsIFetchTelemetryDataCallback';
        readonly number: '3d3b9075-5549-4244-9c08-b64fefa1dd60';
    };
    nsITelemetry: {
        readonly name: 'nsITelemetry';
        readonly number: '273d2dd0-6c63-475a-b864-cb65160a1909';
        readonly HISTOGRAM_EXPONENTIAL: 0;
        readonly HISTOGRAM_LINEAR: 1;
        readonly HISTOGRAM_BOOLEAN: 2;
        readonly HISTOGRAM_FLAG: 3;
        readonly HISTOGRAM_COUNT: 4;
        readonly HISTOGRAM_CATEGORICAL: 5;
        readonly SCALAR_TYPE_COUNT: 0;
        readonly SCALAR_TYPE_STRING: 1;
        readonly SCALAR_TYPE_BOOLEAN: 2;
        readonly DATASET_ALL_CHANNELS: 0;
        readonly DATASET_PRERELEASE_CHANNELS: 1;
        readonly INCLUDE_OLD_LOADEVENTS;
        readonly KEEP_LOADEVENTS_NEW;
        readonly INCLUDE_PRIVATE_FIELDS_IN_LOADEVENTS;
        readonly EXCLUDE_STACKINFO_FROM_LOADEVENTS;
    };
    nsITellableStream: {
        readonly name: 'nsITellableStream';
        readonly number: 'ee942946-4538-45d2-bf05-ffdbf5932621';
    };
    nsITextInputProcessor: {
        readonly name: 'nsITextInputProcessor';
        readonly number: '';
        readonly ATTR_RAW_CLAUSE: 0x02;
        readonly ATTR_SELECTED_RAW_CLAUSE: 0x03;
        readonly ATTR_CONVERTED_CLAUSE: 0x04;
        readonly ATTR_SELECTED_CLAUSE: 0x05;
        readonly KEY_DEFAULT_PREVENTED: 0x00000001;
        readonly KEY_NON_PRINTABLE_KEY: 0x00000002;
        readonly KEY_FORCE_PRINTABLE_KEY: 0x00000004;
        readonly KEY_KEEP_KEY_LOCATION_STANDARD: 0x00000008;
        readonly KEY_KEEP_KEYCODE_ZERO: 0x00000010;
        readonly KEY_DONT_DISPATCH_MODIFIER_KEY_EVENT: 0x00000020;
        readonly KEY_DONT_MARK_KEYDOWN_AS_PROCESSED: 0x00000040;
        readonly KEY_MARK_KEYUP_AS_PROCESSED: 0x00000080;
        readonly KEYEVENT_NOT_CONSUMED: 0x00000000;
        readonly KEYDOWN_IS_CONSUMED: 0x00000001;
        readonly KEYPRESS_IS_CONSUMED: 0x00000002;
    };
    nsITextInputProcessorNotification: {
        readonly name: 'nsITextInputProcessorNotification';
        readonly number: 'c0ce1add-82bb-45ab-b99a-42cfba7fd5d7';
    };
    nsITextInputProcessorCallback: {
        readonly name: 'nsITextInputProcessorCallback';
        readonly number: '23d5f242-adb5-46f1-8766-90d1bf0383df';
    };
    nsITextToSubURI: {
        readonly name: 'nsITextToSubURI';
        readonly number: '8B042E24-6F87-11d3-B3C8-00805F8A6670';
    };
    nsIThread: {
        readonly name: 'nsIThread';
        readonly number: '';
    };
    nsIThreadInternal: {
        readonly name: 'nsIThreadInternal';
        readonly number: 'a3a72e5f-71d9-4add-8f30-59a78fb6d5eb';
    };
    nsIThreadObserver: {
        readonly name: 'nsIThreadObserver';
        readonly number: 'cc8da053-1776-44c2-9199-b5a629d0a19d';
    };
    nsINestedEventLoopCondition: {
        readonly name: 'nsINestedEventLoopCondition';
        readonly number: '039a227d-0cb7-44a5-a8f9-dbb7071979f2';
    };
    nsIThreadManager: {
        readonly name: 'nsIThreadManager';
        readonly number: '1be89eca-e2f7-453b-8d38-c11ba247f6f3';
    };
    nsIThreadPoolListener: {
        readonly name: 'nsIThreadPoolListener';
        readonly number: 'ef194cab-3f86-4b61-b132-e5e96a79e5d1';
    };
    nsIThreadPool: {
        readonly name: 'nsIThreadPool';
        readonly number: '76ce99c9-8e43-489a-9789-f27cc4424965';
    };
    nsIThreadRetargetableRequest: {
        readonly name: 'nsIThreadRetargetableRequest';
        readonly number: '27b84c48-5a73-4ba4-a8a4-8b5e649a145e';
    };
    nsIThreadRetargetableStreamListener: {
        readonly name: 'nsIThreadRetargetableStreamListener';
        readonly number: 'fb2304b8-f82f-4433-af68-d874a2ebbdc1';
    };
    nsIThreadShutdown: {
        readonly name: 'nsIThreadShutdown';
        readonly number: '70a43748-6130-4ea6-a440-7c74e1b7dd7c';
    };
    nsIInputChannelThrottleQueue: {
        readonly name: 'nsIInputChannelThrottleQueue';
        readonly number: '6b4b96fe-3c67-4587-af7b-58b6b17da411';
    };
    nsIThrottledInputChannel: {
        readonly name: 'nsIThrottledInputChannel';
        readonly number: '0a32a100-c031-45b6-9e8b-0444c7d4a143';
    };
    nsIServerTiming: {
        readonly name: 'nsIServerTiming';
        readonly number: 'c2d9e95b-9cc9-4f47-9ef6-1de0cf7ebc75';
    };
    nsITimedChannel: {
        readonly name: 'nsITimedChannel';
        readonly number: 'ca63784d-959c-4c3a-9a59-234a2a520de0';
    };
    nsITimerCallback: {
        readonly name: 'nsITimerCallback';
        readonly number: '';
    };
    nsITimer: {
        readonly name: 'nsITimer';
        readonly number: '3de4b105-363c-482c-a409-baac83a01bfc';
        readonly TYPE_ONE_SHOT: 0;
        readonly TYPE_REPEATING_SLACK: 1;
        readonly TYPE_REPEATING_PRECISE: 2;
        readonly TYPE_REPEATING_PRECISE_CAN_SKIP: 3;
        readonly TYPE_REPEATING_SLACK_LOW_PRIORITY: 4;
        readonly TYPE_ONE_SHOT_LOW_PRIORITY: 5;
    };
    nsITimerManager: {
        readonly name: 'nsITimerManager';
        readonly number: '5482506d-1d21-4d08-b01c-95c87e1295ad';
    };
    nsITlsHandshakeCallbackListener: {
        readonly name: 'nsITlsHandshakeCallbackListener';
        readonly number: 'b4bbe824-ec4c-48be-9a40-6a7339347f40';
    };
    nsITokenDialogs: {
        readonly name: 'nsITokenDialogs';
        readonly number: 'a1cbc159-468c-495d-8068-61dd538cbcca';
    };
    nsITokenPasswordDialogs: {
        readonly name: 'nsITokenPasswordDialogs';
        readonly number: '87dbd64a-4466-474e-95f5-1ad1cee5702c';
    };
    nsIToolkitChromeRegistry: {
        readonly name: 'nsIToolkitChromeRegistry';
        readonly number: '8727651c-9530-45a0-b81e-0e0690c30c50';
    };
    nsIProfileLock: {
        readonly name: 'nsIProfileLock';
        readonly number: '';
    };
    nsIToolkitProfile: {
        readonly name: 'nsIToolkitProfile';
        readonly number: '';
    };
    nsIToolkitProfileService: {
        readonly name: 'nsIToolkitProfileService';
        readonly number: '1947899b-f369-48fa-89da-f7c37bb1e6bc';
    };
    nsIToolkitShellService: {
        readonly name: 'nsIToolkitShellService';
        readonly number: '9246cad6-926a-4c17-88b0-ecba8078d143';
    };
    nsITooltipListener: {
        readonly name: 'nsITooltipListener';
        readonly number: '44b78386-1dd2-11b2-9ad2-e4eee2ca1916';
    };
    nsITooltipTextProvider: {
        readonly name: 'nsITooltipTextProvider';
        readonly number: 'b128a1e6-44f3-4331-8fbe-5af360ff21ee';
    };
    nsITouchBarHelper: {
        readonly name: 'nsITouchBarHelper';
        readonly number: 'ea109912-3acc-48de-b679-c23b6a122da5';
    };
    nsITouchBarInputCallback: {
        readonly name: 'nsITouchBarInputCallback';
        readonly number: '001ab07c-1b3a-4dbf-a657-fada0065ff55';
    };
    nsITouchBarInput: {
        readonly name: 'nsITouchBarInput';
        readonly number: '77441d17-f29c-49d7-982f-f20a5ab5a900';
    };
    nsITouchBarUpdater: {
        readonly name: 'nsITouchBarUpdater';
        readonly number: '38f396e2-93c9-4a77-aaf7-2d50b9962186';
    };
    nsITraceableChannel: {
        readonly name: 'nsITraceableChannel';
        readonly number: '68167b0b-ef34-4d79-a09a-8045f7c5140e';
    };
    nsITrackingDBService: {
        readonly name: 'nsITrackingDBService';
        readonly number: '650934db-1939-4424-be26-6ffb0375424d';
        readonly OTHER_COOKIES_BLOCKED_ID: 0;
        readonly TRACKERS_ID: 1;
        readonly TRACKING_COOKIES_ID: 2;
        readonly CRYPTOMINERS_ID: 3;
        readonly FINGERPRINTERS_ID: 4;
        readonly SOCIAL_ID: 5;
    };
    nsITransaction: {
        readonly name: 'nsITransaction';
        readonly number: '58e330c1-7b48-11d2-98b9-00805f297d89';
    };
    nsITransactionManager: {
        readonly name: 'nsITransactionManager';
        readonly number: 'c77763df-0fb9-41a8-8074-8e882f605755';
    };
    nsITransfer: {
        readonly name: 'nsITransfer';
        readonly number: '37ec75d3-97ad-4da8-afaa-eabe5b4afd73';
        readonly DOWNLOAD_ACCEPTABLE: 0;
        readonly DOWNLOAD_FORBIDDEN: 1;
        readonly DOWNLOAD_POTENTIALLY_UNSAFE: 2;
    };
    nsIFlavorDataProvider: {
        readonly name: 'nsIFlavorDataProvider';
        readonly number: '7E225E5F-711C-11D7-9FAE-000393636592';
    };
    nsITransferable: {
        readonly name: 'nsITransferable';
        readonly number: '97e0c418-1c1e-4106-bad1-9fcb11dff2fe';
    };
    nsITransport: {
        readonly name: 'nsITransport';
        readonly number: '2a8c6334-a5e6-4ec3-9865-1256541446fb';
        readonly OPEN_BLOCKING;
        readonly OPEN_UNBUFFERED;
        readonly STATUS_READING: 0x4b0008;
        readonly STATUS_WRITING: 0x4b0009;
    };
    nsITransportEventSink: {
        readonly name: 'nsITransportEventSink';
        readonly number: 'EDA4F520-67F7-484b-A691-8C3226A5B0A6';
    };
    nsITransportProvider: {
        readonly name: 'nsITransportProvider';
        readonly number: '';
    };
    nsITransportSecurityInfo: {
        readonly name: 'nsITransportSecurityInfo';
        readonly number: '';
        readonly SSL_VERSION_3: 0;
        readonly TLS_VERSION_1: 1;
        readonly TLS_VERSION_1_1: 2;
        readonly TLS_VERSION_1_2: 3;
        readonly TLS_VERSION_1_3: 4;
        readonly CERTIFICATE_TRANSPARENCY_NOT_APPLICABLE: 0;
        readonly CERTIFICATE_TRANSPARENCY_POLICY_COMPLIANT: 5;
        readonly CERTIFICATE_TRANSPARENCY_POLICY_NOT_ENOUGH_SCTS: 6;
        readonly CERTIFICATE_TRANSPARENCY_POLICY_NOT_DIVERSE_SCTS: 7;
    };
    nsITreeSelection: {
        readonly name: 'nsITreeSelection';
        readonly number: '';
    };
    nsINativeTreeSelection: {
        readonly name: 'nsINativeTreeSelection';
        readonly number: '1bd59678-5cb3-4316-b246-31a91b19aabe';
    };
    nsITreeView: {
        readonly name: 'nsITreeView';
        readonly number: '091116f0-0bdc-4b32-b9c8-c8d5a37cb088';
        readonly DROP_BEFORE;
        readonly DROP_ON: 0;
        readonly DROP_AFTER: 1;
    };
    nsITypeAheadFind: {
        readonly name: 'nsITypeAheadFind';
        readonly number: 'ae501e28-c57f-4692-ac74-410e1bed98b7';
        readonly FIND_INITIAL: 0;
        readonly FIND_NEXT: 1;
        readonly FIND_PREVIOUS: 2;
        readonly FIND_FIRST: 3;
        readonly FIND_LAST: 4;
        readonly FIND_FOUND: 0;
        readonly FIND_NOTFOUND: 1;
        readonly FIND_WRAPPED: 2;
        readonly FIND_PENDING: 3;
    };
    nsIU2FTokenManager: {
        readonly name: 'nsIU2FTokenManager';
        readonly number: '745e1eac-e449-4342-bca1-ee0e6ead09fc';
    };
    nsIUDPSocket: {
        readonly name: 'nsIUDPSocket';
        readonly number: 'd423bf4e-4499-40cf-bc03-153e2bf206d1';
    };
    nsIUDPSocketListener: {
        readonly name: 'nsIUDPSocketListener';
        readonly number: '2E4B5DD3-7358-4281-B81F-10C62EF39CB5';
    };
    nsIUDPMessage: {
        readonly name: 'nsIUDPMessage';
        readonly number: 'afdc743f-9cc0-40d8-b442-695dc54bbb74';
    };
    nsIUDPSocketSyncListener: {
        readonly name: 'nsIUDPSocketSyncListener';
        readonly number: '99f3d085-3d69-45da-a2c2-a6176af617cb';
    };
    nsIUDPSocketInternal: {
        readonly name: 'nsIUDPSocketInternal';
        readonly number: '613dd3ad-598b-4da9-ad63-bbda50c20098';
    };
    nsIURI: {
        readonly name: 'nsIURI';
        readonly number: '';
    };
    nsIURIClassifierCallback: {
        readonly name: 'nsIURIClassifierCallback';
        readonly number: '8face46e-0c96-470f-af40-0037dcd797bd';
    };
    nsIURIClassifier: {
        readonly name: 'nsIURIClassifier';
        readonly number: '596620cc-76e3-4133-9d90-360e59a794cf';
    };
    nsIURIContentListener: {
        readonly name: 'nsIURIContentListener';
        readonly number: '';
    };
    nsIURIFixupInfo: {
        readonly name: 'nsIURIFixupInfo';
        readonly number: '4819f183-b532-4932-ac09-b309cd853be7';
    };
    nsIURIFixup: {
        readonly name: 'nsIURIFixup';
        readonly number: '1da7e9d4-620b-4949-849a-1cd6077b1b2d';
        readonly FIXUP_FLAG_NONE: 0;
        readonly FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP: 1;
        readonly FIXUP_FLAGS_MAKE_ALTERNATE_URI: 2;
        readonly FIXUP_FLAG_PRIVATE_CONTEXT: 4;
        readonly FIXUP_FLAG_FIX_SCHEME_TYPOS: 8;
    };
    nsIURILoader: {
        readonly name: 'nsIURILoader';
        readonly number: '8762c4e7-be35-4958-9b81-a05685bb516d';
        readonly IS_CONTENT_PREFERRED;
        readonly DONT_RETARGET;
    };
    nsIURISetSpec: {
        readonly name: 'nsIURISetSpec';
        readonly number: '1fc53257-898b-4c5e-b69c-05bc84b4cd8f';
    };
    nsIURISetters: {
        readonly name: 'nsIURISetters';
        readonly number: '5403a6ec-99d7-405e-8b45-9f805bbdfcef';
    };
    nsIURIMutator: {
        readonly name: 'nsIURIMutator';
        readonly number: '';
    };
    nsIURIWithSpecialOrigin: {
        readonly name: 'nsIURIWithSpecialOrigin';
        readonly number: '4f65569b-d6fc-4580-94d9-21e775658a2a';
    };
    nsIURL: {
        readonly name: 'nsIURL';
        readonly number: '86adcd89-0b70-47a2-b0fe-5bb2c5f37e31';
    };
    nsIURLMutator: {
        readonly name: 'nsIURLMutator';
        readonly number: '25072eb8-f1e6-482f-9ca9-eddd3d65169a';
    };
    nsIURLDecorationAnnotationsService: {
        readonly name: 'nsIURLDecorationAnnotationsService';
        readonly number: '937d0c66-6821-4e3f-9e04-50dbc2b2b476';
    };
    nsIURLFormatter: {
        readonly name: 'nsIURLFormatter';
        readonly number: '4ab31d30-372d-11db-a98b-0800200c9a66';
    };
    nsIURLParser: {
        readonly name: 'nsIURLParser';
        readonly number: '78c5d19f-f5d2-4732-8d3d-d5a7d7133bc0';
    };
    nsIURLQueryStringStripper: {
        readonly name: 'nsIURLQueryStringStripper';
        readonly number: '6b42a890-2624-4560-99c4-b25380e8cd77';
    };
    nsIURLQueryStrippingListObserver: {
        readonly name: 'nsIURLQueryStrippingListObserver';
        readonly number: 'ef56ae12-b1bb-43e6-b1d8-16459cb98dfd';
    };
    nsIURLQueryStrippingListService: {
        readonly name: 'nsIURLQueryStrippingListService';
        readonly number: 'afff16f0-3fd2-4153-9ccd-c6d9abd879e4';
    };
    nsIUUIDGenerator: {
        readonly name: 'nsIUUIDGenerator';
        readonly number: '138ad1b2-c694-41cc-b201-333ce936d8b8';
    };
    nsIUnicharInputStream: {
        readonly name: 'nsIUnicharInputStream';
        readonly number: 'd5e3bd80-6723-4b92-b0c9-22f6162fd94f';
    };
    nsIUnicharLineInputStream: {
        readonly name: 'nsIUnicharLineInputStream';
        readonly number: '67f42475-ba80-40f8-ac0b-649c89230184';
    };
    nsIUnicharOutputStream: {
        readonly name: 'nsIUnicharOutputStream';
        readonly number: '2d00b1bb-8b21-4a63-bcc6-7213f513ac2e';
    };
    nsIUpdatePatch: {
        readonly name: 'nsIUpdatePatch';
        readonly number: 'dc8fb8a9-3a53-4031-9469-2a5197ea30e7';
    };
    nsIUpdate: {
        readonly name: 'nsIUpdate';
        readonly number: 'e094c045-f4ff-41fd-92da-cd2effd2c7c9';
    };
    nsIUpdateCheckResult: {
        readonly name: 'nsIUpdateCheckResult';
        readonly number: 'bff08110-e79f-4a9f-a56c-348170f9208a';
    };
    nsIUpdateCheck: {
        readonly name: 'nsIUpdateCheck';
        readonly number: '2620aa24-27aa-463a-b6d2-0734695c1f7a';
    };
    nsIUpdateChecker: {
        readonly name: 'nsIUpdateChecker';
        readonly number: '877ace25-8bc5-452a-8586-9c1cf2871994';
        readonly BACKGROUND_CHECK: 1;
        readonly FOREGROUND_CHECK: 2;
    };
    nsIApplicationUpdateService: {
        readonly name: 'nsIApplicationUpdateService';
        readonly number: '1107d207-a263-403a-b268-05772ec10757';
        readonly STATE_IDLE: 1;
        readonly STATE_DOWNLOADING: 2;
        readonly STATE_STAGING: 4;
        readonly STATE_PENDING: 5;
        readonly STATE_SWAP: 6;
    };
    nsIUpdateProcessor: {
        readonly name: 'nsIUpdateProcessor';
        readonly number: '74439497-d796-4915-8cef-3dfe43027e4d';
    };
    nsIUpdateSyncManager: {
        readonly name: 'nsIUpdateSyncManager';
        readonly number: 'cf4c4487-66d9-4e18-a2e9-39002245332f';
    };
    nsIUpdateManager: {
        readonly name: 'nsIUpdateManager';
        readonly number: '0f1098e9-a447-4af9-b030-6f8f35c85f89';
    };
    nsIUpdateTimerManager: {
        readonly name: 'nsIUpdateTimerManager';
        readonly number: '0765c92c-6145-4253-9db4-594d8023087e';
    };
    nsIUploadChannel: {
        readonly name: 'nsIUploadChannel';
        readonly number: '5cfe15bd-5adb-4a7f-9e55-4f5a67d15794';
    };
    nsIUploadChannel2: {
        readonly name: 'nsIUploadChannel2';
        readonly number: '2f712b52-19c5-4e0c-9e8f-b5c7c3b67049';
    };
    nsIUrlClassifierCallback: {
        readonly name: 'nsIUrlClassifierCallback';
        readonly number: '4ca27b6b-a674-4b3d-ab30-d21e2da2dffb';
    };
    nsIUrlClassifierUpdateObserver: {
        readonly name: 'nsIUrlClassifierUpdateObserver';
        readonly number: '9fa11561-5816-4e1b-bcc9-b629ca05cce6';
    };
    nsIUrlClassifierDBService: {
        readonly name: 'nsIUrlClassifierDBService';
        readonly number: '7a258022-6765-11e5-b379-b37b1f2354be';
    };
    nsIUrlClassifierLookupCallback: {
        readonly name: 'nsIUrlClassifierLookupCallback';
        readonly number: 'b903dc8f-dff1-42fe-894b-36e7a59bb801';
    };
    nsIUrlClassifierClassifyCallback: {
        readonly name: 'nsIUrlClassifierClassifyCallback';
        readonly number: '091adf98-28a5-473d-8dec-5b34b4e62496';
    };
    nsIUrlClassifierExceptionListObserver: {
        readonly name: 'nsIUrlClassifierExceptionListObserver';
        readonly number: 'f7c918e5-94bf-4b6e-9758-ef7bdab6af7e';
    };
    nsIUrlClassifierExceptionListService: {
        readonly name: 'nsIUrlClassifierExceptionListService';
        readonly number: '75c3d1a3-e977-4079-9e27-b3b56bdb76ea';
    };
    nsIUrlClassifierFeature: {
        readonly name: 'nsIUrlClassifierFeature';
        readonly number: 'a6c9b24e-b4f1-426e-af58-2c976c3943a8';
    };
    nsIUrlClassifierFeatureResult: {
        readonly name: 'nsIUrlClassifierFeatureResult';
        readonly number: 'ccb88140-5d66-4873-9815-a1b98d6cdc92';
    };
    nsIUrlClassifierFeatureCallback: {
        readonly name: 'nsIUrlClassifierFeatureCallback';
        readonly number: '2ea83c26-dfc9-44ed-9cfc-171d4753d78e';
    };
    nsIFullHashMatch: {
        readonly name: 'nsIFullHashMatch';
        readonly number: 'aabeb50e-d9f7-418e-9469-2cd9608958c0';
    };
    nsIUrlClassifierHashCompleterCallback: {
        readonly name: 'nsIUrlClassifierHashCompleterCallback';
        readonly number: 'da16de40-df26-414d-bde7-c4faf4504868';
    };
    nsIUrlClassifierHashCompleter: {
        readonly name: 'nsIUrlClassifierHashCompleter';
        readonly number: '231fb2ad-ea8a-4e63-a331-eafc3b434811';
    };
    nsIUrlClassifierPositiveCacheEntry: {
        readonly name: 'nsIUrlClassifierPositiveCacheEntry';
        readonly number: 'b3c27f8c-7db8-4f3f-97a5-5a94d781e565';
    };
    nsIUrlClassifierCacheEntry: {
        readonly name: 'nsIUrlClassifierCacheEntry';
        readonly number: 'd6297907-8236-4126-adaf-c3aa239a0d40';
    };
    nsIUrlClassifierCacheInfo: {
        readonly name: 'nsIUrlClassifierCacheInfo';
        readonly number: '69384f24-d9c5-4462-b24e-351c69e3b46a';
    };
    nsIUrlClassifierGetCacheCallback: {
        readonly name: 'nsIUrlClassifierGetCacheCallback';
        readonly number: '26e12ea4-14ff-4c77-858f-6745998b7659';
    };
    nsIUrlClassifierInfo: {
        readonly name: 'nsIUrlClassifierInfo';
        readonly number: '411bbff4-1b88-4687-aa36-e2bbdd93f6e8';
    };
    nsIUrlClassifierPrefixSet: {
        readonly name: 'nsIUrlClassifierPrefixSet';
        readonly number: '3d8579f0-75fa-4e00-ba41-38661d5b5d17';
    };
    nsIUrlClassifierRemoteSettingsService: {
        readonly name: 'nsIUrlClassifierRemoteSettingsService';
        readonly number: '26a445a4-0d00-4b20-ba5f-1297d3344a25';
    };
    nsIUrlClassifierStreamUpdater: {
        readonly name: 'nsIUrlClassifierStreamUpdater';
        readonly number: 'e1797597-f4d6-4dd3-a1e1-745ad352cd80';
    };
    nsIUrlClassifierParseFindFullHashCallback: {
        readonly name: 'nsIUrlClassifierParseFindFullHashCallback';
        readonly number: 'fbb9684a-a0aa-11e6-88b0-08606e456b8a';
    };
    nsIUrlClassifierUtils: {
        readonly name: 'nsIUrlClassifierUtils';
        readonly number: 'e4f0e59c-b922-48b0-a7b6-1735c1f96fed';
    };
    nsIUrlListManager: {
        readonly name: 'nsIUrlListManager';
        readonly number: 'd60a08ee-5c83-4eb6-bdfb-79fd0716501e';
    };
    nsIUserIdleService: {
        readonly name: 'nsIUserIdleService';
        readonly number: 'cc52f19a-63ae-4a1c-9cc3-e79eace0b471';
    };
    nsIUserIdleServiceInternal: {
        readonly name: 'nsIUserIdleServiceInternal';
        readonly number: '7b89a2e7-ed12-42e0-b86d-4984239abd7b';
    };
    nsIUtilityProcessTest: {
        readonly name: 'nsIUtilityProcessTest';
        readonly number: '0a4478f4-c5ae-4fb1-8686-d5b09fb99afb';
    };
    nsIVariant: {
        readonly name: 'nsIVariant';
        readonly number: '';
    };
    nsIWritableVariant: {
        readonly name: 'nsIWritableVariant';
        readonly number: '5586a590-8c82-11d5-90f3-0010a4e73d9a';
    };
    nsIVersionComparator: {
        readonly name: 'nsIVersionComparator';
        readonly number: 'e6cd620a-edbb-41d2-9e42-9a2ffc8107f3';
    };
    nsIViewSourceChannel: {
        readonly name: 'nsIViewSourceChannel';
        readonly number: '3e9800f8-edb7-4c9a-9285-09b4f045b019';
    };
    nsIWakeLock: {
        readonly name: 'nsIWakeLock';
        readonly number: 'e27e57ce-fa63-4035-b9ef-27c5dc0cc3ae';
    };
    nsIWeakReference: {
        readonly name: 'nsIWeakReference';
        readonly number: '';
    };
    nsISupportsWeakReference: {
        readonly name: 'nsISupportsWeakReference';
        readonly number: '9188bc86-f92e-11d2-81ef-0060083a0bcf';
    };
    nsICtapRegisterArgs: {
        readonly name: 'nsICtapRegisterArgs';
        readonly number: '2fc8febe-a277-11ed-bda2-8f6495a5e75c';
    };
    nsICtapSignArgs: {
        readonly name: 'nsICtapSignArgs';
        readonly number: '2e621cf4-a277-11ed-ae00-bf41a54ef553';
    };
    nsICtapRegisterResult: {
        readonly name: 'nsICtapRegisterResult';
        readonly number: '0567c384-a728-11ed-85f7-030324a370f0';
    };
    nsIWebAuthnAttObj: {
        readonly name: 'nsIWebAuthnAttObj';
        readonly number: '91e41be0-ed73-4a10-b55e-3312319bfddf';
    };
    nsICtapSignResult: {
        readonly name: 'nsICtapSignResult';
        readonly number: '05fff816-a728-11ed-b9ac-ff38cc2c8c28';
    };
    nsIWebAuthnController: {
        readonly name: 'nsIWebAuthnController';
        readonly number: 'c0744f48-ad64-11ed-b515-cf5149f4d6a6';
    };
    nsICredentialParameters: {
        readonly name: 'nsICredentialParameters';
        readonly number: '6c4ecd9f-57c0-4d7d-8080-bf6e4d499f8f';
    };
    nsIWebAuthnTransport: {
        readonly name: 'nsIWebAuthnTransport';
        readonly number: 'e236a9b4-a26f-11ed-b6cc-07a9834e19b1';
    };
    nsIWebBrowser: {
        readonly name: 'nsIWebBrowser';
        readonly number: '';
    };
    nsIWebBrowserChrome: {
        readonly name: 'nsIWebBrowserChrome';
        readonly number: '';
        readonly CHROME_DEFAULT: 0x00000001;
        readonly CHROME_WINDOW_BORDERS: 0x00000002;
        readonly CHROME_WINDOW_CLOSE: 0x00000004;
        readonly CHROME_WINDOW_RESIZE: 0x00000008;
        readonly CHROME_MENUBAR: 0x00000010;
        readonly CHROME_TOOLBAR: 0x00000020;
        readonly CHROME_LOCATIONBAR: 0x00000040;
        readonly CHROME_STATUSBAR: 0x00000080;
        readonly CHROME_PERSONAL_TOOLBAR: 0x00000100;
        readonly CHROME_SCROLLBARS: 0x00000200;
        readonly CHROME_TITLEBAR: 0x00000400;
        readonly CHROME_EXTRA: 0x00000800;
        readonly CHROME_WITH_SIZE: 0x00001000;
        readonly CHROME_WITH_POSITION: 0x00002000;
        readonly CHROME_WINDOW_MIN: 0x00004000;
        readonly CHROME_WINDOW_POPUP: 0x00008000;
        readonly CHROME_PRIVATE_WINDOW: 0x00010000;
        readonly CHROME_NON_PRIVATE_WINDOW: 0x00020000;
        readonly CHROME_PRIVATE_LIFETIME: 0x00040000;
        readonly CHROME_ALWAYS_ON_TOP: 0x00080000;
        readonly CHROME_REMOTE_WINDOW: 0x00100000;
        readonly CHROME_FISSION_WINDOW: 0x00200000;
        readonly CHROME_SUPPRESS_ANIMATION: 0x01000000;
        readonly CHROME_WINDOW_RAISED: 0x02000000;
        readonly CHROME_WINDOW_LOWERED: 0x04000000;
        readonly CHROME_CENTER_SCREEN: 0x08000000;
        readonly CHROME_DEPENDENT: 0x10000000;
        readonly CHROME_MODAL: 0x20000000;
        readonly CHROME_OPENAS_DIALOG: 0x40000000;
        readonly CHROME_OPENAS_CHROME: 0x80000000;
        readonly CHROME_ALL: 0x00000ffe;
        readonly CHROME_MINIMAL_POPUP;
    };
    nsIWebBrowserChromeFocus: {
        readonly name: 'nsIWebBrowserChromeFocus';
        readonly number: '947B2EE6-51ED-4C2B-9F45-426C27CA84C6';
    };
    nsIWebBrowserFind: {
        readonly name: 'nsIWebBrowserFind';
        readonly number: 'e4920136-b3e0-49e0-b1cd-6c783d2591a8';
    };
    nsIWebBrowserFindInFrames: {
        readonly name: 'nsIWebBrowserFindInFrames';
        readonly number: 'e0f5d182-34bc-11d5-be5b-b760676c6ebc';
    };
    nsIWebBrowserPersist: {
        readonly name: 'nsIWebBrowserPersist';
        readonly number: '8cd752a4-60b1-42c3-a819-65c7a1138a28';
        readonly PERSIST_FLAGS_NONE: 0;
        readonly PERSIST_FLAGS_FROM_CACHE: 1;
        readonly PERSIST_FLAGS_BYPASS_CACHE: 2;
        readonly PERSIST_FLAGS_IGNORE_REDIRECTED_DATA: 4;
        readonly PERSIST_FLAGS_IGNORE_IFRAMES: 8;
        readonly PERSIST_FLAGS_NO_CONVERSION: 16;
        readonly PERSIST_FLAGS_REPLACE_EXISTING_FILES: 32;
        readonly PERSIST_FLAGS_NO_BASE_TAG_MODIFICATIONS: 64;
        readonly PERSIST_FLAGS_FIXUP_ORIGINAL_DOM: 128;
        readonly PERSIST_FLAGS_FIXUP_LINKS_TO_DESTINATION: 256;
        readonly PERSIST_FLAGS_DONT_FIXUP_LINKS: 512;
        readonly PERSIST_FLAGS_SERIALIZE_OUTPUT: 1024;
        readonly PERSIST_FLAGS_DONT_CHANGE_FILENAMES: 2048;
        readonly PERSIST_FLAGS_FAIL_ON_BROKEN_LINKS: 4096;
        readonly PERSIST_FLAGS_CLEANUP_ON_FAILURE: 8192;
        readonly PERSIST_FLAGS_AUTODETECT_APPLY_CONVERSION: 16384;
        readonly PERSIST_FLAGS_APPEND_TO_FILE: 32768;
        readonly PERSIST_STATE_READY: 1;
        readonly PERSIST_STATE_SAVING: 2;
        readonly PERSIST_STATE_FINISHED: 3;
        readonly ENCODE_FLAGS_SELECTION_ONLY: 1;
        readonly ENCODE_FLAGS_FORMATTED: 2;
        readonly ENCODE_FLAGS_RAW: 4;
        readonly ENCODE_FLAGS_BODY_ONLY: 8;
        readonly ENCODE_FLAGS_PREFORMATTED: 16;
        readonly ENCODE_FLAGS_WRAP: 32;
        readonly ENCODE_FLAGS_FORMAT_FLOWED: 64;
        readonly ENCODE_FLAGS_ABSOLUTE_LINKS: 128;
        readonly ENCODE_FLAGS_CR_LINEBREAKS: 512;
        readonly ENCODE_FLAGS_LF_LINEBREAKS: 1024;
        readonly ENCODE_FLAGS_NOSCRIPT_CONTENT: 2048;
        readonly ENCODE_FLAGS_NOFRAMES_CONTENT: 4096;
        readonly ENCODE_FLAGS_ENCODE_BASIC_ENTITIES: 8192;
    };
    nsIWebBrowserPersistURIMap: {
        readonly name: 'nsIWebBrowserPersistURIMap';
        readonly number: 'd52e8b93-2771-45e8-a5b0-6e12b667046b';
    };
    nsIWebBrowserPersistDocument: {
        readonly name: 'nsIWebBrowserPersistDocument';
        readonly number: '74aa4918-5d15-46b6-9ccf-74f9696d721d';
    };
    nsIWebBrowserPersistResourceVisitor: {
        readonly name: 'nsIWebBrowserPersistResourceVisitor';
        readonly number: '8ce37706-b7d3-481a-be68-54f174fc0d0a';
    };
    nsIWebBrowserPersistWriteCompletion: {
        readonly name: 'nsIWebBrowserPersistWriteCompletion';
        readonly number: 'a07e6892-38ae-4207-8340-7fa6ec446ed6';
    };
    nsIWebBrowserPersistDocumentReceiver: {
        readonly name: 'nsIWebBrowserPersistDocumentReceiver';
        readonly number: '321e3174-594f-4036-b7be-791b821bd376';
    };
    nsIWebBrowserPrint: {
        readonly name: 'nsIWebBrowserPrint';
        readonly number: 'c9a934ed-fff1-4971-bfba-6c25ad70e1e6';
        readonly PRINTPREVIEW_GOTO_PAGENUM: 0;
        readonly PRINTPREVIEW_PREV_PAGE: 1;
        readonly PRINTPREVIEW_NEXT_PAGE: 2;
        readonly PRINTPREVIEW_HOME: 3;
        readonly PRINTPREVIEW_END: 4;
    };
    nsIWebNavigation: {
        readonly name: 'nsIWebNavigation';
        readonly number: '3ade79d4-8cb9-4952-b18d-4f9b63ca0d31';
        readonly LOAD_FLAGS_MASK: 0xffff;
        readonly LOAD_FLAGS_NONE: 0x0000;
        readonly LOAD_FLAGS_IS_REFRESH: 0x0010;
        readonly LOAD_FLAGS_IS_LINK: 0x0020;
        readonly LOAD_FLAGS_BYPASS_HISTORY: 0x0040;
        readonly LOAD_FLAGS_REPLACE_HISTORY: 0x0080;
        readonly LOAD_FLAGS_BYPASS_CACHE: 0x0100;
        readonly LOAD_FLAGS_BYPASS_PROXY: 0x0200;
        readonly LOAD_FLAGS_CHARSET_CHANGE: 0x0400;
        readonly LOAD_FLAGS_STOP_CONTENT: 0x0800;
        readonly LOAD_FLAGS_FROM_EXTERNAL: 0x1000;
        readonly LOAD_FLAGS_FIRST_LOAD: 0x4000;
        readonly LOAD_FLAGS_ALLOW_POPUPS: 0x8000;
        readonly LOAD_FLAGS_BYPASS_CLASSIFIER: 0x10000;
        readonly LOAD_FLAGS_FORCE_ALLOW_COOKIES: 0x20000;
        readonly LOAD_FLAGS_DISALLOW_INHERIT_PRINCIPAL: 0x40000;
        readonly LOAD_FLAGS_ERROR_LOAD_CHANGES_RV: 0x80000;
        readonly LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP: 0x100000;
        readonly LOAD_FLAGS_FIXUP_SCHEME_TYPOS: 0x200000;
        readonly LOAD_FLAGS_FORCE_ALLOW_DATA_URI: 0x400000;
        readonly LOAD_FLAGS_IS_REDIRECT: 0x800000;
        readonly LOAD_FLAGS_DISABLE_TRR: 0x1000000;
        readonly LOAD_FLAGS_FORCE_TRR: 0x2000000;
        readonly LOAD_FLAGS_BYPASS_LOAD_URI_DELEGATE: 0x4000000;
        readonly LOAD_FLAGS_USER_ACTIVATION: 0x8000000;
        readonly STOP_NETWORK: 0x01;
        readonly STOP_CONTENT: 0x02;
        readonly STOP_ALL: 0x03;
    };
    nsIWebNavigationInfo: {
        readonly name: 'nsIWebNavigationInfo';
        readonly number: '62a93afb-93a1-465c-84c8-0432264229de';
        readonly UNSUPPORTED: 0;
        readonly IMAGE: 1;
        readonly FALLBACK: 2;
        readonly OTHER;
    };
    nsIWebPageDescriptor: {
        readonly name: 'nsIWebPageDescriptor';
        readonly number: '6f30b676-3710-4c2c-80b1-0395fb26516e';
    };
    nsIWebProgress: {
        readonly name: 'nsIWebProgress';
        readonly number: '';
        readonly NOTIFY_STATE_REQUEST: 0x00000001;
        readonly NOTIFY_STATE_DOCUMENT: 0x00000002;
        readonly NOTIFY_STATE_NETWORK: 0x00000004;
        readonly NOTIFY_STATE_WINDOW: 0x00000008;
        readonly NOTIFY_STATE_ALL: 0x0000000f;
        readonly NOTIFY_PROGRESS: 0x00000010;
        readonly NOTIFY_STATUS: 0x00000020;
        readonly NOTIFY_SECURITY: 0x00000040;
        readonly NOTIFY_LOCATION: 0x00000080;
        readonly NOTIFY_REFRESH: 0x00000100;
        readonly NOTIFY_CONTENT_BLOCKING: 0x00000200;
        readonly NOTIFY_ALL: 0x000003ff;
    };
    nsIWebProgressListener: {
        readonly name: 'nsIWebProgressListener';
        readonly number: 'a9df523b-efe2-421e-9d8e-3d7f807dda4c';
        readonly STATE_START: 0x00000001;
        readonly STATE_REDIRECTING: 0x00000002;
        readonly STATE_TRANSFERRING: 0x00000004;
        readonly STATE_NEGOTIATING: 0x00000008;
        readonly STATE_STOP: 0x00000010;
        readonly STATE_IS_REQUEST: 0x00010000;
        readonly STATE_IS_DOCUMENT: 0x00020000;
        readonly STATE_IS_NETWORK: 0x00040000;
        readonly STATE_IS_WINDOW: 0x00080000;
        readonly STATE_IS_REDIRECTED_DOCUMENT: 0x00100000;
        readonly STATE_RESTORING: 0x01000000;
        readonly STATE_IS_INSECURE: 0x00000004;
        readonly STATE_IS_BROKEN: 0x00000001;
        readonly STATE_IS_SECURE: 0x00000002;
        readonly STATE_BLOCKED_MIXED_ACTIVE_CONTENT: 0x00000010;
        readonly STATE_LOADED_MIXED_ACTIVE_CONTENT: 0x00000020;
        readonly STATE_BLOCKED_MIXED_DISPLAY_CONTENT: 0x00000100;
        readonly STATE_LOADED_MIXED_DISPLAY_CONTENT: 0x00000200;
        readonly STATE_IDENTITY_EV_TOPLEVEL: 0x00100000;
        readonly STATE_USES_SSL_3: 0x01000000;
        readonly STATE_USES_WEAK_CRYPTO: 0x02000000;
        readonly STATE_CERT_USER_OVERRIDDEN: 0x04000000;
        readonly STATE_BLOCKED_TRACKING_CONTENT: 0x00001000;
        readonly STATE_LOADED_LEVEL_1_TRACKING_CONTENT: 0x00002000;
        readonly STATE_LOADED_LEVEL_2_TRACKING_CONTENT: 0x00100000;
        readonly STATE_BLOCKED_FINGERPRINTING_CONTENT: 0x00000040;
        readonly STATE_LOADED_FINGERPRINTING_CONTENT: 0x00000400;
        readonly STATE_REPLACED_FINGERPRINTING_CONTENT: 0x08000000;
        readonly STATE_ALLOWED_FINGERPRINTING_CONTENT: 0x00000200;
        readonly STATE_BLOCKED_CRYPTOMINING_CONTENT: 0x00000800;
        readonly STATE_LOADED_CRYPTOMINING_CONTENT: 0x00200000;
        readonly STATE_BLOCKED_UNSAFE_CONTENT: 0x00004000;
        readonly STATE_COOKIES_LOADED: 0x00008000;
        readonly STATE_COOKIES_LOADED_TRACKER: 0x00040000;
        readonly STATE_COOKIES_LOADED_SOCIALTRACKER: 0x00080000;
        readonly STATE_COOKIES_BLOCKED_BY_PERMISSION: 0x10000000;
        readonly STATE_COOKIES_BLOCKED_TRACKER: 0x20000000;
        readonly STATE_COOKIES_BLOCKED_SOCIALTRACKER: 0x01000000;
        readonly STATE_COOKIES_BLOCKED_ALL: 0x40000000;
        readonly STATE_COOKIES_PARTITIONED_FOREIGN: 0x80000000;
        readonly STATE_COOKIES_BLOCKED_FOREIGN: 0x00000080;
        readonly STATE_BLOCKED_SOCIALTRACKING_CONTENT: 0x00010000;
        readonly STATE_LOADED_SOCIALTRACKING_CONTENT: 0x00020000;
        readonly STATE_REPLACED_TRACKING_CONTENT: 0x00000010;
        readonly STATE_ALLOWED_TRACKING_CONTENT: 0x00000020;
        readonly STATE_BLOCKED_EMAILTRACKING_CONTENT: 0x00400000;
        readonly STATE_LOADED_EMAILTRACKING_LEVEL_1_CONTENT: 0x00800000;
        readonly STATE_LOADED_EMAILTRACKING_LEVEL_2_CONTENT: 0x00000100;
        readonly STATE_HTTPS_ONLY_MODE_UPGRADED: 0x00400000;
        readonly STATE_HTTPS_ONLY_MODE_UPGRADE_FAILED: 0x00800000;
        readonly STATE_HTTPS_ONLY_MODE_UPGRADED_FIRST: 0x08000000;
        readonly LOCATION_CHANGE_SAME_DOCUMENT: 0x00000001;
        readonly LOCATION_CHANGE_ERROR_PAGE: 0x00000002;
        readonly LOCATION_CHANGE_RELOAD: 0x00000004;
        readonly LOCATION_CHANGE_HASHCHANGE: 0x00000008;
        readonly LOCATION_CHANGE_SESSION_STORE: 0x00000010;
    };
    nsIWebProgressListener2: {
        readonly name: 'nsIWebProgressListener2';
        readonly number: 'dde39de0-e4e0-11da-8ad9-0800200c9a66';
    };
    nsIWebProtocolHandlerRegistrar: {
        readonly name: 'nsIWebProtocolHandlerRegistrar';
        readonly number: '1ce9ef8d-f462-49ca-b8e9-c946c4f37d6e';
    };
    nsIWebSocketChannel: {
        readonly name: 'nsIWebSocketChannel';
        readonly number: 'ce71d028-322a-4105-a947-a894689b52bf';
        readonly CLOSE_NORMAL: 1000;
        readonly CLOSE_GOING_AWAY: 1001;
        readonly CLOSE_PROTOCOL_ERROR: 1002;
        readonly CLOSE_UNSUPPORTED_DATATYPE: 1003;
        readonly CLOSE_NO_STATUS: 1005;
        readonly CLOSE_ABNORMAL: 1006;
        readonly CLOSE_INVALID_PAYLOAD: 1007;
        readonly CLOSE_POLICY_VIOLATION: 1008;
        readonly CLOSE_TOO_LARGE: 1009;
        readonly CLOSE_EXTENSION_MISSING: 1010;
        readonly CLOSE_INTERNAL_ERROR: 1011;
        readonly CLOSE_TLS_FAILED: 1015;
    };
    nsIWebSocketFrame: {
        readonly name: 'nsIWebSocketFrame';
        readonly number: '6714a6be-2265-4f73-a988-d78a12416037';
        readonly OPCODE_CONTINUATION: 0x0;
        readonly OPCODE_TEXT: 0x1;
        readonly OPCODE_BINARY: 0x2;
        readonly OPCODE_CLOSE: 0x8;
        readonly OPCODE_PING: 0x9;
        readonly OPCODE_PONG: 0xA;
    };
    nsIWebSocketEventListener: {
        readonly name: 'nsIWebSocketEventListener';
        readonly number: 'e7c005ab-e694-489b-b741-96db43ffb16f';
        readonly TYPE_STRING: 0x0;
        readonly TYPE_BLOB: 0x1;
        readonly TYPE_ARRAYBUFFER: 0x2;
    };
    nsIWebSocketEventService: {
        readonly name: 'nsIWebSocketEventService';
        readonly number: 'b89d1b90-2cf3-4d8f-ac21-5aedfb25c760';
    };
    nsIWebSocketImpl: {
        readonly name: 'nsIWebSocketImpl';
        readonly number: 'db1f4e2b-3cff-4615-a03c-341fda66c53d';
    };
    nsIWebSocketListener: {
        readonly name: 'nsIWebSocketListener';
        readonly number: 'd74c96b2-65b3-4e39-9e39-c577de5d7a73';
    };
    nsIWebTransport: {
        readonly name: 'nsIWebTransport';
        readonly number: 'c20d6e77-8cb1-4838-a88d-fff826080aa3';
    };
    WebTransportSessionEventListener: {
        readonly name: 'WebTransportSessionEventListener';
        readonly number: '0e3cb269-f318-43c8-959e-897f57894b71';
    };
    nsIWebTransportStreamCallback: {
        readonly name: 'nsIWebTransportStreamCallback';
        readonly number: 'c6eeff1d-599b-40a8-9157-c7a40c3d51a2';
    };
    nsIWebTransportSendStreamStats: {
        readonly name: 'nsIWebTransportSendStreamStats';
        readonly number: 'ccc3e685-8411-48f0-8b3e-ff6d1fae4809';
    };
    nsIWebTransportReceiveStreamStats: {
        readonly name: 'nsIWebTransportReceiveStreamStats';
        readonly number: '43ce1145-30ef-41a7-b97d-fa797f7f7d18';
    };
    nsIWebTransportStreamStatsCallback: {
        readonly name: 'nsIWebTransportStreamStatsCallback';
        readonly number: '9c1df3f5-bf04-46b6-9977-eb6389076db8';
    };
    nsIWebTransportReceiveStream: {
        readonly name: 'nsIWebTransportReceiveStream';
        readonly number: 'd461b235-6291-4817-adcc-a2a3b3dfc10b';
    };
    nsIWebTransportSendStream: {
        readonly name: 'nsIWebTransportSendStream';
        readonly number: '804f245c-52ea-403c-8a78-f751533bdd70';
    };
    nsIWebTransportBidirectionalStream: {
        readonly name: 'nsIWebTransportBidirectionalStream';
        readonly number: 'f9ecb509-36db-4689-97d6-137639a08750';
    };
    nsIWebVTTListener: {
        readonly name: 'nsIWebVTTListener';
        readonly number: '';
    };
    nsIWebVTTParserWrapper: {
        readonly name: 'nsIWebVTTParserWrapper';
        readonly number: '8dfe016e-1701-4618-9f5e-9a6154e853f0';
    };
    nsIWellKnownOpportunisticUtils: {
        readonly name: 'nsIWellKnownOpportunisticUtils';
        readonly number: 'b4f96c89-5238-450c-8bda-e12c26f1d150';
    };
    nsIWifiAccessPoint: {
        readonly name: 'nsIWifiAccessPoint';
        readonly number: '';
    };
    nsIWifiListener: {
        readonly name: 'nsIWifiListener';
        readonly number: '';
    };
    nsIWifiMonitor: {
        readonly name: 'nsIWifiMonitor';
        readonly number: 'F289701E-D9AF-4685-BC2F-E4226FF7C018';
    };
    nsIWinAppHelper: {
        readonly name: 'nsIWinAppHelper';
        readonly number: 'dc263ca8-b257-47eb-b5b7-339d9e0b90f7';
    };
    nsIWinTaskSchedulerService: {
        readonly name: 'nsIWinTaskSchedulerService';
        readonly number: 'a8d36901-0b6a-46c3-a214-a9e1d5d6047a';
    };
    nsIWinTaskbar: {
        readonly name: 'nsIWinTaskbar';
        readonly number: '11751471-9246-4c72-a80f-0c7df765d640';
    };
    nsIWindowCreator: {
        readonly name: 'nsIWindowCreator';
        readonly number: '';
    };
    nsIWindowMediator: {
        readonly name: 'nsIWindowMediator';
        readonly number: 'df0da056-357d-427f-bafd-e6cbf19c9381';
        readonly zLevelTop: 1;
        readonly zLevelBottom: 2;
        readonly zLevelBelow: 3;
    };
    nsIWindowMediatorListener: {
        readonly name: 'nsIWindowMediatorListener';
        readonly number: '2F276982-0D60-4377-A595-D350BA516395';
    };
    nsIWindowProvider: {
        readonly name: 'nsIWindowProvider';
        readonly number: 'e97a3830-15ef-499b-8372-c22d128091c1';
    };
    nsIWindowWatcher: {
        readonly name: 'nsIWindowWatcher';
        readonly number: '641fe945-6902-4b3f-87c2-0daef32499b3';
    };
    nsIWindowlessBrowser: {
        readonly name: 'nsIWindowlessBrowser';
        readonly number: 'abb46f48-abfc-41bf-aa9a-7feccefcf977';
    };
    nsIWindowsAlertsService: {
        readonly name: 'nsIWindowsAlertsService';
        readonly number: 'e01c8066-fb4b-4304-b9c9-ab6ed4a8322c';
    };
    nsIWindowsPackageManager: {
        readonly name: 'nsIWindowsPackageManager';
        readonly number: 'ad57ac40-52f0-11ec-ada8-4f671255c4aa';
    };
    nsIWindowsRegKey: {
        readonly name: 'nsIWindowsRegKey';
        readonly number: '2555b930-d64f-437e-9be7-0a2cb252c1f4';
        readonly ROOT_KEY_CLASSES_ROOT: 0x80000000;
        readonly ROOT_KEY_CURRENT_USER: 0x80000001;
        readonly ROOT_KEY_LOCAL_MACHINE: 0x80000002;
        readonly ACCESS_BASIC: 0x00020000;
        readonly ACCESS_QUERY_VALUE: 0x00000001;
        readonly ACCESS_SET_VALUE: 0x00000002;
        readonly ACCESS_CREATE_SUB_KEY: 0x00000004;
        readonly ACCESS_ENUMERATE_SUB_KEYS: 0x00000008;
        readonly ACCESS_NOTIFY: 0x00000010;
        readonly ACCESS_READ;
        readonly ACCESS_WRITE;
        readonly ACCESS_ALL;
        readonly WOW64_32: 0x00000200;
        readonly WOW64_64: 0x00000100;
        readonly TYPE_NONE: 0;
        readonly TYPE_STRING: 1;
        readonly TYPE_BINARY: 3;
        readonly TYPE_INT: 4;
        readonly TYPE_INT64: 11;
    };
    nsIWindowsShellService: {
        readonly name: 'nsIWindowsShellService';
        readonly number: 'fb9b59db-5a91-4e67-92b6-35e7d6e6d3fd';
    };
    nsIWindowsUIUtils: {
        readonly name: 'nsIWindowsUIUtils';
        readonly number: 'aa8a0ecf-96a1-418c-b80e-f24ae18bbedc';
    };
    nsIWorkerChannelLoadInfo: {
        readonly name: 'nsIWorkerChannelLoadInfo';
        readonly number: 'bf9a175a-03bc-4d7b-ba2f-76347cf40d7b';
    };
    nsIWorkerChannelInfo: {
        readonly name: 'nsIWorkerChannelInfo';
        readonly number: 'df1fffe4-dac6-487e-979a-629ac8c64831';
    };
    nsIWorkerDebuggerListener: {
        readonly name: 'nsIWorkerDebuggerListener';
        readonly number: '9cf3b48e-361d-486a-8917-55cf8d00bb41';
    };
    nsIWorkerDebugger: {
        readonly name: 'nsIWorkerDebugger';
        readonly number: '';
        readonly TYPE_DEDICATED: 0;
        readonly TYPE_SHARED: 1;
        readonly TYPE_SERVICE: 2;
    };
    nsIWorkerDebuggerManagerListener: {
        readonly name: 'nsIWorkerDebuggerManagerListener';
        readonly number: 'd2aa74ee-6b98-4d5d-8173-4e23422daf1e';
    };
    nsIWorkerDebuggerManager: {
        readonly name: 'nsIWorkerDebuggerManager';
        readonly number: '056d7918-dc86-452a-b4e6-86da3405f015';
    };
    nsIWritablePropertyBag: {
        readonly name: 'nsIWritablePropertyBag';
        readonly number: '96fc4671-eeb4-4823-9421-e50fb70ad353';
    };
    nsIWritablePropertyBag2: {
        readonly name: 'nsIWritablePropertyBag2';
        readonly number: '9cfd1587-360e-4957-a58f-4c2b1c5e7ed9';
    };
    nsIX509Cert: {
        readonly name: 'nsIX509Cert';
        readonly number: '';
        readonly UNKNOWN_CERT: 0;
        readonly CA_CERT;
        readonly USER_CERT;
        readonly EMAIL_CERT;
        readonly SERVER_CERT;
        readonly ANY_CERT: 0xffff;
    };
    nsIOpenSignedAppFileCallback: {
        readonly name: 'nsIOpenSignedAppFileCallback';
        readonly number: 'fc2b60e5-9a07-47c2-a2cd-b83b68a660ac';
    };
    nsIAsyncBoolCallback: {
        readonly name: 'nsIAsyncBoolCallback';
        readonly number: '07c08655-8b11-4650-b6c4-0c145595ceb5';
    };
    nsICertVerificationCallback: {
        readonly name: 'nsICertVerificationCallback';
        readonly number: '49e16fc8-efac-4f57-8361-956ef6b960a4';
    };
    nsIX509CertDB: {
        readonly name: 'nsIX509CertDB';
        readonly number: '5c16cd9b-5a73-47f1-ab0f-11ede7495cce';
        readonly UNTRUSTED: 0;
        readonly TRUSTED_SSL;
        readonly TRUSTED_EMAIL;
        readonly Success: 0;
        readonly ERROR_UNKNOWN: 1;
        readonly ERROR_PKCS12_NOSMARTCARD_EXPORT: 2;
        readonly ERROR_PKCS12_RESTORE_FAILED: 3;
        readonly ERROR_PKCS12_BACKUP_FAILED: 4;
        readonly ERROR_PKCS12_CERT_COLLISION: 5;
        readonly ERROR_BAD_PASSWORD: 6;
        readonly ERROR_DECODE_ERROR: 7;
        readonly ERROR_PKCS12_DUPLICATE_DATA: 8;
        readonly AppXPCShellRoot: 6;
        readonly AddonsPublicRoot: 7;
        readonly AddonsStageRoot: 8;
        readonly FLAG_LOCAL_ONLY;
        readonly FLAG_MUST_BE_EV;
    };
    nsIX509CertValidity: {
        readonly name: 'nsIX509CertValidity';
        readonly number: 'e701dfd8-1dd1-11b2-a172-ffa6cc6156ad';
    };
    nsIXPCScriptable: {
        readonly name: 'nsIXPCScriptable';
        readonly number: '19b70b26-7c3f-437f-a04a-2a8f9e28b617';
    };
    nsIXREDirProvider: {
        readonly name: 'nsIXREDirProvider';
        readonly number: 'f6ee3c0a-5119-47fc-b1a7-ace9e1111fff';
    };
    nsIXULAppInfo: {
        readonly name: 'nsIXULAppInfo';
        readonly number: 'ddea4f31-3c5e-4769-ac68-21ab4b3d7845';
    };
    nsIXULBrowserWindow: {
        readonly name: 'nsIXULBrowserWindow';
        readonly number: 'a8675fa9-c8b4-4350-9803-c38f344a9e38';
    };
    nsIXULRuntime: {
        readonly name: 'nsIXULRuntime';
        readonly number: '03602fac-fa3f-4a50-9baa-b88456fb4a0f';
        readonly PROCESS_TYPE_DEFAULT: 0;
        readonly PROCESS_TYPE_CONTENT: 2;
        readonly PROCESS_TYPE_IPDLUNITTEST: 3;
        readonly PROCESS_TYPE_GMPLUGIN: 4;
        readonly PROCESS_TYPE_GPU: 5;
        readonly PROCESS_TYPE_VR: 6;
        readonly PROCESS_TYPE_RDD: 7;
        readonly PROCESS_TYPE_SOCKET: 8;
        readonly PROCESS_TYPE_REMOTESANDBOXBROKER: 9;
        readonly PROCESS_TYPE_FORKSERVER: 10;
        readonly PROCESS_TYPE_UTILITY: 11;
        readonly E10S_MULTI_EXPERIMENT: 1;
    };
    nsIXULStore: {
        readonly name: 'nsIXULStore';
        readonly number: '987c4b35-c426-4dd7-ad49-3c9fa4c65d20';
    };
    nsIZipEntry: {
        readonly name: 'nsIZipEntry';
        readonly number: '';
    };
    nsIZipReader: {
        readonly name: 'nsIZipReader';
        readonly number: '9ba4ef54-e0a0-4f65-9d23-128482448885';
    };
    nsIZipReaderCache: {
        readonly name: 'nsIZipReaderCache';
        readonly number: '31179807-9fcd-46c4-befa-2ade209a394b';
    };
    nsIZipWriter: {
        readonly name: 'nsIZipWriter';
        readonly number: '3ca10750-797e-4a22-bcfe-66170b5e96dd';
        readonly COMPRESSION_NONE: 0;
        readonly COMPRESSION_FASTEST: 1;
        readonly COMPRESSION_DEFAULT: 6;
        readonly COMPRESSION_BEST: 9;
    };
    nsPIDNSService: {
        readonly name: 'nsPIDNSService';
        readonly number: '24e598fd-7b1a-436c-9154-14d8b38df8a5';
    };
    nsPIPromptService: {
        readonly name: 'nsPIPromptService';
        readonly number: 'C60A1955-6CB3-4827-8EF8-4F5C668AF0B3';
    };
    nsPISocketTransportService: {
        readonly name: 'nsPISocketTransportService';
        readonly number: '18f73bf1-b35b-4b7b-aa9a-11bcbdbc389c';
    };
    nsPIWidgetCocoa: {
        readonly name: 'nsPIWidgetCocoa';
        readonly number: 'f75ff69e-3a51-419e-bd29-042f804bc2ed';
    };
    nsPIWindowWatcher: {
        readonly name: 'nsPIWindowWatcher';
        readonly number: 'd162f9c4-19d5-4723-931f-f1e51bfa9f68';
    };
    txIEXSLTFunctions: {
        readonly name: 'txIEXSLTFunctions';
        readonly number: '21b1cfa4-00ce-4cc1-bfc1-92af1d00e580';
    };
    xpcIJSWeakReference: {
        readonly name: 'xpcIJSWeakReference';
        readonly number: '';
    };
    nsIXPCComponents_Interfaces: {
        readonly name: 'nsIXPCComponents_Interfaces';
        readonly number: 'b8c31bba-79db-4a1d-930d-4cdd68713f9e';
    };
    nsIXPCComponents_Classes: {
        readonly name: 'nsIXPCComponents_Classes';
        readonly number: '978ff520-d26c-11d2-9842-006008962422';
    };
    nsIXPCComponents_Results: {
        readonly name: 'nsIXPCComponents_Results';
        readonly number: '2fc229a0-5860-11d3-9899-006008962422';
    };
    nsIXPCComponents_ID: {
        readonly name: 'nsIXPCComponents_ID';
        readonly number: '7994a6e0-e028-11d3-8f5d-0010a4e73d9a';
    };
    nsIXPCComponents_Exception: {
        readonly name: 'nsIXPCComponents_Exception';
        readonly number: '5bf039c0-e028-11d3-8f5d-0010a4e73d9a';
    };
    nsIXPCComponents_Constructor: {
        readonly name: 'nsIXPCComponents_Constructor';
        readonly number: '88655640-e028-11d3-8f5d-0010a4e73d9a';
    };
    nsIXPCComponents_utils_Sandbox: {
        readonly name: 'nsIXPCComponents_utils_Sandbox';
        readonly number: '4f8ae0dc-d266-4a32-875b-6a9de71a8ce9';
    };
    nsIScheduledGCCallback: {
        readonly name: 'nsIScheduledGCCallback';
        readonly number: '71000535-b0fd-44d1-8ce0-909760e3953c';
    };
    nsIXPCComponents_Utils: {
        readonly name: 'nsIXPCComponents_Utils';
        readonly number: '86003fe3-ee9a-4620-91dc-eef8b1e58815';
    };
    nsIXPCComponents: {
        readonly name: 'nsIXPCComponents';
        readonly number: 'aa28aaf6-70ce-4b03-9514-afe43c7dfda8';
    };
    nsIXPCTestObjectReadOnly: {
        readonly name: 'nsIXPCTestObjectReadOnly';
        readonly number: '42fbd9f6-b12d-47ef-b7a1-02d73c11fe53';
    };
    nsIXPCTestObjectReadWrite: {
        readonly name: 'nsIXPCTestObjectReadWrite';
        readonly number: 'f07529b0-a479-4954-aba5-ab3142c6b1cb';
    };
    nsIXPCTestBug809674: {
        readonly name: 'nsIXPCTestBug809674';
        readonly number: '2df46559-da21-49bf-b863-0d7b7bbcbc73';
    };
    nsIXPCTestCEnums: {
        readonly name: 'nsIXPCTestCEnums';
        readonly number: '6a2f918e-cda2-11e8-bc9a-a34c716d1f2a';
        readonly testConst: 1;
    };
    nsIXPCTestESMReturnCodeParent: {
        readonly name: 'nsIXPCTestESMReturnCodeParent';
        readonly number: '494f9336-ad06-46ad-bbb4-b0010e27e12d';
    };
    nsIXPCTestESMReturnCodeChild: {
        readonly name: 'nsIXPCTestESMReturnCodeChild';
        readonly number: 'dee07408-75d8-4968-a37c-fe0d48ccd1ac';
        readonly CHILD_SHOULD_THROW: 0;
        readonly CHILD_SHOULD_RETURN_SUCCESS: 1;
        readonly CHILD_SHOULD_RETURN_RESULTCODE: 2;
        readonly CHILD_SHOULD_NEST_RESULTCODES: 3;
    };
    nsIXPCTestInterfaceA: {
        readonly name: 'nsIXPCTestInterfaceA';
        readonly number: '';
    };
    nsIXPCTestInterfaceB: {
        readonly name: 'nsIXPCTestInterfaceB';
        readonly number: '';
    };
    nsIXPCTestInterfaceC: {
        readonly name: 'nsIXPCTestInterfaceC';
        readonly number: '401cf1b4-355b-4cee-b7b3-c7973aee49bd';
    };
    nsIXPCTestParams: {
        readonly name: 'nsIXPCTestParams';
        readonly number: '812145c7-9fcc-425e-a878-36ad1b7730b7';
    };
    nsIXPCTestReturnCodeParent: {
        readonly name: 'nsIXPCTestReturnCodeParent';
        readonly number: '479e4532-95cf-48b8-a99b-8a5881e47138';
    };
    nsIXPCTestReturnCodeChild: {
        readonly name: 'nsIXPCTestReturnCodeChild';
        readonly number: '672cfd34-1fd1-455d-9901-d879fa6fdb95';
        readonly CHILD_SHOULD_THROW: 0;
        readonly CHILD_SHOULD_RETURN_SUCCESS: 1;
        readonly CHILD_SHOULD_RETURN_RESULTCODE: 2;
        readonly CHILD_SHOULD_NEST_RESULTCODES: 3;
    };
    nsIXPCTestFunctionInterface: {
        readonly name: 'nsIXPCTestFunctionInterface';
        readonly number: 'd58a82ab-d8f7-4ca9-9273-b3290d42a0cf';
    };
    nsIXPCTestUtils: {
        readonly name: 'nsIXPCTestUtils';
        readonly number: '1e9cddeb-510d-449a-b152-3c1b5b31d41d';
    };
}
interface CiNumberBinding {
    "{a36fa816-31da-4b23-bc97-6412771f0867}": {
        readonly name: 'IJSDebugger';
        readonly interface: IJSDebuggerType;
    };
    "{d7dfe148-0416-446b-a128-66a7c71ae8d3}": {
        readonly name: 'IPeerConnectionObserver';
        readonly interface: IPeerConnectionObserverType;
    };
    "{14afc8e7-e421-4d0c-99a5-69308d871481}": {
        readonly name: 'IPeerConnection';
        readonly interface: IPeerConnectionType;
    };
    "{a6c62ce5-3a95-41bb-b0f1-8cd4f4ca00e3}": {
        readonly name: 'IUrlClassifierUITelemetry';
        readonly interface: IUrlClassifierUITelemetryType;
    };
    "{93142a4f-e4cf-424a-b833-e638f87d2607}": {
        readonly name: 'nsIScriptableOK';
        readonly interface: nsIScriptableOKType;
    };
    "{237d01a3-771e-4c6e-adf9-c97f9aab2950}": {
        readonly name: 'nsIScriptableWithNotXPCOM';
        readonly interface: nsIScriptableWithNotXPCOMType;
    };
    "{1A060FBA-A19D-11E9-B7EB-580D0EDD8E6F}": {
        readonly name: 'nsISessionStoreFunctions';
        readonly interface: nsISessionStoreFunctionsType;
    };
    "{01dfa47b-87e4-4135-877b-586d033e1b5d}": {
        readonly name: 'amIAddonManagerStartup';
        readonly interface: amIAddonManagerStartupType;
    };
    "{386906f1-4d18-45bf-bc81-5dcd68e42c3b}": {
        readonly name: 'amIWebInstallPrompt';
        readonly interface: amIWebInstallPromptType;
    };
    "{5cc10dac-cab3-41dd-b4ce-55e27c43cc40}": {
        readonly name: 'extIWebNavigation';
        readonly interface: extIWebNavigationType;
    };
    "{}": {
        readonly name: 'imgICache';
        readonly interface: imgICacheType;
    };
    "{}": {
        readonly name: 'imgIContainer';
        readonly interface: imgIContainerType;
    };
    "{52cbb839-6e63-4a70-b21a-1db4ca706c49}": {
        readonly name: 'imgIContainerDebug';
        readonly interface: imgIContainerDebugType;
    };
    "{4baa2d6e-fee7-42df-ae3f-5fbebc0c267c}": {
        readonly name: 'imgIEncoder';
        readonly interface: imgIEncoderType;
    };
    "{}": {
        readonly name: 'imgILoader';
        readonly interface: imgILoaderType;
    };
    "{}": {
        readonly name: 'imgINotificationObserver';
        readonly interface: imgINotificationObserverType;
    };
    "{}": {
        readonly name: 'imgIRequest';
        readonly interface: imgIRequestType;
    };
    "{}": {
        readonly name: 'imgIScriptedNotificationObserver';
        readonly interface: imgIScriptedNotificationObserverType;
    };
    "{4c2383a4-931c-484d-8c4a-973590f66e3f}": {
        readonly name: 'imgITools';
        readonly interface: imgIToolsType;
    };
    "{f195772c-a4c0-47ae-80ca-211e001c67be}": {
        readonly name: 'imgIContainerCallback';
        readonly interface: imgIContainerCallbackType;
    };
    "{6657e8eb-b646-48e7-993e-cfa6e96415b4}": {
        readonly name: 'inIDeepTreeWalker';
        readonly interface: inIDeepTreeWalkerType;
    };
    "{446dd837-fbb0-41e4-8221-f740f672b20d}": {
        readonly name: 'mozIAppServicesLogger';
        readonly interface: mozIAppServicesLoggerType;
    };
    "{41e4ccc9-f0c8-4cd7-9753-7a38514b8488}": {
        readonly name: 'mozIVisitInfo';
        readonly interface: mozIVisitInfoType;
    };
    "{ad83e137-c92a-4b7b-b67e-0a318811f91e}": {
        readonly name: 'mozIPlaceInfo';
        readonly interface: mozIPlaceInfoType;
    };
    "{1f266877-2859-418b-a11b-ec3ae4f4f93d}": {
        readonly name: 'mozIVisitInfoCallback';
        readonly interface: mozIVisitInfoCallbackType;
    };
    "{994092bf-936f-449b-8dd6-0941e024360d}": {
        readonly name: 'mozIVisitedStatusCallback';
        readonly interface: mozIVisitedStatusCallbackType;
    };
    "{1643EFD2-A329-4733-A39D-17069C8D3B2D}": {
        readonly name: 'mozIAsyncHistory';
        readonly interface: mozIAsyncHistoryType;
    };
    "{9b7dd2a3-df99-4469-9ea9-61b222098695}": {
        readonly name: 'mozIBridgedSyncEngineCallback';
        readonly interface: mozIBridgedSyncEngineCallbackType;
    };
    "{2776cdd5-799a-4009-b2f3-356d940a5244}": {
        readonly name: 'mozIBridgedSyncEngineApplyCallback';
        readonly interface: mozIBridgedSyncEngineApplyCallbackType;
    };
    "{3b2b80be-c30e-4498-8065-01809cfe8d47}": {
        readonly name: 'mozIBridgedSyncEngine';
        readonly interface: mozIBridgedSyncEngineType;
    };
    "{}": {
        readonly name: 'mozIDOMWindow';
        readonly interface: mozIDOMWindowType;
    };
    "{}": {
        readonly name: 'mozIDOMWindowProxy';
        readonly interface: mozIDOMWindowProxyType;
    };
    "{9f556e4a-d9b3-46c3-9f8f-d0db1ac6c8c1}": {
        readonly name: 'mozIDownloadPlatform';
        readonly interface: mozIDownloadPlatformType;
    };
    "{e6862533-8844-4207-a6ab-04748a29d859}": {
        readonly name: 'mozIExtensionServiceWorkerInfo';
        readonly interface: mozIExtensionServiceWorkerInfoType;
    };
    "{876d45db-5c1b-4c9b-9148-1c86b33d120b}": {
        readonly name: 'mozIExtensionListenerCallOptions';
        readonly interface: mozIExtensionListenerCallOptionsType;
    };
    "{e68e3c19-1b35-4112-8faa-5c5b84086a5b}": {
        readonly name: 'mozIExtensionEventListener';
        readonly interface: mozIExtensionEventListenerType;
    };
    "{0fee1c8f-e363-46a6-bd0c-d3c3338e2534}": {
        readonly name: 'mozIExtensionAPIRequest';
        readonly interface: mozIExtensionAPIRequestType;
    };
    "{59fd4097-d88e-40fd-8664-fedd8ab67ab6}": {
        readonly name: 'mozIExtensionAPIRequestResult';
        readonly interface: mozIExtensionAPIRequestResultType;
    };
    "{0c61bd33-0557-43a2-9497-96c449f39e33}": {
        readonly name: 'mozIExtensionAPIRequestHandler';
        readonly interface: mozIExtensionAPIRequestHandlerType;
    };
    "{6b09dc51-6caa-4ca7-9d6d-30c87258a630}": {
        readonly name: 'mozIExtensionProcessScript';
        readonly interface: mozIExtensionProcessScriptType;
    };
    "{d8eb3ff1-9b4b-435a-99ca-5b8cbaba2420}": {
        readonly name: 'mozIExtensionStorageArea';
        readonly interface: mozIExtensionStorageAreaType;
    };
    "{2b008295-1bcc-4610-84f1-ad4cab2fa9ee}": {
        readonly name: 'mozIConfigurableExtensionStorageArea';
        readonly interface: mozIConfigurableExtensionStorageAreaType;
    };
    "{6dac82c9-1d8a-4893-8c0f-6e626aef802c}": {
        readonly name: 'mozISyncedExtensionStorageArea';
        readonly interface: mozISyncedExtensionStorageAreaType;
    };
    "{8cb3c7e4-d0ca-4353-bccd-2673b4e11510}": {
        readonly name: 'mozIExtensionStorageListener';
        readonly interface: mozIExtensionStorageListenerType;
    };
    "{870dca40-6602-4748-8493-c4253eb7f322}": {
        readonly name: 'mozIExtensionStorageCallback';
        readonly interface: mozIExtensionStorageCallbackType;
    };
    "{32d35d21-181f-4630-8caa-a431e2ebad72}": {
        readonly name: 'mozIGeckoMediaPluginChromeService';
        readonly interface: mozIGeckoMediaPluginChromeServiceType;
    };
    "{44d362ae-937a-4803-bee6-f2512a0149d1}": {
        readonly name: 'mozIGeckoMediaPluginService';
        readonly interface: mozIGeckoMediaPluginServiceType;
    };
    "{1c06bfd3-76b1-46fa-a64a-db682d478374}": {
        readonly name: 'mozIInterruptible';
        readonly interface: mozIInterruptibleType;
    };
    "{19533e7b-f321-4ef1-bc59-6e812dc2a733}": {
        readonly name: 'mozIJSSubScriptLoader';
        readonly interface: mozIJSSubScriptLoaderType;
    };
    "{C27F8983-B48B-4D1A-92D7-FEB8106F212D}": {
        readonly name: 'mozILocaleService';
        readonly interface: mozILocaleServiceType;
    };
    "{7f63279a-1a29-4ae6-9e7a-dc9684a23530}": {
        readonly name: 'mozIMozIntl';
        readonly interface: mozIMozIntlType;
    };
    "{189eaa7d-b29a-43a9-b1fb-7658990df940}": {
        readonly name: 'mozIMozIntlHelper';
        readonly interface: mozIMozIntlHelperType;
    };
    "{65944815-e9ae-48bd-a2bf-f1108720950c}": {
        readonly name: 'mozIOSPreferences';
        readonly interface: mozIOSPreferencesType;
    };
    "{}": {
        readonly name: 'mozIPersonalDictionary';
        readonly interface: mozIPersonalDictionaryType;
    };
    "{61b6348a-09e1-4810-8057-f8cb3cec6ef8}": {
        readonly name: 'mozIPlacesAutoComplete';
        readonly interface: mozIPlacesAutoCompleteType;
    };
    "{}": {
        readonly name: 'mozIPlacesPendingOperation';
        readonly interface: mozIPlacesPendingOperationType;
    };
    "{4125585f-b0c2-4964-a83c-4b0d99f26d49}": {
        readonly name: 'mozIRemoteLazyInputStream';
        readonly interface: mozIRemoteLazyInputStreamType;
    };
    "{ed1e84d3-3346-42e1-b28c-e76a77f549f0}": {
        readonly name: 'mozISandboxReport';
        readonly interface: mozISandboxReportType;
    };
    "{6e8ff6e5-05c9-42d3-853d-40523fd86a50}": {
        readonly name: 'mozISandboxReportArray';
        readonly interface: mozISandboxReportArrayType;
    };
    "{8535bdf7-6d9e-4853-acf9-a146449c4a3b}": {
        readonly name: 'mozISandboxReporter';
        readonly interface: mozISandboxReporterType;
    };
    "{5516303d-9007-45a0-94b9-940ef134a6e2}": {
        readonly name: 'mozISandboxSettings';
        readonly interface: mozISandboxSettingsType;
    };
    "{2306c118-3544-4674-9222-670b88dc07a9}": {
        readonly name: 'mozISandboxTest';
        readonly interface: mozISandboxTestType;
    };
    "{c92bfe0d-50b7-4a7f-9686-fe5335a696b9}": {
        readonly name: 'mozIServicesLogSink';
        readonly interface: mozIServicesLogSinkType;
    };
    "{8ba643a4-7ddc-4662-b976-7ec123843f10}": {
        readonly name: 'mozISpellCheckingEngine';
        readonly interface: mozISpellCheckingEngineType;
    };
    "{}": {
        readonly name: 'mozIStorageAsyncConnection';
        readonly interface: mozIStorageAsyncConnectionType;
    };
    "{}": {
        readonly name: 'mozIStorageAsyncStatement';
        readonly interface: mozIStorageAsyncStatementType;
    };
    "{}": {
        readonly name: 'mozIStorageBaseStatement';
        readonly interface: mozIStorageBaseStatementType;
    };
    "{}": {
        readonly name: 'mozIStorageBindingParams';
        readonly interface: mozIStorageBindingParamsType;
    };
    "{67eea5c3-4881-41ff-b0fe-09f2356aeadb}": {
        readonly name: 'mozIStorageBindingParamsArray';
        readonly interface: mozIStorageBindingParamsArrayType;
    };
    "{}": {
        readonly name: 'mozIStorageCompletionCallback';
        readonly interface: mozIStorageCompletionCallbackType;
    };
    "{}": {
        readonly name: 'mozIStorageConnection';
        readonly interface: mozIStorageConnectionType;
    };
    "{}": {
        readonly name: 'mozIStorageError';
        readonly interface: mozIStorageErrorType;
    };
    "{9ff02465-21cb-49f3-b975-7d5b38ceec73}": {
        readonly name: 'mozIStorageFunction';
        readonly interface: mozIStorageFunctionType;
    };
    "{}": {
        readonly name: 'mozIStoragePendingStatement';
        readonly interface: mozIStoragePendingStatementType;
    };
    "{a3a6fcd4-bf89-4208-a837-bf2a73afd30c}": {
        readonly name: 'mozIStorageProgressHandler';
        readonly interface: mozIStorageProgressHandlerType;
    };
    "{}": {
        readonly name: 'mozIStorageResultSet';
        readonly interface: mozIStorageResultSetType;
    };
    "{62d1b6bd-cbfe-4f9b-aee1-0ead4af4e6dc}": {
        readonly name: 'mozIStorageRow';
        readonly interface: mozIStorageRowType;
    };
    "{07b6b2f5-6d97-47b4-9584-e65bc467fe9e}": {
        readonly name: 'mozIStorageService';
        readonly interface: mozIStorageServiceType;
    };
    "{5f567c35-6c32-4140-828c-683ea49cfd3a}": {
        readonly name: 'mozIStorageStatement';
        readonly interface: mozIStorageStatementType;
    };
    "{}": {
        readonly name: 'mozIStorageStatementCallback';
        readonly interface: mozIStorageStatementCallbackType;
    };
    "{8f367508-1d9a-4d3f-be0c-ac11b6dd7dbf}": {
        readonly name: 'mozIStorageVacuumParticipant';
        readonly interface: mozIStorageVacuumParticipantType;
    };
    "{6e6306f4-ffa7-40f5-96ca-36159ce8f431}": {
        readonly name: 'mozIStorageValueArray';
        readonly interface: mozIStorageValueArrayType;
    };
    "{6239ffe3-6ffd-49ac-8b1d-958407395bf9}": {
        readonly name: 'mozISyncedBookmarksMirrorProgressListener';
        readonly interface: mozISyncedBookmarksMirrorProgressListenerType;
    };
    "{d23fdfea-92c8-409d-a516-08ae395d578f}": {
        readonly name: 'mozISyncedBookmarksMirrorCallback';
        readonly interface: mozISyncedBookmarksMirrorCallbackType;
    };
    "{37485984-a6ab-46e3-9b0c-e8b613413ef3}": {
        readonly name: 'mozISyncedBookmarksMirrorLogger';
        readonly interface: mozISyncedBookmarksMirrorLoggerType;
    };
    "{f0a6217d-8344-4e68-9995-bbf5554be86e}": {
        readonly name: 'mozISyncedBookmarksMerger';
        readonly interface: mozISyncedBookmarksMergerType;
    };
    "{77c0e42a-1dd2-11b2-8ebf-edc6606f2f4b}": {
        readonly name: 'mozITXTToHTMLConv';
        readonly interface: mozITXTToHTMLConvType;
    };
    "{9eeb2c12-ddd9-4734-8cfb-c0cdfb136e07}": {
        readonly name: 'mozITestInterfaceJS';
        readonly interface: mozITestInterfaceJSType;
    };
    "{fd82700e-ffb4-4932-b7d6-08f0b5697dda}": {
        readonly name: 'mozIThirdPartyUtil';
        readonly interface: mozIThirdPartyUtilType;
    };
    "{de142307-7b88-4e0a-b232-250f310e25d8}": {
        readonly name: 'nsIASN1Tree';
        readonly interface: nsIASN1TreeType;
    };
    "{c0c19db9-1b5a-4ac5-b656-ed6f8149fa48}": {
        readonly name: 'nsIAboutModule';
        readonly interface: nsIAboutModuleType;
    };
    "{dfcd2adc-7867-4d3a-ba70-17501f208142}": {
        readonly name: 'nsIAboutNewTabService';
        readonly interface: nsIAboutNewTabServiceType;
    };
    "{063813a0-85d8-4e77-80ea-b61292c0493d}": {
        readonly name: 'nsIInstalledApplication';
        readonly interface: nsIInstalledApplicationType;
    };
    "{d33ff086-b328-4ae6-aaf5-52d41aa5df38}": {
        readonly name: 'nsIAboutThirdParty';
        readonly interface: nsIAboutThirdPartyType;
    };
    "{8a034ef9-9d14-4c5d-8319-06c1ab574baa}": {
        readonly name: 'nsIAddonPolicyService';
        readonly interface: nsIAddonPolicyServiceType;
    };
    "{7a4fe60b-9131-45f5-83f3-dc63b5d71a5d}": {
        readonly name: 'nsIAddonContentPolicy';
        readonly interface: nsIAddonContentPolicyType;
    };
    "{a71a637d-de1d-47c6-a8d2-c60b2596f471}": {
        readonly name: 'nsIAlertNotificationImageListener';
        readonly interface: nsIAlertNotificationImageListenerType;
    };
    "{a054c2c9-2787-4686-859c-45609d790056}": {
        readonly name: 'nsIAlertAction';
        readonly interface: nsIAlertActionType;
    };
    "{cf2e4cb6-4b8f-4eca-aea9-d51a8f9f7a50}": {
        readonly name: 'nsIAlertNotification';
        readonly interface: nsIAlertNotificationType;
    };
    "{f7a36392-d98b-4141-a7d7-4e46642684e3}": {
        readonly name: 'nsIAlertsService';
        readonly interface: nsIAlertsServiceType;
    };
    "{c5d63e3a-259d-45a8-b964-8377967cb4d2}": {
        readonly name: 'nsIAlertsDoNotDisturb';
        readonly interface: nsIAlertsDoNotDisturbType;
    };
    "{fc6d7f0a-0cf6-4268-8c71-ab640842b9b1}": {
        readonly name: 'nsIAlertsIconData';
        readonly interface: nsIAlertsIconDataType;
    };
    "{f3c82915-bf60-41ea-91ce-6c46b22e381a}": {
        readonly name: 'nsIAlertsIconURI';
        readonly interface: nsIAlertsIconURIType;
    };
    "{e64c39b8-b8ec-477d-aef5-89d517ff9219}": {
        readonly name: 'nsIAndroidEventCallback';
        readonly interface: nsIAndroidEventCallbackType;
    };
    "{819ee2db-d3b8-46dd-a476-40f89c49133c}": {
        readonly name: 'nsIAndroidEventFinalizer';
        readonly interface: nsIAndroidEventFinalizerType;
    };
    "{73569a75-78eb-4c7f-82b9-2d4f5ccf44c3}": {
        readonly name: 'nsIAndroidEventListener';
        readonly interface: nsIAndroidEventListenerType;
    };
    "{e98bf792-4145-411e-b298-8219d9b03817}": {
        readonly name: 'nsIAndroidEventDispatcher';
        readonly interface: nsIAndroidEventDispatcherType;
    };
    "{60a78a94-6117-432f-9d49-304913a931c5}": {
        readonly name: 'nsIAndroidView';
        readonly interface: nsIAndroidViewType;
    };
    "{1beb70d3-70f3-4742-98cc-a3d301b26c0c}": {
        readonly name: 'nsIAndroidBridge';
        readonly interface: nsIAndroidBridgeType;
    };
    "{}": {
        readonly name: 'nsIAppShell';
        readonly interface: nsIAppShellType;
    };
    "{19266025-354c-4bb9-986b-3483b2b1cdef}": {
        readonly name: 'nsIAppShellService';
        readonly interface: nsIAppShellServiceType;
    };
    "{6621f6d5-6c04-4a0e-9e74-447db221484e}": {
        readonly name: 'nsIAppStartup';
        readonly interface: nsIAppStartupType;
    };
    "{}": {
        readonly name: 'nsIAppWindow';
        readonly interface: nsIAppWindowType;
    };
    "{8144404d-e6c7-4861-bcca-47de912ee811}": {
        readonly name: 'nsIApplicationChooserFinishedCallback';
        readonly interface: nsIApplicationChooserFinishedCallbackType;
    };
    "{f7a149da-612a-46ba-8a2f-54786fc28791}": {
        readonly name: 'nsIApplicationChooser';
        readonly interface: nsIApplicationChooserType;
    };
    "{c9f03479-fd68-4393-acb2-c88d4f563174}": {
        readonly name: 'nsIApplicationReputationService';
        readonly interface: nsIApplicationReputationServiceType;
    };
    "{812d7509-a9a3-446e-a66f-3ed8cc91ebd0}": {
        readonly name: 'nsIApplicationReputationQuery';
        readonly interface: nsIApplicationReputationQueryType;
    };
    "{9a228470-cfe5-11e2-8b8b-0800200c9a66}": {
        readonly name: 'nsIApplicationReputationCallback';
        readonly interface: nsIApplicationReputationCallbackType;
    };
    "{}": {
        readonly name: 'nsIArray';
        readonly interface: nsIArrayType;
    };
    "{3014dde6-aa1c-41db-87d0-48764a3710f6}": {
        readonly name: 'nsIArrayBufferInputStream';
        readonly interface: nsIArrayBufferInputStreamType;
    };
    "{261d442e-050c-453d-8aaa-b3f23bcc528b}": {
        readonly name: 'nsIArrayExtensions';
        readonly interface: nsIArrayExtensionsType;
    };
    "{}": {
        readonly name: 'nsIAsyncInputStream';
        readonly interface: nsIAsyncInputStreamType;
    };
    "{}": {
        readonly name: 'nsIInputStreamCallback';
        readonly interface: nsIInputStreamCallbackType;
    };
    "{}": {
        readonly name: 'nsIAsyncOutputStream';
        readonly interface: nsIAsyncOutputStreamType;
    };
    "{40dbcdff-9053-42c5-a57c-3ec910d0f148}": {
        readonly name: 'nsIOutputStreamCallback';
        readonly interface: nsIOutputStreamCallbackType;
    };
    "{4ef43f29-6715-4b57-a750-2ff83695ddce}": {
        readonly name: 'nsIAsyncShutdownBlocker';
        readonly interface: nsIAsyncShutdownBlockerType;
    };
    "{}": {
        readonly name: 'nsIAsyncShutdownClient';
        readonly interface: nsIAsyncShutdownClientType;
    };
    "{910c9309-1da0-4dd0-8bdb-a325a38c604e}": {
        readonly name: 'nsIAsyncShutdownCompletionCallback';
        readonly interface: nsIAsyncShutdownCompletionCallbackType;
    };
    "{50fa8a86-9c91-4256-8389-17d310adec90}": {
        readonly name: 'nsIAsyncShutdownBarrier';
        readonly interface: nsIAsyncShutdownBarrierType;
    };
    "{db365c78-c860-4e64-9a63-25b73f89a016}": {
        readonly name: 'nsIAsyncShutdownService';
        readonly interface: nsIAsyncShutdownServiceType;
    };
    "{5a19ca27-e041-4aca-8287-eb248d4c50c0}": {
        readonly name: 'nsIAsyncStreamCopier';
        readonly interface: nsIAsyncStreamCopierType;
    };
    "{a5b2decf-4ede-4801-8b38-e5fe5db46bf2}": {
        readonly name: 'nsIAsyncStreamCopier2';
        readonly interface: nsIAsyncStreamCopier2Type;
    };
    "{}": {
        readonly name: 'nsIAsyncVerifyRedirectCallback';
        readonly interface: nsIAsyncVerifyRedirectCallbackType;
    };
    "{2822a840-f009-11e5-a837-0800200c9a66}": {
        readonly name: 'nsISuspendedTypes';
        readonly interface: nsISuspendedTypesType;
    };
    "{15c05894-408e-4798-b527-a8c32d9c5f8c}": {
        readonly name: 'nsIAudioChannelAgentCallback';
        readonly interface: nsIAudioChannelAgentCallbackType;
    };
    "{4d212770-5d7b-446f-9394-632e351d96ee}": {
        readonly name: 'nsIAudioChannelAgent';
        readonly interface: nsIAudioChannelAgentType;
    };
    "{feb979a8-f8cc-4522-9dff-6c055ca50762}": {
        readonly name: 'nsIAudioDeviceInfo';
        readonly interface: nsIAudioDeviceInfoType;
    };
    "{}": {
        readonly name: 'nsIAuthInformation';
        readonly interface: nsIAuthInformationType;
    };
    "{6e35dbc0-49ef-4e2c-b1ea-b72ec64450a2}": {
        readonly name: 'nsIAuthModule';
        readonly interface: nsIAuthModuleType;
    };
    "{}": {
        readonly name: 'nsIAuthPrompt';
        readonly interface: nsIAuthPromptType;
    };
    "{}": {
        readonly name: 'nsIAuthPrompt2';
        readonly interface: nsIAuthPrompt2Type;
    };
    "{60e46383-bb9a-4860-8962-80d9c5c05ddc}": {
        readonly name: 'nsIAuthPromptAdapterFactory';
        readonly interface: nsIAuthPromptAdapterFactoryType;
    };
    "{}": {
        readonly name: 'nsIAuthPromptCallback';
        readonly interface: nsIAuthPromptCallbackType;
    };
    "{bd9dc0fa-68ce-47d0-8859-6418c2ae8576}": {
        readonly name: 'nsIAuthPromptProvider';
        readonly interface: nsIAuthPromptProviderType;
    };
    "{ff9f8465-204a-47a6-b3c9-0628b3856684}": {
        readonly name: 'nsIAutoCompleteController';
        readonly interface: nsIAutoCompleteControllerType;
    };
    "{}": {
        readonly name: 'nsIAutoCompleteInput';
        readonly interface: nsIAutoCompleteInputType;
    };
    "{}": {
        readonly name: 'nsIAutoCompletePopup';
        readonly interface: nsIAutoCompletePopupType;
    };
    "{}": {
        readonly name: 'nsIAutoCompleteResult';
        readonly interface: nsIAutoCompleteResultType;
    };
    "{DE8DB85F-C1DE-4d87-94BA-7844890F91FE}": {
        readonly name: 'nsIAutoCompleteSearch';
        readonly interface: nsIAutoCompleteSearchType;
    };
    "{8bd1dbbc-dcce-4007-9afa-b551eb687b61}": {
        readonly name: 'nsIAutoCompleteObserver';
        readonly interface: nsIAutoCompleteObserverType;
    };
    "{4c3e7462-fbfb-4310-8f4b-239238392b75}": {
        readonly name: 'nsIAutoCompleteSearchDescriptor';
        readonly interface: nsIAutoCompleteSearchDescriptorType;
    };
    "{23de9c96-becb-4d0d-a9bb-1d131ce361b5}": {
        readonly name: 'nsIAutoCompleteSimpleResult';
        readonly interface: nsIAutoCompleteSimpleResultType;
    };
    "{004efdc5-1989-4874-8a7a-345bf2fa33af}": {
        readonly name: 'nsIAutoCompleteSimpleResultListener';
        readonly interface: nsIAutoCompleteSimpleResultListenerType;
    };
    "{dc185a77-ba88-4caa-8f16-465253f7599a}": {
        readonly name: 'nsIAutoCompleteSimpleSearch';
        readonly interface: nsIAutoCompleteSimpleSearchType;
    };
    "{048a24f6-c4d6-47bc-bea2-f6038d1db80a}": {
        readonly name: 'nsIAutoplay';
        readonly interface: nsIAutoplayType;
    };
    "{2e530956-6054-464f-9f4c-0ae6f8de5523}": {
        readonly name: 'nsITabUnloader';
        readonly interface: nsITabUnloaderType;
    };
    "{b0b5701e-239d-49db-9009-37e89f86441c}": {
        readonly name: 'nsIAvailableMemoryWatcherBase';
        readonly interface: nsIAvailableMemoryWatcherBaseType;
    };
    "{}": {
        readonly name: 'nsIBFCacheEntry';
        readonly interface: nsIBFCacheEntryType;
    };
    "{8acaa9b1-f0c4-4ade-baeb-39b0d4b96e5b}": {
        readonly name: 'nsIBackgroundChannelRegistrar';
        readonly interface: nsIBackgroundChannelRegistrarType;
    };
    "{c43544a4-682c-4262-b407-2453d26e660d}": {
        readonly name: 'nsIBackgroundFileSaver';
        readonly interface: nsIBackgroundFileSaverType;
    };
    "{ee7058c3-6e54-4411-b76b-3ce87b76fcb6}": {
        readonly name: 'nsIBackgroundFileSaverObserver';
        readonly interface: nsIBackgroundFileSaverObserverType;
    };
    "{353dccb8-a863-49e4-941b-007382eac168}": {
        readonly name: 'nsIBackgroundTasks';
        readonly interface: nsIBackgroundTasksType;
    };
    "{4d48c536-e16f-4699-8f9c-add4f28f92f0}": {
        readonly name: 'nsIBackgroundTasksManager';
        readonly interface: nsIBackgroundTasksManagerType;
    };
    "{8cd92fce-1ec3-470a-ad09-c0de9d98497e}": {
        readonly name: 'nsIBackgroundTasksRunner';
        readonly interface: nsIBackgroundTasksRunnerType;
    };
    "{}": {
        readonly name: 'nsIBaseWindow';
        readonly interface: nsIBaseWindowType;
    };
    "{288dae24-76e2-43a3-befe-9d9fabe8014e}": {
        readonly name: 'nsIBidiKeyboard';
        readonly interface: nsIBidiKeyboardType;
    };
    "{f6f899cc-683a-43da-9206-0eb0c09cc758}": {
        readonly name: 'nsIBinaryHttpRequest';
        readonly interface: nsIBinaryHttpRequestType;
    };
    "{6ca85d9c-cdc5-45d4-9adc-005abedce9c9}": {
        readonly name: 'nsIBinaryHttpResponse';
        readonly interface: nsIBinaryHttpResponseType;
    };
    "{b43b3f73-8160-4ab2-9f5d-4129a9708081}": {
        readonly name: 'nsIBinaryHttp';
        readonly interface: nsIBinaryHttpType;
    };
    "{899b826b-2eb3-469c-8b31-4c29f5d341a6}": {
        readonly name: 'nsIBinaryInputStream';
        readonly interface: nsIBinaryInputStreamType;
    };
    "{204ee610-8765-11d3-90cf-0040056a906e}": {
        readonly name: 'nsIBinaryOutputStream';
        readonly interface: nsIBinaryOutputStreamType;
    };
    "{495d6f3d-9748-4d30-8ce5-0290c0001edf}": {
        readonly name: 'nsIBits';
        readonly interface: nsIBitsType;
    };
    "{aa12e433-5b9f-452d-b5c9-840a9541328b}": {
        readonly name: 'nsIBitsNewRequestCallback';
        readonly interface: nsIBitsNewRequestCallbackType;
    };
    "{ab9da0e9-06bf-4e73-bb1b-c0f2ea9ecc3e}": {
        readonly name: 'nsIBitsRequest';
        readonly interface: nsIBitsRequestType;
    };
    "{ea657e66-6bad-4e41-84d9-c6d107e9799d}": {
        readonly name: 'nsIBitsCallback';
        readonly interface: nsIBitsCallbackType;
    };
    "{a6dcc76e-9f62-4cc1-a470-b483a1a6f096}": {
        readonly name: 'nsIBlocklistService';
        readonly interface: nsIBlocklistServiceType;
    };
    "{4866F748-29DA-4C10-8EAA-ED2F7851E6B1}": {
        readonly name: 'nsIBounceTrackingProtection';
        readonly interface: nsIBounceTrackingProtectionType;
    };
    "{}": {
        readonly name: 'nsIBrowser';
        readonly interface: nsIBrowserType;
    };
    "{}": {
        readonly name: 'nsIBrowserChild';
        readonly interface: nsIBrowserChildType;
    };
    "{5bb3d56b-e733-4a2c-8a53-058123df65e2}": {
        readonly name: 'nsIBrowserController';
        readonly interface: nsIBrowserControllerType;
    };
    "{e774db14-79ac-4156-a7a3-aa3fd0a22c10}": {
        readonly name: 'nsIOpenURIInFrameParams';
        readonly interface: nsIOpenURIInFrameParamsType;
    };
    "{}": {
        readonly name: 'nsIBrowserDOMWindow';
        readonly interface: nsIBrowserDOMWindowType;
    };
    "{57758c10-6036-11e5-a837-0800200c9a66}": {
        readonly name: 'nsIBrowserElementAPI';
        readonly interface: nsIBrowserElementAPIType;
    };
    "{8D3F5A9D-118D-4548-A137-CF7718679069}": {
        readonly name: 'nsIBrowserHandler';
        readonly interface: nsIBrowserHandlerType;
    };
    "{2703b5ed-a41f-42be-8764-b795eb67ed25}": {
        readonly name: 'nsIBrowserUsage';
        readonly interface: nsIBrowserUsageType;
    };
    "{f6190951-69d0-4ce5-b503-d2535d9de98c}": {
        readonly name: 'nsIVisibleTab';
        readonly interface: nsIVisibleTabType;
    };
    "{846ff245-ccbf-4c7a-807e-060f02927651}": {
        readonly name: 'nsIBrowserWindowTracker';
        readonly interface: nsIBrowserWindowTrackerType;
    };
    "{616f5b48-da09-11d3-8cda-0060b0fc14a3}": {
        readonly name: 'nsIBufferedInputStream';
        readonly interface: nsIBufferedInputStreamType;
    };
    "{6476378a-da09-11d3-8cda-0060b0fc14a3}": {
        readonly name: 'nsIBufferedOutputStream';
        readonly interface: nsIBufferedOutputStreamType;
    };
    "{C1B1F426-7E83-4759-9F88-0E1B17F49366}": {
        readonly name: 'nsIByteRangeRequest';
        readonly interface: nsIByteRangeRequestType;
    };
    "{}": {
        readonly name: 'nsICacheEntry';
        readonly interface: nsICacheEntryType;
    };
    "{fea3e276-6ba5-4ceb-a581-807d1f43f6d0}": {
        readonly name: 'nsICacheEntryMetaDataVisitor';
        readonly interface: nsICacheEntryMetaDataVisitorType;
    };
    "{}": {
        readonly name: 'nsICacheEntryDoomCallback';
        readonly interface: nsICacheEntryDoomCallbackType;
    };
    "{}": {
        readonly name: 'nsICacheEntryOpenCallback';
        readonly interface: nsICacheEntryOpenCallbackType;
    };
    "{1fb8ccf2-5fa5-45ec-bc57-8c8022a5d0d3}": {
        readonly name: 'nsIInputStreamReceiver';
        readonly interface: nsIInputStreamReceiverType;
    };
    "{}": {
        readonly name: 'nsICacheInfoChannel';
        readonly interface: nsICacheInfoChannelType;
    };
    "{8abb21e3-c6a0-4b4d-9333-cc0d72f2c23b}": {
        readonly name: 'nsICachePurgeLock';
        readonly interface: nsICachePurgeLockType;
    };
    "{}": {
        readonly name: 'nsICacheStorage';
        readonly interface: nsICacheStorageType;
    };
    "{ae29c44b-fbc3-4552-afaf-0a157ce771e7}": {
        readonly name: 'nsICacheStorageService';
        readonly interface: nsICacheStorageServiceType;
    };
    "{7728ab5b-4c01-4483-a606-32bf5b8136cb}": {
        readonly name: 'nsICacheStorageConsumptionObserver';
        readonly interface: nsICacheStorageConsumptionObserverType;
    };
    "{6cc7c253-93b6-482b-8e9d-1e04d8e9d655}": {
        readonly name: 'nsICacheStorageVisitor';
        readonly interface: nsICacheStorageVisitorType;
    };
    "{4e8ba935-92e1-4a74-944b-b1a2f02a7480}": {
        readonly name: 'nsICacheTesting';
        readonly interface: nsICacheTestingType;
    };
    "{dd1d6122-5ecf-4fe4-8f0f-995e7ab3121a}": {
        readonly name: 'nsICachingChannel';
        readonly interface: nsICachingChannelType;
    };
    "{}": {
        readonly name: 'nsICancelable';
        readonly interface: nsICancelableType;
    };
    "{593fdeec-6284-4de8-b416-8e63cbdc695e}": {
        readonly name: 'nsICaptivePortalCallback';
        readonly interface: nsICaptivePortalCallbackType;
    };
    "{2f827c5a-f551-477f-af09-71adbfbd854a}": {
        readonly name: 'nsICaptivePortalDetector';
        readonly interface: nsICaptivePortalDetectorType;
    };
    "{b5fd5629-d04c-4138-9529-9311f291ecd4}": {
        readonly name: 'nsICaptivePortalServiceCallback';
        readonly interface: nsICaptivePortalServiceCallbackType;
    };
    "{bdbe0555-fc3d-4f7b-9205-c309ceb2d641}": {
        readonly name: 'nsICaptivePortalService';
        readonly interface: nsICaptivePortalServiceType;
    };
    "{c8d0b0b3-17f8-458b-9264-7b67b288fe79}": {
        readonly name: 'nsICascadeFilter';
        readonly interface: nsICascadeFilterType;
    };
    "{de021d54-57a3-4025-ae63-4c8eedbe74c0}": {
        readonly name: 'nsICategoryEntry';
        readonly interface: nsICategoryEntryType;
    };
    "{3275b2cd-af6d-429a-80d7-f0c5120342ac}": {
        readonly name: 'nsICategoryManager';
        readonly interface: nsICategoryManagerType;
    };
    "{ed735e24-fa55-4163-906d-17fb78851fe1}": {
        readonly name: 'nsICertOverride';
        readonly interface: nsICertOverrideType;
    };
    "{be019e47-22fc-4355-9f16-9ab047d6742d}": {
        readonly name: 'nsICertOverrideService';
        readonly interface: nsICertOverrideServiceType;
    };
    "{3f8fe26a-a436-4ad4-9c1c-a53c60973c31}": {
        readonly name: 'nsICertStorageCallback';
        readonly interface: nsICertStorageCallbackType;
    };
    "{96db6fd7-6b64-4a5a-955d-310bd9ca4234}": {
        readonly name: 'nsIRevocationState';
        readonly interface: nsIRevocationStateType;
    };
    "{23ce3546-f1b9-46f6-8de3-77704da5702f}": {
        readonly name: 'nsIIssuerAndSerialRevocationState';
        readonly interface: nsIIssuerAndSerialRevocationStateType;
    };
    "{e78b51b4-6fa4-41e2-92ce-e9404f541e96}": {
        readonly name: 'nsISubjectAndPubKeyRevocationState';
        readonly interface: nsISubjectAndPubKeyRevocationStateType;
    };
    "{416453f7-29bd-4820-a039-9c2e055d3715}": {
        readonly name: 'nsICRLiteCoverage';
        readonly interface: nsICRLiteCoverageType;
    };
    "{9676cfc4-6e84-11ec-a30d-d3cd0af86e01}": {
        readonly name: 'nsICRLiteTimestamp';
        readonly interface: nsICRLiteTimestampType;
    };
    "{27b66f5e-0faf-403b-95b4-bc11691ac50d}": {
        readonly name: 'nsICertInfo';
        readonly interface: nsICertInfoType;
    };
    "{327100a7-3401-45ef-b160-bf880f1016fd}": {
        readonly name: 'nsICertStorage';
        readonly interface: nsICertStorageType;
    };
    "{d0180863-606e-49e6-8324-cf45ed4dd891}": {
        readonly name: 'nsICertTreeItem';
        readonly interface: nsICertTreeItemType;
    };
    "{55d5ad6b-5572-47fe-941c-f01fe723659e}": {
        readonly name: 'nsICertTree';
        readonly interface: nsICertTreeType;
    };
    "{da871dab-f69e-4173-ab26-99fcd47b0e85}": {
        readonly name: 'nsICertificateDialogs';
        readonly interface: nsICertificateDialogsType;
    };
    "{}": {
        readonly name: 'nsIChannel';
        readonly interface: nsIChannelType;
    };
    "{1ebbff64-d742-4f4a-aad5-4df2d1eb937a}": {
        readonly name: 'nsIIdentChannel';
        readonly interface: nsIIdentChannelType;
    };
    "{9b0353a7-ab46-4914-9178-2215ee221e4e}": {
        readonly name: 'nsIUrlClassifierBlockedChannel';
        readonly interface: nsIUrlClassifierBlockedChannelType;
    };
    "{9411409c-5dac-40b9-ba36-2738a7237a4c}": {
        readonly name: 'nsIChannelClassifierService';
        readonly interface: nsIChannelClassifierServiceType;
    };
    "{0197720d-37ed-4e75-8956-d0d296e4d8a6}": {
        readonly name: 'nsIChannelEventSink';
        readonly interface: nsIChannelEventSinkType;
    };
    "{c45b92ae-4f07-41dd-b0ef-aa044eeabb1e}": {
        readonly name: 'nsIChildChannel';
        readonly interface: nsIChildChannelType;
    };
    "{249fb5ad-ae29-4e2c-a728-ba5cf464d188}": {
        readonly name: 'nsIChromeRegistry';
        readonly interface: nsIChromeRegistryType;
    };
    "{93251ddf-5e85-4172-ac2a-31780562974f}": {
        readonly name: 'nsIXULChromeRegistry';
        readonly interface: nsIXULChromeRegistryType;
    };
    "{}": {
        readonly name: 'nsIClassInfo';
        readonly interface: nsIClassInfoType;
    };
    "{1ccb58ec-5e07-4cf9-a30d-ac5490d23b41}": {
        readonly name: 'nsIClassOfService';
        readonly interface: nsIClassOfServiceType;
    };
    "{70cf6091-a1de-4aa8-8224-058f8964be31}": {
        readonly name: 'nsIClassifiedChannel';
        readonly interface: nsIClassifiedChannelType;
    };
    "{6ef3ef16-a502-4576-9fb4-919f1c40bf61}": {
        readonly name: 'nsIClearDataService';
        readonly interface: nsIClearDataServiceType;
    };
    "{e225517b-24c5-498a-b9fb-9993e341a398}": {
        readonly name: 'nsIClearDataCallback';
        readonly interface: nsIClearDataCallbackType;
    };
    "{7e104b32-b6db-43f3-b887-573c01acef39}": {
        readonly name: 'nsIClickRule';
        readonly interface: nsIClickRuleType;
    };
    "{6b00d96d-fb8a-4c9f-9632-c9e1235befce}": {
        readonly name: 'nsIClientAuthDialogCallback';
        readonly interface: nsIClientAuthDialogCallbackType;
    };
    "{fa4c7520-1433-11d5-ba24-00108303b117}": {
        readonly name: 'nsIClientAuthDialogService';
        readonly interface: nsIClientAuthDialogServiceType;
    };
    "{fa4c7520-1433-11d5-ba24-00108303b117}": {
        readonly name: 'nsIClientAuthDialogs';
        readonly interface: nsIClientAuthDialogsType;
    };
    "{e92825af-7e81-4b5c-b412-8e1dd36d14fe}": {
        readonly name: 'nsIClientAuthRememberRecord';
        readonly interface: nsIClientAuthRememberRecordType;
    };
    "{1dbc6eb6-0972-4bdb-9dc4-acd0abf72369}": {
        readonly name: 'nsIClientAuthRememberService';
        readonly interface: nsIClientAuthRememberServiceType;
    };
    "{801e2318-c8fa-11ed-afa1-0242ac120002}": {
        readonly name: 'nsIAsyncSetClipboardData';
        readonly interface: nsIAsyncSetClipboardDataType;
    };
    "{78f7c18e-c8fa-11ed-afa1-0242ac120002}": {
        readonly name: 'nsIAsyncSetClipboardDataCallback';
        readonly interface: nsIAsyncSetClipboardDataCallbackType;
    };
    "{ceaa0047-647f-4b8e-ad1c-aff9fa62aa51}": {
        readonly name: 'nsIClipboard';
        readonly interface: nsIClipboardType;
    };
    "{438307fd-0c68-4d79-922a-f6cc9550cd02}": {
        readonly name: 'nsIClipboardHelper';
        readonly interface: nsIClipboardHelperType;
    };
    "{5A31C7A1-E122-11d2-9A57-000064657374}": {
        readonly name: 'nsIClipboardOwner';
        readonly interface: nsIClipboardOwnerType;
    };
    "{8149be1f-44d3-4f14-8b65-a57a5fbbeb97}": {
        readonly name: 'nsICloneableInputStream';
        readonly interface: nsICloneableInputStreamType;
    };
    "{ece853c3-aded-4cef-8f51-0d1493d60bd5}": {
        readonly name: 'nsICloneableInputStreamWithRange';
        readonly interface: nsICloneableInputStreamWithRangeType;
    };
    "{57d92056-37b4-4d0a-a52f-deb8f6dac8bc}": {
        readonly name: 'nsICodeCoverage';
        readonly interface: nsICodeCoverageType;
    };
    "{d2ce78d1-40b5-49d1-b66d-5801fcb9a385}": {
        readonly name: 'nsIColorPickerShownCallback';
        readonly interface: nsIColorPickerShownCallbackType;
    };
    "{de229d37-a8a6-46f1-969a-0c1de33d0ad7}": {
        readonly name: 'nsIColorPicker';
        readonly interface: nsIColorPickerType;
    };
    "{}": {
        readonly name: 'nsICommandLine';
        readonly interface: nsICommandLineType;
    };
    "{d4b123df-51ee-48b1-a663-002180e60d3b}": {
        readonly name: 'nsICommandLineHandler';
        readonly interface: nsICommandLineHandlerType;
    };
    "{c9f2996c-b25a-4d3d-821f-4cd0c4bc8afb}": {
        readonly name: 'nsICommandLineRunner';
        readonly interface: nsICommandLineRunnerType;
    };
    "{5ecaa593-7660-4a3a-957a-92d5770671c7}": {
        readonly name: 'nsICommandLineValidator';
        readonly interface: nsICommandLineValidatorType;
    };
    "{bb5a1730-d83b-4fa2-831b-35b9d5842e84}": {
        readonly name: 'nsICommandManager';
        readonly interface: nsICommandManagerType;
    };
    "{}": {
        readonly name: 'nsICommandParams';
        readonly interface: nsICommandParamsType;
    };
    "{}": {
        readonly name: 'nsIComponentManager';
        readonly interface: nsIComponentManagerType;
    };
    "{2417cbfe-65ad-48a6-b4b6-eb84db174392}": {
        readonly name: 'nsIComponentRegistrar';
        readonly interface: nsIComponentRegistrarType;
    };
    "{58172ad0-46a9-4893-8fde-cd909c10792a}": {
        readonly name: 'nsICompressConvStats';
        readonly interface: nsICompressConvStatsType;
    };
    "{9e32a7b6-c4d1-4d9a-87b9-1ef6b75c27a9}": {
        readonly name: 'nsIConsoleAPIStorage';
        readonly interface: nsIConsoleAPIStorageType;
    };
    "{}": {
        readonly name: 'nsIConsoleListener';
        readonly interface: nsIConsoleListenerType;
    };
    "{}": {
        readonly name: 'nsIConsoleMessage';
        readonly interface: nsIConsoleMessageType;
    };
    "{0eb81d20-c37e-42d4-82a8-ca9ae96bdf52}": {
        readonly name: 'nsIConsoleService';
        readonly interface: nsIConsoleServiceType;
    };
    "{00ed5d73-9de5-42cf-868c-e739a94f6b37}": {
        readonly name: 'nsIContentBlockingAllowList';
        readonly interface: nsIContentBlockingAllowListType;
    };
    "{456ca3b2-02be-4f97-89a2-08c08d3ad88f}": {
        readonly name: 'nsIContentDispatchChooser';
        readonly interface: nsIContentDispatchChooserType;
    };
    "{49439df2-b3d2-441c-bf62-866bdaf56fd2}": {
        readonly name: 'nsIContentHandler';
        readonly interface: nsIContentHandlerType;
    };
    "{ef4db3b8-ca9c-4b1d-8f81-fd88ec32af13}": {
        readonly name: 'nsIContentPermissionType';
        readonly interface: nsIContentPermissionTypeType;
    };
    "{}": {
        readonly name: 'nsIContentPermissionRequest';
        readonly interface: nsIContentPermissionRequestType;
    };
    "{F72DE90D-E954-4E69-9A61-917303029301}": {
        readonly name: 'nsIContentPermissionPrompt';
        readonly interface: nsIContentPermissionPromptType;
    };
    "{caad4f1f-d047-46ac-ae9d-dc598e4fb91b}": {
        readonly name: 'nsIContentPolicy';
        readonly interface: nsIContentPolicyType;
    };
    "{43635c53-b445-4c4e-8cc5-562697299b55}": {
        readonly name: 'nsIContentPrefObserver';
        readonly interface: nsIContentPrefObserverType;
    };
    "{bed98666-d995-470f-bebd-62476d318576}": {
        readonly name: 'nsIContentPrefService2';
        readonly interface: nsIContentPrefService2Type;
    };
    "{1a12cf41-79e8-4d0f-9899-2f7b27c5d9a1}": {
        readonly name: 'nsIContentPrefCallback2';
        readonly interface: nsIContentPrefCallback2Type;
    };
    "{9f24948d-24b5-4b1b-b554-7dbd58c1d792}": {
        readonly name: 'nsIContentPref';
        readonly interface: nsIContentPrefType;
    };
    "{456f58be-29dd-4973-885b-95aece1c9a8a}": {
        readonly name: 'nsIContentProcessInfo';
        readonly interface: nsIContentProcessInfoType;
    };
    "{83ffb063-5f65-4c45-ae07-3f553e0809bb}": {
        readonly name: 'nsIContentProcessProvider';
        readonly interface: nsIContentProcessProviderType;
    };
    "{3a9a1818-2ae8-4ec5-a340-8b29d31fca3b}": {
        readonly name: 'nsIContentSecurityManager';
        readonly interface: nsIContentSecurityManagerType;
    };
    "{}": {
        readonly name: 'nsIContentSecurityPolicy';
        readonly interface: nsIContentSecurityPolicyType;
    };
    "{}": {
        readonly name: 'nsICSPEventListener';
        readonly interface: nsICSPEventListenerType;
    };
    "{45a5fe2f-c350-4b86-962d-02d5aaaa955a}": {
        readonly name: 'nsIContentSignatureVerifier';
        readonly interface: nsIContentSignatureVerifierType;
    };
    "{a5772d1b-fc63-495e-a169-96e8d3311af0}": {
        readonly name: 'nsIContentSniffer';
        readonly interface: nsIContentSnifferType;
    };
    "{}": {
        readonly name: 'nsIContentViewer';
        readonly interface: nsIContentViewerType;
    };
    "{35BE2D7E-F29B-48EC-BF7E-80A30A724DE3}": {
        readonly name: 'nsIContentViewerEdit';
        readonly interface: nsIContentViewerEditType;
    };
    "{}": {
        readonly name: 'nsIController';
        readonly interface: nsIControllerType;
    };
    "{EEC0B435-7F53-44FE-B00A-CF3EED65C01A}": {
        readonly name: 'nsICommandController';
        readonly interface: nsICommandControllerType;
    };
    "{0eae9a46-1dd2-11b2-aca0-9176f05fe9db}": {
        readonly name: 'nsIControllerCommand';
        readonly interface: nsIControllerCommandType;
    };
    "{c847f90e-b8f3-49db-a4df-8867831f2800}": {
        readonly name: 'nsIControllerCommandTable';
        readonly interface: nsIControllerCommandTableType;
    };
    "{47B82B60-A36F-4167-8072-6F421151ED50}": {
        readonly name: 'nsIControllerContext';
        readonly interface: nsIControllerContextType;
    };
    "{}": {
        readonly name: 'nsIControllers';
        readonly interface: nsIControllersType;
    };
    "{FC66FFB6-5404-4908-A4A3-27F92FA0579D}": {
        readonly name: 'nsIConverterInputStream';
        readonly interface: nsIConverterInputStreamType;
    };
    "{4b71113a-cb0d-479f-8ed5-01daeba2e8d4}": {
        readonly name: 'nsIConverterOutputStream';
        readonly interface: nsIConverterOutputStreamType;
    };
    "{}": {
        readonly name: 'nsICookie';
        readonly interface: nsICookieType;
    };
    "{1d8d9470-97d3-4885-a108-44a5c4fb36e2}": {
        readonly name: 'nsICookieBannerListService';
        readonly interface: nsICookieBannerListServiceType;
    };
    "{eb1904db-e0d1-4760-a721-db76b1ca3e94}": {
        readonly name: 'nsICookieBannerRule';
        readonly interface: nsICookieBannerRuleType;
    };
    "{eac9cdc4-ecee-49f2-91da-7627e15c1f3c}": {
        readonly name: 'nsICookieBannerService';
        readonly interface: nsICookieBannerServiceType;
    };
    "{}": {
        readonly name: 'nsICookieJarSettings';
        readonly interface: nsICookieJarSettingsType;
    };
    "{AAAB6710-0F2C-11d5-A53B-0010A401EB10}": {
        readonly name: 'nsICookieManager';
        readonly interface: nsICookieManagerType;
    };
    "{5b3490f2-75f0-4e36-9f3d-47c857ecdfbb}": {
        readonly name: 'nsICookieNotification';
        readonly interface: nsICookieNotificationType;
    };
    "{11ddd4ed-8f5b-40b3-b2a0-27c20ea1c88d}": {
        readonly name: 'nsICookiePermission';
        readonly interface: nsICookiePermissionType;
    };
    "{bf049b1e-8a05-481f-a120-332ea1bd65ef}": {
        readonly name: 'nsICookieRule';
        readonly interface: nsICookieRuleType;
    };
    "{0fc41ffb-f1b7-42d9-9a42-8dc420c158c1}": {
        readonly name: 'nsICookieTransactionCallback';
        readonly interface: nsICookieTransactionCallbackType;
    };
    "{1e94e283-2811-4f43-b947-d22b1549d824}": {
        readonly name: 'nsICookieService';
        readonly interface: nsICookieServiceType;
    };
    "{4b74c39a-cf69-4a8a-8e63-169d81ad1ecf}": {
        readonly name: 'nsICrashReporter';
        readonly interface: nsICrashReporterType;
    };
    "{70bd93ff-88fa-4600-8af8-57c8d002dbac}": {
        readonly name: 'nsICrashService';
        readonly interface: nsICrashServiceType;
    };
    "{1e5b7c43-4688-45ce-92e1-77ed931e3bbe}": {
        readonly name: 'nsICryptoHash';
        readonly interface: nsICryptoHashType;
    };
    "{7f093367-1492-4b89-87af-c01dbc831246}": {
        readonly name: 'nsICycleCollectorHandler';
        readonly interface: nsICycleCollectorHandlerType;
    };
    "{}": {
        readonly name: 'nsICycleCollectorLogSink';
        readonly interface: nsICycleCollectorLogSinkType;
    };
    "{}": {
        readonly name: 'nsICycleCollectorListener';
        readonly interface: nsICycleCollectorListenerType;
    };
    "{58a4c579-d2dd-46b7-9c3b-6881a1c36c6a}": {
        readonly name: 'nsIDAPTelemetry';
        readonly interface: nsIDAPTelemetryType;
    };
    "{aee75dc0-be1a-46b9-9e0c-31a6899c175c}": {
        readonly name: 'nsIDHCPClient';
        readonly interface: nsIDHCPClientType;
    };
    "{}": {
        readonly name: 'nsIDNSAdditionalInfo';
        readonly interface: nsIDNSAdditionalInfoType;
    };
    "{}": {
        readonly name: 'nsIDNSByTypeRecord';
        readonly interface: nsIDNSByTypeRecordType;
    };
    "{2a71750d-cb21-45f1-9e1c-666d18dd7645}": {
        readonly name: 'nsIDNSTXTRecord';
        readonly interface: nsIDNSTXTRecordType;
    };
    "{2979ceaa-9c7e-49de-84b8-ea81c16aebf1}": {
        readonly name: 'nsISVCParam';
        readonly interface: nsISVCParamType;
    };
    "{0dc58309-4d67-4fc4-a4e3-38dbde9d9f4c}": {
        readonly name: 'nsISVCParamAlpn';
        readonly interface: nsISVCParamAlpnType;
    };
    "{b3ed89c3-2ae6-4c92-8176-b76bc2437fcb}": {
        readonly name: 'nsISVCParamNoDefaultAlpn';
        readonly interface: nsISVCParamNoDefaultAlpnType;
    };
    "{a37c7bcb-bfcd-4ab4-b826-cc583859ba73}": {
        readonly name: 'nsISVCParamPort';
        readonly interface: nsISVCParamPortType;
    };
    "{d3163d2f-0bbe-47d4-bcac-db3fb1433b39}": {
        readonly name: 'nsISVCParamIPv4Hint';
        readonly interface: nsISVCParamIPv4HintType;
    };
    "{1f31e41d-b6d8-4796-b12a-82ef8d2b0e43}": {
        readonly name: 'nsISVCParamEchConfig';
        readonly interface: nsISVCParamEchConfigType;
    };
    "{5100bce4-9d3b-42e1-a3c9-0f386bbc9dad}": {
        readonly name: 'nsISVCParamIPv6Hint';
        readonly interface: nsISVCParamIPv6HintType;
    };
    "{bdcef040-452e-11eb-b378-0242ac130002}": {
        readonly name: 'nsISVCParamODoHConfig';
        readonly interface: nsISVCParamODoHConfigType;
    };
    "{a4da5645-2160-4439-bd11-540a2d26c989}": {
        readonly name: 'nsISVCBRecord';
        readonly interface: nsISVCBRecordType;
    };
    "{5b649e95-e0d3-422b-99a6-79d70a041387}": {
        readonly name: 'nsIDNSHTTPSSVCRecord';
        readonly interface: nsIDNSHTTPSSVCRecordType;
    };
    "{}": {
        readonly name: 'nsIDNSListener';
        readonly interface: nsIDNSListenerType;
    };
    "{}": {
        readonly name: 'nsIDNSRecord';
        readonly interface: nsIDNSRecordType;
    };
    "{cb260e20-943f-4309-953b-78c90d3a7638}": {
        readonly name: 'nsIDNSAddrRecord';
        readonly interface: nsIDNSAddrRecordType;
    };
    "{de5642c6-61fc-4fcf-9a47-03226b0d4e21}": {
        readonly name: 'nsIDNSService';
        readonly interface: nsIDNSServiceType;
    };
    "{78bdcb41-1efa-409f-aaba-70842213f80f}": {
        readonly name: 'nsIDOMChromeWindow';
        readonly interface: nsIDOMChromeWindowType;
    };
    "{df31c120-ded6-11d1-bd85-00805f8ae3f4}": {
        readonly name: 'nsIDOMEventListener';
        readonly interface: nsIDOMEventListenerType;
    };
    "{}": {
        readonly name: 'nsIDOMGeoPosition';
        readonly interface: nsIDOMGeoPositionType;
    };
    "{527E8B53-6F29-4B6A-8D04-5C1666A4C4C1}": {
        readonly name: 'nsIDOMGeoPositionCallback';
        readonly interface: nsIDOMGeoPositionCallbackType;
    };
    "{B31702D0-6DAC-4FA0-B93B-F043E71C8F9A}": {
        readonly name: 'nsIDOMGeoPositionCoords';
        readonly interface: nsIDOMGeoPositionCoordsType;
    };
    "{7D9B09D9-4843-43EB-A7A7-67F7DDA6B3C4}": {
        readonly name: 'nsIDOMGeoPositionErrorCallback';
        readonly interface: nsIDOMGeoPositionErrorCallbackType;
    };
    "{5842e275-797f-4afb-b7e0-e29f0cb312ae}": {
        readonly name: 'nsIDOMGlobalPropertyInitializer';
        readonly interface: nsIDOMGlobalPropertyInitializerType;
    };
    "{4CAFE116-581B-4194-B0DE-7F02378FC51D}": {
        readonly name: 'nsIDOMMozBrowserFrame';
        readonly interface: nsIDOMMozBrowserFrameType;
    };
    "{b0c6e5f3-02f1-4f11-a0af-336fc231f3bf}": {
        readonly name: 'nsIDOMProcessChild';
        readonly interface: nsIDOMProcessChildType;
    };
    "{81fc08b9-c901-471f-ab0d-876362eba770}": {
        readonly name: 'nsIDOMProcessParent';
        readonly interface: nsIDOMProcessParentType;
    };
    "{9a57e5de-ce93-45fa-8145-755722834f7c}": {
        readonly name: 'nsIDOMRequestService';
        readonly interface: nsIDOMRequestServiceType;
    };
    "{a20c742e-3ed1-44fb-b897-4080a75b1662}": {
        readonly name: 'nsIDOMStorageManager';
        readonly interface: nsIDOMStorageManagerType;
    };
    "{b3bfbbd0-e738-4cbf-b0f0-b65f25265e82}": {
        readonly name: 'nsIDOMSessionStorageManager';
        readonly interface: nsIDOMSessionStorageManagerType;
    };
    "{}": {
        readonly name: 'nsIDOMMozWakeLockListener';
        readonly interface: nsIDOMMozWakeLockListenerType;
    };
    "{}": {
        readonly name: 'nsIDOMWindow';
        readonly interface: nsIDOMWindowType;
    };
    "{4d6732ca-9da7-4176-b8a1-8dde15cd0bf9}": {
        readonly name: 'nsIDOMWindowUtils';
        readonly interface: nsIDOMWindowUtilsType;
    };
    "{c694e359-7227-4392-a138-33c0cc1f15a6}": {
        readonly name: 'nsITranslationNodeList';
        readonly interface: nsITranslationNodeListType;
    };
    "{52e5a996-d0a9-4efc-a6fa-24489c532b19}": {
        readonly name: 'nsIJSRAIIHelper';
        readonly interface: nsIJSRAIIHelperType;
    };
    "{6ed53cfb-9e59-424c-af8d-e74582381951}": {
        readonly name: 'nsIDOMXULButtonElement';
        readonly interface: nsIDOMXULButtonElementType;
    };
    "{a9fa9fd3-8d62-4f94-9ed8-3ea9c3cf0773}": {
        readonly name: 'nsIDOMXULCommandDispatcher';
        readonly interface: nsIDOMXULCommandDispatcherType;
    };
    "{800a68c7-b854-4597-a436-3055ce5c5c96}": {
        readonly name: 'nsIDOMXULContainerItemElement';
        readonly interface: nsIDOMXULContainerItemElementType;
    };
    "{b2bc96b8-31fc-42f4-937a-bd27291af40b}": {
        readonly name: 'nsIDOMXULContainerElement';
        readonly interface: nsIDOMXULContainerElementType;
    };
    "{bdc1d047-6d22-4813-bc50-638ccb349c7d}": {
        readonly name: 'nsIDOMXULControlElement';
        readonly interface: nsIDOMXULControlElementType;
    };
    "{36c16a17-c0e9-4b35-951b-81a147314ef1}": {
        readonly name: 'nsIDOMXULMenuListElement';
        readonly interface: nsIDOMXULMenuListElementType;
    };
    "{40654a10-8204-4f06-9f21-7baa31c7b1dd}": {
        readonly name: 'nsIDOMXULMultiSelectControlElement';
        readonly interface: nsIDOMXULMultiSelectControlElementType;
    };
    "{2cc1d24b-ec9f-4e18-aa34-a298a9007f23}": {
        readonly name: 'nsIDOMXULRadioGroupElement';
        readonly interface: nsIDOMXULRadioGroupElementType;
    };
    "{9fbac05a-fb27-470d-8e5f-028b2dc54ad0}": {
        readonly name: 'nsIDOMXULRelatedElement';
        readonly interface: nsIDOMXULRelatedElementType;
    };
    "{}": {
        readonly name: 'nsIDOMXULSelectControlElement';
        readonly interface: nsIDOMXULSelectControlElementType;
    };
    "{5c6be58f-17df-4750-88a5-4a59ac28adc9}": {
        readonly name: 'nsIDOMXULSelectControlItemElement';
        readonly interface: nsIDOMXULSelectControlItemElementType;
    };
    "{19d7f24f-a95a-4fd9-87e2-d96e9e4b1f6d}": {
        readonly name: 'nsINetDashboardCallback';
        readonly interface: nsINetDashboardCallbackType;
    };
    "{c79eb3c6-091a-45a6-8544-5a8d1ab79537}": {
        readonly name: 'nsIDashboard';
        readonly interface: nsIDashboardType;
    };
    "{24fdfcbe-54cb-4997-8392-3c476126ea3b}": {
        readonly name: 'nsIDashboardEventNotifier';
        readonly interface: nsIDashboardEventNotifierType;
    };
    "{71b49926-fd4e-43e2-ab8d-d9b049413c0b}": {
        readonly name: 'nsIDataStorageManager';
        readonly interface: nsIDataStorageManagerType;
    };
    "{fcbb5ec4-7134-4069-91c6-9378eff51e03}": {
        readonly name: 'nsIDataStorage';
        readonly interface: nsIDataStorageType;
    };
    "{4501f984-0e3a-4199-a67e-7753649e93f1}": {
        readonly name: 'nsIDataStorageItem';
        readonly interface: nsIDataStorageItemType;
    };
    "{9641dc15-10fb-42e3-a285-18be90a5c10b}": {
        readonly name: 'nsIDebug2';
        readonly interface: nsIDebug2Type;
    };
    "{0462247e-fe8c-4aa5-b675-3752547e485f}": {
        readonly name: 'nsIDeviceSensorData';
        readonly interface: nsIDeviceSensorDataType;
    };
    "{e46e47c7-55ff-44c4-abce-21b14ba07f86}": {
        readonly name: 'nsIDeviceSensors';
        readonly interface: nsIDeviceSensorsType;
    };
    "{}": {
        readonly name: 'nsIDialogParamBlock';
        readonly interface: nsIDialogParamBlockType;
    };
    "{}": {
        readonly name: 'nsIDirIndex';
        readonly interface: nsIDirIndexType;
    };
    "{fae4e9a8-1dd1-11b2-b53c-8f3aa1bbf8f5}": {
        readonly name: 'nsIDirIndexListener';
        readonly interface: nsIDirIndexListenerType;
    };
    "{38e3066c-1dd2-11b2-9b59-8be515c1ee3f}": {
        readonly name: 'nsIDirIndexParser';
        readonly interface: nsIDirIndexParserType;
    };
    "{e05bf0fe-94b7-4e28-8462-a8368da9c136}": {
        readonly name: 'nsIDirectTaskDispatcher';
        readonly interface: nsIDirectTaskDispatcherType;
    };
    "{31f7f4ae-6916-4f2d-a81e-926a4e3022ee}": {
        readonly name: 'nsIDirectoryEnumerator';
        readonly interface: nsIDirectoryEnumeratorType;
    };
    "{bbf8cab0-d43a-11d3-8cc2-00609792278c}": {
        readonly name: 'nsIDirectoryServiceProvider';
        readonly interface: nsIDirectoryServiceProviderType;
    };
    "{2f977d4b-5485-11d4-87e2-0010a4e75ef2}": {
        readonly name: 'nsIDirectoryServiceProvider2';
        readonly interface: nsIDirectoryServiceProvider2Type;
    };
    "{57a66a60-d43a-11d3-8cc2-00609792278c}": {
        readonly name: 'nsIDirectoryService';
        readonly interface: nsIDirectoryServiceType;
    };
    "{615bc23d-6346-4b15-9c10-add002f140b6}": {
        readonly name: 'nsIDisplayInfo';
        readonly interface: nsIDisplayInfoType;
    };
    "{}": {
        readonly name: 'nsIDocShell';
        readonly interface: nsIDocShellType;
    };
    "{}": {
        readonly name: 'nsIDocShellTreeItem';
        readonly interface: nsIDocShellTreeItemType;
    };
    "{0e3dc4b1-4cea-4a37-af71-79f0afd07574}": {
        readonly name: 'nsIDocShellTreeOwner';
        readonly interface: nsIDocShellTreeOwnerType;
    };
    "{3d9371d8-a2ad-403e-8b0e-8885ad3562e3}": {
        readonly name: 'nsIDocumentEncoderNodeFixup';
        readonly interface: nsIDocumentEncoderNodeFixupType;
    };
    "{}": {
        readonly name: 'nsIDocumentEncoder';
        readonly interface: nsIDocumentEncoderType;
    };
    "{bbe961ee-59e9-42bb-be50-0331979bb79f}": {
        readonly name: 'nsIDocumentLoader';
        readonly interface: nsIDocumentLoaderType;
    };
    "{e795239e-9d3c-47c4-b063-9e600fb3b287}": {
        readonly name: 'nsIDocumentLoaderFactory';
        readonly interface: nsIDocumentLoaderFactoryType;
    };
    "{}": {
        readonly name: 'nsIDocumentStateListener';
        readonly interface: nsIDocumentStateListenerType;
    };
    "{}": {
        readonly name: 'nsIDomainPolicy';
        readonly interface: nsIDomainPolicyType;
    };
    "{665c981b-0a0f-4229-ac06-a826e02d4f69}": {
        readonly name: 'nsIDomainSet';
        readonly interface: nsIDomainSetType;
    };
    "{fafe41a9-a531-4d6d-89bc-588a6522fb4e}": {
        readonly name: 'nsIDownloader';
        readonly interface: nsIDownloaderType;
    };
    "{44b3153e-a54e-4077-a527-b0325e40924e}": {
        readonly name: 'nsIDownloadObserver';
        readonly interface: nsIDownloadObserverType;
    };
    "{ebd6b3a2-af16-43af-a698-3091a087dd62}": {
        readonly name: 'nsIDragService';
        readonly interface: nsIDragServiceType;
    };
    "{25bce737-73f0-43c7-bc20-c71044a73c5a}": {
        readonly name: 'nsIDragSession';
        readonly interface: nsIDragSessionType;
    };
    "{69E14F91-2E09-4CA6-A511-A715C99A2804}": {
        readonly name: 'nsIDroppedLinkItem';
        readonly interface: nsIDroppedLinkItemType;
    };
    "{21B5C25A-28A9-47BD-8431-FA9116305DED}": {
        readonly name: 'nsIDroppedLinkHandler';
        readonly interface: nsIDroppedLinkHandlerType;
    };
    "{1e18680e-052d-4509-a17e-678f5c495e02}": {
        readonly name: 'nsIE10SUtils';
        readonly interface: nsIE10SUtilsType;
    };
    "{}": {
        readonly name: 'nsIEarlyHintObserver';
        readonly interface: nsIEarlyHintObserverType;
    };
    "{9c7b7436-a17c-4c03-ba66-aeb5ae070126}": {
        readonly name: 'nsIEdgeMigrationUtils';
        readonly interface: nsIEdgeMigrationUtilsType;
    };
    "{}": {
        readonly name: 'nsIEditActionListener';
        readonly interface: nsIEditActionListenerType;
    };
    "{24f963d1-e6fc-43ea-a206-99ac5fcc5265}": {
        readonly name: 'nsIEditingSession';
        readonly interface: nsIEditingSessionType;
    };
    "{}": {
        readonly name: 'nsIEditor';
        readonly interface: nsIEditorType;
    };
    "{fdf23301-4a94-11d3-9ce4-9960496c41bc}": {
        readonly name: 'nsIEditorMailSupport';
        readonly interface: nsIEditorMailSupportType;
    };
    "{}": {
        readonly name: 'nsIEditorSpellCheck';
        readonly interface: nsIEditorSpellCheckType;
    };
    "{5f0a4bab-8538-4074-89d3-2f0e866a1c0b}": {
        readonly name: 'nsIEditorSpellCheckCallback';
        readonly interface: nsIEditorSpellCheckCallbackType;
    };
    "{68067eb5-ad8d-43cb-a043-1cc85ebe06e7}": {
        readonly name: 'nsIEffectiveTLDService';
        readonly interface: nsIEffectiveTLDServiceType;
    };
    "{0b976267-4aaa-4f36-a2d4-27b5ca8d73bb}": {
        readonly name: 'nsIEmbeddingSiteWindow';
        readonly interface: nsIEmbeddingSiteWindowType;
    };
    "{00000000-0000-0000-c000-000000000046}": {
        readonly name: 'nsISupports';
        readonly interface: nsISupportsType;
    };
    "{29c29ce6-8ce4-45e6-8d60-36c8fa3e255b}": {
        readonly name: 'nsIEncodedChannel';
        readonly interface: nsIEncodedChannelType;
    };
    "{6a568972-cc91-4bf5-963e-3768f3319b8a}": {
        readonly name: 'nsIEnterprisePolicies';
        readonly interface: nsIEnterprisePoliciesType;
    };
    "{101d5941-d820-4e85-a266-9a3469940807}": {
        readonly name: 'nsIEnvironment';
        readonly interface: nsIEnvironmentType;
    };
    "{07222b02-da12-4cf4-b2f7-761da007a8d8}": {
        readonly name: 'nsIEventListenerChange';
        readonly interface: nsIEventListenerChangeType;
    };
    "{aa7c95f6-d3b5-44b3-9597-1d9f19b9c5f2}": {
        readonly name: 'nsIListenerChangeListener';
        readonly interface: nsIListenerChangeListenerType;
    };
    "{11ba5fd7-8db2-4b1a-9f67-342cfa11afad}": {
        readonly name: 'nsIEventListenerInfo';
        readonly interface: nsIEventListenerInfoType;
    };
    "{77aab5f7-213d-4db4-9f22-e46dfb774f15}": {
        readonly name: 'nsIEventListenerService';
        readonly interface: nsIEventListenerServiceType;
    };
    "{d2cc6222-b7f2-490d-adc2-497d89878fa2}": {
        readonly name: 'nsIEventSourceEventListener';
        readonly interface: nsIEventSourceEventListenerType;
    };
    "{c0378840-8a74-4b0a-9225-c3a0ac1fac41}": {
        readonly name: 'nsIEventSourceEventService';
        readonly interface: nsIEventSourceEventServiceType;
    };
    "{}": {
        readonly name: 'nsIEventTarget';
        readonly interface: nsIEventTargetType;
    };
    "{}": {
        readonly name: 'nsIStackFrame';
        readonly interface: nsIStackFrameType;
    };
    "{4371b5bf-6845-487f-8d9d-3f1e4a9badd2}": {
        readonly name: 'nsIException';
        readonly interface: nsIExceptionType;
    };
    "{01f681af-0f22-4725-a914-0d396114daf0}": {
        readonly name: 'nsIExpatSink';
        readonly interface: nsIExpatSinkType;
    };
    "{1E4F3AE1-B737-431F-A95D-31FA8DA70199}": {
        readonly name: 'nsIExternalHelperAppService';
        readonly interface: nsIExternalHelperAppServiceType;
    };
    "{6613e2e7-feab-4e3a-bb1f-b03200d544ec}": {
        readonly name: 'nsPIExternalAppLauncher';
        readonly interface: nsPIExternalAppLauncherType;
    };
    "{}": {
        readonly name: 'nsIHelperAppLauncher';
        readonly interface: nsIHelperAppLauncherType;
    };
    "{0e61f3b2-34d7-4c79-bfdc-4860bc7341b7}": {
        readonly name: 'nsIExternalProtocolHandler';
        readonly interface: nsIExternalProtocolHandlerType;
    };
    "{70f93b7a-3ec6-4bcb-b093-92d9984c9f83}": {
        readonly name: 'nsIExternalProtocolService';
        readonly interface: nsIExternalProtocolServiceType;
    };
    "{98d0e975-9cad-4ce3-ae2f-f878b8be6307}": {
        readonly name: 'nsIFOG';
        readonly interface: nsIFOGType;
    };
    "{1bb40a56-9223-41e6-97d4-da97bdeb6a4d}": {
        readonly name: 'nsIFactory';
        readonly interface: nsIFactoryType;
    };
    "{e81e0b0c-b9f1-4c2e-8f3c-b809933cf73c}": {
        readonly name: 'nsIFaviconService';
        readonly interface: nsIFaviconServiceType;
    };
    "{c85e5c82-b70f-4621-9528-beb2aa47fb44}": {
        readonly name: 'nsIFaviconDataCallback';
        readonly interface: nsIFaviconDataCallbackType;
    };
    "{}": {
        readonly name: 'nsIFile';
        readonly interface: nsIFileType;
    };
    "{06169120-136d-45a5-b535-498f1f755ab7}": {
        readonly name: 'nsIFileChannel';
        readonly interface: nsIFileChannelType;
    };
    "{9285b984-02d3-46b4-9514-7da8c471a747}": {
        readonly name: 'nsIFilePicker';
        readonly interface: nsIFilePickerType;
    };
    "{0d79adad-b244-49A5-9997-2a8cad93fc44}": {
        readonly name: 'nsIFilePickerShownCallback';
        readonly interface: nsIFilePickerShownCallbackType;
    };
    "{1fb25bd5-4354-4dcd-8d97-621b7b3ed2e4}": {
        readonly name: 'nsIFileProtocolHandler';
        readonly interface: nsIFileProtocolHandlerType;
    };
    "{e3d56a20-c7ec-11d3-8cda-0060b0fc14a3}": {
        readonly name: 'nsIFileInputStream';
        readonly interface: nsIFileInputStreamType;
    };
    "{e734cac9-1295-4e6f-9684-3ac4e1f91063}": {
        readonly name: 'nsIFileOutputStream';
        readonly interface: nsIFileOutputStreamType;
    };
    "{82cf605a-8393-4550-83ab-43cd5578e006}": {
        readonly name: 'nsIFileRandomAccessStream';
        readonly interface: nsIFileRandomAccessStreamType;
    };
    "{07f679e4-9601-4bd1-b510-cd3852edb881}": {
        readonly name: 'nsIFileMetadata';
        readonly interface: nsIFileMetadataType;
    };
    "{de15b80b-29ba-4b7f-9220-a3d75b17ae8c}": {
        readonly name: 'nsIAsyncFileMetadata';
        readonly interface: nsIAsyncFileMetadataType;
    };
    "{d01c7ead-7ba3-4726-b399-618ec8ec7057}": {
        readonly name: 'nsIFileMetadataCallback';
        readonly interface: nsIFileMetadataCallbackType;
    };
    "{e91ac988-27c2-448b-b1a1-3822e1ef1987}": {
        readonly name: 'nsIFileURL';
        readonly interface: nsIFileURLType;
    };
    "{a588b6f2-d2b9-4024-84c7-be3368546b57}": {
        readonly name: 'nsIFileURLMutator';
        readonly interface: nsIFileURLMutatorType;
    };
    "{15686f9d-483e-4361-98cd-37f1e8f1e61d}": {
        readonly name: 'nsIFinalizationWitnessService';
        readonly interface: nsIFinalizationWitnessServiceType;
    };
    "{40aba110-2a56-4678-be90-e2c17a9ae7d7}": {
        readonly name: 'nsIFind';
        readonly interface: nsIFindType;
    };
    "{5060b801-340e-11d5-be5b-b3e063ec6a3c}": {
        readonly name: 'nsIFindService';
        readonly interface: nsIFindServiceType;
    };
    "{86e1f1e1-365d-493b-b52a-a649f3f311dc}": {
        readonly name: 'nsIFocusManager';
        readonly interface: nsIFocusManagerType;
    };
    "{924d98d9-3518-4cb4-8708-c74fe8e3ec3c}": {
        readonly name: 'nsIFontEnumerator';
        readonly interface: nsIFontEnumeratorType;
    };
    "{302dbf09-079b-4648-8a06-a0486c1749c0}": {
        readonly name: 'nsIFontLoadCompleteCallback';
        readonly interface: nsIFontLoadCompleteCallbackType;
    };
    "{2ac3e1ca-049f-44c3-a519-f0681f51e9b1}": {
        readonly name: 'nsIForcePendingChannel';
        readonly interface: nsIForcePendingChannelType;
    };
    "{bfd9b82b-0ab3-4b6b-9e54-aa961ff4b732}": {
        readonly name: 'nsIFormAutoComplete';
        readonly interface: nsIFormAutoCompleteType;
    };
    "{}": {
        readonly name: 'nsIFormAutoCompleteObserver';
        readonly interface: nsIFormAutoCompleteObserverType;
    };
    "{07f0a0dc-f6e9-4cdd-a55f-56d770523a4c}": {
        readonly name: 'nsIFormFillController';
        readonly interface: nsIFormFillControllerType;
    };
    "{fc826b53-0db8-42b4-aa6a-5dd2cfca52a4}": {
        readonly name: 'nsIFormPOSTActionChannel';
        readonly interface: nsIFormPOSTActionChannelType;
    };
    "{948A0023-E3A7-11d2-96CF-0060B0FB9956}": {
        readonly name: 'nsIFormatConverter';
        readonly interface: nsIFormatConverterType;
    };
    "{ca6bad0c-8a48-48ac-82c7-27bb8f510fbe}": {
        readonly name: 'nsIGIOMimeApp';
        readonly interface: nsIGIOMimeAppType;
    };
    "{eda22a30-84e1-4e16-9ca0-cd1553c2b34a}": {
        readonly name: 'nsIGIOService';
        readonly interface: nsIGIOServiceType;
    };
    "{2ce5c803-edcd-443d-98eb-ceba86d02d13}": {
        readonly name: 'nsIGNOMEShellService';
        readonly interface: nsIGNOMEShellServiceType;
    };
    "{16d5b0ed-e756-4f1b-a8ce-9132e869acd8}": {
        readonly name: 'nsIGSettingsCollection';
        readonly interface: nsIGSettingsCollectionType;
    };
    "{849c088b-57d1-4f24-b7b2-3dc4acb04c0a}": {
        readonly name: 'nsIGSettingsService';
        readonly interface: nsIGSettingsServiceType;
    };
    "{643dc5e9-b911-4b2c-8d44-603162696baf}": {
        readonly name: 'nsIGeolocationUpdate';
        readonly interface: nsIGeolocationUpdateType;
    };
    "{AC4A133B-9F92-4F7C-B369-D40CB6B17650}": {
        readonly name: 'nsIGeolocationProvider';
        readonly interface: nsIGeolocationProviderType;
    };
    "{1accd618-4c80-4703-9d29-ecf257d397c8}": {
        readonly name: 'nsIGfxInfo';
        readonly interface: nsIGfxInfoType;
    };
    "{ca7b0bc7-c67c-4b79-8270-ed7ba002af08}": {
        readonly name: 'nsIGfxInfoDebug';
        readonly interface: nsIGfxInfoDebugType;
    };
    "{d3180fe0-19fa-11eb-8b6f-0800200c9a66}": {
        readonly name: 'nsIGleanBoolean';
        readonly interface: nsIGleanBooleanType;
    };
    "{aa15fd20-1e8a-11eb-9bec-0800200c9a66}": {
        readonly name: 'nsIGleanDatetime';
        readonly interface: nsIGleanDatetimeType;
    };
    "{05b89d2a-d57c-11ea-82da-3f63399a6f5a}": {
        readonly name: 'nsIGleanCounter';
        readonly interface: nsIGleanCounterType;
    };
    "{92e14730-9b5f-45a1-b018-f588d0b964d8}": {
        readonly name: 'nsIGleanTimingDistribution';
        readonly interface: nsIGleanTimingDistributionType;
    };
    "{eea5ed46-16ba-46cd-bb1f-504581987fe1}": {
        readonly name: 'nsIGleanMemoryDistribution';
        readonly interface: nsIGleanMemoryDistributionType;
    };
    "{45cc016f-c1d5-4d54-aaa5-a802cf65f23b}": {
        readonly name: 'nsIGleanCustomDistribution';
        readonly interface: nsIGleanCustomDistributionType;
    };
    "{e5447f62-4b03-497c-81e9-6ab683d20380}": {
        readonly name: 'nsIGleanPingTestCallback';
        readonly interface: nsIGleanPingTestCallbackType;
    };
    "{5223a48b-687d-47ff-a629-fd4a72d1ecfa}": {
        readonly name: 'nsIGleanPing';
        readonly interface: nsIGleanPingType;
    };
    "{d84a3555-46f1-48c1-9122-e8e88b069d2b}": {
        readonly name: 'nsIGleanString';
        readonly interface: nsIGleanStringType;
    };
    "{46751205-2ac7-47dc-91d2-ef4a95ef2af9}": {
        readonly name: 'nsIGleanStringList';
        readonly interface: nsIGleanStringListType;
    };
    "{2586530c-030f-11eb-93cb-cbf30d25225a}": {
        readonly name: 'nsIGleanTimespan';
        readonly interface: nsIGleanTimespanType;
    };
    "{395700e7-06f6-46be-adcc-ea58977fda6d}": {
        readonly name: 'nsIGleanUuid';
        readonly interface: nsIGleanUuidType;
    };
    "{1b01424a-1f55-11eb-92a5-0754f6c3f240}": {
        readonly name: 'nsIGleanEvent';
        readonly interface: nsIGleanEventType;
    };
    "{0558c1b2-2cb1-4e21-a0a0-6a91a35ef219}": {
        readonly name: 'nsIGleanQuantity';
        readonly interface: nsIGleanQuantityType;
    };
    "{394d9d3b-9e7e-48cc-b76c-a89a51830da3}": {
        readonly name: 'nsIGleanDenominator';
        readonly interface: nsIGleanDenominatorType;
    };
    "{153fff71-7edd-49b4-a166-4697aa89c7a1}": {
        readonly name: 'nsIGleanNumerator';
        readonly interface: nsIGleanNumeratorType;
    };
    "{920cf631-2b1e-4efe-ae2e-f03277c3112a}": {
        readonly name: 'nsIGleanRate';
        readonly interface: nsIGleanRateType;
    };
    "{a59672c4-bc48-4bfe-8f9c-6f408a59d819}": {
        readonly name: 'nsIGleanUrl';
        readonly interface: nsIGleanUrlType;
    };
    "{fafceafb-c3a0-4424-b3b9-b7bd487f6bb4}": {
        readonly name: 'nsIGleanText';
        readonly interface: nsIGleanTextType;
    };
    "{39f6fc5a-2386-4bc6-941c-d7479253bc3f}": {
        readonly name: 'nsIGtkTaskbarProgress';
        readonly interface: nsIGtkTaskbarProgressType;
    };
    "{91375f52-20e6-4757-9835-eb04fabe5498}": {
        readonly name: 'nsIHTMLAbsPosEditor';
        readonly interface: nsIHTMLAbsPosEditorType;
    };
    "{87ee993e-985f-4a43-a974-0d9512da2fb0}": {
        readonly name: 'nsIHTMLEditor';
        readonly interface: nsIHTMLEditorType;
    };
    "{eda2e65c-a758-451f-9b05-77cb8de74ed2}": {
        readonly name: 'nsIHTMLInlineTableEditor';
        readonly interface: nsIHTMLInlineTableEditorType;
    };
    "{8b396020-69d3-451f-80c1-1a96a7da25a9}": {
        readonly name: 'nsIHTMLObjectResizer';
        readonly interface: nsIHTMLObjectResizerType;
    };
    "{53f0ad17-ec62-46a1-adbc-efccc06babcd}": {
        readonly name: 'nsIHandlerService';
        readonly interface: nsIHandlerServiceType;
    };
    "{23d63fff-38d6-4003-9c57-2c90aca1180a}": {
        readonly name: 'nsIHangDetails';
        readonly interface: nsIHangDetailsType;
    };
    "{5fcffbb9-be62-49b1-b8a1-36e820787a74}": {
        readonly name: 'nsIHangReport';
        readonly interface: nsIHangReportType;
    };
    "{91917c98-a8f3-4c98-8f10-4afb872f54c7}": {
        readonly name: 'nsIHapticFeedback';
        readonly interface: nsIHapticFeedbackType;
    };
    "{bfc739f3-8d75-4034-a6f8-1039a5996bad}": {
        readonly name: 'nsIHelperAppLauncherDialog';
        readonly interface: nsIHelperAppLauncherDialogType;
    };
    "{412880C8-6C36-48d8-BF8F-84F91F892503}": {
        readonly name: 'nsIHttpActivityObserver';
        readonly interface: nsIHttpActivityObserverType;
    };
    "{7C512CB8-582A-4625-B5B6-8639755271B5}": {
        readonly name: 'nsIHttpActivityDistributor';
        readonly interface: nsIHttpActivityDistributorType;
    };
    "{54f90444-c52b-4d2d-8916-c59a2bb25938}": {
        readonly name: 'nsIHttpAuthManager';
        readonly interface: nsIHttpAuthManagerType;
    };
    "{}": {
        readonly name: 'nsIHttpAuthenticableChannel';
        readonly interface: nsIHttpAuthenticableChannelType;
    };
    "{fef7db8a-a4e2-49d1-9685-19ed7e309b7d}": {
        readonly name: 'nsIHttpAuthenticator';
        readonly interface: nsIHttpAuthenticatorType;
    };
    "{d989cb03-e446-4086-b9e6-46842cb97bd5}": {
        readonly name: 'nsIHttpAuthenticatorCallback';
        readonly interface: nsIHttpAuthenticatorCallbackType;
    };
    "{}": {
        readonly name: 'nsIHttpChannel';
        readonly interface: nsIHttpChannelType;
    };
    "{788f331b-2e1f-436c-b405-4f88a31a105b}": {
        readonly name: 'nsIHttpChannelAuthProvider';
        readonly interface: nsIHttpChannelAuthProviderType;
    };
    "{d02b96ed-2789-4f42-a25c-7abe63de7c18}": {
        readonly name: 'nsIHttpChannelChild';
        readonly interface: nsIHttpChannelChildType;
    };
    "{}": {
        readonly name: 'nsIHttpUpgradeListener';
        readonly interface: nsIHttpUpgradeListenerType;
    };
    "{4e28263d-1e03-46f4-aa5c-9512f91957f9}": {
        readonly name: 'nsIHttpChannelInternal';
        readonly interface: nsIHttpChannelInternalType;
    };
    "{35412859-b9d9-423c-8866-2d4559fdd2be}": {
        readonly name: 'nsIHttpHeaderVisitor';
        readonly interface: nsIHttpHeaderVisitorType;
    };
    "{c48126d9-2ddd-485b-a51a-378e917e75f8}": {
        readonly name: 'nsIHttpProtocolHandler';
        readonly interface: nsIHttpProtocolHandlerType;
    };
    "{0d6ce59c-ad5d-4520-b4d3-09664868f279}": {
        readonly name: 'nsIHttpPushListener';
        readonly interface: nsIHttpPushListenerType;
    };
    "{cea8812e-faa6-4013-9396-f9936cbb74ec}": {
        readonly name: 'nsIHttpServer';
        readonly interface: nsIHttpServerType;
    };
    "{925a6d33-9937-4c63-abe1-a1c56a986455}": {
        readonly name: 'nsIHttpServerStoppedCallback';
        readonly interface: nsIHttpServerStoppedCallbackType;
    };
    "{a89de175-ae8e-4c46-91a5-0dba99bbd284}": {
        readonly name: 'nsIHttpServerIdentity';
        readonly interface: nsIHttpServerIdentityType;
    };
    "{2bbb4db7-d285-42b3-a3ce-142b8cc7e139}": {
        readonly name: 'nsIHttpRequestHandler';
        readonly interface: nsIHttpRequestHandlerType;
    };
    "{978cf30e-ad73-42ee-8f22-fe0aaf1bf5d2}": {
        readonly name: 'nsIHttpRequest';
        readonly interface: nsIHttpRequestType;
    };
    "{1acd16c2-dc59-42fa-9160-4f26c43c1c21}": {
        readonly name: 'nsIHttpResponse';
        readonly interface: nsIHttpResponseType;
    };
    "{73f4f039-d6ff-41a7-9eb3-00db57b0b7f4}": {
        readonly name: 'nsIHttpsOnlyModePermission';
        readonly interface: nsIHttpsOnlyModePermissionType;
    };
    "{c3493c65-0530-496e-995c-bcd38dbfce21}": {
        readonly name: 'nsIIDBPermissionsRequest';
        readonly interface: nsIIDBPermissionsRequestType;
    };
    "{a592a60e-3621-4f19-a318-2bf233cfad3e}": {
        readonly name: 'nsIIDNService';
        readonly interface: nsIIDNServiceType;
    };
    "{7eb955f6-3e78-4d39-b72f-c1bf12a94bce}": {
        readonly name: 'nsIINIParser';
        readonly interface: nsIINIParserType;
    };
    "{b67bb24b-31a3-4a6a-a5d9-0485c9af5a04}": {
        readonly name: 'nsIINIParserWriter';
        readonly interface: nsIINIParserWriterType;
    };
    "{ccae7ea5-1218-4b51-aecb-c2d8ecd46af9}": {
        readonly name: 'nsIINIParserFactory';
        readonly interface: nsIINIParserFactoryType;
    };
    "{4286de5a-b2ea-446f-8f70-e2a461f42694}": {
        readonly name: 'nsIIOService';
        readonly interface: nsIIOServiceType;
    };
    "{6633c0bf-d97a-428f-8ece-cb6a655fb95a}": {
        readonly name: 'nsIIOServiceInternal';
        readonly interface: nsIIOServiceInternalType;
    };
    "{e8152f7f-4209-4c63-ad23-c3d2aa0c5a49}": {
        readonly name: 'nsIIOUtil';
        readonly interface: nsIIOUtilType;
    };
    "{f8fe5ef2-5f2b-43f3-857d-5b64d192c427}": {
        readonly name: 'nsIMozIconURI';
        readonly interface: nsIMozIconURIType;
    };
    "{936007db-a957-4f1d-a23d-f7d9403223e6}": {
        readonly name: 'nsIIdentityCredentialPromptService';
        readonly interface: nsIIdentityCredentialPromptServiceType;
    };
    "{029823d0-0448-46c5-af1f-25cd4501d0d7}": {
        readonly name: 'nsIIdentityCredentialStorageService';
        readonly interface: nsIIdentityCredentialStorageServiceType;
    };
    "{21dd35a2-eae9-4bd8-b470-0dfa35a0e3b9}": {
        readonly name: 'nsIIdlePeriod';
        readonly interface: nsIIdlePeriodType;
    };
    "{0357123d-9224-4d12-a47e-868c32689777}": {
        readonly name: 'nsIImageLoadingContent';
        readonly interface: nsIImageLoadingContentType;
    };
    "{6687823f-56c4-461d-93a1-7f6cb7dfbfba}": {
        readonly name: 'nsIIncrementalDownload';
        readonly interface: nsIIncrementalDownloadType;
    };
    "{07c3d2cc-5454-4618-9f4f-cd93de9504a4}": {
        readonly name: 'nsIIncrementalStreamLoaderObserver';
        readonly interface: nsIIncrementalStreamLoaderObserverType;
    };
    "{a023b060-ba23-431a-b449-2dd63e220554}": {
        readonly name: 'nsIIncrementalStreamLoader';
        readonly interface: nsIIncrementalStreamLoaderType;
    };
    "{b7b7a77c-40c4-4196-b0b7-b0338243b3fe}": {
        readonly name: 'nsIInlineSpellChecker';
        readonly interface: nsIInlineSpellCheckerType;
    };
    "{0e33de3e-4faf-4a1a-b96e-24115b8bfd45}": {
        readonly name: 'nsIInputListAutoComplete';
        readonly interface: nsIInputListAutoCompleteType;
    };
    "{}": {
        readonly name: 'nsIInputStream';
        readonly interface: nsIInputStreamType;
    };
    "{ea730238-4bfd-4015-8489-8f264d05b343}": {
        readonly name: 'nsIInputStreamChannel';
        readonly interface: nsIInputStreamChannelType;
    };
    "{452d059f-9a9c-4434-8839-e10d1405647c}": {
        readonly name: 'nsIInputStreamLength';
        readonly interface: nsIInputStreamLengthType;
    };
    "{b63f9ecf-4668-44a3-93bd-72dbc65a6125}": {
        readonly name: 'nsIAsyncInputStreamLength';
        readonly interface: nsIAsyncInputStreamLengthType;
    };
    "{9c0c13b9-1b33-445d-8adb-a8a7866a6c06}": {
        readonly name: 'nsIInputStreamLengthCallback';
        readonly interface: nsIInputStreamLengthCallbackType;
    };
    "{daa45b24-98ee-4eb2-9cec-aad0bc023e9d}": {
        readonly name: 'nsIInputStreamPriority';
        readonly interface: nsIInputStreamPriorityType;
    };
    "{400F5468-97E7-4d2b-9C65-A82AECC7AE82}": {
        readonly name: 'nsIInputStreamPump';
        readonly interface: nsIInputStreamPumpType;
    };
    "{90a9d790-3bca-421e-a73b-98f68e13c917}": {
        readonly name: 'nsIInputStreamTee';
        readonly interface: nsIInputStreamTeeType;
    };
    "{8b9cd81f-3cd1-4f6a-9086-92a9bbf055f4}": {
        readonly name: 'nsIInterceptionInfo';
        readonly interface: nsIInterceptionInfoType;
    };
    "{}": {
        readonly name: 'nsIInterfaceRequestor';
        readonly interface: nsIInterfaceRequestorType;
    };
    "{e72b179b-d5df-4d87-b5de-fd73a65c60f6}": {
        readonly name: 'nsIJARChannel';
        readonly interface: nsIJARChannelType;
    };
    "{646a508c-f786-4e14-be6d-8dda2a633c60}": {
        readonly name: 'nsIJARURI';
        readonly interface: nsIJARURIType;
    };
    "{d66df117-eda7-4324-b4e4-1f670ff6718e}": {
        readonly name: 'nsIJARURIMutator';
        readonly interface: nsIJARURIMutatorType;
    };
    "{6758d0d7-e96a-4c5c-bca8-3bcbe5a15943}": {
        readonly name: 'nsIJSInspector';
        readonly interface: nsIJSInspectorType;
    };
    "{5131a62a-e99f-4631-9138-751f8aad1ae4}": {
        readonly name: 'nsIJumpListCommittedCallback';
        readonly interface: nsIJumpListCommittedCallbackType;
    };
    "{}": {
        readonly name: 'nsIJumpListBuilder';
        readonly interface: nsIJumpListBuilderType;
    };
    "{ACB8FB3C-E1B0-4044-8A50-E52C3E7C1057}": {
        readonly name: 'nsIJumpListItem';
        readonly interface: nsIJumpListItemType;
    };
    "{69A2D5C5-14DC-47da-925D-869E0BD64D27}": {
        readonly name: 'nsIJumpListSeparator';
        readonly interface: nsIJumpListSeparatorType;
    };
    "{76EA47B1-C797-49b3-9F18-5E740A688524}": {
        readonly name: 'nsIJumpListLink';
        readonly interface: nsIJumpListLinkType;
    };
    "{CBE3A37C-BCE1-4fec-80A5-5FFBC7F33EEA}": {
        readonly name: 'nsIJumpListShortcut';
        readonly interface: nsIJumpListShortcutType;
    };
    "{46c893dd-4c14-4de0-b33d-a1be18c6d062}": {
        readonly name: 'nsIKeyValueService';
        readonly interface: nsIKeyValueServiceType;
    };
    "{c449398e-174c-425b-8195-da6aa0ccd9a5}": {
        readonly name: 'nsIKeyValueDatabase';
        readonly interface: nsIKeyValueDatabaseType;
    };
    "{bc37b06a-23b5-4b32-8281-4b8479601c7e}": {
        readonly name: 'nsIKeyValuePair';
        readonly interface: nsIKeyValuePairType;
    };
    "{b9ba7116-b7ff-4717-9a28-a08e6879b199}": {
        readonly name: 'nsIKeyValueEnumerator';
        readonly interface: nsIKeyValueEnumeratorType;
    };
    "{2becc1f8-2d80-4b63-92a8-24ee8f79ee45}": {
        readonly name: 'nsIKeyValueDatabaseCallback';
        readonly interface: nsIKeyValueDatabaseCallbackType;
    };
    "{b7ea2183-880b-4424-ab24-5aa1555b775d}": {
        readonly name: 'nsIKeyValueEnumeratorCallback';
        readonly interface: nsIKeyValueEnumeratorCallbackType;
    };
    "{50f65485-ec1e-4307-812b-b8a15e1f382e}": {
        readonly name: 'nsIKeyValuePairCallback';
        readonly interface: nsIKeyValuePairCallbackType;
    };
    "{174ebfa1-74ea-42a7-aa90-85bbaf1da4bf}": {
        readonly name: 'nsIKeyValueVariantCallback';
        readonly interface: nsIKeyValueVariantCallbackType;
    };
    "{0c17497a-ccf8-451a-838d-9dfa7f846379}": {
        readonly name: 'nsIKeyValueVoidCallback';
        readonly interface: nsIKeyValueVoidCallbackType;
    };
    "{647bf80c-cd35-4ce6-b904-fd586b97ae48}": {
        readonly name: 'nsIKeychainMigrationUtils';
        readonly interface: nsIKeychainMigrationUtilsType;
    };
    "{f336d8d3-9721-4ad3-85d0-a7018c0a3383}": {
        readonly name: 'nsILayoutDebuggingTools';
        readonly interface: nsILayoutDebuggingToolsType;
    };
    "{}": {
        readonly name: 'nsILayoutHistoryState';
        readonly interface: nsILayoutHistoryStateType;
    };
    "{c97b466c-1e6e-4773-a4ab-2b2b3190a7a6}": {
        readonly name: 'nsILineInputStream';
        readonly interface: nsILineInputStreamType;
    };
    "{}": {
        readonly name: 'nsILoadContext';
        readonly interface: nsILoadContextType;
    };
    "{555e2f8a-a1f6-41dd-88ca-ed4ed6b98a22}": {
        readonly name: 'nsILoadContextInfo';
        readonly interface: nsILoadContextInfoType;
    };
    "{c1c7023d-4318-4f99-8307-b5ccf0558793}": {
        readonly name: 'nsILoadContextInfoFactory';
        readonly interface: nsILoadContextInfoFactoryType;
    };
    "{}": {
        readonly name: 'nsILoadGroup';
        readonly interface: nsILoadGroupType;
    };
    "{02efe8e2-fbbc-4718-a299-b8a09c60bf6b}": {
        readonly name: 'nsILoadGroupChild';
        readonly interface: nsILoadGroupChildType;
    };
    "{}": {
        readonly name: 'nsILoadInfo';
        readonly interface: nsILoadInfoType;
    };
    "{78e42d37-a34c-4d96-b901-25385669aba4}": {
        readonly name: 'nsILoadURIDelegate';
        readonly interface: nsILoadURIDelegateType;
    };
    "{623eca5b-c25d-4e27-be5a-789a66c4b2f7}": {
        readonly name: 'nsILocalFileMac';
        readonly interface: nsILocalFileMacType;
    };
    "{e7a3a954-384b-4aeb-a5f7-55626b0de9be}": {
        readonly name: 'nsILocalFileWin';
        readonly interface: nsILocalFileWinType;
    };
    "{d4f534da-2744-4db3-8774-8b187c64ade9}": {
        readonly name: 'nsILocalStorageManager';
        readonly interface: nsILocalStorageManagerType;
    };
    "{2bdac17c-53f1-4896-a521-682ccdeef3a8}": {
        readonly name: 'nsILoginAutoCompleteSearch';
        readonly interface: nsILoginAutoCompleteSearchType;
    };
    "{4c3c9a82-722a-4b0b-9c7d-36ef90135537}": {
        readonly name: 'nsILoginDetectionService';
        readonly interface: nsILoginDetectionServiceType;
    };
    "{}": {
        readonly name: 'nsILoginInfo';
        readonly interface: nsILoginInfoType;
    };
    "{43429075-ede6-41eb-ac69-a8cd4376b041}": {
        readonly name: 'nsILoginSearchCallback';
        readonly interface: nsILoginSearchCallbackType;
    };
    "{38c7f6af-7df9-49c7-b558-2776b24e6cc1}": {
        readonly name: 'nsILoginManager';
        readonly interface: nsILoginManagerType;
    };
    "{425f73b9-b2db-4e8a-88c5-9ac2512934ce}": {
        readonly name: 'nsILoginManagerAuthPrompter';
        readonly interface: nsILoginManagerAuthPrompterType;
    };
    "{2030770e-542e-40cd-8061-cd9d4ad4227f}": {
        readonly name: 'nsILoginManagerCrypto';
        readonly interface: nsILoginManagerCryptoType;
    };
    "{c47ff942-9678-44a5-bc9b-05e0d676c79c}": {
        readonly name: 'nsILoginManagerPrompter';
        readonly interface: nsILoginManagerPrompterType;
    };
    "{5df81a93-25e6-4b45-a696-089479e15c7d}": {
        readonly name: 'nsILoginManagerStorage';
        readonly interface: nsILoginManagerStorageType;
    };
    "{20d8eb40-c494-497f-b2a6-aaa32f807ebd}": {
        readonly name: 'nsILoginMetaInfo';
        readonly interface: nsILoginMetaInfoType;
    };
    "{6219f9da-297e-446d-8d47-ccdd8e72a1d5}": {
        readonly name: 'nsILoginReputationVerdictType';
        readonly interface: nsILoginReputationVerdictTypeType;
    };
    "{c21ffe59-595f-46c8-9052-fefb639e196e}": {
        readonly name: 'nsILoginReputationQuery';
        readonly interface: nsILoginReputationQueryType;
    };
    "{b527be1e-8fbb-41d9-bee4-267a71236368}": {
        readonly name: 'nsILoginReputationQueryCallback';
        readonly interface: nsILoginReputationQueryCallbackType;
    };
    "{1b3f1dfe-ce3a-486b-953e-ce5ac863eff9}": {
        readonly name: 'nsILoginReputationService';
        readonly interface: nsILoginReputationServiceType;
    };
    "{9c9252a1-fdaf-40a2-9c2b-a3dc45e28dde}": {
        readonly name: 'nsIMIMEHeaderParam';
        readonly interface: nsIMIMEHeaderParamType;
    };
    "{325e56a7-3762-4312-aec7-f1fcf84b4145}": {
        readonly name: 'nsIHandlerInfo';
        readonly interface: nsIHandlerInfoType;
    };
    "{}": {
        readonly name: 'nsIMIMEInfo';
        readonly interface: nsIMIMEInfoType;
    };
    "{8BDF20A4-9170-4548-AF52-78311A44F920}": {
        readonly name: 'nsIHandlerApp';
        readonly interface: nsIHandlerAppType;
    };
    "{D36B6329-52AE-4f45-80F4-B2536AE5F8B2}": {
        readonly name: 'nsILocalHandlerApp';
        readonly interface: nsILocalHandlerAppType;
    };
    "{7521a093-c498-45ce-b462-df7ba0d882f6}": {
        readonly name: 'nsIWebHandlerApp';
        readonly interface: nsIWebHandlerAppType;
    };
    "{1ffc274b-4cbf-4bb5-a635-05ad2cbb6534}": {
        readonly name: 'nsIDBusHandlerApp';
        readonly interface: nsIDBusHandlerAppType;
    };
    "{dcbce63c-1dd1-11b2-b94d-91f6d49a3161}": {
        readonly name: 'nsIMIMEInputStream';
        readonly interface: nsIMIMEInputStreamType;
    };
    "{5b3675a1-02db-4f8f-a560-b34736635f47}": {
        readonly name: 'nsIMIMEService';
        readonly interface: nsIMIMEServiceType;
    };
    "{6FC66A78-6CBC-4B3F-B7BA-379289B29276}": {
        readonly name: 'nsIMacAttributionService';
        readonly interface: nsIMacAttributionServiceType;
    };
    "{8BE66B0C-5F71-4B74-98CF-6C2551B999B1}": {
        readonly name: 'nsIMacDockSupport';
        readonly interface: nsIMacDockSupportType;
    };
    "{6BAE6D1C-7FFD-4354-8D7B-64697E98A801}": {
        readonly name: 'nsIMacFinderProgressCanceledCallback';
        readonly interface: nsIMacFinderProgressCanceledCallbackType;
    };
    "{25A0B01F-54D4-4AEF-B2BF-C5764CDC68A8}": {
        readonly name: 'nsIMacFinderProgress';
        readonly interface: nsIMacFinderProgressType;
    };
    "{b0f20595-88ce-4738-a1a4-24de78eb8051}": {
        readonly name: 'nsIMacPreferencesReader';
        readonly interface: nsIMacPreferencesReaderType;
    };
    "{de59fe1a-46c8-490f-b04d-34545acb06c9}": {
        readonly name: 'nsIMacSharingService';
        readonly interface: nsIMacSharingServiceType;
    };
    "{387fdc80-0077-4b60-a0d9-d9e80a83ba64}": {
        readonly name: 'nsIMacShellService';
        readonly interface: nsIMacShellServiceType;
    };
    "{29046c8f-cba6-4ffa-9141-1685e96c4ea0}": {
        readonly name: 'nsIMacUserActivityUpdater';
        readonly interface: nsIMacUserActivityUpdaterType;
    };
    "{8c899c4f-58c1-4b74-9034-3bb64e484b68}": {
        readonly name: 'nsITrashAppCallback';
        readonly interface: nsITrashAppCallbackType;
    };
    "{c69cf343-ea41-428b-b161-4655fd54d8e7}": {
        readonly name: 'nsIMacWebAppUtils';
        readonly interface: nsIMacWebAppUtilsType;
    };
    "{13fa7d76-f976-4711-a00c-29ac9c1881e1}": {
        readonly name: 'nsIMarionette';
        readonly interface: nsIMarionetteType;
    };
    "{}": {
        readonly name: 'nsIMediaDevice';
        readonly interface: nsIMediaDeviceType;
    };
    "{24b23e01-33fd-401f-ba25-6e52658750b0}": {
        readonly name: 'nsIMediaManagerService';
        readonly interface: nsIMediaManagerServiceType;
    };
    "{2dea18fc-fbfa-4bf7-ad45-0efaf5495f5e}": {
        readonly name: 'nsIFinishDumpingCallback';
        readonly interface: nsIFinishDumpingCallbackType;
    };
    "{dc1b2b24-65bd-441b-b6bd-cb5825a7ed14}": {
        readonly name: 'nsIDumpGCAndCCLogsCallback';
        readonly interface: nsIDumpGCAndCCLogsCallbackType;
    };
    "{48541b74-47ee-4a62-9557-7f4b809bda5c}": {
        readonly name: 'nsIMemoryInfoDumper';
        readonly interface: nsIMemoryInfoDumperType;
    };
    "{62ef0e1c-dbd6-11e3-aa75-3c970e9f4238}": {
        readonly name: 'nsIHandleReportCallback';
        readonly interface: nsIHandleReportCallbackType;
    };
    "{92a36db1-46bd-4fe6-988e-47db47236d8b}": {
        readonly name: 'nsIMemoryReporter';
        readonly interface: nsIMemoryReporterType;
    };
    "{548b3909-c04d-4ca6-8466-b8bee3837457}": {
        readonly name: 'nsIFinishReportingCallback';
        readonly interface: nsIFinishReportingCallbackType;
    };
    "{1a80cd0f-0d9e-4397-be69-68ad28fe5175}": {
        readonly name: 'nsIHeapAllocatedCallback';
        readonly interface: nsIHeapAllocatedCallbackType;
    };
    "{2998574d-8993-407a-b1a5-8ad7417653e1}": {
        readonly name: 'nsIMemoryReporterManager';
        readonly interface: nsIMemoryReporterManagerType;
    };
    "{3E8C58E8-E52C-43E0-8E66-669CA788FF5F}": {
        readonly name: 'nsIMessageLoop';
        readonly interface: nsIMessageLoopType;
    };
    "{bb5d79e4-e73c-45e7-9651-4d718f4b994c}": {
        readonly name: 'nsIMessageSender';
        readonly interface: nsIMessageSenderType;
    };
    "{b39a3324-b574-4f85-8cdb-274d04f807ef}": {
        readonly name: 'nsIInProcessContentFrameMessageManager';
        readonly interface: nsIInProcessContentFrameMessageManagerType;
    };
    "{0c0a862c-1a47-43c0-ae9e-d51835e3e1a6}": {
        readonly name: 'nsIMozBrowserFrame';
        readonly interface: nsIMozBrowserFrameType;
    };
    "{4fefb490-5567-11e5-a837-0800200c9a66}": {
        readonly name: 'nsIMultiPartChannel';
        readonly interface: nsIMultiPartChannelType;
    };
    "{b084959a-4fb9-41a5-88a0-d0f045ce75cf}": {
        readonly name: 'nsIMultiPartChannelListener';
        readonly interface: nsIMultiPartChannelListenerType;
    };
    "{a076fd12-1dd1-11b2-b19a-d53b5dffaade}": {
        readonly name: 'nsIMultiplexInputStream';
        readonly interface: nsIMultiplexInputStreamType;
    };
    "{}": {
        readonly name: 'nsIMutableArray';
        readonly interface: nsIMutableArrayType;
    };
    "{a0a8f52b-ea18-4abc-a3ca-eccf704ffe63}": {
        readonly name: 'nsINSSComponent';
        readonly interface: nsINSSComponentType;
    };
    "{12f60021-e14b-4020-99d1-ed2c795be66a}": {
        readonly name: 'nsINSSErrorsService';
        readonly interface: nsINSSErrorsServiceType;
    };
    "{a8a53a2b-75cc-4c68-a9bb-9791dbddaa00}": {
        readonly name: 'nsINSSVersion';
        readonly interface: nsINSSVersionType;
    };
    "{0c5fe7de-7e83-4d0d-a8a6-4a6518b9a7b3}": {
        readonly name: 'nsINamed';
        readonly interface: nsINamedType;
    };
    "{de4f460b-94fd-442c-9002-1637beb2185a}": {
        readonly name: 'nsINamedPipeDataObserver';
        readonly interface: nsINamedPipeDataObserverType;
    };
    "{1bf19133-5625-4ac8-836a-80b1c215f72b}": {
        readonly name: 'nsINamedPipeService';
        readonly interface: nsINamedPipeServiceType;
    };
    "{5fdf8480-1f98-11d4-8077-00600811a9c3}": {
        readonly name: 'nsINativeAppSupport';
        readonly interface: nsINativeAppSupportType;
    };
    "{8e38d536-5501-48c0-a412-6c450040c8c8}": {
        readonly name: 'nsINativeDNSResolverOverride';
        readonly interface: nsINativeDNSResolverOverrideType;
    };
    "{08B4CF29-3D65-4E79-B522-A694C322ED07}": {
        readonly name: 'nsINativeOSFileResult';
        readonly interface: nsINativeOSFileResultType;
    };
    "{2C1922CA-CA1B-4099-8B61-EC23CFF49412}": {
        readonly name: 'nsINativeOSFileSuccessCallback';
        readonly interface: nsINativeOSFileSuccessCallbackType;
    };
    "{F612E0FC-6736-4D24-AA50-FD661B3B40B6}": {
        readonly name: 'nsINativeOSFileErrorCallback';
        readonly interface: nsINativeOSFileErrorCallbackType;
    };
    "{913362AD-1526-4623-9E6B-A2EB08AFBBB9}": {
        readonly name: 'nsINativeOSFileInternalsService';
        readonly interface: nsINativeOSFileInternalsServiceType;
    };
    "{24533891-afa6-4663-b72d-3143d03f1b04}": {
        readonly name: 'nsINavBookmarksService';
        readonly interface: nsINavBookmarksServiceType;
    };
    "{91d104bb-17ef-404b-9f9a-d9ed8de6824c}": {
        readonly name: 'nsINavHistoryResultNode';
        readonly interface: nsINavHistoryResultNodeType;
    };
    "{3E9CC95F-0D93-45F1-894F-908EEB9866D7}": {
        readonly name: 'nsINavHistoryContainerResultNode';
        readonly interface: nsINavHistoryContainerResultNodeType;
    };
    "{62817759-4FEE-44A3-B58C-3E2F5AFC9D0A}": {
        readonly name: 'nsINavHistoryQueryResultNode';
        readonly interface: nsINavHistoryQueryResultNodeType;
    };
    "{f62d8b6b-3c4e-4a9f-a897-db605d0b7a0f}": {
        readonly name: 'nsINavHistoryResultObserver';
        readonly interface: nsINavHistoryResultObserverType;
    };
    "{c2229ce3-2159-4001-859c-7013c52f7619}": {
        readonly name: 'nsINavHistoryResult';
        readonly interface: nsINavHistoryResultType;
    };
    "{dc87ae79-22f1-4dcf-975b-852b01d210cb}": {
        readonly name: 'nsINavHistoryQuery';
        readonly interface: nsINavHistoryQueryType;
    };
    "{8198dfa7-8061-4766-95cb-fa86b3c00a47}": {
        readonly name: 'nsINavHistoryQueryOptions';
        readonly interface: nsINavHistoryQueryOptionsType;
    };
    "{20c974ff-ee16-4828-9326-1b7c9e036622}": {
        readonly name: 'nsINavHistoryService';
        readonly interface: nsINavHistoryServiceType;
    };
    "{6de2c874-796c-46bf-b57f-0d7bd7d6cab0}": {
        readonly name: 'nsINestedURI';
        readonly interface: nsINestedURIType;
    };
    "{ca3d6c03-4eee-4271-a97a-d16c0a0b2c5c}": {
        readonly name: 'nsINestedURIMutator';
        readonly interface: nsINestedURIMutatorType;
    };
    "{c6357a3b-c2bb-4b4b-9278-513377398a38}": {
        readonly name: 'nsINestedAboutURIMutator';
        readonly interface: nsINestedAboutURIMutatorType;
    };
    "{3bd44535-08ea-478f-99b9-85fa1084e820}": {
        readonly name: 'nsIJSURIMutator';
        readonly interface: nsIJSURIMutatorType;
    };
    "{}": {
        readonly name: 'nsINetAddr';
        readonly interface: nsINetAddrType;
    };
    "{fe2625ec-b884-4df1-b39c-9e830e47aa94}": {
        readonly name: 'nsINetUtil';
        readonly interface: nsINetUtilType;
    };
    "{2693457e-3ba5-4455-991f-5350946adb12}": {
        readonly name: 'nsINetworkConnectivityService';
        readonly interface: nsINetworkConnectivityServiceType;
    };
    "{c4bdaac1-3ab1-4fdb-9a16-17cbed794603}": {
        readonly name: 'nsIListNetworkAddressesListener';
        readonly interface: nsIListNetworkAddressesListenerType;
    };
    "{3ebdcb62-2df4-4042-8864-3fa81abd4693}": {
        readonly name: 'nsIGetHostnameListener';
        readonly interface: nsIGetHostnameListenerType;
    };
    "{55fc8dae-4a58-4e0f-a49b-901cbabae809}": {
        readonly name: 'nsINetworkInfoService';
        readonly interface: nsINetworkInfoServiceType;
    };
    "{51039eb6-bea0-40c7-b523-ccab56cc4fde}": {
        readonly name: 'nsIInterceptedBodyCallback';
        readonly interface: nsIInterceptedBodyCallbackType;
    };
    "{}": {
        readonly name: 'nsIInterceptedChannel';
        readonly interface: nsIInterceptedChannelType;
    };
    "{70d2b4fe-a552-48cd-8d93-1d8437a56b53}": {
        readonly name: 'nsINetworkInterceptController';
        readonly interface: nsINetworkInterceptControllerType;
    };
    "{103e5293-77b3-4b70-af59-6e9e4a1f994a}": {
        readonly name: 'nsINetworkLinkService';
        readonly interface: nsINetworkLinkServiceType;
    };
    "{acc88e7c-3f39-42c7-ac31-6377c2c3d73e}": {
        readonly name: 'nsINetworkPredictor';
        readonly interface: nsINetworkPredictorType;
    };
    "{2e43bb32-dabf-4494-9f90-2b3195b1c73d}": {
        readonly name: 'nsINetworkPredictorVerifier';
        readonly interface: nsINetworkPredictorVerifierType;
    };
    "{c1622232-259c-43b0-b52e-89c39dcd9796}": {
        readonly name: 'nsINotificationStorageCallback';
        readonly interface: nsINotificationStorageCallbackType;
    };
    "{17f85e52-fe57-440e-9ba1-5c312ca02b95}": {
        readonly name: 'nsINotificationStorage';
        readonly interface: nsINotificationStorageType;
    };
    "{4610b901-df41-4bb4-bd3f-fd4d6b6d8d68}": {
        readonly name: 'nsINullChannel';
        readonly interface: nsINullChannelType;
    };
    "{d6dd239f-34d6-4b34-baa1-f69ab4a20bc4}": {
        readonly name: 'nsIOSFileConstantsService';
        readonly interface: nsIOSFileConstantsServiceType;
    };
    "{57972956-5718-42d2-8070-b3fc72212eaf}": {
        readonly name: 'nsIOSKeyStore';
        readonly interface: nsIOSKeyStoreType;
    };
    "{95790842-75a0-430d-98bf-f5ce3788ea6d}": {
        readonly name: 'nsIOSPermissionRequest';
        readonly interface: nsIOSPermissionRequestType;
    };
    "{4fe082ae-6ff0-4b41-b24f-eaa664f6e46a}": {
        readonly name: 'nsIOSReauthenticator';
        readonly interface: nsIOSReauthenticatorType;
    };
    "{}": {
        readonly name: 'nsIObjectInputStream';
        readonly interface: nsIObjectInputStreamType;
    };
    "{2eb3195e-3eea-4083-bb1d-d2d70fa35ccb}": {
        readonly name: 'nsIObjectLoadingContent';
        readonly interface: nsIObjectLoadingContentType;
    };
    "{}": {
        readonly name: 'nsIObjectOutputStream';
        readonly interface: nsIObjectOutputStreamType;
    };
    "{f2a4aaa4-046a-439e-beef-893b15a90cff}": {
        readonly name: 'nsIObliviousHttpClientResponse';
        readonly interface: nsIObliviousHttpClientResponseType;
    };
    "{403af7f9-4a76-49fc-a622-38d6ba3ee496}": {
        readonly name: 'nsIObliviousHttpClientRequest';
        readonly interface: nsIObliviousHttpClientRequestType;
    };
    "{105deb62-45b4-407a-b330-550433279111}": {
        readonly name: 'nsIObliviousHttpServerResponse';
        readonly interface: nsIObliviousHttpServerResponseType;
    };
    "{fb1abc56-b525-4e1a-a4c6-341a9b32084e}": {
        readonly name: 'nsIObliviousHttpServer';
        readonly interface: nsIObliviousHttpServerType;
    };
    "{d581149e-3319-4563-b95e-46c64af5c4e8}": {
        readonly name: 'nsIObliviousHttp';
        readonly interface: nsIObliviousHttpType;
    };
    "{b1f08d56-fca6-4290-9500-d5168dc9d8c3}": {
        readonly name: 'nsIObliviousHttpService';
        readonly interface: nsIObliviousHttpServiceType;
    };
    "{}": {
        readonly name: 'nsIObserver';
        readonly interface: nsIObserverType;
    };
    "{D07F5192-E3D1-11d2-8ACD-00105A1B8860}": {
        readonly name: 'nsIObserverService';
        readonly interface: nsIObserverServiceType;
    };
    "{0524ee06-7f4c-4cd3-ab80-084562745cad}": {
        readonly name: 'nsIBrowsingContextReadyCallback';
        readonly interface: nsIBrowsingContextReadyCallbackType;
    };
    "{}": {
        readonly name: 'nsIOpenWindowInfo';
        readonly interface: nsIOpenWindowInfoType;
    };
    "{}": {
        readonly name: 'nsIOutputStream';
        readonly interface: nsIOutputStreamType;
    };
    "{}": {
        readonly name: 'nsIPK11Token';
        readonly interface: nsIPK11TokenType;
    };
    "{4ee28c82-1dd2-11b2-aabf-bb4017abe395}": {
        readonly name: 'nsIPK11TokenDB';
        readonly interface: nsIPK11TokenDBType;
    };
    "{}": {
        readonly name: 'nsIPKCS11Module';
        readonly interface: nsIPKCS11ModuleType;
    };
    "{ff9fbcd7-9517-4334-b97a-ceed78909974}": {
        readonly name: 'nsIPKCS11ModuleDB';
        readonly interface: nsIPKCS11ModuleDBType;
    };
    "{c2d4f296-ee60-11d4-998b-00b0d02354a0}": {
        readonly name: 'nsIPKCS11Slot';
        readonly interface: nsIPKCS11SlotType;
    };
    "{97943eec-0e48-49ef-b7b7-cf4aa0109bb6}": {
        readonly name: 'nsIPageThumbsStorageService';
        readonly interface: nsIPageThumbsStorageServiceType;
    };
    "{a4dd9675-6311-45a9-a547-44e0127304a6}": {
        readonly name: 'nsIPaper';
        readonly interface: nsIPaperType;
    };
    "{0858d1a7-b646-4b15-a1e8-7eb5ab572d0a}": {
        readonly name: 'nsIPaperMargin';
        readonly interface: nsIPaperMarginType;
    };
    "{}": {
        readonly name: 'nsIParentChannel';
        readonly interface: nsIParentChannelType;
    };
    "{01987690-48cf-45de-bae3-e143c2adc2a8}": {
        readonly name: 'nsIAsyncVerifyRedirectReadyCallback';
        readonly interface: nsIAsyncVerifyRedirectReadyCallbackType;
    };
    "{3ed1d288-5324-46ee-8a98-33ac37d1080b}": {
        readonly name: 'nsIParentRedirectingChannel';
        readonly interface: nsIParentRedirectingChannelType;
    };
    "{2e97e5dd-467b-4aea-a1bb-6773c0f2beb0}": {
        readonly name: 'nsIParentalControlsService';
        readonly interface: nsIParentalControlsServiceType;
    };
    "{a1101145-0025-411e-8873-fdf57bf28128}": {
        readonly name: 'nsIParserUtils';
        readonly interface: nsIParserUtilsType;
    };
    "{d8db1086-7b59-44d3-9f88-f31a7e642637}": {
        readonly name: 'nsIPartitioningExceptionListObserver';
        readonly interface: nsIPartitioningExceptionListObserverType;
    };
    "{cf83a9af-dd3f-43a2-88bb-489a22bca124}": {
        readonly name: 'nsIPartitioningExceptionListService';
        readonly interface: nsIPartitioningExceptionListServiceType;
    };
    "{2a338575-c688-40ee-a157-7488ab292ef2}": {
        readonly name: 'nsIPaymentResponseData';
        readonly interface: nsIPaymentResponseDataType;
    };
    "{b986773e-2b30-4ed2-b8fe-6a96631c8000}": {
        readonly name: 'nsIGeneralResponseData';
        readonly interface: nsIGeneralResponseDataType;
    };
    "{0d55a5e6-d185-44f0-b992-a8e1321e4bce}": {
        readonly name: 'nsIBasicCardResponseData';
        readonly interface: nsIBasicCardResponseDataType;
    };
    "{a607c095-ef60-4a9b-a3d0-0506c60728b3}": {
        readonly name: 'nsIPaymentActionResponse';
        readonly interface: nsIPaymentActionResponseType;
    };
    "{52fc3f9f-c0cb-4874-b3d4-ee4b6e9cbe9c}": {
        readonly name: 'nsIPaymentCanMakeActionResponse';
        readonly interface: nsIPaymentCanMakeActionResponseType;
    };
    "{184385cb-2d35-4b99-a9a3-7c780bf66b9b}": {
        readonly name: 'nsIPaymentShowActionResponse';
        readonly interface: nsIPaymentShowActionResponseType;
    };
    "{8c72bcdb-0c37-4786-a9e5-510afa2f8ede}": {
        readonly name: 'nsIPaymentAbortActionResponse';
        readonly interface: nsIPaymentAbortActionResponseType;
    };
    "{62c01e69-9ca4-4060-99e4-b95f628c8e6d}": {
        readonly name: 'nsIPaymentCompleteActionResponse';
        readonly interface: nsIPaymentCompleteActionResponseType;
    };
    "{2035e0a9-c9ab-4c9f-b8e9-28b2ed61548c}": {
        readonly name: 'nsIMethodChangeDetails';
        readonly interface: nsIMethodChangeDetailsType;
    };
    "{e031267e-bec8-4f3c-b0b1-396b77ca260c}": {
        readonly name: 'nsIGeneralChangeDetails';
        readonly interface: nsIGeneralChangeDetailsType;
    };
    "{5296f79e-15ea-40c3-8196-19cfa64d328c}": {
        readonly name: 'nsIBasicCardChangeDetails';
        readonly interface: nsIBasicCardChangeDetailsType;
    };
    "{49a02241-7e48-477a-9345-9f246925dcb3}": {
        readonly name: 'nsIPaymentAddress';
        readonly interface: nsIPaymentAddressType;
    };
    "{2fe296cc-d917-4820-b492-aa42df23f9b4}": {
        readonly name: 'nsIPaymentMethodData';
        readonly interface: nsIPaymentMethodDataType;
    };
    "{d22a6f5f-767b-4fea-bf92-68b0b8003eba}": {
        readonly name: 'nsIPaymentCurrencyAmount';
        readonly interface: nsIPaymentCurrencyAmountType;
    };
    "{4f78a59f-b5ff-4fb5-ab48-3b37d0101b02}": {
        readonly name: 'nsIPaymentItem';
        readonly interface: nsIPaymentItemType;
    };
    "{74259861-c318-40e8-b3d5-518e701bed80}": {
        readonly name: 'nsIPaymentDetailsModifier';
        readonly interface: nsIPaymentDetailsModifierType;
    };
    "{68341551-3605-4381-b936-41e830aa88fb}": {
        readonly name: 'nsIPaymentShippingOption';
        readonly interface: nsIPaymentShippingOptionType;
    };
    "{73a5a3f1-45b9-4605-a6e6-7aa60daa9039}": {
        readonly name: 'nsIPaymentDetails';
        readonly interface: nsIPaymentDetailsType;
    };
    "{d53f9f20-138e-47cc-9fd5-db16a3f6d301}": {
        readonly name: 'nsIPaymentOptions';
        readonly interface: nsIPaymentOptionsType;
    };
    "{2fa36783-d684-4487-b7a8-9def6ae3128f}": {
        readonly name: 'nsIPaymentRequest';
        readonly interface: nsIPaymentRequestType;
    };
    "{cccd665f-edf3-41fc-ab9b-fc55b37340aa}": {
        readonly name: 'nsIPaymentRequestService';
        readonly interface: nsIPaymentRequestServiceType;
    };
    "{01f8bd55-9017-438b-85ec-7c15d2b35cdc}": {
        readonly name: 'nsIPaymentUIService';
        readonly interface: nsIPaymentUIServiceType;
    };
    "{}": {
        readonly name: 'nsIPermission';
        readonly interface: nsIPermissionType;
    };
    "{07611dc6-bf4d-4d8a-a64b-f3a5904dddc7}": {
        readonly name: 'nsIPermissionDelegateHandler';
        readonly interface: nsIPermissionDelegateHandlerType;
    };
    "{4dcb3851-eba2-4e42-b236-82d2596fca22}": {
        readonly name: 'nsIPermissionManager';
        readonly interface: nsIPermissionManagerType;
    };
    "{283EE646-1AEF-11D4-98B3-00C04fA0CE9A}": {
        readonly name: 'nsIPropertyElement';
        readonly interface: nsIPropertyElementType;
    };
    "{}": {
        readonly name: 'nsIPersistentProperties';
        readonly interface: nsIPersistentPropertiesType;
    };
    "{25d0de93-685e-4ea4-95d3-d884e31df63c}": {
        readonly name: 'nsIPipe';
        readonly interface: nsIPipeType;
    };
    "{8C39EF62-F7C9-11d4-98F5-001083010E9B}": {
        readonly name: 'nsISearchableInputStream';
        readonly interface: nsISearchableInputStreamType;
    };
    "{bd0a4d3b-ff26-4d4d-9a62-a513e1c1bf92}": {
        readonly name: 'nsIPlacesPreviewsHelperService';
        readonly interface: nsIPlacesPreviewsHelperServiceType;
    };
    "{ab6650cf-0806-4aea-b8f2-40fdae74f1cc}": {
        readonly name: 'nsIPlatformInfo';
        readonly interface: nsIPlatformInfoType;
    };
    "{5daa99d5-265a-4397-b429-c943803e2619}": {
        readonly name: 'nsIPluginTag';
        readonly interface: nsIPluginTagType;
    };
    "{6d22c968-226d-4156-b230-da6ad6bbf6e8}": {
        readonly name: 'nsIFakePluginTag';
        readonly interface: nsIFakePluginTagType;
    };
    "{ba7ca4c1-9d92-4425-a83b-85dd7fa953f7}": {
        readonly name: 'nsIPowerManagerService';
        readonly interface: nsIPowerManagerServiceType;
    };
    "{55d25e49-793f-4727-a69f-de8b15f4b985}": {
        readonly name: 'nsIPrefBranch';
        readonly interface: nsIPrefBranchType;
    };
    "{ae419e24-1dd1-11b2-b39a-d3e5e7073802}": {
        readonly name: 'nsIPrefLocalizedString';
        readonly interface: nsIPrefLocalizedStringType;
    };
    "{c3f0cedc-e244-4316-b33a-80306a1c35a1}": {
        readonly name: 'nsIPrefStatsCallback';
        readonly interface: nsIPrefStatsCallbackType;
    };
    "{0a2dbc02-2218-4687-b151-33d890676e00}": {
        readonly name: 'nsIPrefObserver';
        readonly interface: nsIPrefObserverType;
    };
    "{1f84fd56-3956-40df-b86a-1ea01402ee96}": {
        readonly name: 'nsIPrefService';
        readonly interface: nsIPrefServiceType;
    };
    "{422a1807-4e7f-463d-b8d7-ca2ceb9b5d53}": {
        readonly name: 'nsIPrefetchService';
        readonly interface: nsIPrefetchServiceType;
    };
    "{}": {
        readonly name: 'nsIPreloadedStyleSheet';
        readonly interface: nsIPreloadedStyleSheetType;
    };
    "{}": {
        readonly name: 'nsIPrincipal';
        readonly interface: nsIPrincipalType;
    };
    "{f3e177Df-6a5e-489f-80a7-2dd1481471d8}": {
        readonly name: 'nsIExpandedPrincipal';
        readonly interface: nsIExpandedPrincipalType;
    };
    "{88af6712-a9fd-4393-9af3-3ffbb1f2caaf}": {
        readonly name: 'nsIPrintDialogService';
        readonly interface: nsIPrintDialogServiceType;
    };
    "{8148E3F1-2E8B-11d5-A86C-00105A183419}": {
        readonly name: 'nsIPrintPreviewNavigation';
        readonly interface: nsIPrintPreviewNavigationType;
    };
    "{}": {
        readonly name: 'nsIPrintSettings';
        readonly interface: nsIPrintSettingsType;
    };
    "{841387C8-72E6-484b-9296-BF6EEA80D58A}": {
        readonly name: 'nsIPrintSettingsService';
        readonly interface: nsIPrintSettingsServiceType;
    };
    "{c63eed41-6ac5-459e-8a64-033eb9ad770a}": {
        readonly name: 'nsIPrintSettingsWin';
        readonly interface: nsIPrintSettingsWinType;
    };
    "{855ae9dd-62a4-64aa-9c60-b1078ff028f1}": {
        readonly name: 'nsIPrinterInfo';
        readonly interface: nsIPrinterInfoType;
    };
    "{d2dde9bb-df86-469c-bfcc-fd95a44b1db8}": {
        readonly name: 'nsIPrinter';
        readonly interface: nsIPrinterType;
    };
    "{5e738fff-404c-4c94-9189-e8f2cce93e94}": {
        readonly name: 'nsIPrinterList';
        readonly interface: nsIPrinterListType;
    };
    "{b4b1449d-0ef0-47f5-b62e-adc57fd49702}": {
        readonly name: 'nsIPrivacyTransitionObserver';
        readonly interface: nsIPrivacyTransitionObserverType;
    };
    "{df702bb0-55b8-11e2-bcfd-0800200c9a66}": {
        readonly name: 'nsIPrivateBrowsingChannel';
        readonly interface: nsIPrivateBrowsingChannelType;
    };
    "{609610de-9954-4a63-8a7c-346350a86403}": {
        readonly name: 'nsIProcess';
        readonly interface: nsIProcessType;
    };
    "{1341f571-ebed-4305-b264-4d8fc3b6b11c}": {
        readonly name: 'nsIProcessToolsService';
        readonly interface: nsIProcessToolsServiceType;
    };
    "{048e5ca1-0eb7-4bb1-a9a2-a36f7d4e0e3c}": {
        readonly name: 'nsIProfileStartup';
        readonly interface: nsIProfileStartupType;
    };
    "{3df284a5-2258-4d46-a664-761ecdc04c22}": {
        readonly name: 'nsIProfileMigrator';
        readonly interface: nsIProfileMigratorType;
    };
    "{}": {
        readonly name: 'nsIProfileUnlocker';
        readonly interface: nsIProfileUnlockerType;
    };
    "{0a175ba7-8fcf-4ce9-9c4b-ccc6272f4425}": {
        readonly name: 'nsIProfilerStartParams';
        readonly interface: nsIProfilerStartParamsType;
    };
    "{ead3f75c-0e0e-4fbb-901c-1e5392ef5b2a}": {
        readonly name: 'nsIProfiler';
        readonly interface: nsIProfilerType;
    };
    "{}": {
        readonly name: 'nsIProgressEventSink';
        readonly interface: nsIProgressEventSinkType;
    };
    "{}": {
        readonly name: 'nsIPrompt';
        readonly interface: nsIPromptType;
    };
    "{7913837c-9623-11ea-bb37-0242ac130002}": {
        readonly name: 'nsIPromptCollection';
        readonly interface: nsIPromptCollectionType;
    };
    "{2803541c-c96a-4ff1-bd7c-9cb566d46aeb}": {
        readonly name: 'nsIPromptFactory';
        readonly interface: nsIPromptFactoryType;
    };
    "{889842e9-052c-46c9-99f3-f4a426571e38}": {
        readonly name: 'nsIPromptInstance';
        readonly interface: nsIPromptInstanceType;
    };
    "{404ebfa2-d8f4-4c94-8416-e65a55f9df5a}": {
        readonly name: 'nsIPromptService';
        readonly interface: nsIPromptServiceType;
    };
    "{78650582-4e93-4b60-8e85-26ebd3eb14ca}": {
        readonly name: 'nsIProperties';
        readonly interface: nsIPropertiesType;
    };
    "{6dcf9030-a49f-11d5-910d-0010a4e73d9a}": {
        readonly name: 'nsIProperty';
        readonly interface: nsIPropertyType;
    };
    "{bfcd37b0-a49f-11d5-910d-0010a4e73d9a}": {
        readonly name: 'nsIPropertyBag';
        readonly interface: nsIPropertyBagType;
    };
    "{625cfd1e-da1e-4417-9ee9-dbc8e0b3fd79}": {
        readonly name: 'nsIPropertyBag2';
        readonly interface: nsIPropertyBag2Type;
    };
    "{}": {
        readonly name: 'nsIProtectedAuthThread';
        readonly interface: nsIProtectedAuthThreadType;
    };
    "{65a8e823-0591-4fc0-a56a-03265e0a4ce8}": {
        readonly name: 'nsIProtocolHandlerWithDynamicFlags';
        readonly interface: nsIProtocolHandlerWithDynamicFlagsType;
    };
    "{a87210e6-7c8c-41f7-864d-df809015193e}": {
        readonly name: 'nsIProtocolHandler';
        readonly interface: nsIProtocolHandlerType;
    };
    "{}": {
        readonly name: 'nsIProtocolProxyCallback';
        readonly interface: nsIProtocolProxyCallbackType;
    };
    "{009E6C3F-FB64-40C5-8093-F1495C64773E}": {
        readonly name: 'nsIProxyProtocolFilterResult';
        readonly interface: nsIProxyProtocolFilterResultType;
    };
    "{}": {
        readonly name: 'nsIProtocolProxyFilter';
        readonly interface: nsIProtocolProxyFilterType;
    };
    "{}": {
        readonly name: 'nsIProtocolProxyChannelFilter';
        readonly interface: nsIProtocolProxyChannelFilterType;
    };
    "{77984234-aad5-47fc-a412-03398c2134a5}": {
        readonly name: 'nsIProxyConfigChangedCallback';
        readonly interface: nsIProxyConfigChangedCallbackType;
    };
    "{ef57c8b6-e09d-4cd4-9222-2a5d2402e15d}": {
        readonly name: 'nsIProtocolProxyService';
        readonly interface: nsIProtocolProxyServiceType;
    };
    "{b2e5b2c0-e21e-4845-b336-be6d60a38951}": {
        readonly name: 'nsIProtocolProxyService2';
        readonly interface: nsIProtocolProxyService2Type;
    };
    "{6238f134-8c3f-4354-958f-dfd9d54a4446}": {
        readonly name: 'nsIProxiedChannel';
        readonly interface: nsIProxiedChannelType;
    };
    "{3756047a-fa2b-4b45-9948-3b5f8fc375e7}": {
        readonly name: 'nsIProxiedProtocolHandler';
        readonly interface: nsIProxiedProtocolHandlerType;
    };
    "{}": {
        readonly name: 'nsIProxyInfo';
        readonly interface: nsIProxyInfoType;
    };
    "{f64432b9-e8c6-41b4-b2da-8eb004344bba}": {
        readonly name: 'nsIPublicKeyPinningService';
        readonly interface: nsIPublicKeyPinningServiceType;
    };
    "{cd68d61e-9a44-402d-9671-838ac0872176}": {
        readonly name: 'nsIPurgeTrackerService';
        readonly interface: nsIPurgeTrackerServiceType;
    };
    "{b58249f9-1a04-48cc-bc20-2c992d64c73e}": {
        readonly name: 'nsIPushErrorReporter';
        readonly interface: nsIPushErrorReporterType;
    };
    "{b00dfdeb-14e5-425b-adc7-b531442e3216}": {
        readonly name: 'nsIPushNotifier';
        readonly interface: nsIPushNotifierType;
    };
    "{dfc4f151-cead-40df-8eb7-7a7a67c54b16}": {
        readonly name: 'nsIPushData';
        readonly interface: nsIPushDataType;
    };
    "{b9d063ca-0e3f-4fee-be4b-ea9103263433}": {
        readonly name: 'nsIPushMessage';
        readonly interface: nsIPushMessageType;
    };
    "{1de32d5c-ea88-4c9e-9626-b032bd87f415}": {
        readonly name: 'nsIPushSubscription';
        readonly interface: nsIPushSubscriptionType;
    };
    "{1799c074-9d52-46b0-ab3c-c09790732f6f}": {
        readonly name: 'nsIPushSubscriptionCallback';
        readonly interface: nsIPushSubscriptionCallbackType;
    };
    "{d574118f-61a9-4270-b1f6-4461aa85c4f5}": {
        readonly name: 'nsIUnsubscribeResultCallback';
        readonly interface: nsIUnsubscribeResultCallbackType;
    };
    "{bd47b38e-8bfa-4f92-834e-832a4431e05e}": {
        readonly name: 'nsIPushClearResultCallback';
        readonly interface: nsIPushClearResultCallbackType;
    };
    "{678ef584-bf25-47aa-ac84-03efc0865b68}": {
        readonly name: 'nsIPushService';
        readonly interface: nsIPushServiceType;
    };
    "{a2555e70-46f8-4b52-bf02-d978b979d143}": {
        readonly name: 'nsIPushQuotaManager';
        readonly interface: nsIPushQuotaManagerType;
    };
    "{e2c39e0e-345f-451a-a7b2-e0230d555847}": {
        readonly name: 'nsIQueryContentEventResult';
        readonly interface: nsIQueryContentEventResultType;
    };
    "{}": {
        readonly name: 'nsIQuotaUsageCallback';
        readonly interface: nsIQuotaUsageCallbackType;
    };
    "{}": {
        readonly name: 'nsIQuotaCallback';
        readonly interface: nsIQuotaCallbackType;
    };
    "{1b3d0a38-8151-4cf9-89fa-4f92c2ef0e7e}": {
        readonly name: 'nsIQuotaManagerService';
        readonly interface: nsIQuotaManagerServiceType;
    };
    "{9af54222-0407-48fd-a4ab-9457c986fc49}": {
        readonly name: 'nsIQuotaRequestBase';
        readonly interface: nsIQuotaRequestBaseType;
    };
    "{166e28e6-cf6d-4927-a6d7-b51bca9d3469}": {
        readonly name: 'nsIQuotaUsageRequest';
        readonly interface: nsIQuotaUsageRequestType;
    };
    "{22890e3e-ff25-4372-9684-d901060e2f6c}": {
        readonly name: 'nsIQuotaRequest';
        readonly interface: nsIQuotaRequestType;
    };
    "{4d8def75-014e-404d-bf30-e2f0Bfcf4d89}": {
        readonly name: 'nsIQuotaFullOriginMetadataResult';
        readonly interface: nsIQuotaFullOriginMetadataResultType;
    };
    "{d8c9328b-9aa8-4f5d-90e6-482de4a6d5b8}": {
        readonly name: 'nsIQuotaUsageResult';
        readonly interface: nsIQuotaUsageResultType;
    };
    "{96df03d2-116a-493f-bb0b-118c212a6b32}": {
        readonly name: 'nsIQuotaOriginUsageResult';
        readonly interface: nsIQuotaOriginUsageResultType;
    };
    "{9827fc69-7ea9-48ef-b30d-2e2ae0451ec0}": {
        readonly name: 'nsIQuotaEstimateResult';
        readonly interface: nsIQuotaEstimateResultType;
    };
    "{4d963475-8b16-4c58-b804-8a23d49436c5}": {
        readonly name: 'nsIRaceCacheWithNetwork';
        readonly interface: nsIRaceCacheWithNetworkType;
    };
    "{9b5904a8-886a-420f-a1d8-847de8ffc133}": {
        readonly name: 'nsIRandomAccessStream';
        readonly interface: nsIRandomAccessStreamType;
    };
    "{2362d97a-747a-4576-8863-697667309209}": {
        readonly name: 'nsIRandomGenerator';
        readonly interface: nsIRandomGeneratorType;
    };
    "{12f7d302-5368-412d-bdc9-26d151518e6c}": {
        readonly name: 'nsIRddProcessTest';
        readonly interface: nsIRddProcessTestType;
    };
    "{efa36ea2-5b07-46fc-9534-a5acb8b77b72}": {
        readonly name: 'nsIRedirectChannelRegistrar';
        readonly interface: nsIRedirectChannelRegistrarType;
    };
    "{133b2905-0eba-411c-a8bb-f59787142aa2}": {
        readonly name: 'nsIRedirectHistoryEntry';
        readonly interface: nsIRedirectHistoryEntryType;
    };
    "{85cd2640-e91e-41ac-bdca-1dbf10dc131e}": {
        readonly name: 'nsIRedirectResultListener';
        readonly interface: nsIRedirectResultListenerType;
    };
    "{}": {
        readonly name: 'nsIReferrerInfo';
        readonly interface: nsIReferrerInfoType;
    };
    "{832e692c-c4a6-11e2-8fd1-dce678957a39}": {
        readonly name: 'nsIReflowObserver';
        readonly interface: nsIReflowObserverType;
    };
    "{a5e61a3c-51bd-45be-ac0c-e87b71860656}": {
        readonly name: 'nsIRefreshURI';
        readonly interface: nsIRefreshURIType;
    };
    "{21e6d094-e016-41a4-80cd-76d2e20871aa}": {
        readonly name: 'nsIRegion';
        readonly interface: nsIRegionType;
    };
    "{2f977d4e-5485-11d4-87e2-0010a4e75ef2}": {
        readonly name: 'nsIRelativeFilePref';
        readonly interface: nsIRelativeFilePrefType;
    };
    "{8f685a9d-8181-46d6-a71d-869289099c6d}": {
        readonly name: 'nsIRemoteAgent';
        readonly interface: nsIRemoteAgentType;
    };
    "{}": {
        readonly name: 'nsIRemoteTab';
        readonly interface: nsIRemoteTabType;
    };
    "{}": {
        readonly name: 'nsIRequest';
        readonly interface: nsIRequestType;
    };
    "{7EB361D4-37A5-42C9-AFAE-F6C88FE7C394}": {
        readonly name: 'nsIRequestTailUnblockCallback';
        readonly interface: nsIRequestTailUnblockCallbackType;
    };
    "{658e3e6e-8633-4b1a-8d66-fa9f72293e63}": {
        readonly name: 'nsIRequestContext';
        readonly interface: nsIRequestContextType;
    };
    "{7fcbf4da-d828-4acc-b144-e5435198f727}": {
        readonly name: 'nsIRequestContextService';
        readonly interface: nsIRequestContextServiceType;
    };
    "{}": {
        readonly name: 'nsIRequestObserver';
        readonly interface: nsIRequestObserverType;
    };
    "{c2b06151-1bf8-4eef-aea9-1532f12f5a10}": {
        readonly name: 'nsIRequestObserverProxy';
        readonly interface: nsIRequestObserverProxyType;
    };
    "{241d34ac-9ed5-46d7-910c-7a9d914aa0c5}": {
        readonly name: 'nsIResProtocolHandler';
        readonly interface: nsIResProtocolHandlerType;
    };
    "{4ad136fa-83af-4a22-a76e-503642c0f4a8}": {
        readonly name: 'nsIResumableChannel';
        readonly interface: nsIResumableChannelType;
    };
    "{}": {
        readonly name: 'nsIRunnable';
        readonly interface: nsIRunnableType;
    };
    "{e75aa42a-80a9-11e6-afb5-e89d87348e2c}": {
        readonly name: 'nsIRunnablePriority';
        readonly interface: nsIRunnablePriorityType;
    };
    "{3114c36c-a482-4c6e-9523-1dcfc6f605b9}": {
        readonly name: 'nsIRunnableIPCMessageType';
        readonly interface: nsIRunnableIPCMessageTypeType;
    };
    "{}": {
        readonly name: 'nsISDBCallback';
        readonly interface: nsISDBCallbackType;
    };
    "{}": {
        readonly name: 'nsISDBCloseCallback';
        readonly interface: nsISDBCloseCallbackType;
    };
    "{ea420fdd-548f-44f9-9286-59aad6a40f01}": {
        readonly name: 'nsISDBConnection';
        readonly interface: nsISDBConnectionType;
    };
    "{13f05bcf-715c-427e-aac8-df9b2c1ec1e3}": {
        readonly name: 'nsISDBRequest';
        readonly interface: nsISDBRequestType;
    };
    "{bca19e01-b34e-4a48-8875-2f4cb871febf}": {
        readonly name: 'nsISDBResult';
        readonly interface: nsISDBResultType;
    };
    "{}": {
        readonly name: 'nsISHEntry';
        readonly interface: nsISHEntryType;
    };
    "{}": {
        readonly name: 'nsISHistory';
        readonly interface: nsISHistoryType;
    };
    "{125c0833-746a-400e-9b89-d2d18545c08a}": {
        readonly name: 'nsISHistoryListener';
        readonly interface: nsISHistoryListenerType;
    };
    "{5f914307-5c34-4e1f-8e32-ec749d25b27a}": {
        readonly name: 'nsISafeOutputStream';
        readonly interface: nsISafeOutputStreamType;
    };
    "{826e80c8-d70f-42e2-8aa9-82c05f2a370a}": {
        readonly name: 'nsIScreen';
        readonly interface: nsIScreenType;
    };
    "{e8a96e60-6b61-4a14-bacc-53891604b502}": {
        readonly name: 'nsIScreenManager';
        readonly interface: nsIScreenManagerType;
    };
    "{33234b99-9588-4c7d-9da6-86b8b7cba565}": {
        readonly name: 'nsIScriptChannel';
        readonly interface: nsIScriptChannelType;
    };
    "{e8933fc9-c302-4e12-a55b-4f88611d9c6c}": {
        readonly name: 'nsIScriptErrorNote';
        readonly interface: nsIScriptErrorNoteType;
    };
    "{63eb4d3e-7d99-4150-b4f3-11314f9d82a9}": {
        readonly name: 'nsIScriptError';
        readonly interface: nsIScriptErrorType;
    };
    "{7b787204-76fb-4764-96f1-fb7a666db4f4}": {
        readonly name: 'nsIScriptLoaderObserver';
        readonly interface: nsIScriptLoaderObserverType;
    };
    "{51daad87-3a0c-44cc-b620-7356801c9022}": {
        readonly name: 'nsIScriptSecurityManager';
        readonly interface: nsIScriptSecurityManagerType;
    };
    "{9479c864-d1f9-45ab-b7b9-28b907bd2ba9}": {
        readonly name: 'nsIScriptableBase64Encoder';
        readonly interface: nsIScriptableBase64EncoderType;
    };
    "{9f25fb2a-265f-44f9-a122-62bbf443239e}": {
        readonly name: 'nsIScriptableContentIterator';
        readonly interface: nsIScriptableContentIteratorType;
    };
    "{3fce9015-472a-4080-ac3e-cd875dbe361e}": {
        readonly name: 'nsIScriptableInputStream';
        readonly interface: nsIScriptableInputStreamType;
    };
    "{f36ee324-5c1c-437f-ba10-2b4db7a18031}": {
        readonly name: 'nsIScriptableUnicodeConverter';
        readonly interface: nsIScriptableUnicodeConverterType;
    };
    "{5799251f-5b55-4df7-a9e7-0c27812c469a}": {
        readonly name: 'nsISearchSubmission';
        readonly interface: nsISearchSubmissionType;
    };
    "{620bd920-0491-48c8-99a8-d6047e64802d}": {
        readonly name: 'nsISearchEngine';
        readonly interface: nsISearchEngineType;
    };
    "{0dc93e51-a7bf-4a16-862d-4b3469ff6206}": {
        readonly name: 'nsISearchParseSubmissionResult';
        readonly interface: nsISearchParseSubmissionResultType;
    };
    "{0301834b-2630-440e-8b98-db8dc55f34b9}": {
        readonly name: 'nsISearchService';
        readonly interface: nsISearchServiceType;
    };
    "{9446c5d5-c9fb-4a6e-acf9-ca4fc666efe0}": {
        readonly name: 'nsISecCheckWrapChannel';
        readonly interface: nsISecCheckWrapChannelType;
    };
    "{0EC80360-075C-11d4-9FD4-00C04F1B83D8}": {
        readonly name: 'nsISecretDecoderRing';
        readonly interface: nsISecretDecoderRingType;
    };
    "{718c662a-f810-4a80-a6c9-0b1810ecade2}": {
        readonly name: 'nsISecureBrowserUI';
        readonly interface: nsISecureBrowserUIType;
    };
    "{FE9FC9B6-DDE2-11E2-A8F1-0A326188709B}": {
        readonly name: 'nsISecurityConsoleMessage';
        readonly interface: nsISecurityConsoleMessageType;
    };
    "{5d1acf82-223a-46fb-a8f3-a1b16e2ceb04}": {
        readonly name: 'nsISecurityUITelemetry';
        readonly interface: nsISecurityUITelemetryType;
    };
    "{8429d350-1040-4661-8b71-f2a6ba455980}": {
        readonly name: 'nsISeekableStream';
        readonly interface: nsISeekableStreamType;
    };
    "{3801c9d4-8e69-4bfc-9edb-b58278621f8f}": {
        readonly name: 'nsISelectionController';
        readonly interface: nsISelectionControllerType;
    };
    "{0DDF9E1C-1DD2-11B2-A183-908A08AA75AE}": {
        readonly name: 'nsISelectionDisplay';
        readonly interface: nsISelectionDisplayType;
    };
    "{45686299-ae2b-46bc-9502-c56c35691ab9}": {
        readonly name: 'nsISelectionListener';
        readonly interface: nsISelectionListenerType;
    };
    "{a5761968-6e1a-4f2d-8191-ec749602b178}": {
        readonly name: 'nsISensitiveInfoHiddenURI';
        readonly interface: nsISensitiveInfoHiddenURIType;
    };
    "{}": {
        readonly name: 'nsISerialEventTarget';
        readonly interface: nsISerialEventTargetType;
    };
    "{}": {
        readonly name: 'nsISerializable';
        readonly interface: nsISerializableType;
    };
    "{31654c0f-35f3-44c6-b31e-37a11516e6bc}": {
        readonly name: 'nsISerializationHelper';
        readonly interface: nsISerializationHelperType;
    };
    "{7a9c39cb-a13f-4eef-9bdf-a74301628742}": {
        readonly name: 'nsIServerSocket';
        readonly interface: nsIServerSocketType;
    };
    "{836d98ec-fee2-4bde-b609-abd5e966eabd}": {
        readonly name: 'nsIServerSocketListener';
        readonly interface: nsIServerSocketListenerType;
    };
    "{8bb35ed9-e332-462d-9155-4a002ab5c958}": {
        readonly name: 'nsIServiceManager';
        readonly interface: nsIServiceManagerType;
    };
    "{52ee2c9d-ee87-4caf-9588-23ae77ff8798}": {
        readonly name: 'nsIServiceWorkerUnregisterCallback';
        readonly interface: nsIServiceWorkerUnregisterCallbackType;
    };
    "{76e357ed-208d-4e4c-9165-1c4059707879}": {
        readonly name: 'nsIServiceWorkerInfo';
        readonly interface: nsIServiceWorkerInfoType;
    };
    "{87e63548-d440-4b8a-b158-65ad1de0211E}": {
        readonly name: 'nsIServiceWorkerRegistrationInfoListener';
        readonly interface: nsIServiceWorkerRegistrationInfoListenerType;
    };
    "{ddbc1fd4-2f2e-4fca-a395-6e010bbedfe3}": {
        readonly name: 'nsIServiceWorkerRegistrationInfo';
        readonly interface: nsIServiceWorkerRegistrationInfoType;
    };
    "{9e523e7c-ad6f-4df0-8077-c74aebbc679d}": {
        readonly name: 'nsIServiceWorkerManagerListener';
        readonly interface: nsIServiceWorkerManagerListenerType;
    };
    "{7404c8e8-4d47-4449-8ed1-47d1261d4e33}": {
        readonly name: 'nsIServiceWorkerManager';
        readonly interface: nsIServiceWorkerManagerType;
    };
    "{3b95dd6c-0293-4e06-baeb-2affaefc9e74}": {
        readonly name: 'nsISessionStorageService';
        readonly interface: nsISessionStorageServiceType;
    };
    "{cd9f33c5-460d-4bbf-a459-f375ca9566d8}": {
        readonly name: 'nsISessionStoreRestoreData';
        readonly interface: nsISessionStoreRestoreDataType;
    };
    "{1201d357-8417-4926-a694-e6408fbedcf8}": {
        readonly name: 'nsISharePicker';
        readonly interface: nsISharePickerType;
    };
    "{7111f769-53ec-41fd-b314-613661d5b6ba}": {
        readonly name: 'nsISharingHandlerApp';
        readonly interface: nsISharingHandlerAppType;
    };
    "{2d1a95e4-5bd8-4eeb-b0a8-c1455fd2a357}": {
        readonly name: 'nsIShellService';
        readonly interface: nsIShellServiceType;
    };
    "{}": {
        readonly name: 'nsIJSEnumerator';
        readonly interface: nsIJSEnumeratorType;
    };
    "{796f340d-0a2a-490b-9c60-640765e99782}": {
        readonly name: 'nsISimpleEnumeratorBase';
        readonly interface: nsISimpleEnumeratorBaseType;
    };
    "{}": {
        readonly name: 'nsISimpleEnumerator';
        readonly interface: nsISimpleEnumeratorType;
    };
    "{a9b84f6a-0824-4278-bae6-bfca0570a26e}": {
        readonly name: 'nsISimpleStreamListener';
        readonly interface: nsISimpleStreamListenerType;
    };
    "{e055bddd-f3c2-404b-adec-db9304e93be2}": {
        readonly name: 'nsISimpleURIMutator';
        readonly interface: nsISimpleURIMutatorType;
    };
    "{275127f8-dbd7-4681-afbf-6df0c6587a01}": {
        readonly name: 'nsISiteSecurityService';
        readonly interface: nsISiteSecurityServiceType;
    };
    "{f7dbb80c-5d1e-4fd9-b55c-a9ffda4a75b1}": {
        readonly name: 'nsISlowScriptDebugCallback';
        readonly interface: nsISlowScriptDebugCallbackType;
    };
    "{b1c6ecd0-8fa4-11e4-b4a9-0800200c9a66}": {
        readonly name: 'nsISlowScriptDebuggerStartupCallback';
        readonly interface: nsISlowScriptDebuggerStartupCallbackType;
    };
    "{dbee14b0-8fa0-11e4-b4a9-0800200c9a66}": {
        readonly name: 'nsISlowScriptDebugRemoteCallback';
        readonly interface: nsISlowScriptDebugRemoteCallbackType;
    };
    "{f75d4164-3aa7-4395-ba44-a5f95b2e8427}": {
        readonly name: 'nsISlowScriptDebug';
        readonly interface: nsISlowScriptDebugType;
    };
    "{afe2c40c-b9b9-4207-b898-e5cde18c6139}": {
        readonly name: 'nsISocketFilter';
        readonly interface: nsISocketFilterType;
    };
    "{81ee76c6-4753-4125-9c8c-290ed9ba62fb}": {
        readonly name: 'nsISocketFilterHandler';
        readonly interface: nsISocketFilterHandlerType;
    };
    "{}": {
        readonly name: 'nsISocketProvider';
        readonly interface: nsISocketProviderType;
    };
    "{8f8a23d0-5472-11d3-bbc8-0000861d1237}": {
        readonly name: 'nsISocketProviderService';
        readonly interface: nsISocketProviderServiceType;
    };
    "{}": {
        readonly name: 'nsISocketTransport';
        readonly interface: nsISocketTransportType;
    };
    "{338947df-2f3b-4d24-9ce4-ecf161c1b7df}": {
        readonly name: 'nsISTSShutdownObserver';
        readonly interface: nsISTSShutdownObserverType;
    };
    "{ad56b25f-e6bb-4db3-9f7b-5b7db33fd2b1}": {
        readonly name: 'nsISocketTransportService';
        readonly interface: nsISocketTransportServiceType;
    };
    "{c5204623-5b58-4a16-8b2e-67c34dd02e3f}": {
        readonly name: 'nsIRoutedSocketTransportService';
        readonly interface: nsIRoutedSocketTransportServiceType;
    };
    "{C3C28D92-A17F-43DF-976D-4EEAE6F995FC}": {
        readonly name: 'nsISound';
        readonly interface: nsISoundType;
    };
    "{d74a17ac-5b8a-4824-a309-b1f04a3c4aed}": {
        readonly name: 'nsISpeculativeConnect';
        readonly interface: nsISpeculativeConnectType;
    };
    "{1040ebe3-6ed1-45a6-8587-995e082518d7}": {
        readonly name: 'nsISpeculativeConnectionOverrider';
        readonly interface: nsISpeculativeConnectionOverriderType;
    };
    "{6fcb6ee8-a6db-49ba-9f06-355d7ee18ea7}": {
        readonly name: 'nsISpeechGrammarCompilationCallback';
        readonly interface: nsISpeechGrammarCompilationCallbackType;
    };
    "{8e97f287-f322-44e8-8888-8344fa408ef8}": {
        readonly name: 'nsISpeechRecognitionService';
        readonly interface: nsISpeechRecognitionServiceType;
    };
    "{c576de0c-8a3d-4570-be7e-9876d3e5bed2}": {
        readonly name: 'nsISpeechTaskCallback';
        readonly interface: nsISpeechTaskCallbackType;
    };
    "{ad59949c-2437-4b35-8eeb-d760caab75c5}": {
        readonly name: 'nsISpeechTask';
        readonly interface: nsISpeechTaskType;
    };
    "{}": {
        readonly name: 'nsISpeechService';
        readonly interface: nsISpeechServiceType;
    };
    "{7F7201EB-510C-4CEF-BDF0-04A15A7A4A8C}": {
        readonly name: 'nsIStandaloneNativeMenu';
        readonly interface: nsIStandaloneNativeMenuType;
    };
    "{babd6cca-ebe7-4329-967c-d6b9e33caa81}": {
        readonly name: 'nsIStandardURL';
        readonly interface: nsIStandardURLType;
    };
    "{fc894e98-23a1-43cd-a7fe-72876f8ea2ee}": {
        readonly name: 'nsIStandardURLMutator';
        readonly interface: nsIStandardURLMutatorType;
    };
    "{a6b2f8b0-7438-11ea-bc55-0242ac130003}": {
        readonly name: 'nsIStartupCacheInfo';
        readonly interface: nsIStartupCacheInfoType;
    };
    "{fd1310ba-d1be-4327-988e-92b39fcff6f4}": {
        readonly name: 'nsIStorageActivityService';
        readonly interface: nsIStorageActivityServiceType;
    };
    "{44a200fe-6c2b-4b41-b4e3-63e8c14e7c0d}": {
        readonly name: 'nsIStorageStream';
        readonly interface: nsIStorageStreamType;
    };
    "{ac923b72-ac87-4892-ac7a-ca385d429435}": {
        readonly name: 'nsIStreamBufferAccess';
        readonly interface: nsIStreamBufferAccessType;
    };
    "{0b6e2c69-5cf5-48b0-9dfd-c95950e2cc7b}": {
        readonly name: 'nsIStreamConverter';
        readonly interface: nsIStreamConverterType;
    };
    "{f2b1ab53-f0bd-4adb-9365-e59b1701a258}": {
        readonly name: 'nsIStreamConverterService';
        readonly interface: nsIStreamConverterServiceType;
    };
    "{}": {
        readonly name: 'nsIStreamListener';
        readonly interface: nsIStreamListenerType;
    };
    "{62b27fc1-6e8c-4225-8ad0-b9d44252973a}": {
        readonly name: 'nsIStreamListenerTee';
        readonly interface: nsIStreamListenerTeeType;
    };
    "{359F7990-D4E9-11d3-A1A5-0050041CAF44}": {
        readonly name: 'nsIStreamLoaderObserver';
        readonly interface: nsIStreamLoaderObserverType;
    };
    "{323bcff1-7513-4e1f-a541-1c9213c2ed1b}": {
        readonly name: 'nsIStreamLoader';
        readonly interface: nsIStreamLoaderType;
    };
    "{5e0adf7d-9785-45c3-a193-04f25a75da8f}": {
        readonly name: 'nsIStreamTransportService';
        readonly interface: nsIStreamTransportServiceType;
    };
    "{ff2da731-44d0-4dd9-8236-c99387fec721}": {
        readonly name: 'nsIInputAvailableCallback';
        readonly interface: nsIInputAvailableCallbackType;
    };
    "{D85A17C2-AA7C-11d2-9B8C-00805F8A16D9}": {
        readonly name: 'nsIStringBundle';
        readonly interface: nsIStringBundleType;
    };
    "{D85A17C0-AA7C-11d2-9B8C-00805F8A16D9}": {
        readonly name: 'nsIStringBundleService';
        readonly interface: nsIStringBundleServiceType;
    };
    "{f5213d15-a4d1-4fb7-8a48-d69ccb7fb0eb}": {
        readonly name: 'nsIStringEnumeratorBase';
        readonly interface: nsIStringEnumeratorBaseType;
    };
    "{}": {
        readonly name: 'nsIStringEnumerator';
        readonly interface: nsIStringEnumeratorType;
    };
    "{}": {
        readonly name: 'nsIUTF8StringEnumerator';
        readonly interface: nsIUTF8StringEnumeratorType;
    };
    "{450cd2d4-f0fd-424d-b365-b1251f80fd53}": {
        readonly name: 'nsIStringInputStream';
        readonly interface: nsIStringInputStreamType;
    };
    "{c664aae7-0d67-4155-a2dd-a3861778626f}": {
        readonly name: 'nsIStructuredCloneContainer';
        readonly interface: nsIStructuredCloneContainerType;
    };
    "{7072853f-215b-4a8a-92e5-9732bccc377b}": {
        readonly name: 'nsISFVBareItem';
        readonly interface: nsISFVBareItemType;
    };
    "{843eea44-990a-422c-bbf2-2aa4ba9ee4d2}": {
        readonly name: 'nsISFVInteger';
        readonly interface: nsISFVIntegerType;
    };
    "{df6a0787-7caa-4fef-b145-08c1104c2fde}": {
        readonly name: 'nsISFVString';
        readonly interface: nsISFVStringType;
    };
    "{d263c6d7-4123-4c39-a121-ccf874a19012}": {
        readonly name: 'nsISFVBool';
        readonly interface: nsISFVBoolType;
    };
    "{1098da8b-b4df-4526-b985-53dbd4160ad2}": {
        readonly name: 'nsISFVDecimal';
        readonly interface: nsISFVDecimalType;
    };
    "{8ad33d52-b9b2-4a17-8aa8-991250fc1214}": {
        readonly name: 'nsISFVToken';
        readonly interface: nsISFVTokenType;
    };
    "{887eaef0-19fe-42bc-9a42-9ff773aa8fea}": {
        readonly name: 'nsISFVByteSeq';
        readonly interface: nsISFVByteSeqType;
    };
    "{b1a397d7-3333-43e7-993a-fbe8ab90ee96}": {
        readonly name: 'nsISFVParams';
        readonly interface: nsISFVParamsType;
    };
    "{6c0399f8-01de-4b25-b339-68e35e8d2e49}": {
        readonly name: 'nsISFVParametrizable';
        readonly interface: nsISFVParametrizableType;
    };
    "{99ac1b56-b5b3-44e7-ad96-db7444aae4b2}": {
        readonly name: 'nsISFVItemOrInnerList';
        readonly interface: nsISFVItemOrInnerListType;
    };
    "{28b9215d-c131-413c-9482-0004a371a5ec}": {
        readonly name: 'nsISFVSerialize';
        readonly interface: nsISFVSerializeType;
    };
    "{abe8826b-6af7-4e54-bd2c-46ab231700ce}": {
        readonly name: 'nsISFVItem';
        readonly interface: nsISFVItemType;
    };
    "{b2e52be2-8488-41b2-9ee2-3c48d92d095c}": {
        readonly name: 'nsISFVInnerList';
        readonly interface: nsISFVInnerListType;
    };
    "{02bb92a6-d1de-449c-b54f-d137f30c613d}": {
        readonly name: 'nsISFVList';
        readonly interface: nsISFVListType;
    };
    "{6642a7fe-7026-4eba-b730-05e230ee3437}": {
        readonly name: 'nsISFVDictionary';
        readonly interface: nsISFVDictionaryType;
    };
    "{049f4be1-2f22-4438-a8da-518552ed390c}": {
        readonly name: 'nsISFVService';
        readonly interface: nsISFVServiceType;
    };
    "{4de68896-e8eb-41de-8237-a797b570ac4a}": {
        readonly name: 'nsIStyleSheetService';
        readonly interface: nsIStyleSheetServiceType;
    };
    "{154c64fd-a69e-4105-89f8-bd7dfe621372}": {
        readonly name: 'nsISubstitutingProtocolHandler';
        readonly interface: nsISubstitutingProtocolHandlerType;
    };
    "{7330650e-1dd2-11b2-a0c2-9ff86ee97bed}": {
        readonly name: 'nsIOutputIterator';
        readonly interface: nsIOutputIteratorType;
    };
    "{85585e12-1dd2-11b2-a930-f6929058269a}": {
        readonly name: 'nsIInputIterator';
        readonly interface: nsIInputIteratorType;
    };
    "{8da01646-1dd2-11b2-98a7-c7009045be7e}": {
        readonly name: 'nsIForwardIterator';
        readonly interface: nsIForwardIteratorType;
    };
    "{948defaa-1dd1-11b2-89f6-8ce81f5ebda9}": {
        readonly name: 'nsIBidirectionalIterator';
        readonly interface: nsIBidirectionalIteratorType;
    };
    "{9bd6fdb0-1dd1-11b2-9101-d15375968230}": {
        readonly name: 'nsIRandomAccessIterator';
        readonly interface: nsIRandomAccessIteratorType;
    };
    "{d0d4b136-1dd1-11b2-9371-f0727ef827c0}": {
        readonly name: 'nsISupportsPrimitive';
        readonly interface: nsISupportsPrimitiveType;
    };
    "{d18290a0-4a1c-11d3-9890-006008962422}": {
        readonly name: 'nsISupportsID';
        readonly interface: nsISupportsIDType;
    };
    "{d65ff270-4a1c-11d3-9890-006008962422}": {
        readonly name: 'nsISupportsCString';
        readonly interface: nsISupportsCStringType;
    };
    "{d79dc970-4a1c-11d3-9890-006008962422}": {
        readonly name: 'nsISupportsString';
        readonly interface: nsISupportsStringType;
    };
    "{ddc3b490-4a1c-11d3-9890-006008962422}": {
        readonly name: 'nsISupportsPRBool';
        readonly interface: nsISupportsPRBoolType;
    };
    "{dec2e4e0-4a1c-11d3-9890-006008962422}": {
        readonly name: 'nsISupportsPRUint8';
        readonly interface: nsISupportsPRUint8Type;
    };
    "{dfacb090-4a1c-11d3-9890-006008962422}": {
        readonly name: 'nsISupportsPRUint16';
        readonly interface: nsISupportsPRUint16Type;
    };
    "{e01dc470-4a1c-11d3-9890-006008962422}": {
        readonly name: 'nsISupportsPRUint32';
        readonly interface: nsISupportsPRUint32Type;
    };
    "{e13567c0-4a1c-11d3-9890-006008962422}": {
        readonly name: 'nsISupportsPRUint64';
        readonly interface: nsISupportsPRUint64Type;
    };
    "{e2563630-4a1c-11d3-9890-006008962422}": {
        readonly name: 'nsISupportsPRTime';
        readonly interface: nsISupportsPRTimeType;
    };
    "{e2b05e40-4a1c-11d3-9890-006008962422}": {
        readonly name: 'nsISupportsChar';
        readonly interface: nsISupportsCharType;
    };
    "{e30d94b0-4a1c-11d3-9890-006008962422}": {
        readonly name: 'nsISupportsPRInt16';
        readonly interface: nsISupportsPRInt16Type;
    };
    "{e36c5250-4a1c-11d3-9890-006008962422}": {
        readonly name: 'nsISupportsPRInt32';
        readonly interface: nsISupportsPRInt32Type;
    };
    "{e3cb0ff0-4a1c-11d3-9890-006008962422}": {
        readonly name: 'nsISupportsPRInt64';
        readonly interface: nsISupportsPRInt64Type;
    };
    "{abeaa390-4ac0-11d3-baea-00805f8a5dd7}": {
        readonly name: 'nsISupportsFloat';
        readonly interface: nsISupportsFloatType;
    };
    "{b32523a0-4ac0-11d3-baea-00805f8a5dd7}": {
        readonly name: 'nsISupportsDouble';
        readonly interface: nsISupportsDoubleType;
    };
    "{995ea724-1dd1-11b2-9211-c21bdd3e7ed0}": {
        readonly name: 'nsISupportsInterfacePointer';
        readonly interface: nsISupportsInterfacePointerType;
    };
    "{aa578b44-abd5-4c19-8b14-36d4de6fdc36}": {
        readonly name: 'nsISupportsPriority';
        readonly interface: nsISupportsPriorityType;
    };
    "{7e1aa658-6e3f-4521-9946-9685a169f764}": {
        readonly name: 'nsISyncStreamListener';
        readonly interface: nsISyncStreamListenerType;
    };
    "{5d7a0b38-77e5-4ee5-897c-ce5db9b85d44}": {
        readonly name: 'nsISynthVoiceRegistry';
        readonly interface: nsISynthVoiceRegistryType;
    };
    "{09a0502b-cedc-4cae-bf7c-35662dbd1249}": {
        readonly name: 'nsISystemInfo';
        readonly interface: nsISystemInfoType;
    };
    "{971591cd-277e-409a-bbf6-0a79879cd307}": {
        readonly name: 'nsISystemProxySettings';
        readonly interface: nsISystemProxySettingsType;
    };
    "{24493180-ee81-4b7c-8b17-9e69480b7b8a}": {
        readonly name: 'nsISystemStatusBar';
        readonly interface: nsISystemStatusBarType;
    };
    "{ac2c4b69-cb79-4767-b1ce-bcf62945cd39}": {
        readonly name: 'nsITCPSocketCallback';
        readonly interface: nsITCPSocketCallbackType;
    };
    "{cc2c30f9-cfaa-4b8a-bd44-c24881981b74}": {
        readonly name: 'nsITLSServerSocket';
        readonly interface: nsITLSServerSocketType;
    };
    "{19668ea4-e5ad-4182-9698-7e890d48f327}": {
        readonly name: 'nsITLSClientStatus';
        readonly interface: nsITLSClientStatusType;
    };
    "{8a93f5d5-eddd-4c62-a4bd-bfd297653184}": {
        readonly name: 'nsITLSServerConnectionInfo';
        readonly interface: nsITLSServerConnectionInfoType;
    };
    "{1f62e1ae-e546-4a38-8917-d428472ed736}": {
        readonly name: 'nsITLSServerSecurityObserver';
        readonly interface: nsITLSServerSecurityObserverType;
    };
    "{418265c8-654e-4fbb-ba62-4eed27de1f03}": {
        readonly name: 'nsITLSSocketControl';
        readonly interface: nsITLSSocketControlType;
    };
    "{e61b5d39-f6d6-4ed3-aead-1213b24c6f27}": {
        readonly name: 'nsITRRSkipReason';
        readonly interface: nsITRRSkipReasonType;
    };
    "{933355f6-1dd2-11b2-a9b0-d335b9e35983}": {
        readonly name: 'nsITXTToHTMLConv';
        readonly interface: nsITXTToHTMLConvType;
    };
    "{4805e684-49b9-11d3-9ce4-ed60bd6cb5bc}": {
        readonly name: 'nsITableEditor';
        readonly interface: nsITableEditorType;
    };
    "{9759bd0e-78e2-4421-9ed1-c676e1af3513}": {
        readonly name: 'nsITaggingService';
        readonly interface: nsITaggingServiceType;
    };
    "{}": {
        readonly name: 'nsITaskbarOverlayIconController';
        readonly interface: nsITaskbarOverlayIconControllerType;
    };
    "{}": {
        readonly name: 'nsITaskbarPreview';
        readonly interface: nsITaskbarPreviewType;
    };
    "{}": {
        readonly name: 'nsITaskbarPreviewButton';
        readonly interface: nsITaskbarPreviewButtonType;
    };
    "{f3744696-320d-4804-9c27-6a84c29acaa6}": {
        readonly name: 'nsITaskbarPreviewCallback';
        readonly interface: nsITaskbarPreviewCallbackType;
    };
    "{}": {
        readonly name: 'nsITaskbarPreviewController';
        readonly interface: nsITaskbarPreviewControllerType;
    };
    "{}": {
        readonly name: 'nsITaskbarProgress';
        readonly interface: nsITaskbarProgressType;
    };
    "{}": {
        readonly name: 'nsITaskbarTabPreview';
        readonly interface: nsITaskbarTabPreviewType;
    };
    "{}": {
        readonly name: 'nsITaskbarWindowPreview';
        readonly interface: nsITaskbarWindowPreviewType;
    };
    "{3d3b9075-5549-4244-9c08-b64fefa1dd60}": {
        readonly name: 'nsIFetchTelemetryDataCallback';
        readonly interface: nsIFetchTelemetryDataCallbackType;
    };
    "{273d2dd0-6c63-475a-b864-cb65160a1909}": {
        readonly name: 'nsITelemetry';
        readonly interface: nsITelemetryType;
    };
    "{ee942946-4538-45d2-bf05-ffdbf5932621}": {
        readonly name: 'nsITellableStream';
        readonly interface: nsITellableStreamType;
    };
    "{}": {
        readonly name: 'nsITextInputProcessor';
        readonly interface: nsITextInputProcessorType;
    };
    "{c0ce1add-82bb-45ab-b99a-42cfba7fd5d7}": {
        readonly name: 'nsITextInputProcessorNotification';
        readonly interface: nsITextInputProcessorNotificationType;
    };
    "{23d5f242-adb5-46f1-8766-90d1bf0383df}": {
        readonly name: 'nsITextInputProcessorCallback';
        readonly interface: nsITextInputProcessorCallbackType;
    };
    "{8B042E24-6F87-11d3-B3C8-00805F8A6670}": {
        readonly name: 'nsITextToSubURI';
        readonly interface: nsITextToSubURIType;
    };
    "{}": {
        readonly name: 'nsIThread';
        readonly interface: nsIThreadType;
    };
    "{a3a72e5f-71d9-4add-8f30-59a78fb6d5eb}": {
        readonly name: 'nsIThreadInternal';
        readonly interface: nsIThreadInternalType;
    };
    "{cc8da053-1776-44c2-9199-b5a629d0a19d}": {
        readonly name: 'nsIThreadObserver';
        readonly interface: nsIThreadObserverType;
    };
    "{039a227d-0cb7-44a5-a8f9-dbb7071979f2}": {
        readonly name: 'nsINestedEventLoopCondition';
        readonly interface: nsINestedEventLoopConditionType;
    };
    "{1be89eca-e2f7-453b-8d38-c11ba247f6f3}": {
        readonly name: 'nsIThreadManager';
        readonly interface: nsIThreadManagerType;
    };
    "{ef194cab-3f86-4b61-b132-e5e96a79e5d1}": {
        readonly name: 'nsIThreadPoolListener';
        readonly interface: nsIThreadPoolListenerType;
    };
    "{76ce99c9-8e43-489a-9789-f27cc4424965}": {
        readonly name: 'nsIThreadPool';
        readonly interface: nsIThreadPoolType;
    };
    "{27b84c48-5a73-4ba4-a8a4-8b5e649a145e}": {
        readonly name: 'nsIThreadRetargetableRequest';
        readonly interface: nsIThreadRetargetableRequestType;
    };
    "{fb2304b8-f82f-4433-af68-d874a2ebbdc1}": {
        readonly name: 'nsIThreadRetargetableStreamListener';
        readonly interface: nsIThreadRetargetableStreamListenerType;
    };
    "{70a43748-6130-4ea6-a440-7c74e1b7dd7c}": {
        readonly name: 'nsIThreadShutdown';
        readonly interface: nsIThreadShutdownType;
    };
    "{6b4b96fe-3c67-4587-af7b-58b6b17da411}": {
        readonly name: 'nsIInputChannelThrottleQueue';
        readonly interface: nsIInputChannelThrottleQueueType;
    };
    "{0a32a100-c031-45b6-9e8b-0444c7d4a143}": {
        readonly name: 'nsIThrottledInputChannel';
        readonly interface: nsIThrottledInputChannelType;
    };
    "{c2d9e95b-9cc9-4f47-9ef6-1de0cf7ebc75}": {
        readonly name: 'nsIServerTiming';
        readonly interface: nsIServerTimingType;
    };
    "{ca63784d-959c-4c3a-9a59-234a2a520de0}": {
        readonly name: 'nsITimedChannel';
        readonly interface: nsITimedChannelType;
    };
    "{}": {
        readonly name: 'nsITimerCallback';
        readonly interface: nsITimerCallbackType;
    };
    "{3de4b105-363c-482c-a409-baac83a01bfc}": {
        readonly name: 'nsITimer';
        readonly interface: nsITimerType;
    };
    "{5482506d-1d21-4d08-b01c-95c87e1295ad}": {
        readonly name: 'nsITimerManager';
        readonly interface: nsITimerManagerType;
    };
    "{b4bbe824-ec4c-48be-9a40-6a7339347f40}": {
        readonly name: 'nsITlsHandshakeCallbackListener';
        readonly interface: nsITlsHandshakeCallbackListenerType;
    };
    "{a1cbc159-468c-495d-8068-61dd538cbcca}": {
        readonly name: 'nsITokenDialogs';
        readonly interface: nsITokenDialogsType;
    };
    "{87dbd64a-4466-474e-95f5-1ad1cee5702c}": {
        readonly name: 'nsITokenPasswordDialogs';
        readonly interface: nsITokenPasswordDialogsType;
    };
    "{8727651c-9530-45a0-b81e-0e0690c30c50}": {
        readonly name: 'nsIToolkitChromeRegistry';
        readonly interface: nsIToolkitChromeRegistryType;
    };
    "{}": {
        readonly name: 'nsIProfileLock';
        readonly interface: nsIProfileLockType;
    };
    "{}": {
        readonly name: 'nsIToolkitProfile';
        readonly interface: nsIToolkitProfileType;
    };
    "{1947899b-f369-48fa-89da-f7c37bb1e6bc}": {
        readonly name: 'nsIToolkitProfileService';
        readonly interface: nsIToolkitProfileServiceType;
    };
    "{9246cad6-926a-4c17-88b0-ecba8078d143}": {
        readonly name: 'nsIToolkitShellService';
        readonly interface: nsIToolkitShellServiceType;
    };
    "{44b78386-1dd2-11b2-9ad2-e4eee2ca1916}": {
        readonly name: 'nsITooltipListener';
        readonly interface: nsITooltipListenerType;
    };
    "{b128a1e6-44f3-4331-8fbe-5af360ff21ee}": {
        readonly name: 'nsITooltipTextProvider';
        readonly interface: nsITooltipTextProviderType;
    };
    "{ea109912-3acc-48de-b679-c23b6a122da5}": {
        readonly name: 'nsITouchBarHelper';
        readonly interface: nsITouchBarHelperType;
    };
    "{001ab07c-1b3a-4dbf-a657-fada0065ff55}": {
        readonly name: 'nsITouchBarInputCallback';
        readonly interface: nsITouchBarInputCallbackType;
    };
    "{77441d17-f29c-49d7-982f-f20a5ab5a900}": {
        readonly name: 'nsITouchBarInput';
        readonly interface: nsITouchBarInputType;
    };
    "{38f396e2-93c9-4a77-aaf7-2d50b9962186}": {
        readonly name: 'nsITouchBarUpdater';
        readonly interface: nsITouchBarUpdaterType;
    };
    "{68167b0b-ef34-4d79-a09a-8045f7c5140e}": {
        readonly name: 'nsITraceableChannel';
        readonly interface: nsITraceableChannelType;
    };
    "{650934db-1939-4424-be26-6ffb0375424d}": {
        readonly name: 'nsITrackingDBService';
        readonly interface: nsITrackingDBServiceType;
    };
    "{58e330c1-7b48-11d2-98b9-00805f297d89}": {
        readonly name: 'nsITransaction';
        readonly interface: nsITransactionType;
    };
    "{c77763df-0fb9-41a8-8074-8e882f605755}": {
        readonly name: 'nsITransactionManager';
        readonly interface: nsITransactionManagerType;
    };
    "{37ec75d3-97ad-4da8-afaa-eabe5b4afd73}": {
        readonly name: 'nsITransfer';
        readonly interface: nsITransferType;
    };
    "{7E225E5F-711C-11D7-9FAE-000393636592}": {
        readonly name: 'nsIFlavorDataProvider';
        readonly interface: nsIFlavorDataProviderType;
    };
    "{97e0c418-1c1e-4106-bad1-9fcb11dff2fe}": {
        readonly name: 'nsITransferable';
        readonly interface: nsITransferableType;
    };
    "{2a8c6334-a5e6-4ec3-9865-1256541446fb}": {
        readonly name: 'nsITransport';
        readonly interface: nsITransportType;
    };
    "{EDA4F520-67F7-484b-A691-8C3226A5B0A6}": {
        readonly name: 'nsITransportEventSink';
        readonly interface: nsITransportEventSinkType;
    };
    "{}": {
        readonly name: 'nsITransportProvider';
        readonly interface: nsITransportProviderType;
    };
    "{}": {
        readonly name: 'nsITransportSecurityInfo';
        readonly interface: nsITransportSecurityInfoType;
    };
    "{}": {
        readonly name: 'nsITreeSelection';
        readonly interface: nsITreeSelectionType;
    };
    "{1bd59678-5cb3-4316-b246-31a91b19aabe}": {
        readonly name: 'nsINativeTreeSelection';
        readonly interface: nsINativeTreeSelectionType;
    };
    "{091116f0-0bdc-4b32-b9c8-c8d5a37cb088}": {
        readonly name: 'nsITreeView';
        readonly interface: nsITreeViewType;
    };
    "{ae501e28-c57f-4692-ac74-410e1bed98b7}": {
        readonly name: 'nsITypeAheadFind';
        readonly interface: nsITypeAheadFindType;
    };
    "{745e1eac-e449-4342-bca1-ee0e6ead09fc}": {
        readonly name: 'nsIU2FTokenManager';
        readonly interface: nsIU2FTokenManagerType;
    };
    "{d423bf4e-4499-40cf-bc03-153e2bf206d1}": {
        readonly name: 'nsIUDPSocket';
        readonly interface: nsIUDPSocketType;
    };
    "{2E4B5DD3-7358-4281-B81F-10C62EF39CB5}": {
        readonly name: 'nsIUDPSocketListener';
        readonly interface: nsIUDPSocketListenerType;
    };
    "{afdc743f-9cc0-40d8-b442-695dc54bbb74}": {
        readonly name: 'nsIUDPMessage';
        readonly interface: nsIUDPMessageType;
    };
    "{99f3d085-3d69-45da-a2c2-a6176af617cb}": {
        readonly name: 'nsIUDPSocketSyncListener';
        readonly interface: nsIUDPSocketSyncListenerType;
    };
    "{613dd3ad-598b-4da9-ad63-bbda50c20098}": {
        readonly name: 'nsIUDPSocketInternal';
        readonly interface: nsIUDPSocketInternalType;
    };
    "{}": {
        readonly name: 'nsIURI';
        readonly interface: nsIURIType;
    };
    "{8face46e-0c96-470f-af40-0037dcd797bd}": {
        readonly name: 'nsIURIClassifierCallback';
        readonly interface: nsIURIClassifierCallbackType;
    };
    "{596620cc-76e3-4133-9d90-360e59a794cf}": {
        readonly name: 'nsIURIClassifier';
        readonly interface: nsIURIClassifierType;
    };
    "{}": {
        readonly name: 'nsIURIContentListener';
        readonly interface: nsIURIContentListenerType;
    };
    "{4819f183-b532-4932-ac09-b309cd853be7}": {
        readonly name: 'nsIURIFixupInfo';
        readonly interface: nsIURIFixupInfoType;
    };
    "{1da7e9d4-620b-4949-849a-1cd6077b1b2d}": {
        readonly name: 'nsIURIFixup';
        readonly interface: nsIURIFixupType;
    };
    "{8762c4e7-be35-4958-9b81-a05685bb516d}": {
        readonly name: 'nsIURILoader';
        readonly interface: nsIURILoaderType;
    };
    "{1fc53257-898b-4c5e-b69c-05bc84b4cd8f}": {
        readonly name: 'nsIURISetSpec';
        readonly interface: nsIURISetSpecType;
    };
    "{5403a6ec-99d7-405e-8b45-9f805bbdfcef}": {
        readonly name: 'nsIURISetters';
        readonly interface: nsIURISettersType;
    };
    "{}": {
        readonly name: 'nsIURIMutator';
        readonly interface: nsIURIMutatorType;
    };
    "{4f65569b-d6fc-4580-94d9-21e775658a2a}": {
        readonly name: 'nsIURIWithSpecialOrigin';
        readonly interface: nsIURIWithSpecialOriginType;
    };
    "{86adcd89-0b70-47a2-b0fe-5bb2c5f37e31}": {
        readonly name: 'nsIURL';
        readonly interface: nsIURLType;
    };
    "{25072eb8-f1e6-482f-9ca9-eddd3d65169a}": {
        readonly name: 'nsIURLMutator';
        readonly interface: nsIURLMutatorType;
    };
    "{937d0c66-6821-4e3f-9e04-50dbc2b2b476}": {
        readonly name: 'nsIURLDecorationAnnotationsService';
        readonly interface: nsIURLDecorationAnnotationsServiceType;
    };
    "{4ab31d30-372d-11db-a98b-0800200c9a66}": {
        readonly name: 'nsIURLFormatter';
        readonly interface: nsIURLFormatterType;
    };
    "{78c5d19f-f5d2-4732-8d3d-d5a7d7133bc0}": {
        readonly name: 'nsIURLParser';
        readonly interface: nsIURLParserType;
    };
    "{6b42a890-2624-4560-99c4-b25380e8cd77}": {
        readonly name: 'nsIURLQueryStringStripper';
        readonly interface: nsIURLQueryStringStripperType;
    };
    "{ef56ae12-b1bb-43e6-b1d8-16459cb98dfd}": {
        readonly name: 'nsIURLQueryStrippingListObserver';
        readonly interface: nsIURLQueryStrippingListObserverType;
    };
    "{afff16f0-3fd2-4153-9ccd-c6d9abd879e4}": {
        readonly name: 'nsIURLQueryStrippingListService';
        readonly interface: nsIURLQueryStrippingListServiceType;
    };
    "{138ad1b2-c694-41cc-b201-333ce936d8b8}": {
        readonly name: 'nsIUUIDGenerator';
        readonly interface: nsIUUIDGeneratorType;
    };
    "{d5e3bd80-6723-4b92-b0c9-22f6162fd94f}": {
        readonly name: 'nsIUnicharInputStream';
        readonly interface: nsIUnicharInputStreamType;
    };
    "{67f42475-ba80-40f8-ac0b-649c89230184}": {
        readonly name: 'nsIUnicharLineInputStream';
        readonly interface: nsIUnicharLineInputStreamType;
    };
    "{2d00b1bb-8b21-4a63-bcc6-7213f513ac2e}": {
        readonly name: 'nsIUnicharOutputStream';
        readonly interface: nsIUnicharOutputStreamType;
    };
    "{dc8fb8a9-3a53-4031-9469-2a5197ea30e7}": {
        readonly name: 'nsIUpdatePatch';
        readonly interface: nsIUpdatePatchType;
    };
    "{e094c045-f4ff-41fd-92da-cd2effd2c7c9}": {
        readonly name: 'nsIUpdate';
        readonly interface: nsIUpdateType;
    };
    "{bff08110-e79f-4a9f-a56c-348170f9208a}": {
        readonly name: 'nsIUpdateCheckResult';
        readonly interface: nsIUpdateCheckResultType;
    };
    "{2620aa24-27aa-463a-b6d2-0734695c1f7a}": {
        readonly name: 'nsIUpdateCheck';
        readonly interface: nsIUpdateCheckType;
    };
    "{877ace25-8bc5-452a-8586-9c1cf2871994}": {
        readonly name: 'nsIUpdateChecker';
        readonly interface: nsIUpdateCheckerType;
    };
    "{1107d207-a263-403a-b268-05772ec10757}": {
        readonly name: 'nsIApplicationUpdateService';
        readonly interface: nsIApplicationUpdateServiceType;
    };
    "{74439497-d796-4915-8cef-3dfe43027e4d}": {
        readonly name: 'nsIUpdateProcessor';
        readonly interface: nsIUpdateProcessorType;
    };
    "{cf4c4487-66d9-4e18-a2e9-39002245332f}": {
        readonly name: 'nsIUpdateSyncManager';
        readonly interface: nsIUpdateSyncManagerType;
    };
    "{0f1098e9-a447-4af9-b030-6f8f35c85f89}": {
        readonly name: 'nsIUpdateManager';
        readonly interface: nsIUpdateManagerType;
    };
    "{0765c92c-6145-4253-9db4-594d8023087e}": {
        readonly name: 'nsIUpdateTimerManager';
        readonly interface: nsIUpdateTimerManagerType;
    };
    "{5cfe15bd-5adb-4a7f-9e55-4f5a67d15794}": {
        readonly name: 'nsIUploadChannel';
        readonly interface: nsIUploadChannelType;
    };
    "{2f712b52-19c5-4e0c-9e8f-b5c7c3b67049}": {
        readonly name: 'nsIUploadChannel2';
        readonly interface: nsIUploadChannel2Type;
    };
    "{4ca27b6b-a674-4b3d-ab30-d21e2da2dffb}": {
        readonly name: 'nsIUrlClassifierCallback';
        readonly interface: nsIUrlClassifierCallbackType;
    };
    "{9fa11561-5816-4e1b-bcc9-b629ca05cce6}": {
        readonly name: 'nsIUrlClassifierUpdateObserver';
        readonly interface: nsIUrlClassifierUpdateObserverType;
    };
    "{7a258022-6765-11e5-b379-b37b1f2354be}": {
        readonly name: 'nsIUrlClassifierDBService';
        readonly interface: nsIUrlClassifierDBServiceType;
    };
    "{b903dc8f-dff1-42fe-894b-36e7a59bb801}": {
        readonly name: 'nsIUrlClassifierLookupCallback';
        readonly interface: nsIUrlClassifierLookupCallbackType;
    };
    "{091adf98-28a5-473d-8dec-5b34b4e62496}": {
        readonly name: 'nsIUrlClassifierClassifyCallback';
        readonly interface: nsIUrlClassifierClassifyCallbackType;
    };
    "{f7c918e5-94bf-4b6e-9758-ef7bdab6af7e}": {
        readonly name: 'nsIUrlClassifierExceptionListObserver';
        readonly interface: nsIUrlClassifierExceptionListObserverType;
    };
    "{75c3d1a3-e977-4079-9e27-b3b56bdb76ea}": {
        readonly name: 'nsIUrlClassifierExceptionListService';
        readonly interface: nsIUrlClassifierExceptionListServiceType;
    };
    "{a6c9b24e-b4f1-426e-af58-2c976c3943a8}": {
        readonly name: 'nsIUrlClassifierFeature';
        readonly interface: nsIUrlClassifierFeatureType;
    };
    "{ccb88140-5d66-4873-9815-a1b98d6cdc92}": {
        readonly name: 'nsIUrlClassifierFeatureResult';
        readonly interface: nsIUrlClassifierFeatureResultType;
    };
    "{2ea83c26-dfc9-44ed-9cfc-171d4753d78e}": {
        readonly name: 'nsIUrlClassifierFeatureCallback';
        readonly interface: nsIUrlClassifierFeatureCallbackType;
    };
    "{aabeb50e-d9f7-418e-9469-2cd9608958c0}": {
        readonly name: 'nsIFullHashMatch';
        readonly interface: nsIFullHashMatchType;
    };
    "{da16de40-df26-414d-bde7-c4faf4504868}": {
        readonly name: 'nsIUrlClassifierHashCompleterCallback';
        readonly interface: nsIUrlClassifierHashCompleterCallbackType;
    };
    "{231fb2ad-ea8a-4e63-a331-eafc3b434811}": {
        readonly name: 'nsIUrlClassifierHashCompleter';
        readonly interface: nsIUrlClassifierHashCompleterType;
    };
    "{b3c27f8c-7db8-4f3f-97a5-5a94d781e565}": {
        readonly name: 'nsIUrlClassifierPositiveCacheEntry';
        readonly interface: nsIUrlClassifierPositiveCacheEntryType;
    };
    "{d6297907-8236-4126-adaf-c3aa239a0d40}": {
        readonly name: 'nsIUrlClassifierCacheEntry';
        readonly interface: nsIUrlClassifierCacheEntryType;
    };
    "{69384f24-d9c5-4462-b24e-351c69e3b46a}": {
        readonly name: 'nsIUrlClassifierCacheInfo';
        readonly interface: nsIUrlClassifierCacheInfoType;
    };
    "{26e12ea4-14ff-4c77-858f-6745998b7659}": {
        readonly name: 'nsIUrlClassifierGetCacheCallback';
        readonly interface: nsIUrlClassifierGetCacheCallbackType;
    };
    "{411bbff4-1b88-4687-aa36-e2bbdd93f6e8}": {
        readonly name: 'nsIUrlClassifierInfo';
        readonly interface: nsIUrlClassifierInfoType;
    };
    "{3d8579f0-75fa-4e00-ba41-38661d5b5d17}": {
        readonly name: 'nsIUrlClassifierPrefixSet';
        readonly interface: nsIUrlClassifierPrefixSetType;
    };
    "{26a445a4-0d00-4b20-ba5f-1297d3344a25}": {
        readonly name: 'nsIUrlClassifierRemoteSettingsService';
        readonly interface: nsIUrlClassifierRemoteSettingsServiceType;
    };
    "{e1797597-f4d6-4dd3-a1e1-745ad352cd80}": {
        readonly name: 'nsIUrlClassifierStreamUpdater';
        readonly interface: nsIUrlClassifierStreamUpdaterType;
    };
    "{fbb9684a-a0aa-11e6-88b0-08606e456b8a}": {
        readonly name: 'nsIUrlClassifierParseFindFullHashCallback';
        readonly interface: nsIUrlClassifierParseFindFullHashCallbackType;
    };
    "{e4f0e59c-b922-48b0-a7b6-1735c1f96fed}": {
        readonly name: 'nsIUrlClassifierUtils';
        readonly interface: nsIUrlClassifierUtilsType;
    };
    "{d60a08ee-5c83-4eb6-bdfb-79fd0716501e}": {
        readonly name: 'nsIUrlListManager';
        readonly interface: nsIUrlListManagerType;
    };
    "{cc52f19a-63ae-4a1c-9cc3-e79eace0b471}": {
        readonly name: 'nsIUserIdleService';
        readonly interface: nsIUserIdleServiceType;
    };
    "{7b89a2e7-ed12-42e0-b86d-4984239abd7b}": {
        readonly name: 'nsIUserIdleServiceInternal';
        readonly interface: nsIUserIdleServiceInternalType;
    };
    "{0a4478f4-c5ae-4fb1-8686-d5b09fb99afb}": {
        readonly name: 'nsIUtilityProcessTest';
        readonly interface: nsIUtilityProcessTestType;
    };
    "{}": {
        readonly name: 'nsIVariant';
        readonly interface: nsIVariantType;
    };
    "{5586a590-8c82-11d5-90f3-0010a4e73d9a}": {
        readonly name: 'nsIWritableVariant';
        readonly interface: nsIWritableVariantType;
    };
    "{e6cd620a-edbb-41d2-9e42-9a2ffc8107f3}": {
        readonly name: 'nsIVersionComparator';
        readonly interface: nsIVersionComparatorType;
    };
    "{3e9800f8-edb7-4c9a-9285-09b4f045b019}": {
        readonly name: 'nsIViewSourceChannel';
        readonly interface: nsIViewSourceChannelType;
    };
    "{e27e57ce-fa63-4035-b9ef-27c5dc0cc3ae}": {
        readonly name: 'nsIWakeLock';
        readonly interface: nsIWakeLockType;
    };
    "{}": {
        readonly name: 'nsIWeakReference';
        readonly interface: nsIWeakReferenceType;
    };
    "{9188bc86-f92e-11d2-81ef-0060083a0bcf}": {
        readonly name: 'nsISupportsWeakReference';
        readonly interface: nsISupportsWeakReferenceType;
    };
    "{2fc8febe-a277-11ed-bda2-8f6495a5e75c}": {
        readonly name: 'nsICtapRegisterArgs';
        readonly interface: nsICtapRegisterArgsType;
    };
    "{2e621cf4-a277-11ed-ae00-bf41a54ef553}": {
        readonly name: 'nsICtapSignArgs';
        readonly interface: nsICtapSignArgsType;
    };
    "{0567c384-a728-11ed-85f7-030324a370f0}": {
        readonly name: 'nsICtapRegisterResult';
        readonly interface: nsICtapRegisterResultType;
    };
    "{91e41be0-ed73-4a10-b55e-3312319bfddf}": {
        readonly name: 'nsIWebAuthnAttObj';
        readonly interface: nsIWebAuthnAttObjType;
    };
    "{05fff816-a728-11ed-b9ac-ff38cc2c8c28}": {
        readonly name: 'nsICtapSignResult';
        readonly interface: nsICtapSignResultType;
    };
    "{c0744f48-ad64-11ed-b515-cf5149f4d6a6}": {
        readonly name: 'nsIWebAuthnController';
        readonly interface: nsIWebAuthnControllerType;
    };
    "{6c4ecd9f-57c0-4d7d-8080-bf6e4d499f8f}": {
        readonly name: 'nsICredentialParameters';
        readonly interface: nsICredentialParametersType;
    };
    "{e236a9b4-a26f-11ed-b6cc-07a9834e19b1}": {
        readonly name: 'nsIWebAuthnTransport';
        readonly interface: nsIWebAuthnTransportType;
    };
    "{}": {
        readonly name: 'nsIWebBrowser';
        readonly interface: nsIWebBrowserType;
    };
    "{}": {
        readonly name: 'nsIWebBrowserChrome';
        readonly interface: nsIWebBrowserChromeType;
    };
    "{947B2EE6-51ED-4C2B-9F45-426C27CA84C6}": {
        readonly name: 'nsIWebBrowserChromeFocus';
        readonly interface: nsIWebBrowserChromeFocusType;
    };
    "{e4920136-b3e0-49e0-b1cd-6c783d2591a8}": {
        readonly name: 'nsIWebBrowserFind';
        readonly interface: nsIWebBrowserFindType;
    };
    "{e0f5d182-34bc-11d5-be5b-b760676c6ebc}": {
        readonly name: 'nsIWebBrowserFindInFrames';
        readonly interface: nsIWebBrowserFindInFramesType;
    };
    "{8cd752a4-60b1-42c3-a819-65c7a1138a28}": {
        readonly name: 'nsIWebBrowserPersist';
        readonly interface: nsIWebBrowserPersistType;
    };
    "{d52e8b93-2771-45e8-a5b0-6e12b667046b}": {
        readonly name: 'nsIWebBrowserPersistURIMap';
        readonly interface: nsIWebBrowserPersistURIMapType;
    };
    "{74aa4918-5d15-46b6-9ccf-74f9696d721d}": {
        readonly name: 'nsIWebBrowserPersistDocument';
        readonly interface: nsIWebBrowserPersistDocumentType;
    };
    "{8ce37706-b7d3-481a-be68-54f174fc0d0a}": {
        readonly name: 'nsIWebBrowserPersistResourceVisitor';
        readonly interface: nsIWebBrowserPersistResourceVisitorType;
    };
    "{a07e6892-38ae-4207-8340-7fa6ec446ed6}": {
        readonly name: 'nsIWebBrowserPersistWriteCompletion';
        readonly interface: nsIWebBrowserPersistWriteCompletionType;
    };
    "{321e3174-594f-4036-b7be-791b821bd376}": {
        readonly name: 'nsIWebBrowserPersistDocumentReceiver';
        readonly interface: nsIWebBrowserPersistDocumentReceiverType;
    };
    "{c9a934ed-fff1-4971-bfba-6c25ad70e1e6}": {
        readonly name: 'nsIWebBrowserPrint';
        readonly interface: nsIWebBrowserPrintType;
    };
    "{3ade79d4-8cb9-4952-b18d-4f9b63ca0d31}": {
        readonly name: 'nsIWebNavigation';
        readonly interface: nsIWebNavigationType;
    };
    "{62a93afb-93a1-465c-84c8-0432264229de}": {
        readonly name: 'nsIWebNavigationInfo';
        readonly interface: nsIWebNavigationInfoType;
    };
    "{6f30b676-3710-4c2c-80b1-0395fb26516e}": {
        readonly name: 'nsIWebPageDescriptor';
        readonly interface: nsIWebPageDescriptorType;
    };
    "{}": {
        readonly name: 'nsIWebProgress';
        readonly interface: nsIWebProgressType;
    };
    "{a9df523b-efe2-421e-9d8e-3d7f807dda4c}": {
        readonly name: 'nsIWebProgressListener';
        readonly interface: nsIWebProgressListenerType;
    };
    "{dde39de0-e4e0-11da-8ad9-0800200c9a66}": {
        readonly name: 'nsIWebProgressListener2';
        readonly interface: nsIWebProgressListener2Type;
    };
    "{1ce9ef8d-f462-49ca-b8e9-c946c4f37d6e}": {
        readonly name: 'nsIWebProtocolHandlerRegistrar';
        readonly interface: nsIWebProtocolHandlerRegistrarType;
    };
    "{ce71d028-322a-4105-a947-a894689b52bf}": {
        readonly name: 'nsIWebSocketChannel';
        readonly interface: nsIWebSocketChannelType;
    };
    "{6714a6be-2265-4f73-a988-d78a12416037}": {
        readonly name: 'nsIWebSocketFrame';
        readonly interface: nsIWebSocketFrameType;
    };
    "{e7c005ab-e694-489b-b741-96db43ffb16f}": {
        readonly name: 'nsIWebSocketEventListener';
        readonly interface: nsIWebSocketEventListenerType;
    };
    "{b89d1b90-2cf3-4d8f-ac21-5aedfb25c760}": {
        readonly name: 'nsIWebSocketEventService';
        readonly interface: nsIWebSocketEventServiceType;
    };
    "{db1f4e2b-3cff-4615-a03c-341fda66c53d}": {
        readonly name: 'nsIWebSocketImpl';
        readonly interface: nsIWebSocketImplType;
    };
    "{d74c96b2-65b3-4e39-9e39-c577de5d7a73}": {
        readonly name: 'nsIWebSocketListener';
        readonly interface: nsIWebSocketListenerType;
    };
    "{c20d6e77-8cb1-4838-a88d-fff826080aa3}": {
        readonly name: 'nsIWebTransport';
        readonly interface: nsIWebTransportType;
    };
    "{0e3cb269-f318-43c8-959e-897f57894b71}": {
        readonly name: 'WebTransportSessionEventListener';
        readonly interface: WebTransportSessionEventListenerType;
    };
    "{c6eeff1d-599b-40a8-9157-c7a40c3d51a2}": {
        readonly name: 'nsIWebTransportStreamCallback';
        readonly interface: nsIWebTransportStreamCallbackType;
    };
    "{ccc3e685-8411-48f0-8b3e-ff6d1fae4809}": {
        readonly name: 'nsIWebTransportSendStreamStats';
        readonly interface: nsIWebTransportSendStreamStatsType;
    };
    "{43ce1145-30ef-41a7-b97d-fa797f7f7d18}": {
        readonly name: 'nsIWebTransportReceiveStreamStats';
        readonly interface: nsIWebTransportReceiveStreamStatsType;
    };
    "{9c1df3f5-bf04-46b6-9977-eb6389076db8}": {
        readonly name: 'nsIWebTransportStreamStatsCallback';
        readonly interface: nsIWebTransportStreamStatsCallbackType;
    };
    "{d461b235-6291-4817-adcc-a2a3b3dfc10b}": {
        readonly name: 'nsIWebTransportReceiveStream';
        readonly interface: nsIWebTransportReceiveStreamType;
    };
    "{804f245c-52ea-403c-8a78-f751533bdd70}": {
        readonly name: 'nsIWebTransportSendStream';
        readonly interface: nsIWebTransportSendStreamType;
    };
    "{f9ecb509-36db-4689-97d6-137639a08750}": {
        readonly name: 'nsIWebTransportBidirectionalStream';
        readonly interface: nsIWebTransportBidirectionalStreamType;
    };
    "{}": {
        readonly name: 'nsIWebVTTListener';
        readonly interface: nsIWebVTTListenerType;
    };
    "{8dfe016e-1701-4618-9f5e-9a6154e853f0}": {
        readonly name: 'nsIWebVTTParserWrapper';
        readonly interface: nsIWebVTTParserWrapperType;
    };
    "{b4f96c89-5238-450c-8bda-e12c26f1d150}": {
        readonly name: 'nsIWellKnownOpportunisticUtils';
        readonly interface: nsIWellKnownOpportunisticUtilsType;
    };
    "{}": {
        readonly name: 'nsIWifiAccessPoint';
        readonly interface: nsIWifiAccessPointType;
    };
    "{}": {
        readonly name: 'nsIWifiListener';
        readonly interface: nsIWifiListenerType;
    };
    "{F289701E-D9AF-4685-BC2F-E4226FF7C018}": {
        readonly name: 'nsIWifiMonitor';
        readonly interface: nsIWifiMonitorType;
    };
    "{dc263ca8-b257-47eb-b5b7-339d9e0b90f7}": {
        readonly name: 'nsIWinAppHelper';
        readonly interface: nsIWinAppHelperType;
    };
    "{a8d36901-0b6a-46c3-a214-a9e1d5d6047a}": {
        readonly name: 'nsIWinTaskSchedulerService';
        readonly interface: nsIWinTaskSchedulerServiceType;
    };
    "{11751471-9246-4c72-a80f-0c7df765d640}": {
        readonly name: 'nsIWinTaskbar';
        readonly interface: nsIWinTaskbarType;
    };
    "{}": {
        readonly name: 'nsIWindowCreator';
        readonly interface: nsIWindowCreatorType;
    };
    "{df0da056-357d-427f-bafd-e6cbf19c9381}": {
        readonly name: 'nsIWindowMediator';
        readonly interface: nsIWindowMediatorType;
    };
    "{2F276982-0D60-4377-A595-D350BA516395}": {
        readonly name: 'nsIWindowMediatorListener';
        readonly interface: nsIWindowMediatorListenerType;
    };
    "{e97a3830-15ef-499b-8372-c22d128091c1}": {
        readonly name: 'nsIWindowProvider';
        readonly interface: nsIWindowProviderType;
    };
    "{641fe945-6902-4b3f-87c2-0daef32499b3}": {
        readonly name: 'nsIWindowWatcher';
        readonly interface: nsIWindowWatcherType;
    };
    "{abb46f48-abfc-41bf-aa9a-7feccefcf977}": {
        readonly name: 'nsIWindowlessBrowser';
        readonly interface: nsIWindowlessBrowserType;
    };
    "{e01c8066-fb4b-4304-b9c9-ab6ed4a8322c}": {
        readonly name: 'nsIWindowsAlertsService';
        readonly interface: nsIWindowsAlertsServiceType;
    };
    "{ad57ac40-52f0-11ec-ada8-4f671255c4aa}": {
        readonly name: 'nsIWindowsPackageManager';
        readonly interface: nsIWindowsPackageManagerType;
    };
    "{2555b930-d64f-437e-9be7-0a2cb252c1f4}": {
        readonly name: 'nsIWindowsRegKey';
        readonly interface: nsIWindowsRegKeyType;
    };
    "{fb9b59db-5a91-4e67-92b6-35e7d6e6d3fd}": {
        readonly name: 'nsIWindowsShellService';
        readonly interface: nsIWindowsShellServiceType;
    };
    "{aa8a0ecf-96a1-418c-b80e-f24ae18bbedc}": {
        readonly name: 'nsIWindowsUIUtils';
        readonly interface: nsIWindowsUIUtilsType;
    };
    "{bf9a175a-03bc-4d7b-ba2f-76347cf40d7b}": {
        readonly name: 'nsIWorkerChannelLoadInfo';
        readonly interface: nsIWorkerChannelLoadInfoType;
    };
    "{df1fffe4-dac6-487e-979a-629ac8c64831}": {
        readonly name: 'nsIWorkerChannelInfo';
        readonly interface: nsIWorkerChannelInfoType;
    };
    "{9cf3b48e-361d-486a-8917-55cf8d00bb41}": {
        readonly name: 'nsIWorkerDebuggerListener';
        readonly interface: nsIWorkerDebuggerListenerType;
    };
    "{}": {
        readonly name: 'nsIWorkerDebugger';
        readonly interface: nsIWorkerDebuggerType;
    };
    "{d2aa74ee-6b98-4d5d-8173-4e23422daf1e}": {
        readonly name: 'nsIWorkerDebuggerManagerListener';
        readonly interface: nsIWorkerDebuggerManagerListenerType;
    };
    "{056d7918-dc86-452a-b4e6-86da3405f015}": {
        readonly name: 'nsIWorkerDebuggerManager';
        readonly interface: nsIWorkerDebuggerManagerType;
    };
    "{96fc4671-eeb4-4823-9421-e50fb70ad353}": {
        readonly name: 'nsIWritablePropertyBag';
        readonly interface: nsIWritablePropertyBagType;
    };
    "{9cfd1587-360e-4957-a58f-4c2b1c5e7ed9}": {
        readonly name: 'nsIWritablePropertyBag2';
        readonly interface: nsIWritablePropertyBag2Type;
    };
    "{}": {
        readonly name: 'nsIX509Cert';
        readonly interface: nsIX509CertType;
    };
    "{fc2b60e5-9a07-47c2-a2cd-b83b68a660ac}": {
        readonly name: 'nsIOpenSignedAppFileCallback';
        readonly interface: nsIOpenSignedAppFileCallbackType;
    };
    "{07c08655-8b11-4650-b6c4-0c145595ceb5}": {
        readonly name: 'nsIAsyncBoolCallback';
        readonly interface: nsIAsyncBoolCallbackType;
    };
    "{49e16fc8-efac-4f57-8361-956ef6b960a4}": {
        readonly name: 'nsICertVerificationCallback';
        readonly interface: nsICertVerificationCallbackType;
    };
    "{5c16cd9b-5a73-47f1-ab0f-11ede7495cce}": {
        readonly name: 'nsIX509CertDB';
        readonly interface: nsIX509CertDBType;
    };
    "{e701dfd8-1dd1-11b2-a172-ffa6cc6156ad}": {
        readonly name: 'nsIX509CertValidity';
        readonly interface: nsIX509CertValidityType;
    };
    "{19b70b26-7c3f-437f-a04a-2a8f9e28b617}": {
        readonly name: 'nsIXPCScriptable';
        readonly interface: nsIXPCScriptableType;
    };
    "{f6ee3c0a-5119-47fc-b1a7-ace9e1111fff}": {
        readonly name: 'nsIXREDirProvider';
        readonly interface: nsIXREDirProviderType;
    };
    "{ddea4f31-3c5e-4769-ac68-21ab4b3d7845}": {
        readonly name: 'nsIXULAppInfo';
        readonly interface: nsIXULAppInfoType;
    };
    "{a8675fa9-c8b4-4350-9803-c38f344a9e38}": {
        readonly name: 'nsIXULBrowserWindow';
        readonly interface: nsIXULBrowserWindowType;
    };
    "{03602fac-fa3f-4a50-9baa-b88456fb4a0f}": {
        readonly name: 'nsIXULRuntime';
        readonly interface: nsIXULRuntimeType;
    };
    "{987c4b35-c426-4dd7-ad49-3c9fa4c65d20}": {
        readonly name: 'nsIXULStore';
        readonly interface: nsIXULStoreType;
    };
    "{}": {
        readonly name: 'nsIZipEntry';
        readonly interface: nsIZipEntryType;
    };
    "{9ba4ef54-e0a0-4f65-9d23-128482448885}": {
        readonly name: 'nsIZipReader';
        readonly interface: nsIZipReaderType;
    };
    "{31179807-9fcd-46c4-befa-2ade209a394b}": {
        readonly name: 'nsIZipReaderCache';
        readonly interface: nsIZipReaderCacheType;
    };
    "{3ca10750-797e-4a22-bcfe-66170b5e96dd}": {
        readonly name: 'nsIZipWriter';
        readonly interface: nsIZipWriterType;
    };
    "{24e598fd-7b1a-436c-9154-14d8b38df8a5}": {
        readonly name: 'nsPIDNSService';
        readonly interface: nsPIDNSServiceType;
    };
    "{C60A1955-6CB3-4827-8EF8-4F5C668AF0B3}": {
        readonly name: 'nsPIPromptService';
        readonly interface: nsPIPromptServiceType;
    };
    "{18f73bf1-b35b-4b7b-aa9a-11bcbdbc389c}": {
        readonly name: 'nsPISocketTransportService';
        readonly interface: nsPISocketTransportServiceType;
    };
    "{f75ff69e-3a51-419e-bd29-042f804bc2ed}": {
        readonly name: 'nsPIWidgetCocoa';
        readonly interface: nsPIWidgetCocoaType;
    };
    "{d162f9c4-19d5-4723-931f-f1e51bfa9f68}": {
        readonly name: 'nsPIWindowWatcher';
        readonly interface: nsPIWindowWatcherType;
    };
    "{21b1cfa4-00ce-4cc1-bfc1-92af1d00e580}": {
        readonly name: 'txIEXSLTFunctions';
        readonly interface: txIEXSLTFunctionsType;
    };
    "{}": {
        readonly name: 'xpcIJSWeakReference';
        readonly interface: xpcIJSWeakReferenceType;
    };
    "{b8c31bba-79db-4a1d-930d-4cdd68713f9e}": {
        readonly name: 'nsIXPCComponents_Interfaces';
        readonly interface: nsIXPCComponents_InterfacesType;
    };
    "{978ff520-d26c-11d2-9842-006008962422}": {
        readonly name: 'nsIXPCComponents_Classes';
        readonly interface: nsIXPCComponents_ClassesType;
    };
    "{2fc229a0-5860-11d3-9899-006008962422}": {
        readonly name: 'nsIXPCComponents_Results';
        readonly interface: nsIXPCComponents_ResultsType;
    };
    "{7994a6e0-e028-11d3-8f5d-0010a4e73d9a}": {
        readonly name: 'nsIXPCComponents_ID';
        readonly interface: nsIXPCComponents_IDType;
    };
    "{5bf039c0-e028-11d3-8f5d-0010a4e73d9a}": {
        readonly name: 'nsIXPCComponents_Exception';
        readonly interface: nsIXPCComponents_ExceptionType;
    };
    "{88655640-e028-11d3-8f5d-0010a4e73d9a}": {
        readonly name: 'nsIXPCComponents_Constructor';
        readonly interface: nsIXPCComponents_ConstructorType;
    };
    "{4f8ae0dc-d266-4a32-875b-6a9de71a8ce9}": {
        readonly name: 'nsIXPCComponents_utils_Sandbox';
        readonly interface: nsIXPCComponents_utils_SandboxType;
    };
    "{71000535-b0fd-44d1-8ce0-909760e3953c}": {
        readonly name: 'nsIScheduledGCCallback';
        readonly interface: nsIScheduledGCCallbackType;
    };
    "{86003fe3-ee9a-4620-91dc-eef8b1e58815}": {
        readonly name: 'nsIXPCComponents_Utils';
        readonly interface: nsIXPCComponents_UtilsType;
    };
    "{aa28aaf6-70ce-4b03-9514-afe43c7dfda8}": {
        readonly name: 'nsIXPCComponents';
        readonly interface: nsIXPCComponentsType;
    };
    "{42fbd9f6-b12d-47ef-b7a1-02d73c11fe53}": {
        readonly name: 'nsIXPCTestObjectReadOnly';
        readonly interface: nsIXPCTestObjectReadOnlyType;
    };
    "{f07529b0-a479-4954-aba5-ab3142c6b1cb}": {
        readonly name: 'nsIXPCTestObjectReadWrite';
        readonly interface: nsIXPCTestObjectReadWriteType;
    };
    "{2df46559-da21-49bf-b863-0d7b7bbcbc73}": {
        readonly name: 'nsIXPCTestBug809674';
        readonly interface: nsIXPCTestBug809674Type;
    };
    "{6a2f918e-cda2-11e8-bc9a-a34c716d1f2a}": {
        readonly name: 'nsIXPCTestCEnums';
        readonly interface: nsIXPCTestCEnumsType;
    };
    "{494f9336-ad06-46ad-bbb4-b0010e27e12d}": {
        readonly name: 'nsIXPCTestESMReturnCodeParent';
        readonly interface: nsIXPCTestESMReturnCodeParentType;
    };
    "{dee07408-75d8-4968-a37c-fe0d48ccd1ac}": {
        readonly name: 'nsIXPCTestESMReturnCodeChild';
        readonly interface: nsIXPCTestESMReturnCodeChildType;
    };
    "{}": {
        readonly name: 'nsIXPCTestInterfaceA';
        readonly interface: nsIXPCTestInterfaceAType;
    };
    "{}": {
        readonly name: 'nsIXPCTestInterfaceB';
        readonly interface: nsIXPCTestInterfaceBType;
    };
    "{401cf1b4-355b-4cee-b7b3-c7973aee49bd}": {
        readonly name: 'nsIXPCTestInterfaceC';
        readonly interface: nsIXPCTestInterfaceCType;
    };
    "{812145c7-9fcc-425e-a878-36ad1b7730b7}": {
        readonly name: 'nsIXPCTestParams';
        readonly interface: nsIXPCTestParamsType;
    };
    "{479e4532-95cf-48b8-a99b-8a5881e47138}": {
        readonly name: 'nsIXPCTestReturnCodeParent';
        readonly interface: nsIXPCTestReturnCodeParentType;
    };
    "{672cfd34-1fd1-455d-9901-d879fa6fdb95}": {
        readonly name: 'nsIXPCTestReturnCodeChild';
        readonly interface: nsIXPCTestReturnCodeChildType;
    };
    "{d58a82ab-d8f7-4ca9-9273-b3290d42a0cf}": {
        readonly name: 'nsIXPCTestFunctionInterface';
        readonly interface: nsIXPCTestFunctionInterfaceType;
    };
    "{1e9cddeb-510d-449a-b152-3c1b5b31d41d}": {
        readonly name: 'nsIXPCTestUtils';
        readonly interface: nsIXPCTestUtilsType;
    };
}
declare var Ci: CiType;

declare module Services {
    declare var uriFixup: nsIURIFixupType;
    declare var droppedLinkHandler: nsIDroppedLinkHandlerType;
    declare var sessionStorage: nsISessionStorageServiceType;
    declare var perms: nsIPermissionManagerType;
    declare var strings: nsIStringBundleServiceType;
    declare var locale: mozILocaleServiceType;
    declare var textToSubURI: nsITextToSubURIType;
    declare var scriptloader: mozIJSSubScriptLoaderType;
    declare var DOMRequest: nsIDOMRequestServiceType;
    declare var domStorageManager: nsIDOMStorageManagerType & nsILocalStorageManagerType;
    declare var qms: nsIQuotaManagerServiceType;
    declare var els: nsIEventListenerServiceType;
    declare var focus: nsIFocusManagerType;
    declare var scriptSecurityManager: nsIScriptSecurityManagerType;
    declare var prompt: nsIPromptServiceType;
    declare var prefs: nsIPrefServiceType & nsIPrefBranchType;
    declare var loadContextInfo: nsILoadContextInfoFactoryType;
    declare var cache2: nsICacheStorageServiceType;
    declare var dns: nsIDNSServiceType;
    declare var eTLD: nsIEffectiveTLDServiceType;
    declare var io: nsIIOServiceType & nsISpeculativeConnectType & nsINetUtilType;
    declare var cookies: nsICookieServiceType & nsICookieManagerType;
    declare var storage: mozIStorageServiceType;
    declare var startup: nsIAppStartupType;
    declare var clearData: nsIClearDataServiceType;
    declare var cookieBanners: nsICookieBannerServiceType;
    declare var policies: nsIEnterprisePoliciesType;
    declare var fog: nsIFOGType;
    declare var intl: mozIMozIntlType;
    declare var logins: nsILoginManagerType;
    declare var prompt: nsIPromptServiceType;
    declare var search: nsISearchServiceType;
    declare var telemetry: nsITelemetryType;
    declare var DAPTelemetry: nsIDAPTelemetryType;
    declare var urlFormatter: nsIURLFormatterType;
    declare var xulStore: nsIXULStoreType;
    declare var blocklist: nsIBlocklistServiceType;
    declare var appinfo: nsIXULRuntimeType & nsIXULAppInfoType & nsICrashReporterType;
    declare var ww: nsIWindowWatcherType;
    declare var profiler: nsIProfilerType;
    declare var androidBridge: nsIAndroidBridgeType;
    declare var clipboard: nsIClipboardType;
    declare var console: nsIConsoleServiceType;
    declare var sysinfo: nsIPropertyBag2Type & nsISystemInfoType;
    declare var tm: nsIThreadManagerType;
    declare var uuid: nsIUUIDGeneratorType;
    declare var vc: nsIVersionComparatorType;
    declare var catMan: nsICategoryManagerType;
    declare var obs: nsIObserverServiceType;
    declare var dirsvc: nsIDirectoryServiceType & nsIPropertiesType;
    declare var env: nsIEnvironmentType;
    declare var appShell: nsIAppShellServiceType;
    declare var wm: nsIWindowMediatorType;
}